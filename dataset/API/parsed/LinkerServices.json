{"name": "Interface LinkerServices", "module": "jdk.dynalink", "package": "jdk.dynalink.linker", "text": "Interface for services provided to GuardingDynamicLinker instances by\n the DynamicLinker that owns them.", "codes": ["public interface LinkerServices"], "fields": [], "methods": [{"method_name": "asType", "method_sig": "MethodHandle asType (MethodHandle handle,\n                    MethodType fromType)", "description": "Similar to MethodHandle.asType(MethodType) except it also hooks\n in method handles produced by all available\n GuardingTypeConverterFactory implementations, providing for\n language-specific type coercing of parameters. It will apply\n MethodHandle.asType(MethodType) for all primitive-to-primitive,\n wrapper-to-primitive, primitive-to-wrapper conversions as well as for all\n upcasts. For all other conversions, it'll insert\n MethodHandles.filterArguments(MethodHandle, int, MethodHandle...)\n with composite filters provided by GuardingTypeConverterFactory\n implementations."}, {"method_name": "asTypeLosslessReturn", "method_sig": "default MethodHandle asTypeLosslessReturn (MethodHandle handle,\n                                          MethodType fromType)", "description": "Similar to asType(MethodHandle, MethodType) except it treats\n return value type conversion specially. It only converts the return type\n of the method handle when it can be done using a conversion that loses\n neither precision nor magnitude, otherwise it leaves it unchanged. These\n are the only return value conversions that should be performed by\n individual language-specific linkers, and\n pre-link transformer of the dynamic linker should implement the strategy\n for dealing with potentially lossy return type conversions in a manner\n specific to the language runtime where the call site is located."}, {"method_name": "getTypeConverter", "method_sig": "MethodHandle getTypeConverter (Class<?> sourceType,\n                              Class<?> targetType)", "description": "Given a source and target type, returns a method handle that converts\n between them. Never returns null; in worst case it will return an\n identity conversion (that might fail for some values at runtime). You\n rarely need to use this method directly and should mostly rely on\n asType(MethodHandle, MethodType) instead. This method is needed\n when you need to reuse existing type conversion machinery outside the\n context of processing a link request."}, {"method_name": "canConvert", "method_sig": "boolean canConvert (Class<?> from,\n                   Class<?> to)", "description": "Returns true if there might exist a conversion between the requested\n types (either an automatic JVM conversion, or one provided by any\n available GuardingTypeConverterFactory), or false if there\n definitely does not exist a conversion between the requested types. Note\n that returning true does not guarantee that the conversion will succeed\n at runtime for all values (especially if the \"from\" or \"to\" types are\n sufficiently generic), but returning false guarantees that it would fail."}, {"method_name": "getGuardedInvocation", "method_sig": "GuardedInvocation getGuardedInvocation (LinkRequest linkRequest)\n                                throws Exception", "description": "Creates a guarded invocation delegating back to the DynamicLinker\n that exposes this linker services object. The dynamic linker will then\n itself delegate the linking to all of its managed\n GuardingDynamicLinkers including potentially this one if no\n linker responds earlier, so beware of infinite recursion. You'll\n typically craft the link request so that it will be different than the\n one you are currently trying to link."}, {"method_name": "compareConversion", "method_sig": "ConversionComparator.Comparison compareConversion (Class<?> sourceType,\n                                                  Class<?> targetType1,\n                                                  Class<?> targetType2)", "description": "Determines which of the two type conversions from a source type to the\n two target types is preferred. This is used for dynamic overloaded method\n resolution. If the source type is convertible to exactly one target type\n with a method invocation conversion, it is chosen, otherwise available\n ConversionComparators are consulted."}, {"method_name": "filterInternalObjects", "method_sig": "MethodHandle filterInternalObjects (MethodHandle target)", "description": "Modifies the method handle so that any parameters that can receive\n potentially internal language runtime objects will have a filter added on\n them to prevent them from escaping, potentially by wrapping them. It can\n also potentially add an unwrapping filter to the return value. Basically\n transforms the method handle using the transformer configured by\n DynamicLinkerFactory.setInternalObjectsFilter(MethodHandleTransformer)."}, {"method_name": "getWithLookup", "method_sig": "<T> T getWithLookup (Supplier<T> operation,\n                    SecureLookupSupplier lookupSupplier)", "description": "Executes an operation within the context of a particular\n MethodHandles.Lookup lookup object. Normally, methods on\n LinkerServices are invoked as part of the linking mechanism in\n which case Dynalink internally maintains a per-thread current lookup\n (the one belonging to the descriptor of the call site being linked). This\n lookup can be retrieved by any GuardingTypeConverterFactory\n involved in linking if it needs to generate lookup-sensitive converters.\n However, linker services' methods can be invoked outside the linking\n process too when implementing invocation-time dispatch schemes, invoking\n conversions at runtime, etc. If it becomes necessary to use any type\n converter in this situation, and it needs a lookup, it will normally only\n get MethodHandles.publicLookup() as the thread is not engaged in\n a linking operation. If there is a way to meaningfully associate the\n operation to the context of some caller class, consider performing it\n within an invocation of this method and passing a full-strength lookup\n for that class, as it will associate that lookup with the current thread\n for the duration of the operation. Note that since you are passing a\n SecureLookupSupplier, any invoked type converter factories will\n still need to hold the necessary runtime permission to be able to get the\n lookup should they need it."}]}