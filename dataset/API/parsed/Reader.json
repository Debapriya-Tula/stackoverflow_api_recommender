{"name": "Class Reader", "module": "java.base", "package": "java.io", "text": "Abstract class for reading character streams.  The only methods that a\n subclass must implement are read(char[], int, int) and close().  Most\n subclasses, however, will override some of the methods defined here in order\n to provide higher efficiency, additional functionality, or both.", "codes": ["public abstract class Reader\nextends Object\nimplements Readable, Closeable"], "fields": [{"field_name": "lock", "field_sig": "protected\u00a0Object lock", "description": "The object used to synchronize operations on this stream.  For\n efficiency, a character-stream object may use an object other than\n itself to protect critical sections.  A subclass should therefore use\n the object in this field rather than this or a synchronized\n method."}], "methods": [{"method_name": "nullReader", "method_sig": "public static Reader nullReader()", "description": "Returns a new Reader that reads no characters. The returned\n stream is initially open.  The stream is closed by calling the\n close() method.  Subsequent calls to close() have no\n effect.\n\n  While the stream is open, the read(), read(char[]),\n read(char[], int, int), read(Charbuffer), \n ready(), skip(long), and transferTo() methods all\n behave as if end of stream has been reached. After the stream has been\n closed, these methods all throw IOException.\n\n  The markSupported() method returns false.  The\n mark() and reset() methods throw an IOException.\n\n  The object used to synchronize operations on the\n returned Reader is not specified."}, {"method_name": "read", "method_sig": "public int read (CharBuffer target)\n         throws IOException", "description": "Attempts to read characters into the specified character buffer.\n The buffer is used as a repository of characters as-is: the only\n changes made are the results of a put operation. No flipping or\n rewinding of the buffer is performed."}, {"method_name": "read", "method_sig": "public int read()\n         throws IOException", "description": "Reads a single character.  This method will block until a character is\n available, an I/O error occurs, or the end of the stream is reached.\n\n  Subclasses that intend to support efficient single-character input\n should override this method."}, {"method_name": "read", "method_sig": "public int read (char[] cbuf)\n         throws IOException", "description": "Reads characters into an array.  This method will block until some input\n is available, an I/O error occurs, or the end of the stream is reached."}, {"method_name": "read", "method_sig": "public abstract int read (char[] cbuf,\n                         int off,\n                         int len)\n                  throws IOException", "description": "Reads characters into a portion of an array.  This method will block\n until some input is available, an I/O error occurs, or the end of the\n stream is reached."}, {"method_name": "skip", "method_sig": "public long skip (long n)\n          throws IOException", "description": "Skips characters.  This method will block until some characters are\n available, an I/O error occurs, or the end of the stream is reached."}, {"method_name": "ready", "method_sig": "public boolean ready()\n              throws IOException", "description": "Tells whether this stream is ready to be read."}, {"method_name": "markSupported", "method_sig": "public boolean markSupported()", "description": "Tells whether this stream supports the mark() operation. The default\n implementation always returns false. Subclasses should override this\n method."}, {"method_name": "mark", "method_sig": "public void mark (int readAheadLimit)\n          throws IOException", "description": "Marks the present position in the stream.  Subsequent calls to reset()\n will attempt to reposition the stream to this point.  Not all\n character-input streams support the mark() operation."}, {"method_name": "reset", "method_sig": "public void reset()\n           throws IOException", "description": "Resets the stream.  If the stream has been marked, then attempt to\n reposition it at the mark.  If the stream has not been marked, then\n attempt to reset it in some way appropriate to the particular stream,\n for example by repositioning it to its starting point.  Not all\n character-input streams support the reset() operation, and some support\n reset() without supporting mark()."}, {"method_name": "close", "method_sig": "public abstract void close()\n                    throws IOException", "description": "Closes the stream and releases any system resources associated with\n it.  Once the stream has been closed, further read(), ready(),\n mark(), reset(), or skip() invocations will throw an IOException.\n Closing a previously closed stream has no effect."}, {"method_name": "transferTo", "method_sig": "public long transferTo (Writer out)\n                throws IOException", "description": "Reads all characters from this reader and writes the characters to the\n given writer in the order that they are read. On return, this reader\n will be at end of the stream. This method does not close either reader\n or writer.\n \n This method may block indefinitely reading from the reader, or\n writing to the writer. The behavior for the case where the reader\n and/or writer is asynchronously closed, or the thread\n interrupted during the transfer, is highly reader and writer\n specific, and therefore not specified.\n \n If an I/O error occurs reading from the reader or writing to the\n writer, then it may do so after some characters have been read or\n written. Consequently the reader may not be at end of the stream and\n one, or both, streams may be in an inconsistent state. It is strongly\n recommended that both streams be promptly closed if an I/O error occurs."}]}