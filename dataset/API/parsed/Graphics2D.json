{"name": "Class Graphics2D", "module": "java.desktop", "package": "java.awt", "text": "This Graphics2D class extends the\n Graphics class to provide more sophisticated\n control over geometry, coordinate transformations, color management,\n and text layout.  This is the fundamental class for rendering\n 2-dimensional shapes, text and images on the  Java(tm) platform.\n\n Coordinate Spaces\n All coordinates passed to a Graphics2D object are specified\n in a device-independent coordinate system called User Space, which is\n used by applications.  The Graphics2D object contains\n an AffineTransform object as part of its rendering state\n that defines how to convert coordinates from user space to\n device-dependent coordinates in Device Space.\n \n Coordinates in device space usually refer to individual device pixels\n and are aligned on the infinitely thin gaps between these pixels.\n Some Graphics2D objects can be used to capture rendering\n operations for storage into a graphics metafile for playback on a\n concrete device of unknown physical resolution at a later time.  Since\n the resolution might not be known when the rendering operations are\n captured, the Graphics2D Transform is set up\n to transform user coordinates to a virtual device space that\n approximates the expected resolution of the target device. Further\n transformations might need to be applied at playback time if the\n estimate is incorrect.\n \n Some of the operations performed by the rendering attribute objects\n occur in the device space, but all Graphics2D methods take\n user space coordinates.\n \n Every Graphics2D object is associated with a target that\n defines where rendering takes place. A\n GraphicsConfiguration object defines the characteristics\n of the rendering target, such as pixel format and resolution.\n The same rendering target is used throughout the life of a\n Graphics2D object.\n \n When creating a Graphics2D object,  the\n GraphicsConfiguration\n specifies the default transform for\n the target of the Graphics2D (a\n Component or Image).  This default transform maps the\n user space coordinate system to screen and printer device coordinates\n such that the origin maps to the upper left hand corner of the\n target region of the device with increasing X coordinates extending\n to the right and increasing Y coordinates extending downward.\n The scaling of the default transform is set to identity for those devices\n that are close to 72 dpi, such as screen devices.\n The scaling of the default transform is set to approximately 72 user\n space coordinates per square inch for high resolution devices, such as\n printers.  For image buffers, the default transform is the\n Identity transform.\n\n Rendering Process\n The Rendering Process can be broken down into four phases that are\n controlled by the Graphics2D rendering attributes.\n The renderer can optimize many of these steps, either by caching the\n results for future calls, by collapsing multiple virtual steps into\n a single operation, or by recognizing various attributes as common\n simple cases that can be eliminated by modifying other parts of the\n operation.\n \n The steps in the rendering process are:\n \n\n Determine what to render.\n \n Constrain the rendering operation to the current Clip.\n The Clip is specified by a Shape in user\n space and is controlled by the program using the various clip\n manipulation methods of Graphics and\n Graphics2D.  This user clip\n is transformed into device space by the current\n Transform and combined with the\n device clip, which is defined by the visibility of windows and\n device extents.  The combination of the user clip and device clip\n defines the composite clip, which determines the final clipping\n region.  The user clip is not modified by the rendering\n system to reflect the resulting composite clip.\n \n Determine what colors to render.\n \n Apply the colors to the destination drawing surface using the current\n Composite attribute in the Graphics2D context.\n \n\n The three types of rendering operations, along with details of each\n of their particular rendering processes are:\n \n\nShape operations\n\n\n If the operation is a draw(Shape) operation, then\n the  createStrokedShape\n method on the current Stroke attribute in the\n Graphics2D context is used to construct a new\n Shape object that contains the outline of the specified\n Shape.\n \n The Shape is transformed from user space to device space\n using the current Transform\n in the Graphics2D context.\n \n The outline of the Shape is extracted using the\n getPathIterator method of\n Shape, which returns a\n PathIterator\n object that iterates along the boundary of the Shape.\n \n If the Graphics2D object cannot handle the curved segments\n that the PathIterator object returns then it can call the\n alternate\n getPathIterator\n method of Shape, which flattens the Shape.\n \n The current Paint in the Graphics2D context\n is queried for a PaintContext, which specifies the\n colors to render in device space.\n \n\nText operations\n\n\n The following steps are used to determine the set of glyphs required\n to render the indicated String:\n \n\n If the argument is a String, then the current\n Font in the Graphics2D context is asked to\n convert the Unicode characters in the String into a set of\n glyphs for presentation with whatever basic layout and shaping\n algorithms the font implements.\n \n If the argument is an\n AttributedCharacterIterator,\n the iterator is asked to convert itself to a\n TextLayout\n using its embedded font attributes. The TextLayout\n implements more sophisticated glyph layout algorithms that\n perform Unicode bi-directional layout adjustments automatically\n for multiple fonts of differing writing directions.\n \n If the argument is a\n GlyphVector, then the\n GlyphVector object already contains the appropriate\n font-specific glyph codes with explicit coordinates for the position of\n each glyph.\n \n\n The current Font is queried to obtain outlines for the\n indicated glyphs.  These outlines are treated as shapes in user space\n relative to the position of each glyph that was determined in step 1.\n \n The character outlines are filled as indicated above\n under Shape operations.\n \n The current Paint is queried for a\n PaintContext, which specifies\n the colors to render in device space.\n \n\nImage Operations\n\n\n The region of interest is defined by the bounding box of the source\n Image.\n This bounding box is specified in Image Space, which is the\n Image object's local coordinate system.\n \n If an AffineTransform is passed to\n drawImage(Image, AffineTransform, ImageObserver),\n the AffineTransform is used to transform the bounding\n box from image space to user space. If no AffineTransform\n is supplied, the bounding box is treated as if it is already in user space.\n \n The bounding box of the source Image is transformed from user\n space into device space using the current Transform.\n Note that the result of transforming the bounding box does not\n necessarily result in a rectangular region in device space.\n \n The Image object determines what colors to render,\n sampled according to the source to destination\n coordinate mapping specified by the current Transform and the\n optional image transform.\n \n\nDefault Rendering Attributes\n The default values for the Graphics2D rendering attributes are:\n \nPaint\nThe color of the Component.\n Font\nThe Font of the Component.\n Stroke\nA square pen with a linewidth of 1, no dashing, miter segment joins\n and square end caps.\n Transform\nThe\n getDefaultTransform\n for the GraphicsConfiguration of the Component.\n Composite\nThe AlphaComposite.SRC_OVER rule.\n Clip\nNo rendering Clip, the output is clipped to the\n Component.\n \nRendering Compatibility Issues\n The JDK(tm) 1.1 rendering model is based on a pixelization model\n that specifies that coordinates\n are infinitely thin, lying between the pixels.  Drawing operations are\n performed using a one-pixel wide pen that fills the\n pixel below and to the right of the anchor point on the path.\n The JDK 1.1 rendering model is consistent with the\n capabilities of most of the existing class of platform\n renderers that need  to resolve integer coordinates to a\n discrete pen that must fall completely on a specified number of pixels.\n \n The Java 2D(tm) (Java(tm) 2 platform) API supports antialiasing renderers.\n A pen with a width of one pixel does not need to fall\n completely on pixel N as opposed to pixel N+1.  The pen can fall\n partially on both pixels. It is not necessary to choose a bias\n direction for a wide pen since the blending that occurs along the\n pen traversal edges makes the sub-pixel position of the pen\n visible to the user.  On the other hand, when antialiasing is\n turned off by setting the\n KEY_ANTIALIASING hint key\n to the\n VALUE_ANTIALIAS_OFF\n hint value, the renderer might need\n to apply a bias to determine which pixel to modify when the pen\n is straddling a pixel boundary, such as when it is drawn\n along an integer coordinate in device space.  While the capabilities\n of an antialiasing renderer make it no longer necessary for the\n rendering model to specify a bias for the pen, it is desirable for the\n antialiasing and non-antialiasing renderers to perform similarly for\n the common cases of drawing one-pixel wide horizontal and vertical\n lines on the screen.  To ensure that turning on antialiasing by\n setting the\n KEY_ANTIALIASING hint\n key to\n VALUE_ANTIALIAS_ON\n does not cause such lines to suddenly become twice as wide and half\n as opaque, it is desirable to have the model specify a path for such\n lines so that they completely cover a particular set of pixels to help\n increase their crispness.\n \n Java 2D API maintains compatibility with JDK 1.1 rendering\n behavior, such that legacy operations and existing renderer\n behavior is unchanged under Java 2D API.  Legacy\n methods that map onto general draw and\n fill methods are defined, which clearly indicates\n how Graphics2D extends Graphics based\n on settings of Stroke and Transform\n attributes and rendering hints.  The definition\n performs identically under default attribute settings.\n For example, the default Stroke is a\n BasicStroke with a width of 1 and no dashing and the\n default Transform for screen drawing is an Identity transform.\n \n The following two rules provide predictable rendering behavior whether\n aliasing or antialiasing is being used.\n \n Device coordinates are defined to be between device pixels which\n avoids any inconsistent results between aliased and antialiased\n rendering.  If coordinates were defined to be at a pixel's center, some\n of the pixels covered by a shape, such as a rectangle, would only be\n half covered.\n With aliased rendering, the half covered pixels would either be\n rendered inside the shape or outside the shape.  With anti-aliased\n rendering, the pixels on the entire edge of the shape would be half\n covered.  On the other hand, since coordinates are defined to be\n between pixels, a shape like a rectangle would have no half covered\n pixels, whether or not it is rendered using antialiasing.\n  Lines and paths stroked using the BasicStroke\n object may be \"normalized\" to provide consistent rendering of the\n outlines when positioned at various points on the drawable and\n whether drawn with aliased or antialiased rendering.  This\n normalization process is controlled by the\n KEY_STROKE_CONTROL hint.\n The exact normalization algorithm is not specified, but the goals\n of this normalization are to ensure that lines are rendered with\n consistent visual appearance regardless of how they fall on the\n pixel grid and to promote more solid horizontal and vertical\n lines in antialiased mode so that they resemble their non-antialiased\n counterparts more closely.  A typical normalization step might\n promote antialiased line endpoints to pixel centers to reduce the\n amount of blending or adjust the subpixel positioning of\n non-antialiased lines so that the floating point line widths\n round to even or odd pixel counts with equal likelihood.  This\n process can move endpoints by up to half a pixel (usually towards\n positive infinity along both axes) to promote these consistent\n results.\n \n\n The following definitions of general legacy methods\n perform identically to previously specified behavior under default\n attribute settings:\n \n\n For fill operations, including fillRect,\n fillRoundRect, fillOval,\n fillArc, fillPolygon, and\n clearRect, fill can now be called\n with the desired Shape.  For example, when filling a\n rectangle:\n \n fill(new Rectangle(x, y, w, h));\n \n is called.\n\n \n Similarly, for draw operations, including drawLine,\n drawRect, drawRoundRect,\n drawOval, drawArc, drawPolyline,\n and drawPolygon, draw can now be\n called with the desired Shape.  For example, when drawing a\n rectangle:\n \n draw(new Rectangle(x, y, w, h));\n \n is called.\n\n \n The draw3DRect and fill3DRect methods were\n implemented in terms of the drawLine and\n fillRect methods in the Graphics class which\n would predicate their behavior upon the current Stroke\n and Paint objects in a Graphics2D context.\n This class overrides those implementations with versions that use\n the current Color exclusively, overriding the current\n Paint and which uses fillRect to describe\n the exact same behavior as the preexisting methods regardless of the\n setting of the current Stroke.\n \n The Graphics class defines only the setColor\n method to control the color to be painted.  Since the Java 2D API extends\n the Color object to implement the new Paint\n interface, the existing\n setColor method is now a convenience method for setting the\n current Paint attribute to a Color object.\n setColor(c) is equivalent to setPaint(c).\n \n The Graphics class defines two methods for controlling\n how colors are applied to the destination.\n \n\n The setPaintMode method is implemented as a convenience\n method to set the default Composite, equivalent to\n setComposite(new AlphaComposite.SrcOver).\n \n The setXORMode(Color xorcolor) method is implemented\n as a convenience method to set a special Composite object that\n ignores the Alpha components of source colors and sets the\n destination color to the value:\n \n dstpixel = (PixelOf(srccolor) ^ PixelOf(xorcolor) ^ dstpixel);\n \n", "codes": ["public abstract class Graphics2D\nextends Graphics"], "fields": [], "methods": [{"method_name": "draw3DRect", "method_sig": "public void draw3DRect (int x,\n                       int y,\n                       int width,\n                       int height,\n                       boolean raised)", "description": "Draws a 3-D highlighted outline of the specified rectangle.\n The edges of the rectangle are highlighted so that they\n appear to be beveled and lit from the upper left corner.\n \n The colors used for the highlighting effect are determined\n based on the current color.\n The resulting rectangle covers an area that is\n width\u00a0+\u00a01 pixels wide\n by height\u00a0+\u00a01 pixels tall.  This method\n uses the current Color exclusively and ignores\n the current Paint."}, {"method_name": "fill3DRect", "method_sig": "public void fill3DRect (int x,\n                       int y,\n                       int width,\n                       int height,\n                       boolean raised)", "description": "Paints a 3-D highlighted rectangle filled with the current color.\n The edges of the rectangle are highlighted so that it appears\n as if the edges were beveled and lit from the upper left corner.\n The colors used for the highlighting effect and for filling are\n determined from the current Color.  This method uses\n the current Color exclusively and ignores the current\n Paint."}, {"method_name": "draw", "method_sig": "public abstract void draw (Shape s)", "description": "Strokes the outline of a Shape using the settings of the\n current Graphics2D context.  The rendering attributes\n applied include the Clip, Transform,\n Paint, Composite and\n Stroke attributes."}, {"method_name": "drawImage", "method_sig": "public abstract boolean drawImage (Image img,\n                                  AffineTransform xform,\n                                  ImageObserver obs)", "description": "Renders an image, applying a transform from image space into user space\n before drawing.\n The transformation from user space into device space is done with\n the current Transform in the Graphics2D.\n The specified transformation is applied to the image before the\n transform attribute in the Graphics2D context is applied.\n The rendering attributes applied include the Clip,\n Transform, and Composite attributes.\n Note that no rendering is done if the specified transform is\n noninvertible."}, {"method_name": "drawImage", "method_sig": "public abstract void drawImage (BufferedImage img,\n                               BufferedImageOp op,\n                               int x,\n                               int y)", "description": "Renders a BufferedImage that is\n filtered with a\n BufferedImageOp.\n The rendering attributes applied include the Clip,\n Transform\n and Composite attributes.  This is equivalent to:\n \n img1 = op.filter(img, null);\n drawImage(img1, new AffineTransform(1f,0f,0f,1f,x,y), null);\n "}, {"method_name": "drawRenderedImage", "method_sig": "public abstract void drawRenderedImage (RenderedImage img,\n                                       AffineTransform xform)", "description": "Renders a RenderedImage,\n applying a transform from image\n space into user space before drawing.\n The transformation from user space into device space is done with\n the current Transform in the Graphics2D.\n The specified transformation is applied to the image before the\n transform attribute in the Graphics2D context is applied.\n The rendering attributes applied include the Clip,\n Transform, and Composite attributes. Note\n that no rendering is done if the specified transform is\n noninvertible."}, {"method_name": "drawRenderableImage", "method_sig": "public abstract void drawRenderableImage (RenderableImage img,\n                                         AffineTransform xform)", "description": "Renders a\n RenderableImage,\n applying a transform from image space into user space before drawing.\n The transformation from user space into device space is done with\n the current Transform in the Graphics2D.\n The specified transformation is applied to the image before the\n transform attribute in the Graphics2D context is applied.\n The rendering attributes applied include the Clip,\n Transform, and Composite attributes. Note\n that no rendering is done if the specified transform is\n noninvertible.\n\n Rendering hints set on the Graphics2D object might\n be used in rendering the RenderableImage.\n If explicit control is required over specific hints recognized by a\n specific RenderableImage, or if knowledge of which hints\n are used is required, then a RenderedImage should be\n obtained directly from the RenderableImage\n and rendered using\ndrawRenderedImage."}, {"method_name": "drawString", "method_sig": "public abstract void drawString (String str,\n                                int x,\n                                int y)", "description": "Renders the text of the specified String, using the\n current text attribute state in the Graphics2D context.\n The baseline of the\n first character is at position (x,\u00a0y) in\n the User Space.\n The rendering attributes applied include the Clip,\n Transform, Paint, Font and\n Composite attributes.  For characters in script\n systems such as Hebrew and Arabic, the glyphs can be rendered from\n right to left, in which case the coordinate supplied is the\n location of the leftmost character on the baseline."}, {"method_name": "drawString", "method_sig": "public abstract void drawString (String str,\n                                float x,\n                                float y)", "description": "Renders the text specified by the specified String,\n using the current text attribute state in the Graphics2D context.\n The baseline of the first character is at position\n (x,\u00a0y) in the User Space.\n The rendering attributes applied include the Clip,\n Transform, Paint, Font and\n Composite attributes. For characters in script systems\n such as Hebrew and Arabic, the glyphs can be rendered from right to\n left, in which case the coordinate supplied is the location of the\n leftmost character on the baseline."}, {"method_name": "drawString", "method_sig": "public abstract void drawString (AttributedCharacterIterator iterator,\n                                int x,\n                                int y)", "description": "Renders the text of the specified iterator applying its attributes\n in accordance with the specification of the TextAttribute class.\n \n The baseline of the first character is at position\n (x,\u00a0y) in User Space.\n For characters in script systems such as Hebrew and Arabic,\n the glyphs can be rendered from right to left, in which case the\n coordinate supplied is the location of the leftmost character\n on the baseline."}, {"method_name": "drawString", "method_sig": "public abstract void drawString (AttributedCharacterIterator iterator,\n                                float x,\n                                float y)", "description": "Renders the text of the specified iterator applying its attributes\n in accordance with the specification of the TextAttribute class.\n \n The baseline of the first character is at position\n (x,\u00a0y) in User Space.\n For characters in script systems such as Hebrew and Arabic,\n the glyphs can be rendered from right to left, in which case the\n coordinate supplied is the location of the leftmost character\n on the baseline."}, {"method_name": "drawGlyphVector", "method_sig": "public abstract void drawGlyphVector (GlyphVector g,\n                                     float x,\n                                     float y)", "description": "Renders the text of the specified\n GlyphVector using\n the Graphics2D context's rendering attributes.\n The rendering attributes applied include the Clip,\n Transform, Paint, and\n Composite attributes.  The GlyphVector\n specifies individual glyphs from a Font.\n The GlyphVector can also contain the glyph positions.\n This is the fastest way to render a set of characters to the\n screen."}, {"method_name": "fill", "method_sig": "public abstract void fill (Shape s)", "description": "Fills the interior of a Shape using the settings of the\n Graphics2D context. The rendering attributes applied\n include the Clip, Transform,\n Paint, and Composite."}, {"method_name": "hit", "method_sig": "public abstract boolean hit (Rectangle rect,\n                            Shape s,\n                            boolean onStroke)", "description": "Checks whether or not the specified Shape intersects\n the specified Rectangle, which is in device\n space. If onStroke is false, this method checks\n whether or not the interior of the specified Shape\n intersects the specified Rectangle.  If\n onStroke is true, this method checks\n whether or not the Stroke of the specified\n Shape outline intersects the specified\n Rectangle.\n The rendering attributes taken into account include the\n Clip, Transform, and Stroke\n attributes."}, {"method_name": "getDeviceConfiguration", "method_sig": "public abstract GraphicsConfiguration getDeviceConfiguration()", "description": "Returns the device configuration associated with this\n Graphics2D."}, {"method_name": "setComposite", "method_sig": "public abstract void setComposite (Composite comp)", "description": "Sets the Composite for the Graphics2D context.\n The Composite is used in all drawing methods such as\n drawImage, drawString, draw,\n and fill.  It specifies how new pixels are to be combined\n with the existing pixels on the graphics device during the rendering\n process.\n If this Graphics2D context is drawing to a\n Component on the display screen and the\n Composite is a custom object rather than an\n instance of the AlphaComposite class, and if\n there is a security manager, its checkPermission\n method is called with an AWTPermission(\"readDisplayPixels\")\n permission."}, {"method_name": "setPaint", "method_sig": "public abstract void setPaint (Paint paint)", "description": "Sets the Paint attribute for the\n Graphics2D context.  Calling this method\n with a null Paint object does\n not have any effect on the current Paint attribute\n of this Graphics2D."}, {"method_name": "setStroke", "method_sig": "public abstract void setStroke (Stroke s)", "description": "Sets the Stroke for the Graphics2D context."}, {"method_name": "setRenderingHint", "method_sig": "public abstract void setRenderingHint (RenderingHints.Key hintKey,\n                                      Object hintValue)", "description": "Sets the value of a single preference for the rendering algorithms.\n Hint categories include controls for rendering quality and overall\n time/quality trade-off in the rendering process.  Refer to the\n RenderingHints class for definitions of some common\n keys and values."}, {"method_name": "getRenderingHint", "method_sig": "public abstract Object getRenderingHint (RenderingHints.Key hintKey)", "description": "Returns the value of a single preference for the rendering algorithms.\n Hint categories include controls for rendering quality and overall\n time/quality trade-off in the rendering process.  Refer to the\n RenderingHints class for definitions of some common\n keys and values."}, {"method_name": "setRenderingHints", "method_sig": "public abstract void setRenderingHints (Map<?, ?> hints)", "description": "Replaces the values of all preferences for the rendering\n algorithms with the specified hints.\n The existing values for all rendering hints are discarded and\n the new set of known hints and values are initialized from the\n specified Map object.\n Hint categories include controls for rendering quality and\n overall time/quality trade-off in the rendering process.\n Refer to the RenderingHints class for definitions of\n some common keys and values."}, {"method_name": "addRenderingHints", "method_sig": "public abstract void addRenderingHints (Map<?, ?> hints)", "description": "Sets the values of an arbitrary number of preferences for the\n rendering algorithms.\n Only values for the rendering hints that are present in the\n specified Map object are modified.\n All other preferences not present in the specified\n object are left unmodified.\n Hint categories include controls for rendering quality and\n overall time/quality trade-off in the rendering process.\n Refer to the RenderingHints class for definitions of\n some common keys and values."}, {"method_name": "getRenderingHints", "method_sig": "public abstract RenderingHints getRenderingHints()", "description": "Gets the preferences for the rendering algorithms.  Hint categories\n include controls for rendering quality and overall time/quality\n trade-off in the rendering process.\n Returns all of the hint key/value pairs that were ever specified in\n one operation.  Refer to the\n RenderingHints class for definitions of some common\n keys and values."}, {"method_name": "translate", "method_sig": "public abstract void translate (int x,\n                               int y)", "description": "Translates the origin of the Graphics2D context to the\n point (x,\u00a0y) in the current coordinate system.\n Modifies the Graphics2D context so that its new origin\n corresponds to the point (x,\u00a0y) in the\n Graphics2D context's former coordinate system.  All\n coordinates used in subsequent rendering operations on this graphics\n context are relative to this new origin."}, {"method_name": "translate", "method_sig": "public abstract void translate (double tx,\n                               double ty)", "description": "Concatenates the current\n Graphics2D Transform\n with a translation transform.\n Subsequent rendering is translated by the specified\n distance relative to the previous position.\n This is equivalent to calling transform(T), where T is an\n AffineTransform represented by the following matrix:\n \n          [   1    0    tx  ]\n          [   0    1    ty  ]\n          [   0    0    1   ]\n "}, {"method_name": "rotate", "method_sig": "public abstract void rotate (double theta)", "description": "Concatenates the current Graphics2D\nTransform with a rotation transform.\n Subsequent rendering is rotated by the specified radians relative\n to the previous origin.\n This is equivalent to calling transform(R), where R is an\n AffineTransform represented by the following matrix:\n \n          [   cos(theta)    -sin(theta)    0   ]\n          [   sin(theta)     cos(theta)    0   ]\n          [       0              0         1   ]\n \n Rotating with a positive angle theta rotates points on the positive\n x axis toward the positive y axis."}, {"method_name": "rotate", "method_sig": "public abstract void rotate (double theta,\n                            double x,\n                            double y)", "description": "Concatenates the current Graphics2D\nTransform with a translated rotation\n transform.  Subsequent rendering is transformed by a transform\n which is constructed by translating to the specified location,\n rotating by the specified radians, and translating back by the same\n amount as the original translation.  This is equivalent to the\n following sequence of calls:\n \n          translate(x, y);\n          rotate(theta);\n          translate(-x, -y);\n \n Rotating with a positive angle theta rotates points on the positive\n x axis toward the positive y axis."}, {"method_name": "scale", "method_sig": "public abstract void scale (double sx,\n                           double sy)", "description": "Concatenates the current Graphics2D\nTransform with a scaling transformation\n Subsequent rendering is resized according to the specified scaling\n factors relative to the previous scaling.\n This is equivalent to calling transform(S), where S is an\n AffineTransform represented by the following matrix:\n \n          [   sx   0    0   ]\n          [   0    sy   0   ]\n          [   0    0    1   ]\n "}, {"method_name": "shear", "method_sig": "public abstract void shear (double shx,\n                           double shy)", "description": "Concatenates the current Graphics2D\nTransform with a shearing transform.\n Subsequent renderings are sheared by the specified\n multiplier relative to the previous position.\n This is equivalent to calling transform(SH), where SH\n is an AffineTransform represented by the following\n matrix:\n \n          [   1   shx   0   ]\n          [  shy   1    0   ]\n          [   0    0    1   ]\n "}, {"method_name": "transform", "method_sig": "public abstract void transform (AffineTransform Tx)", "description": "Composes an AffineTransform object with the\n Transform in this Graphics2D according\n to the rule last-specified-first-applied.  If the current\n Transform is Cx, the result of composition\n with Tx is a new Transform Cx'.  Cx' becomes the\n current Transform for this Graphics2D.\n Transforming a point p by the updated Transform Cx' is\n equivalent to first transforming p by Tx and then transforming\n the result by the original Transform Cx.  In other\n words, Cx'(p) = Cx(Tx(p)).  A copy of the Tx is made, if necessary,\n so further modifications to Tx do not affect rendering."}, {"method_name": "setTransform", "method_sig": "public abstract void setTransform (AffineTransform Tx)", "description": "Overwrites the Transform in the Graphics2D context.\n WARNING: This method should never be used to apply a new\n coordinate transform on top of an existing transform because the\n Graphics2D might already have a transform that is\n needed for other purposes, such as rendering Swing\n components or applying a scaling transformation to adjust for the\n resolution of a printer.\n To add a coordinate transform, use the\n transform, rotate, scale,\n or shear methods.  The setTransform\n method is intended only for restoring the original\n Graphics2D transform after rendering, as shown in this\n example:\n \n // Get the current transform\n AffineTransform saveAT = g2.getTransform();\n // Perform transformation\n g2d.transform(...);\n // Render\n g2d.draw(...);\n // Restore original transform\n g2d.setTransform(saveAT);\n "}, {"method_name": "getTransform", "method_sig": "public abstract AffineTransform getTransform()", "description": "Returns a copy of the current Transform in the\n Graphics2D context."}, {"method_name": "getPaint", "method_sig": "public abstract Paint getPaint()", "description": "Returns the current Paint of the\n Graphics2D context."}, {"method_name": "getComposite", "method_sig": "public abstract Composite getComposite()", "description": "Returns the current Composite in the\n Graphics2D context."}, {"method_name": "setBackground", "method_sig": "public abstract void setBackground (Color color)", "description": "Sets the background color for the Graphics2D context.\n The background color is used for clearing a region.\n When a Graphics2D is constructed for a\n Component, the background color is\n inherited from the Component. Setting the background color\n in the Graphics2D context only affects the subsequent\n clearRect calls and not the background color of the\n Component.  To change the background\n of the Component, use appropriate methods of\n the Component."}, {"method_name": "getBackground", "method_sig": "public abstract Color getBackground()", "description": "Returns the background color used for clearing a region."}, {"method_name": "getStroke", "method_sig": "public abstract Stroke getStroke()", "description": "Returns the current Stroke in the\n Graphics2D context."}, {"method_name": "clip", "method_sig": "public abstract void clip (Shape s)", "description": "Intersects the current Clip with the interior of the\n specified Shape and sets the Clip to the\n resulting intersection.  The specified Shape is\n transformed with the current Graphics2D\nTransform before being intersected with the current\n Clip.  This method is used to make the current\n Clip smaller.\n To make the Clip larger, use setClip.\n The user clip modified by this method is independent of the\n clipping associated with device bounds and visibility.  If no clip has\n previously been set, or if the clip has been cleared using\n setClip with a null\n argument, the specified Shape becomes the new\n user clip."}, {"method_name": "getFontRenderContext", "method_sig": "public abstract FontRenderContext getFontRenderContext()", "description": "Get the rendering context of the Font within this\n Graphics2D context.\n The FontRenderContext\n encapsulates application hints such as anti-aliasing and\n fractional metrics, as well as target device specific information\n such as dots-per-inch.  This information should be provided by the\n application when using objects that perform typographical\n formatting, such as Font and\n TextLayout.  This information should also be provided\n by applications that perform their own layout and need accurate\n measurements of various characteristics of glyphs such as advance\n and line height when various rendering hints have been applied to\n the text rendering."}]}