{"name": "Class KeyAgreement", "module": "java.base", "package": "javax.crypto", "text": "This class provides the functionality of a key agreement (or key\n exchange) protocol.\n \n The keys involved in establishing a shared secret are created by one of the\n key generators (KeyPairGenerator or\n KeyGenerator), a KeyFactory, or as a result from\n an intermediate phase of the key agreement protocol.\n\n  For each of the correspondents in the key exchange, doPhase\n needs to be called. For example, if this key exchange is with one other\n party, doPhase needs to be called once, with the\n lastPhase flag set to true.\n If this key exchange is\n with two other parties, doPhase needs to be called twice,\n the first time setting the lastPhase flag to\n false, and the second time setting it to true.\n There may be any number of parties involved in a key exchange.\n\n  Every implementation of the Java platform is required to support the\n following standard KeyAgreement algorithm:\n \nDiffieHellman\n\n This algorithm is described in the \n KeyAgreement section of the\n Java Security Standard Algorithm Names Specification.\n Consult the release documentation for your implementation to see if any\n other algorithms are supported.", "codes": ["public class KeyAgreement\nextends Object"], "fields": [], "methods": [{"method_name": "getAlgorithm", "method_sig": "public final String getAlgorithm()", "description": "Returns the algorithm name of this KeyAgreement object.\n\n This is the same name that was specified in one of the\n getInstance calls that created this\n KeyAgreement object."}, {"method_name": "getInstance", "method_sig": "public static final KeyAgreement getInstance (String algorithm)\n                                      throws NoSuchAlgorithmException", "description": "Returns a KeyAgreement object that implements the\n specified key agreement algorithm.\n\n  This method traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new KeyAgreement object encapsulating the\n KeyAgreementSpi implementation from the first\n Provider that supports the specified algorithm is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."}, {"method_name": "getInstance", "method_sig": "public static final KeyAgreement getInstance (String algorithm,\n                                             String provider)\n                                      throws NoSuchAlgorithmException,\n                                             NoSuchProviderException", "description": "Returns a KeyAgreement object that implements the\n specified key agreement algorithm.\n\n  A new KeyAgreement object encapsulating the\n KeyAgreementSpi implementation from the specified provider\n is returned.  The specified provider must be registered\n in the security provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."}, {"method_name": "getInstance", "method_sig": "public static final KeyAgreement getInstance (String algorithm,\n                                             Provider provider)\n                                      throws NoSuchAlgorithmException", "description": "Returns a KeyAgreement object that implements the\n specified key agreement algorithm.\n\n  A new KeyAgreement object encapsulating the\n KeyAgreementSpi implementation from the specified Provider\n object is returned.  Note that the specified Provider object\n does not have to be registered in the provider list."}, {"method_name": "getProvider", "method_sig": "public final Provider getProvider()", "description": "Returns the provider of this KeyAgreement object."}, {"method_name": "init", "method_sig": "public final void init (Key key)\n                throws InvalidKeyException", "description": "Initializes this key agreement with the given key, which is required to\n contain all the algorithm parameters required for this key agreement.\n\n  If this key agreement requires any random bytes, it will get\n them using the\n SecureRandom\n implementation of the highest-priority\n installed provider as the source of randomness.\n (If none of the installed providers supply an implementation of\n SecureRandom, a system-provided source of randomness will be used.)"}, {"method_name": "init", "method_sig": "public final void init (Key key,\n                       SecureRandom random)\n                throws InvalidKeyException", "description": "Initializes this key agreement with the given key and source of\n randomness. The given key is required to contain all the algorithm\n parameters required for this key agreement.\n\n  If the key agreement algorithm requires random bytes, it gets them\n from the given source of randomness, random.\n However, if the underlying\n algorithm implementation does not require any random bytes,\n random is ignored."}, {"method_name": "init", "method_sig": "public final void init (Key key,\n                       AlgorithmParameterSpec params)\n                throws InvalidKeyException,\n                       InvalidAlgorithmParameterException", "description": "Initializes this key agreement with the given key and set of\n algorithm parameters.\n\n  If this key agreement requires any random bytes, it will get\n them using the\n SecureRandom\n implementation of the highest-priority\n installed provider as the source of randomness.\n (If none of the installed providers supply an implementation of\n SecureRandom, a system-provided source of randomness will be used.)"}, {"method_name": "init", "method_sig": "public final void init (Key key,\n                       AlgorithmParameterSpec params,\n                       SecureRandom random)\n                throws InvalidKeyException,\n                       InvalidAlgorithmParameterException", "description": "Initializes this key agreement with the given key, set of\n algorithm parameters, and source of randomness."}, {"method_name": "doPhase", "method_sig": "public final Key doPhase (Key key,\n                         boolean lastPhase)\n                  throws InvalidKeyException,\n                         IllegalStateException", "description": "Executes the next phase of this key agreement with the given\n key that was received from one of the other parties involved in this key\n agreement."}, {"method_name": "generateSecret", "method_sig": "public final byte[] generateSecret()\n                            throws IllegalStateException", "description": "Generates the shared secret and returns it in a new buffer.\n\n This method resets this KeyAgreement object, so that it\n can be reused for further key agreements. Unless this key agreement is\n reinitialized with one of the init methods, the same\n private information and algorithm parameters will be used for\n subsequent key agreements."}, {"method_name": "generateSecret", "method_sig": "public final int generateSecret (byte[] sharedSecret,\n                                int offset)\n                         throws IllegalStateException,\n                                ShortBufferException", "description": "Generates the shared secret, and places it into the buffer\n sharedSecret, beginning at offset inclusive.\n\n If the sharedSecret buffer is too small to hold the\n result, a ShortBufferException is thrown.\n In this case, this call should be repeated with a larger output buffer.\n\n This method resets this KeyAgreement object, so that it\n can be reused for further key agreements. Unless this key agreement is\n reinitialized with one of the init methods, the same\n private information and algorithm parameters will be used for\n subsequent key agreements."}, {"method_name": "generateSecret", "method_sig": "public final SecretKey generateSecret (String algorithm)\n                               throws IllegalStateException,\n                                      NoSuchAlgorithmException,\n                                      InvalidKeyException", "description": "Creates the shared secret and returns it as a SecretKey\n object of the specified algorithm.\n\n This method resets this KeyAgreement object, so that it\n can be reused for further key agreements. Unless this key agreement is\n reinitialized with one of the init methods, the same\n private information and algorithm parameters will be used for\n subsequent key agreements."}]}