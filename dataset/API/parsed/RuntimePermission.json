{"name": "Class RuntimePermission", "module": "java.base", "package": "java.lang", "text": "This class is for runtime permissions. A RuntimePermission\n contains a name (also referred to as a \"target name\") but no actions\n list; you either have the named permission or you don't.\n \n The target name is the name of the runtime permission (see below). The\n naming convention follows the  hierarchical property naming convention.\n Also, an asterisk may appear at the end of the name, following a \".\",\n or by itself, to signify a wildcard match. For example: \"loadLibrary.*\"\n and \"*\" signify a wildcard match, while \"*loadLibrary\" and \"a*b\" do not.\n \n The following table lists the standard RuntimePermission\n target names, and for each provides a description of what the permission\n allows and a discussion of the risks of granting code the permission.\n\n \npermission target name,\n  what the target allows, and associated risks\n\n\nPermission Target Name\nWhat the Permission Allows\nRisks of Allowing this Permission\n\n\n\n\ncreateClassLoader\nCreation of a class loader\nThis is an extremely dangerous permission to grant.\n Malicious applications that can instantiate their own class\n loaders could then load their own rogue classes into the system.\n These newly loaded classes could be placed into any protection\n domain by the class loader, thereby automatically granting the\n classes the permissions for that domain.\n\n\ngetClassLoader\nRetrieval of a class loader (e.g., the class loader for the calling\n class)\nThis would grant an attacker permission to get the\n class loader for a particular class. This is dangerous because\n having access to a class's class loader allows the attacker to\n load other classes available to that class loader. The attacker\n would typically otherwise not have access to those classes.\n\n\nsetContextClassLoader\nSetting of the context class loader used by a thread\nThe context class loader is used by system code and extensions\n when they need to lookup resources that might not exist in the system\n class loader. Granting setContextClassLoader permission would allow\n code to change which context class loader is used\n for a particular thread, including system threads.\n\n\nenableContextClassLoaderOverride\nSubclass implementation of the thread context class loader methods\nThe context class loader is used by system code and extensions\n when they need to lookup resources that might not exist in the system\n class loader. Granting enableContextClassLoaderOverride permission would allow\n a subclass of Thread to override the methods that are used\n to get or set the context class loader for a particular thread.\n\n\ncloseClassLoader\nClosing of a ClassLoader\nGranting this permission allows code to close any URLClassLoader\n that it has a reference to.\n\n\nsetSecurityManager\nSetting of the security manager (possibly replacing an existing one)\n \nThe security manager is a class that allows\n applications to implement a security policy. Granting the setSecurityManager\n permission would allow code to change which security manager is used by\n installing a different, possibly less restrictive security manager,\n thereby bypassing checks that would have been enforced by the original\n security manager.\n\n\ncreateSecurityManager\nCreation of a new security manager\nThis gives code access to protected, sensitive methods that may\n disclose information about other classes or the execution stack.\n\n\ngetenv.{variable name}\nReading of the value of the specified environment variable\nThis would allow code to read the value, or determine the\n       existence, of a particular environment variable.  This is\n       dangerous if the variable contains confidential data.\n\n\nexitVM.{exit status}\nHalting of the Java Virtual Machine with the specified exit status\nThis allows an attacker to mount a denial-of-service attack\n by automatically forcing the virtual machine to halt.\n Note: The \"exitVM.*\" permission is automatically granted to all code\n loaded from the application class path, thus enabling applications\n to terminate themselves. Also, the \"exitVM\" permission is equivalent to\n \"exitVM.*\".\n\n\nshutdownHooks\nRegistration and cancellation of virtual-machine shutdown hooks\nThis allows an attacker to register a malicious shutdown\n hook that interferes with the clean shutdown of the virtual machine.\n\n\nsetFactory\nSetting of the socket factory used by ServerSocket or Socket,\n or of the stream handler factory used by URL\nThis allows code to set the actual implementation\n for the socket, server socket, stream handler, or RMI socket factory.\n An attacker may set a faulty implementation which mangles the data\n stream.\n\n\nsetIO\nSetting of System.out, System.in, and System.err\nThis allows changing the value of the standard system streams.\n An attacker may change System.in to monitor and\n steal user input, or may set System.err to a \"null\" OutputStream,\n which would hide any error messages sent to System.err. \n\n\nmodifyThread\nModification of threads, e.g., via calls to Thread\n interrupt, stop, suspend, resume, setDaemon, setPriority,\n setName and setUncaughtExceptionHandler\n methods\nThis allows an attacker to modify the behaviour of\n any thread in the system.\n\n\nstopThread\nStopping of threads via calls to the Thread stop\n method\nThis allows code to stop any thread in the system provided that it is\n already granted permission to access that thread.\n This poses as a threat, because that code may corrupt the system by\n killing existing threads.\n\n\nmodifyThreadGroup\nmodification of thread groups, e.g., via calls to ThreadGroup\n destroy, getParent, resume,\n setDaemon, setMaxPriority, stop,\n and suspend methods\nThis allows an attacker to create thread groups and\n set their run priority.\n\n\ngetProtectionDomain\nRetrieval of the ProtectionDomain for a class\nThis allows code to obtain policy information\n for a particular code source. While obtaining policy information\n does not compromise the security of the system, it does give\n attackers additional information, such as local file names for\n example, to better aim an attack.\n\n\ngetFileSystemAttributes\nRetrieval of file system attributes\nThis allows code to obtain file system information such as disk usage\n       or disk space available to the caller.  This is potentially dangerous\n       because it discloses information about the system hardware\n       configuration and some information about the caller's privilege to\n       write files.\n\n\nreadFileDescriptor\nReading of file descriptors\nThis would allow code to read the particular file associated\n       with the file descriptor read. This is dangerous if the file\n       contains confidential data.\n\n\nwriteFileDescriptor\nWriting to file descriptors\nThis allows code to write to a particular file associated\n       with the descriptor. This is dangerous because it may allow\n       malicious code to plant viruses or at the very least, fill up\n       your entire disk.\n\n\nloadLibrary.{library name}\nDynamic linking of the specified library\nIt is dangerous to allow an applet permission to load native code\n libraries, because the Java security architecture is not designed to and\n does not prevent malicious behavior at the level of native code.\n\n\naccessClassInPackage.{package name}\nAccess to the specified package via a class loader's\n loadClass method when that class loader calls\n the SecurityManager checkPackageAccess method\nThis gives code access to classes in packages\n to which it normally does not have access. Malicious code\n may use these classes to help in its attempt to compromise\n security in the system.\n\n\ndefineClassInPackage.{package name}\nDefinition of classes in the specified package, via a class\n loader's defineClass method when that class loader calls\n the SecurityManager checkPackageDefinition method.\nThis grants code permission to define a class\n in a particular package. This is dangerous because malicious\n code with this permission may define rogue classes in\n trusted packages like java.security or java.lang,\n for example.\n\n\ndefineClass\nDefine a class with\n Lookup.defineClass.\nThis grants code with a suitably privileged Lookup object\n permission to define classes in the same package as the Lookup's\n lookup class. \n\n\naccessDeclaredMembers\nAccess to the declared members of a class\nThis grants code permission to query a class for its public,\n protected, default (package) access, and private fields and/or\n methods. Although the code would have\n access to the private and protected field and method names, it would not\n have access to the private/protected field data and would not be able\n to invoke any private methods. Nevertheless, malicious code\n may use this information to better aim an attack.\n Additionally, it may invoke any public methods and/or access public fields\n in the class.  This could be dangerous if\n the code would normally not be able to invoke those methods and/or\n access the fields  because\n it can't cast the object to the class/interface with those methods\n and fields.\n\n\n\nqueuePrintJob\nInitiation of a print job request\nThis could print sensitive information to a printer,\n or simply waste paper.\n\n\ngetStackTrace\nRetrieval of the stack trace information of another thread.\nThis allows retrieval of the stack trace information of\n another thread.  This might allow malicious code to monitor the\n execution of threads and discover vulnerabilities in applications.\n\n\ngetStackWalkerWithClassReference\nGet a stack walker that can retrieve stack frames with class reference.\nThis allows retrieval of Class objects from stack walking.\n   This might allow malicious code to access Class objects on the stack\n   outside its own context.\n\n\nsetDefaultUncaughtExceptionHandler\nSetting the default handler to be used when a thread\n   terminates abruptly due to an uncaught exception\nThis allows an attacker to register a malicious\n   uncaught exception handler that could interfere with termination\n   of a thread\n\n\npreferences\nRepresents the permission required to get access to the\n   java.util.prefs.Preferences implementations user or system root\n   which in turn allows retrieval or update operations within the\n   Preferences persistent backing store.) \nThis permission allows the user to read from or write to the\n   preferences backing store if the user running the code has\n   sufficient OS privileges to read/write to that backing store.\n   The actual backing store may reside within a traditional filesystem\n   directory or within a registry depending on the platform OS\n\n\nmanageProcess\nNative process termination and information about processes\n       ProcessHandle.\nAllows code to identify and terminate processes that it did not create.\n\n\nlocaleServiceProvider\nThis RuntimePermission is required to be granted to\n   classes which subclass and implement\n   java.util.spi.LocaleServiceProvider. The permission is\n   checked during invocation of the abstract base class constructor.\n   This permission ensures trust in classes which implement this\n   security-sensitive provider mechanism. \nSee \njava.util.spi.LocaleServiceProvider for more\n   information.\n\n\nloggerFinder\nThis RuntimePermission is required to be granted to\n   classes which subclass or call methods on\n   java.lang.System.LoggerFinder. The permission is\n   checked during invocation of the abstract base class constructor, as\n   well as on the invocation of its public methods.\n   This permission ensures trust in classes which provide loggers\n   to system classes.\nSee java.lang.System.LoggerFinder\n   for more information.\n\n\naccessSystemModules\nAccess system modules in the runtime image.\nThis grants the permission to access resources in the\n   system modules in the runtime image.\n\n\n", "codes": ["public final class RuntimePermission\nextends BasicPermission"], "fields": [], "methods": []}