{"name": "Class Area", "module": "java.desktop", "package": "java.awt.geom", "text": "An Area object stores and manipulates a\n resolution-independent description of an enclosed area of\n 2-dimensional space.\n Area objects can be transformed and can perform\n various Constructive Area Geometry (CAG) operations when combined\n with other Area objects.\n The CAG operations include area\n addition, subtraction,\n intersection, and exclusive or.\n See the linked method documentation for examples of the various\n operations.\n \n The Area class implements the Shape\n interface and provides full support for all of its hit-testing\n and path iteration facilities, but an Area is more\n specific than a generalized path in a number of ways:\n \nOnly closed paths and sub-paths are stored.\n     Area objects constructed from unclosed paths\n     are implicitly closed during construction as if those paths\n     had been filled by the Graphics2D.fill method.\n The interiors of the individual stored sub-paths are all\n     non-empty and non-overlapping.  Paths are decomposed during\n     construction into separate component non-overlapping parts,\n     empty pieces of the path are discarded, and then these\n     non-empty and non-overlapping properties are maintained\n     through all subsequent CAG operations.  Outlines of different\n     component sub-paths may touch each other, as long as they\n     do not cross so that their enclosed areas overlap.\n The geometry of the path describing the outline of the\n     Area resembles the path from which it was\n     constructed only in that it describes the same enclosed\n     2-dimensional area, but may use entirely different types\n     and ordering of the path segments to do so.\n \n Interesting issues which are not always obvious when using\n the Area include:\n \nCreating an Area from an unclosed (open)\n     Shape results in a closed outline in the\n     Area object.\n Creating an Area from a Shape\n     which encloses no area (even when \"closed\") produces an\n     empty Area.  A common example of this issue\n     is that producing an Area from a line will\n     be empty since the line encloses no area.  An empty\n     Area will iterate no geometry in its\n     PathIterator objects.\n A self-intersecting Shape may be split into\n     two (or more) sub-paths each enclosing one of the\n     non-intersecting portions of the original path.\n An Area may take more path segments to\n     describe the same geometry even when the original\n     outline is simple and obvious.  The analysis that the\n     Area class must perform on the path may\n     not reflect the same concepts of \"simple and obvious\"\n     as a human being perceives.\n ", "codes": ["public class Area\nextends Object\nimplements Shape, Cloneable"], "fields": [], "methods": [{"method_name": "add", "method_sig": "public void add (Area rhs)", "description": "Adds the shape of the specified Area to the\n shape of this Area.\n The resulting shape of this Area will include\n the union of both shapes, or all areas that were contained\n in either this or the specified Area.\n \n     // Example:\n     Area a1 = new Area([triangle 0,0 => 8,0 => 0,8]);\n     Area a2 = new Area([triangle 0,0 => 8,0 => 8,8]);\n     a1.add(a2);\n\n        a1(before)     +         a2         =     a1(after)\n\n     ################     ################     ################\n     ##############         ##############     ################\n     ############             ############     ################\n     ##########                 ##########     ################\n     ########                     ########     ################\n     ######                         ######     ######    ######\n     ####                             ####     ####        ####\n     ##                                 ##     ##            ##\n "}, {"method_name": "subtract", "method_sig": "public void subtract (Area rhs)", "description": "Subtracts the shape of the specified Area from the\n shape of this Area.\n The resulting shape of this Area will include\n areas that were contained only in this Area\n and not in the specified Area.\n \n     // Example:\n     Area a1 = new Area([triangle 0,0 => 8,0 => 0,8]);\n     Area a2 = new Area([triangle 0,0 => 8,0 => 8,8]);\n     a1.subtract(a2);\n\n        a1(before)     -         a2         =     a1(after)\n\n     ################     ################\n     ##############         ##############     ##\n     ############             ############     ####\n     ##########                 ##########     ######\n     ########                     ########     ########\n     ######                         ######     ######\n     ####                             ####     ####\n     ##                                 ##     ##\n "}, {"method_name": "intersect", "method_sig": "public void intersect (Area rhs)", "description": "Sets the shape of this Area to the intersection of\n its current shape and the shape of the specified Area.\n The resulting shape of this Area will include\n only areas that were contained in both this Area\n and also in the specified Area.\n \n     // Example:\n     Area a1 = new Area([triangle 0,0 => 8,0 => 0,8]);\n     Area a2 = new Area([triangle 0,0 => 8,0 => 8,8]);\n     a1.intersect(a2);\n\n      a1(before)   intersect     a2         =     a1(after)\n\n     ################     ################     ################\n     ##############         ##############       ############\n     ############             ############         ########\n     ##########                 ##########           ####\n     ########                     ########\n     ######                         ######\n     ####                             ####\n     ##                                 ##\n "}, {"method_name": "exclusiveOr", "method_sig": "public void exclusiveOr (Area rhs)", "description": "Sets the shape of this Area to be the combined area\n of its current shape and the shape of the specified Area,\n minus their intersection.\n The resulting shape of this Area will include\n only areas that were contained in either this Area\n or in the specified Area, but not in both.\n \n     // Example:\n     Area a1 = new Area([triangle 0,0 => 8,0 => 0,8]);\n     Area a2 = new Area([triangle 0,0 => 8,0 => 8,8]);\n     a1.exclusiveOr(a2);\n\n        a1(before)    xor        a2         =     a1(after)\n\n     ################     ################\n     ##############         ##############     ##            ##\n     ############             ############     ####        ####\n     ##########                 ##########     ######    ######\n     ########                     ########     ################\n     ######                         ######     ######    ######\n     ####                             ####     ####        ####\n     ##                                 ##     ##            ##\n "}, {"method_name": "reset", "method_sig": "public void reset()", "description": "Removes all of the geometry from this Area and\n restores it to an empty area."}, {"method_name": "isEmpty", "method_sig": "public boolean isEmpty()", "description": "Tests whether this Area object encloses any area."}, {"method_name": "isPolygonal", "method_sig": "public boolean isPolygonal()", "description": "Tests whether this Area consists entirely of\n straight edged polygonal geometry."}, {"method_name": "isRectangular", "method_sig": "public boolean isRectangular()", "description": "Tests whether this Area is rectangular in shape."}, {"method_name": "isSingular", "method_sig": "public boolean isSingular()", "description": "Tests whether this Area is comprised of a single\n closed subpath.  This method returns true if the\n path contains 0 or 1 subpaths, or false if the path\n contains more than 1 subpath.  The subpaths are counted by the\n number of SEG_MOVETO  segments\n that appear in the path."}, {"method_name": "getBounds2D", "method_sig": "public Rectangle2D getBounds2D()", "description": "Returns a high precision bounding Rectangle2D that\n completely encloses this Area.\n \n The Area class will attempt to return the tightest bounding\n box possible for the Shape.  The bounding box will not be\n padded to include the control points of curves in the outline\n of the Shape, but should tightly fit the actual geometry of\n the outline itself."}, {"method_name": "getBounds", "method_sig": "public Rectangle getBounds()", "description": "Returns a bounding Rectangle that completely encloses\n this Area.\n \n The Area class will attempt to return the tightest bounding\n box possible for the Shape.  The bounding box will not be\n padded to include the control points of curves in the outline\n of the Shape, but should tightly fit the actual geometry of\n the outline itself.  Since the returned object represents\n the bounding box with integers, the bounding box can only be\n as tight as the nearest integer coordinates that encompass\n the geometry of the Shape."}, {"method_name": "clone", "method_sig": "public Object clone()", "description": "Returns an exact copy of this Area object."}, {"method_name": "equals", "method_sig": "public boolean equals (Area other)", "description": "Tests whether the geometries of the two Area objects\n are equal.\n This method will return false if the argument is null."}, {"method_name": "transform", "method_sig": "public void transform (AffineTransform t)", "description": "Transforms the geometry of this Area using the specified\n AffineTransform.  The geometry is transformed in place, which\n permanently changes the enclosed area defined by this object."}, {"method_name": "createTransformedArea", "method_sig": "public Area createTransformedArea (AffineTransform t)", "description": "Creates a new Area object that contains the same\n geometry as this Area transformed by the specified\n AffineTransform.  This Area object\n is unchanged."}, {"method_name": "contains", "method_sig": "public boolean contains (double x,\n                        double y)", "description": "Tests if the specified coordinates are inside the boundary of the\n Shape, as described by the\n \n definition of insideness."}, {"method_name": "contains", "method_sig": "public boolean contains (Point2D p)", "description": "Tests if a specified Point2D is inside the boundary\n of the Shape, as described by the\n \n definition of insideness."}, {"method_name": "contains", "method_sig": "public boolean contains (double x,\n                        double y,\n                        double w,\n                        double h)", "description": "Tests if the interior of the Shape entirely contains\n the specified rectangular area.  All coordinates that lie inside\n the rectangular area must lie within the Shape for the\n entire rectangular area to be considered contained within the\n Shape.\n \n The Shape.contains() method allows a Shape\n implementation to conservatively return false when:\n \n\n the intersect method returns true and\n \n the calculations to determine whether or not the\n Shape entirely contains the rectangular area are\n prohibitively expensive.\n \n This means that for some Shapes this method might\n return false even though the Shape contains\n the rectangular area.\n The Area class performs\n more accurate geometric computations than most\n Shape objects and therefore can be used if a more precise\n answer is required."}, {"method_name": "contains", "method_sig": "public boolean contains (Rectangle2D r)", "description": "Tests if the interior of the Shape entirely contains the\n specified Rectangle2D.\n The Shape.contains() method allows a Shape\n implementation to conservatively return false when:\n \n\n the intersect method returns true and\n \n the calculations to determine whether or not the\n Shape entirely contains the Rectangle2D\n are prohibitively expensive.\n \n This means that for some Shapes this method might\n return false even though the Shape contains\n the Rectangle2D.\n The Area class performs\n more accurate geometric computations than most\n Shape objects and therefore can be used if a more precise\n answer is required."}, {"method_name": "intersects", "method_sig": "public boolean intersects (double x,\n                          double y,\n                          double w,\n                          double h)", "description": "Tests if the interior of the Shape intersects the\n interior of a specified rectangular area.\n The rectangular area is considered to intersect the Shape\n if any point is contained in both the interior of the\n Shape and the specified rectangular area.\n \n The Shape.intersects() method allows a Shape\n implementation to conservatively return true when:\n \n\n there is a high probability that the rectangular area and the\n Shape intersect, but\n \n the calculations to accurately determine this intersection\n are prohibitively expensive.\n \n This means that for some Shapes this method might\n return true even though the rectangular area does not\n intersect the Shape.\n The Area class performs\n more accurate computations of geometric intersection than most\n Shape objects and therefore can be used if a more precise\n answer is required."}, {"method_name": "intersects", "method_sig": "public boolean intersects (Rectangle2D r)", "description": "Tests if the interior of the Shape intersects the\n interior of a specified Rectangle2D.\n The Shape.intersects() method allows a Shape\n implementation to conservatively return true when:\n \n\n there is a high probability that the Rectangle2D and the\n Shape intersect, but\n \n the calculations to accurately determine this intersection\n are prohibitively expensive.\n \n This means that for some Shapes this method might\n return true even though the Rectangle2D does not\n intersect the Shape.\n The Area class performs\n more accurate computations of geometric intersection than most\n Shape objects and therefore can be used if a more precise\n answer is required."}, {"method_name": "getPathIterator", "method_sig": "public PathIterator getPathIterator (AffineTransform at)", "description": "Creates a PathIterator for the outline of this\n Area object.  This Area object is unchanged."}, {"method_name": "getPathIterator", "method_sig": "public PathIterator getPathIterator (AffineTransform at,\n                                    double flatness)", "description": "Creates a PathIterator for the flattened outline of\n this Area object.  Only uncurved path segments\n represented by the SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point\n types are returned by the iterator.  This Area\n object is unchanged."}]}