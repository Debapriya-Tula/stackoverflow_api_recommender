{"name": "Class PersistenceDelegate", "module": "java.desktop", "package": "java.beans", "text": "The PersistenceDelegate class takes the responsibility\n for expressing the state of an instance of a given class\n in terms of the methods in the class's public API. Instead\n of associating the responsibility of persistence with\n the class itself as is done, for example, by the\n readObject and writeObject\n methods used by the ObjectOutputStream, streams like\n the XMLEncoder which\n use this delegation model can have their behavior controlled\n independently of the classes themselves. Normally, the class\n is the best place to put such information and conventions\n can easily be expressed in this delegation scheme to do just that.\n Sometimes however, it is the case that a minor problem\n in a single class prevents an entire object graph from\n being written and this can leave the application\n developer with no recourse but to attempt to shadow\n the problematic classes locally or use alternative\n persistence techniques. In situations like these, the\n delegation model gives a relatively clean mechanism for\n the application developer to intervene in all parts of the\n serialization process without requiring that modifications\n be made to the implementation of classes which are not part\n of the application itself.\n \n In addition to using a delegation model, this persistence\n scheme differs from traditional serialization schemes\n in requiring an analog of the writeObject\n method without a corresponding readObject\n method. The writeObject analog encodes each\n instance in terms of its public API and there is no need to\n define a readObject analog\n since the procedure for reading the serialized form\n is defined by the semantics of method invocation as laid\n out in the Java Language Specification.\n Breaking the dependency between writeObject\n and readObject implementations, which may\n change from version to version, is the key factor\n in making the archives produced by this technique immune\n to changes in the private implementations of the classes\n to which they refer.\n \n A persistence delegate, may take control of all\n aspects of the persistence of an object including:\n \n\n Deciding whether or not an instance can be mutated\n into another instance of the same class.\n \n Instantiating the object, either by calling a\n public constructor or a public factory method.\n \n Performing the initialization of the object.\n ", "codes": ["public abstract class PersistenceDelegate\nextends Object"], "fields": [], "methods": [{"method_name": "writeObject", "method_sig": "public void writeObject (Object oldInstance,\n                        Encoder out)", "description": "The writeObject is a single entry point to the persistence\n and is used by an Encoder in the traditional\n mode of delegation. Although this method is not final,\n it should not need to be subclassed under normal circumstances.\n \n This implementation first checks to see if the stream\n has already encountered this object. Next the\n mutatesTo method is called to see if\n that candidate returned from the stream can\n be mutated into an accurate copy of oldInstance.\n If it can, the initialize method is called to\n perform the initialization. If not, the candidate is removed\n from the stream, and the instantiate method\n is called to create a new candidate for this object."}, {"method_name": "mutatesTo", "method_sig": "protected boolean mutatesTo (Object oldInstance,\n                            Object newInstance)", "description": "Returns true if an equivalent copy of oldInstance may be\n created by applying a series of statements to newInstance.\n In the specification of this method, we mean by equivalent that the modified instance\n is indistinguishable from oldInstance in the behavior\n of the relevant methods in its public API. [Note: we use the\n phrase relevant methods rather than all methods\n here only because, to be strictly correct, methods like hashCode\n and toString prevent most classes from producing truly\n indistinguishable copies of their instances].\n \n The default behavior returns true\n if the classes of the two instances are the same."}, {"method_name": "instantiate", "method_sig": "protected abstract Expression instantiate (Object oldInstance,\n                                          Encoder out)", "description": "Returns an expression whose value is oldInstance.\n This method is used to characterize the constructor\n or factory method that should be used to create the given object.\n For example, the instantiate method of the persistence\n delegate for the Field class could be defined as follows:\n \n Field f = (Field)oldInstance;\n return new Expression(f, f.getDeclaringClass(), \"getField\", new Object[]{f.getName()});\n \n Note that we declare the value of the returned expression so that\n the value of the expression (as returned by getValue)\n will be identical to oldInstance."}, {"method_name": "initialize", "method_sig": "protected void initialize (Class<?> type,\n                          Object oldInstance,\n                          Object newInstance,\n                          Encoder out)", "description": "Produce a series of statements with side effects on newInstance\n so that the new instance becomes equivalent to oldInstance.\n In the specification of this method, we mean by equivalent that, after the method\n returns, the modified instance is indistinguishable from\n newInstance in the behavior of all methods in its\n public API.\n \n The implementation typically achieves this goal by producing a series of\n \"what happened\" statements involving the oldInstance\n and its publicly available state. These statements are sent\n to the output stream using its writeExpression\n method which returns an expression involving elements in\n a cloned environment simulating the state of an input stream during\n reading. Each statement returned will have had all instances\n the old environment replaced with objects which exist in the new\n one. In particular, references to the target of these statements,\n which start out as references to oldInstance are returned\n as references to the newInstance instead.\n Executing these statements effects an incremental\n alignment of the state of the two objects as a series of\n modifications to the objects in the new environment.\n By the time the initialize method returns it should be impossible\n to tell the two instances apart by using their public APIs.\n Most importantly, the sequence of steps that were used to make\n these objects appear equivalent will have been recorded\n by the output stream and will form the actual output when\n the stream is flushed.\n \n The default implementation, calls the initialize\n method of the type's superclass."}]}