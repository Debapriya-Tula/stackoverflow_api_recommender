{"name": "Interface AnnotatedConstruct", "module": "java.compiler", "package": "javax.lang.model", "text": "Represents a construct that can be annotated.\n\n A construct is either an element or a type.  Annotations on an element\n are on a declaration, whereas annotations on a type are on\n a specific use of a type name.\n\n The terms directly present, present,\n indirectly present, and associated  are used\n throughout this interface to describe precisely which annotations\n are returned by the methods defined herein.\n\n In the definitions below, an annotation A has an\n annotation type AT. If AT is a repeatable annotation\n type, the type of the containing annotation is ATC.\n\n Annotation A is directly present on a construct\n C if either:\n\n \nA is explicitly or implicitly declared as applying to\n the source code representation of C.\n\n Typically, if exactly one annotation of type AT appears in\n the source code of representation of C, then A is\n explicitly declared as applying to C.\n\n If there are multiple annotations of type AT present on\n C, then if AT is repeatable annotation type, an\n annotation of type ATC is implicitly declared on C.\n\n  A representation of A appears in the executable output\n for C, such as the RuntimeVisibleAnnotations or\n RuntimeVisibleParameterAnnotations attributes of a class\n file.\n\n \nAn annotation A is present on a\n construct C if either:\n \nA is directly present on C.\n\n No annotation of type AT is directly present on\n C, and C is a class and AT is inheritable\n and A is present on the superclass of C.\n\n \n\n An annotation A is indirectly present on a construct\n C if both:\n\n \nAT is a repeatable annotation type with a containing\n annotation type ATC.\n\n An annotation of type ATC is directly present on\n C and A is an annotation included in the result of\n calling the value method of the directly present annotation\n of type ATC.\n\n \n\n An annotation A is associated with a construct\n C if either:\n\n \n A is directly or indirectly present on C.\n\n  No annotation of type AT is directly or indirectly\n present on C, and C is a class, and AT is\n inheritable, and A is associated with the superclass of\n C.\n\n ", "codes": ["public interface AnnotatedConstruct"], "fields": [], "methods": [{"method_name": "getAnnotationMirrors", "method_sig": "List<? extends AnnotationMirror> getAnnotationMirrors()", "description": "Returns the annotations that are directly present on\n this construct."}, {"method_name": "getAnnotation", "method_sig": "<A extends Annotation> A getAnnotation (Class<A> annotationType)", "description": "Returns this construct's annotation of the specified type if\n such an annotation is present, else null.\n\n  The annotation returned by this method could contain an element\n whose value is of type Class.\n This value cannot be returned directly:  information necessary to\n locate and load a class (such as the class loader to use) is\n not available, and the class might not be loadable at all.\n Attempting to read a Class object by invoking the relevant\n method on the returned annotation\n will result in a MirroredTypeException,\n from which the corresponding TypeMirror may be extracted.\n Similarly, attempting to read a Class[]-valued element\n will result in a MirroredTypesException.\n\n \nNote: This method is unlike others in this and related\n interfaces.  It operates on runtime reflective information \u2014\n representations of annotation types currently loaded into the\n VM \u2014 rather than on the representations defined by and used\n throughout these interfaces.  Consequently, calling methods on\n the returned annotation object can throw many of the exceptions\n that can be thrown when calling methods on an annotation object\n returned by core reflection.  This method is intended for\n callers that are written to operate on a known, fixed set of\n annotation types.\n "}, {"method_name": "getAnnotationsByType", "method_sig": "<A extends Annotation> A[] getAnnotationsByType (Class<A> annotationType)", "description": "Returns annotations that are associated with this construct.\n\n If there are no annotations associated with this construct, the\n return value is an array of length 0.\n\n The order of annotations which are directly or indirectly\n present on a construct C is computed as if indirectly present\n annotations on C are directly present on C in place of their\n container annotation, in the order in which they appear in the\n value element of the container annotation.\n\n The difference between this method and getAnnotation(Class)\n is that this method detects if its argument is a repeatable\n annotation type, and if so, attempts to find one or more\n annotations of that type by \"looking through\" a container annotation.\n\n  The annotations returned by this method could contain an element\n whose value is of type Class.\n This value cannot be returned directly:  information necessary to\n locate and load a class (such as the class loader to use) is\n not available, and the class might not be loadable at all.\n Attempting to read a Class object by invoking the relevant\n method on the returned annotation\n will result in a MirroredTypeException,\n from which the corresponding TypeMirror may be extracted.\n Similarly, attempting to read a Class[]-valued element\n will result in a MirroredTypesException.\n\n \nNote: This method is unlike others in this and related\n interfaces.  It operates on runtime reflective information \u2014\n representations of annotation types currently loaded into the\n VM \u2014 rather than on the representations defined by and used\n throughout these interfaces.  Consequently, calling methods on\n the returned annotation object can throw many of the exceptions\n that can be thrown when calling methods on an annotation object\n returned by core reflection.  This method is intended for\n callers that are written to operate on a known, fixed set of\n annotation types.\n "}]}