{"name": "Class ValidatorHandler", "module": "java.xml", "package": "javax.xml.validation", "text": "Streaming validator that works on SAX stream.\n\n \n A ValidatorHandler object is not thread-safe and not reentrant.\n In other words, it is the application's responsibility to make\n sure that one ValidatorHandler object is not used from\n more than one thread at any given time.\n\n \nValidatorHandler checks if the SAX events follow\n the set of constraints described in the associated Schema,\n and additionally it may modify the SAX events (for example\n by adding default values, etc.)\n\n \nValidatorHandler extends from ContentHandler,\n but it refines the underlying ContentHandler in\n the following way:\n \nstartElement/endElement events must receive non-null String\n      for uri, localName, and qname,\n      even though SAX allows some of them to be null.\n      Similarly, the user-specified ContentHandler will receive non-null\n      Strings for all three parameters.\n\n  Applications must ensure that ValidatorHandler's\n      ContentHandler.startPrefixMapping(String,String) and\n      ContentHandler.endPrefixMapping(String) are invoked\n      properly. Similarly, the user-specified ContentHandler\n      will receive startPrefixMapping/endPrefixMapping events.\n      If the ValidatorHandler introduces additional namespace\n      bindings, the user-specified ContentHandler will receive\n      additional startPrefixMapping/endPrefixMapping events.\n\n  Attributes for the\n      ContentHandler.startElement(String,String,String,Attributes) method\n      may or may not include xmlns* attributes.\n \n\n A ValidatorHandler is automatically reset every time\n the startDocument method is invoked.\n\n Recognized Properties and Features\n\n This spec defines the following feature that must be recognized\n by all ValidatorHandler implementations.\n\n http://xml.org/sax/features/namespace-prefixes\n\n This feature controls how a ValidatorHandler introduces\n namespace bindings that were not present in the original SAX event\n stream.\n When this feature is set to true, it must make\n sure that the user's ContentHandler will see\n the corresponding xmlns* attribute in\n the Attributes object of the\n ContentHandler.startElement(String,String,String,Attributes)\n callback. Otherwise, xmlns* attributes must not be\n added to Attributes that's passed to the\n user-specified ContentHandler.\n \n (Note that regardless of this switch, namespace bindings are\n always notified to applications through\n ContentHandler.startPrefixMapping(String,String) and\n ContentHandler.endPrefixMapping(String) methods of the\n ContentHandler specified by the user.)\n\n \n Note that this feature does NOT affect the way\n a ValidatorHandler receives SAX events. It merely\n changes the way it augments SAX events.\n\n This feature is set to false by default.", "codes": ["public abstract class ValidatorHandler\nextends Object\nimplements ContentHandler"], "fields": [], "methods": [{"method_name": "setContentHandler", "method_sig": "public abstract void setContentHandler (ContentHandler receiver)", "description": "Sets the ContentHandler which receives\n the augmented validation result.\n\n \n When a ContentHandler is specified, a\n ValidatorHandler will work as a filter\n and basically copy the incoming events to the\n specified ContentHandler.\n\n \n In doing so, a ValidatorHandler may modify\n the events, for example by adding defaulted attributes.\n\n \n A ValidatorHandler may buffer events to certain\n extent, but to allow ValidatorHandler to be used\n by a parser, the following requirement has to be met.\n\n \nWhen\n      ContentHandler.startElement(String, String, String, Attributes),\n      ContentHandler.endElement(String, String, String),\n      ContentHandler.startDocument(), or\n      ContentHandler.endDocument()\n      are invoked on a ValidatorHandler,\n      the same method on the user-specified ContentHandler\n      must be invoked for the same event before the callback\n      returns.\n  ValidatorHandler may not introduce new elements that\n      were not present in the input.\n\n  ValidatorHandler may not remove attributes that were\n      present in the input.\n \n\n When a callback method on the specified ContentHandler\n throws an exception, the same exception object must be thrown\n from the ValidatorHandler. The ErrorHandler\n should not be notified of such an exception.\n\n \n This method can be called even during a middle of a validation."}, {"method_name": "getContentHandler", "method_sig": "public abstract ContentHandler getContentHandler()", "description": "Gets the ContentHandler which receives the\n augmented validation result."}, {"method_name": "setErrorHandler", "method_sig": "public abstract void setErrorHandler (ErrorHandler errorHandler)", "description": "Sets the ErrorHandler to receive errors encountered\n during the validation.\n\n \n Error handler can be used to customize the error handling process\n during a validation. When an ErrorHandler is set,\n errors found during the validation will be first sent\n to the ErrorHandler.\n\n \n The error handler can abort further validation immediately\n by throwing SAXException from the handler. Or for example\n it can print an error to the screen and try to continue the\n validation by returning normally from the ErrorHandler\n\n If any Throwable is thrown from an ErrorHandler,\n the same Throwable object will be thrown toward the\n root of the call stack.\n\n \nValidatorHandler is not allowed to\n throw SAXException without first reporting it to\n ErrorHandler.\n\n \n When the ErrorHandler is null, the implementation will\n behave as if the following ErrorHandler is set:\n \n class DraconianErrorHandler implements ErrorHandler {\n     public void fatalError( SAXParseException e ) throws SAXException {\n         throw e;\n     }\n     public void error( SAXParseException e ) throws SAXException {\n         throw e;\n     }\n     public void warning( SAXParseException e ) throws SAXException {\n         // noop\n     }\n }\n \n\n When a new ValidatorHandler object is created, initially\n this field is set to null."}, {"method_name": "getErrorHandler", "method_sig": "public abstract ErrorHandler getErrorHandler()", "description": "Gets the current ErrorHandler set to this ValidatorHandler."}, {"method_name": "setResourceResolver", "method_sig": "public abstract void setResourceResolver (LSResourceResolver resourceResolver)", "description": "Sets the LSResourceResolver to customize\n resource resolution while in a validation episode.\n\n \nValidatorHandler uses a LSResourceResolver\n when it needs to locate external resources while a validation,\n although exactly what constitutes \"locating external resources\" is\n up to each schema language.\n\n \n When the LSResourceResolver is null, the implementation will\n behave as if the following LSResourceResolver is set:\n \n class DumbLSResourceResolver implements LSResourceResolver {\n     public LSInput resolveResource(\n         String publicId, String systemId, String baseURI) {\n\n         return null; // always return null\n     }\n }\n \n\n If a LSResourceResolver throws a RuntimeException\n  (or instances of its derived classes),\n then the ValidatorHandler will abort the parsing and\n the caller of the validate method will receive\n the same RuntimeException.\n\n \n When a new ValidatorHandler object is created, initially\n this field is set to null."}, {"method_name": "getResourceResolver", "method_sig": "public abstract LSResourceResolver getResourceResolver()", "description": "Gets the current LSResourceResolver set to this ValidatorHandler."}, {"method_name": "getTypeInfoProvider", "method_sig": "public abstract TypeInfoProvider getTypeInfoProvider()", "description": "Obtains the TypeInfoProvider implementation of this\n ValidatorHandler.\n\n \n The obtained TypeInfoProvider can be queried during a parse\n to access the type information determined by the validator.\n\n \n Some schema languages do not define the notion of type,\n for those languages, this method may not be supported.\n However, to be compliant with this specification, implementations\n for W3C XML Schema 1.0 must support this operation."}, {"method_name": "getFeature", "method_sig": "public boolean getFeature (String name)\n                   throws SAXNotRecognizedException,\n                          SAXNotSupportedException", "description": "Look up the value of a feature flag.\n\n The feature name is any fully-qualified URI.  It is\n possible for a ValidatorHandler to recognize a feature name but\n temporarily be unable to return its value.\n Some feature values may be available only in specific\n contexts, such as before, during, or after a validation.\n\n Implementors are free (and encouraged) to invent their own features,\n using names built on their own URIs."}, {"method_name": "setFeature", "method_sig": "public void setFeature (String name,\n                       boolean value)\n                throws SAXNotRecognizedException,\n                       SAXNotSupportedException", "description": "Set a feature for this ValidatorHandler.\nFeature can be used to control the way a\n ValidatorHandler parses schemas. The feature name is\n any fully-qualified URI. It is possible for a\n SchemaFactory to\n expose a feature value but to be unable to change the current\n value. Some feature values may be immutable or mutable only in\n specific contexts, such as before, during, or after a\n validation.\nAll implementations are required to support the XMLConstants.FEATURE_SECURE_PROCESSING feature.\n When the feature is:\n\n\ntrue: the implementation will limit XML processing to conform to implementation limits.\n     Examples include entity expansion limits and XML Schema constructs that would consume large amounts of resources.\n     If XML processing is limited for security reasons, it will be reported via a call to the registered\n    ErrorHandler.fatalError(SAXParseException exception).\n     See setErrorHandler(ErrorHandler errorHandler).\n   \n\nfalse: the implementation will processing XML according to the XML specifications without\n     regard to possible implementation limits.\n   \n"}, {"method_name": "setProperty", "method_sig": "public void setProperty (String name,\n                        Object object)\n                 throws SAXNotRecognizedException,\n                        SAXNotSupportedException", "description": "Set the value of a property.\n\n The property name is any fully-qualified URI.  It is\n possible for a ValidatorHandler to recognize a property name but\n to be unable to change the current value.\n Some property values may be immutable or mutable only\n in specific contexts, such as before, during, or after\n a validation.\nValidatorHandlers are not required to recognize setting\n any specific property names."}, {"method_name": "getProperty", "method_sig": "public Object getProperty (String name)\n                   throws SAXNotRecognizedException,\n                          SAXNotSupportedException", "description": "Look up the value of a property.\n\n The property name is any fully-qualified URI.  It is\n possible for a ValidatorHandler to recognize a property name but\n temporarily be unable to return its value.\n Some property values may be available only in specific\n contexts, such as before, during, or after a validation.\nValidatorHandlers are not required to recognize any specific\n property names.\nImplementors are free (and encouraged) to invent their own properties,\n using names built on their own URIs."}]}