{"name": "Class TextLayout", "module": "java.desktop", "package": "java.awt.font", "text": "TextLayout is an immutable graphical representation of styled\n character data.\n \n It provides the following capabilities:\n \nimplicit bidirectional analysis and reordering,\n cursor positioning and movement, including split cursors for\n mixed directional text,\n highlighting, including both logical and visual highlighting\n for mixed directional text,\n multiple baselines (roman, hanging, and centered),\n hit testing,\n justification,\n default font substitution,\n metric information such as ascent, descent, and advance, and\n rendering\n \n\n A TextLayout object can be rendered using\n its draw method.\n \nTextLayout can be constructed either directly or through\n the use of a LineBreakMeasurer.  When constructed directly, the\n source text represents a single paragraph.  LineBreakMeasurer\n allows styled text to be broken into lines that fit within a particular\n width.  See the LineBreakMeasurer documentation for more\n information.\n \nTextLayout construction logically proceeds as follows:\n \nparagraph attributes are extracted and examined,\n text is analyzed for bidirectional reordering, and reordering\n information is computed if needed,\n text is segmented into style runs\n fonts are chosen for style runs, first by using a font if the\n attribute TextAttribute.FONT is present, otherwise by computing\n a default font using the attributes that have been defined\n if text is on multiple baselines, the runs or subruns are further\n broken into subruns sharing a common baseline,\n glyphvectors are generated for each run using the chosen font,\n final bidirectional reordering is performed on the glyphvectors\n \n\n All graphical information returned from a TextLayout\n object's methods is relative to the origin of the\n TextLayout, which is the intersection of the\n TextLayout object's baseline with its left edge.  Also,\n coordinates passed into a TextLayout object's methods\n are assumed to be relative to the TextLayout object's\n origin.  Clients usually need to translate between a\n TextLayout object's coordinate system and the coordinate\n system in another object (such as a\n Graphics object).\n \nTextLayout objects are constructed from styled text,\n but they do not retain a reference to their source text.  Thus,\n changes in the text previously used to generate a TextLayout\n do not affect the TextLayout.\n \n Three methods on a TextLayout object\n (getNextRightHit, getNextLeftHit, and\n hitTestChar) return instances of TextHitInfo.\n The offsets contained in these TextHitInfo objects\n are relative to the start of the TextLayout, not\n to the text used to create the TextLayout.  Similarly,\n TextLayout methods that accept TextHitInfo\n instances as parameters expect the TextHitInfo object's\n offsets to be relative to the TextLayout, not to any\n underlying text storage model.\n \nExamples:\n Constructing and drawing a TextLayout and its bounding\n rectangle:\n \n   Graphics2D g = ...;\n   Point2D loc = ...;\n   Font font = Font.getFont(\"Helvetica-bold-italic\");\n   FontRenderContext frc = g.getFontRenderContext();\n   TextLayout layout = new TextLayout(\"This is a string\", font, frc);\n   layout.draw(g, (float)loc.getX(), (float)loc.getY());\n\n   Rectangle2D bounds = layout.getBounds();\n   bounds.setRect(bounds.getX()+loc.getX(),\n                  bounds.getY()+loc.getY(),\n                  bounds.getWidth(),\n                  bounds.getHeight());\n   g.draw(bounds);\n \n\n\n Hit-testing a TextLayout (determining which character is at\n a particular graphical location):\n \n   Point2D click = ...;\n   TextHitInfo hit = layout.hitTestChar(\n                         (float) (click.getX() - loc.getX()),\n                         (float) (click.getY() - loc.getY()));\n \n\n\n Responding to a right-arrow key press:\n \n   int insertionIndex = ...;\n   TextHitInfo next = layout.getNextRightHit(insertionIndex);\n   if (next != null) {\n       // translate graphics to origin of layout on screen\n       g.translate(loc.getX(), loc.getY());\n       Shape[] carets = layout.getCaretShapes(next.getInsertionIndex());\n       g.draw(carets[0]);\n       if (carets[1] != null) {\n           g.draw(carets[1]);\n       }\n   }\n \n\n Drawing a selection range corresponding to a substring in the source text.\n The selected area may not be visually contiguous:\n \n   // selStart, selLimit should be relative to the layout,\n   // not to the source text\n\n   int selStart = ..., selLimit = ...;\n   Color selectionColor = ...;\n   Shape selection = layout.getLogicalHighlightShape(selStart, selLimit);\n   // selection may consist of disjoint areas\n   // graphics is assumed to be translated to origin of layout\n   g.setColor(selectionColor);\n   g.fill(selection);\n \n\n Drawing a visually contiguous selection range.  The selection range may\n correspond to more than one substring in the source text.  The ranges of\n the corresponding source text substrings can be obtained with\n getLogicalRangesForVisualSelection():\n \n   TextHitInfo selStart = ..., selLimit = ...;\n   Shape selection = layout.getVisualHighlightShape(selStart, selLimit);\n   g.setColor(selectionColor);\n   g.fill(selection);\n   int[] ranges = getLogicalRangesForVisualSelection(selStart, selLimit);\n   // ranges[0], ranges[1] is the first selection range,\n   // ranges[2], ranges[3] is the second selection range, etc.\n \n\n Note: Font rotations can cause text baselines to be rotated, and\n multiple runs with different rotations can cause the baseline to\n bend or zig-zag.  In order to account for this (rare) possibility,\n some APIs are specified to return metrics and take parameters 'in\n baseline-relative coordinates' (e.g. ascent, advance), and others\n are in 'in standard coordinates' (e.g. getBounds).  Values in\n baseline-relative coordinates map the 'x' coordinate to the\n distance along the baseline, (positive x is forward along the\n baseline), and the 'y' coordinate to a distance along the\n perpendicular to the baseline at 'x' (positive y is 90 degrees\n clockwise from the baseline vector).  Values in standard\n coordinates are measured along the x and y axes, with 0,0 at the\n origin of the TextLayout.  Documentation for each relevant API\n indicates what values are in what coordinate system.  In general,\n measurement-related APIs are in baseline-relative coordinates,\n while display-related APIs are in standard coordinates.", "codes": ["public final class TextLayout\nextends Object\nimplements Cloneable"], "fields": [{"field_name": "DEFAULT_CARET_POLICY", "field_sig": "public static final\u00a0TextLayout.CaretPolicy DEFAULT_CARET_POLICY", "description": "This CaretPolicy is used when a policy is not specified\n by the client.  With this policy, a hit on a character whose direction\n is the same as the line direction is stronger than a hit on a\n counterdirectional character.  If the characters' directions are\n the same, a hit on the leading edge of a character is stronger\n than a hit on the trailing edge of a character."}], "methods": [{"method_name": "clone", "method_sig": "protected Object clone()", "description": "Creates a copy of this TextLayout."}, {"method_name": "getJustifiedLayout", "method_sig": "public TextLayout getJustifiedLayout (float justificationWidth)", "description": "Creates a copy of this TextLayout justified to the\n specified width.\n \n If this TextLayout has already been justified, an\n exception is thrown.  If this TextLayout object's\n justification ratio is zero, a TextLayout identical\n to this TextLayout is returned."}, {"method_name": "handleJustify", "method_sig": "protected void handleJustify (float justificationWidth)", "description": "Justify this layout.  Overridden by subclassers to control justification\n (if there were subclassers, that is...)\n\n The layout will only justify if the paragraph attributes (from the\n source text, possibly defaulted by the layout attributes) indicate a\n non-zero justification ratio.  The text will be justified to the\n indicated width.  The current implementation also adjusts hanging\n punctuation and trailing whitespace to overhang the justification width.\n Once justified, the layout may not be rejustified.\n \n Some code may rely on immutability of layouts.  Subclassers should not\n call this directly, but instead should call getJustifiedLayout, which\n will call this method on a clone of this layout, preserving\n the original."}, {"method_name": "getBaseline", "method_sig": "public byte getBaseline()", "description": "Returns the baseline for this TextLayout.\n The baseline is one of the values defined in Font,\n which are roman, centered and hanging.  Ascent and descent are\n relative to this baseline.  The baselineOffsets\n are also relative to this baseline."}, {"method_name": "getBaselineOffsets", "method_sig": "public float[] getBaselineOffsets()", "description": "Returns the offsets array for the baselines used for this\n TextLayout.\n \n The array is indexed by one of the values defined in\n Font, which are roman, centered and hanging.  The\n values are relative to this TextLayout object's\n baseline, so that getBaselineOffsets[getBaseline()] == 0.\n Offsets are added to the position of the TextLayout\n object's baseline to get the position for the new baseline."}, {"method_name": "getAdvance", "method_sig": "public float getAdvance()", "description": "Returns the advance of this TextLayout.\n The advance is the distance from the origin to the advance of the\n rightmost (bottommost) character.  This is in baseline-relative\n coordinates."}, {"method_name": "getVisibleAdvance", "method_sig": "public float getVisibleAdvance()", "description": "Returns the advance of this TextLayout, minus trailing\n whitespace.  This is in baseline-relative coordinates."}, {"method_name": "getAscent", "method_sig": "public float getAscent()", "description": "Returns the ascent of this TextLayout.\n The ascent is the distance from the top (right) of the\n TextLayout to the baseline.  It is always either\n positive or zero.  The ascent is sufficient to\n accommodate superscripted text and is the maximum of the sum of the\n ascent, offset, and baseline of each glyph.  The ascent is\n the maximum ascent from the baseline of all the text in the\n TextLayout.  It is in baseline-relative coordinates."}, {"method_name": "getDescent", "method_sig": "public float getDescent()", "description": "Returns the descent of this TextLayout.\n The descent is the distance from the baseline to the bottom (left) of\n the TextLayout.  It is always either positive or zero.\n The descent is sufficient to accommodate subscripted text and is the\n maximum of the sum of the descent, offset, and baseline of each glyph.\n This is the maximum descent from the baseline of all the text in\n the TextLayout.  It is in baseline-relative coordinates."}, {"method_name": "getLeading", "method_sig": "public float getLeading()", "description": "Returns the leading of the TextLayout.\n The leading is the suggested interline spacing for this\n TextLayout.  This is in baseline-relative\n coordinates.\n \n The leading is computed from the leading, descent, and baseline\n of all glyphvectors in the TextLayout.  The algorithm\n is roughly as follows:\n \n maxD = 0;\n maxDL = 0;\n for (GlyphVector g in all glyphvectors) {\n    maxD = max(maxD, g.getDescent() + offsets[g.getBaseline()]);\n    maxDL = max(maxDL, g.getDescent() + g.getLeading() +\n                       offsets[g.getBaseline()]);\n }\n return maxDL - maxD;\n "}, {"method_name": "getBounds", "method_sig": "public Rectangle2D getBounds()", "description": "Returns the bounds of this TextLayout.\n The bounds are in standard coordinates.\n Due to rasterization effects, this bounds might not enclose all of the\n pixels rendered by the TextLayout.\n It might not coincide exactly with the ascent, descent,\n origin or advance of the TextLayout."}, {"method_name": "getPixelBounds", "method_sig": "public Rectangle getPixelBounds (FontRenderContext frc,\n                                float x,\n                                float y)", "description": "Returns the pixel bounds of this TextLayout when\n rendered in a graphics with the given\n FontRenderContext at the given location.  The\n graphics render context need not be the same as the\n FontRenderContext used to create this\n TextLayout, and can be null.  If it is null, the\n FontRenderContext of this TextLayout\n is used."}, {"method_name": "isLeftToRight", "method_sig": "public boolean isLeftToRight()", "description": "Returns true if this TextLayout has\n a left-to-right base direction or false if it has\n a right-to-left base direction.  The TextLayout\n has a base direction of either left-to-right (LTR) or\n right-to-left (RTL).  The base direction is independent of the\n actual direction of text on the line, which may be either LTR,\n RTL, or mixed. Left-to-right layouts by default should position\n flush left.  If the layout is on a tabbed line, the\n tabs run left to right, so that logically successive layouts position\n left to right.  The opposite is true for RTL layouts. By default they\n should position flush left, and tabs run right-to-left."}, {"method_name": "isVertical", "method_sig": "public boolean isVertical()", "description": "Returns true if this TextLayout is vertical."}, {"method_name": "getCharacterCount", "method_sig": "public int getCharacterCount()", "description": "Returns the number of characters represented by this\n TextLayout."}, {"method_name": "getCaretInfo", "method_sig": "public float[] getCaretInfo (TextHitInfo hit,\n                            Rectangle2D bounds)", "description": "Returns information about the caret corresponding to hit.\n The first element of the array is the intersection of the caret with\n the baseline, as a distance along the baseline. The second element\n of the array is the inverse slope (run/rise) of the caret, measured\n with respect to the baseline at that point.\n \n This method is meant for informational use.  To display carets, it\n is better to use getCaretShapes."}, {"method_name": "getCaretInfo", "method_sig": "public float[] getCaretInfo (TextHitInfo hit)", "description": "Returns information about the caret corresponding to hit.\n This method is a convenience overload of getCaretInfo and\n uses the natural bounds of this TextLayout."}, {"method_name": "getNextRightHit", "method_sig": "public TextHitInfo getNextRightHit (TextHitInfo hit)", "description": "Returns the hit for the next caret to the right (bottom); if there\n is no such hit, returns null.\n If the hit character index is out of bounds, an\n IllegalArgumentException is thrown."}, {"method_name": "getNextRightHit", "method_sig": "public TextHitInfo getNextRightHit (int offset,\n                                   TextLayout.CaretPolicy policy)", "description": "Returns the hit for the next caret to the right (bottom); if no\n such hit, returns null.  The hit is to the right of\n the strong caret at the specified offset, as determined by the\n specified policy.\n The returned hit is the stronger of the two possible\n hits, as determined by the specified policy."}, {"method_name": "getNextRightHit", "method_sig": "public TextHitInfo getNextRightHit (int offset)", "description": "Returns the hit for the next caret to the right (bottom); if no\n such hit, returns null.  The hit is to the right of\n the strong caret at the specified offset, as determined by the\n default policy.\n The returned hit is the stronger of the two possible\n hits, as determined by the default policy."}, {"method_name": "getNextLeftHit", "method_sig": "public TextHitInfo getNextLeftHit (TextHitInfo hit)", "description": "Returns the hit for the next caret to the left (top); if no such\n hit, returns null.\n If the hit character index is out of bounds, an\n IllegalArgumentException is thrown."}, {"method_name": "getNextLeftHit", "method_sig": "public TextHitInfo getNextLeftHit (int offset,\n                                  TextLayout.CaretPolicy policy)", "description": "Returns the hit for the next caret to the left (top); if no\n such hit, returns null.  The hit is to the left of\n the strong caret at the specified offset, as determined by the\n specified policy.\n The returned hit is the stronger of the two possible\n hits, as determined by the specified policy."}, {"method_name": "getNextLeftHit", "method_sig": "public TextHitInfo getNextLeftHit (int offset)", "description": "Returns the hit for the next caret to the left (top); if no\n such hit, returns null.  The hit is to the left of\n the strong caret at the specified offset, as determined by the\n default policy.\n The returned hit is the stronger of the two possible\n hits, as determined by the default policy."}, {"method_name": "getVisualOtherHit", "method_sig": "public TextHitInfo getVisualOtherHit (TextHitInfo hit)", "description": "Returns the hit on the opposite side of the specified hit's caret."}, {"method_name": "getCaretShape", "method_sig": "public Shape getCaretShape (TextHitInfo hit,\n                           Rectangle2D bounds)", "description": "Returns a Shape representing the caret at the specified\n hit inside the specified bounds."}, {"method_name": "getCaretShape", "method_sig": "public Shape getCaretShape (TextHitInfo hit)", "description": "Returns a Shape representing the caret at the specified\n hit inside the natural bounds of this TextLayout."}, {"method_name": "getCharacterLevel", "method_sig": "public byte getCharacterLevel (int index)", "description": "Returns the level of the character at index.\n Indices -1 and characterCount are assigned the base\n level of this TextLayout."}, {"method_name": "getCaretShapes", "method_sig": "public Shape[] getCaretShapes (int offset,\n                              Rectangle2D bounds,\n                              TextLayout.CaretPolicy policy)", "description": "Returns two paths corresponding to the strong and weak caret."}, {"method_name": "getCaretShapes", "method_sig": "public Shape[] getCaretShapes (int offset,\n                              Rectangle2D bounds)", "description": "Returns two paths corresponding to the strong and weak caret.\n This method is a convenience overload of getCaretShapes\n that uses the default caret policy."}, {"method_name": "getCaretShapes", "method_sig": "public Shape[] getCaretShapes (int offset)", "description": "Returns two paths corresponding to the strong and weak caret.\n This method is a convenience overload of getCaretShapes\n that uses the default caret policy and this TextLayout\n object's natural bounds."}, {"method_name": "getLogicalRangesForVisualSelection", "method_sig": "public int[] getLogicalRangesForVisualSelection (TextHitInfo firstEndpoint,\n                                                TextHitInfo secondEndpoint)", "description": "Returns the logical ranges of text corresponding to a visual selection."}, {"method_name": "getVisualHighlightShape", "method_sig": "public Shape getVisualHighlightShape (TextHitInfo firstEndpoint,\n                                     TextHitInfo secondEndpoint,\n                                     Rectangle2D bounds)", "description": "Returns a path enclosing the visual selection in the specified range,\n extended to bounds.\n \n If the selection includes the leftmost (topmost) position, the selection\n is extended to the left (top) of bounds.  If the\n selection includes the rightmost (bottommost) position, the selection\n is extended to the right (bottom) of the bounds.  The height\n (width on vertical lines) of the selection is always extended to\n bounds.\n \n Although the selection is always contiguous, the logically selected\n text can be discontiguous on lines with mixed-direction text.  The\n logical ranges of text selected can be retrieved using\n getLogicalRangesForVisualSelection.  For example,\n consider the text 'ABCdef' where capital letters indicate\n right-to-left text, rendered on a right-to-left line, with a visual\n selection from 0L (the leading edge of 'A') to 3T (the trailing edge\n of 'd').  The text appears as follows, with bold underlined areas\n representing the selection:\n \n    defCBA  \n \n The logical selection ranges are 0-3, 4-6 (ABC, ef) because the\n visually contiguous text is logically discontiguous.  Also note that\n since the rightmost position on the layout (to the right of 'A') is\n selected, the selection is extended to the right of the bounds."}, {"method_name": "getVisualHighlightShape", "method_sig": "public Shape getVisualHighlightShape (TextHitInfo firstEndpoint,\n                                     TextHitInfo secondEndpoint)", "description": "Returns a Shape enclosing the visual selection in the\n specified range, extended to the bounds.  This method is a\n convenience overload of getVisualHighlightShape that\n uses the natural bounds of this TextLayout."}, {"method_name": "getLogicalHighlightShape", "method_sig": "public Shape getLogicalHighlightShape (int firstEndpoint,\n                                      int secondEndpoint,\n                                      Rectangle2D bounds)", "description": "Returns a Shape enclosing the logical selection in the\n specified range, extended to the specified bounds.\n \n If the selection range includes the first logical character, the\n selection is extended to the portion of bounds before\n the start of this TextLayout.  If the range includes\n the last logical character, the selection is extended to the portion\n of bounds after the end of this TextLayout.\n The height (width on vertical lines) of the selection is always\n extended to bounds.\n \n The selection can be discontiguous on lines with mixed-direction text.\n Only those characters in the logical range between start and limit\n appear selected.  For example, consider the text 'ABCdef' where capital\n letters indicate right-to-left text, rendered on a right-to-left line,\n with a logical selection from 0 to 4 ('ABCd').  The text appears as\n follows, with bold standing in for the selection, and underlining for\n the extension:\n \n    defCBA  \n \n The selection is discontiguous because the selected characters are\n visually discontiguous. Also note that since the range includes the\n first logical character (A), the selection is extended to the portion\n of the bounds before the start of the layout, which in\n this case (a right-to-left line) is the right portion of the\n bounds."}, {"method_name": "getLogicalHighlightShape", "method_sig": "public Shape getLogicalHighlightShape (int firstEndpoint,\n                                      int secondEndpoint)", "description": "Returns a Shape enclosing the logical selection in the\n specified range, extended to the natural bounds of this\n TextLayout.  This method is a convenience overload of\n getLogicalHighlightShape that uses the natural bounds of\n this TextLayout."}, {"method_name": "getBlackBoxBounds", "method_sig": "public Shape getBlackBoxBounds (int firstEndpoint,\n                               int secondEndpoint)", "description": "Returns the black box bounds of the characters in the specified range.\n The black box bounds is an area consisting of the union of the bounding\n boxes of all the glyphs corresponding to the characters between start\n and limit.  This area can be disjoint."}, {"method_name": "hitTestChar", "method_sig": "public TextHitInfo hitTestChar (float x,\n                               float y,\n                               Rectangle2D bounds)", "description": "Returns a TextHitInfo corresponding to the\n specified point.\n Coordinates outside the bounds of the TextLayout\n map to hits on the leading edge of the first logical character,\n or the trailing edge of the last logical character, as appropriate,\n regardless of the position of that character in the line.  Only the\n direction along the baseline is used to make this evaluation."}, {"method_name": "hitTestChar", "method_sig": "public TextHitInfo hitTestChar (float x,\n                               float y)", "description": "Returns a TextHitInfo corresponding to the\n specified point.  This method is a convenience overload of\n hitTestChar that uses the natural bounds of this\n TextLayout."}, {"method_name": "equals", "method_sig": "public boolean equals (TextLayout rhs)", "description": "Returns true if the two layouts are equal.\n Obeys the general contract of equals(Object)."}, {"method_name": "toString", "method_sig": "public String toString()", "description": "Returns debugging information for this TextLayout."}, {"method_name": "draw", "method_sig": "public void draw (Graphics2D g2,\n                 float x,\n                 float y)", "description": "Renders this TextLayout at the specified location in\n the specified Graphics2D context.\n The origin of the layout is placed at x,\u00a0y.  Rendering may touch\n any point within getBounds() of this position.  This\n leaves the g2 unchanged.  Text is rendered along the\n baseline path."}, {"method_name": "getOutline", "method_sig": "public Shape getOutline (AffineTransform tx)", "description": "Returns a Shape representing the outline of this\n TextLayout."}, {"method_name": "getLayoutPath", "method_sig": "public LayoutPath getLayoutPath()", "description": "Return the LayoutPath, or null if the layout path is the\n default path (x maps to advance, y maps to offset)."}, {"method_name": "hitToPoint", "method_sig": "public void hitToPoint (TextHitInfo hit,\n                       Point2D point)", "description": "Convert a hit to a point in standard coordinates.  The point is\n on the baseline of the character at the leading or trailing\n edge of the character, as appropriate.  If the path is\n broken at the side of the character represented by the hit, the\n point will be adjacent to the character."}]}