{"name": "Interface Shape", "module": "java.desktop", "package": "java.awt", "text": "The Shape interface provides definitions for objects\n that represent some form of geometric shape.  The Shape\n is described by a PathIterator object, which can express the\n outline of the Shape as well as a rule for determining\n how the outline divides the 2D plane into interior and exterior\n points.  Each Shape object provides callbacks to get the\n bounding box of the geometry, determine whether points or\n rectangles lie partly or entirely within the interior\n of the Shape, and retrieve a PathIterator\n object that describes the trajectory path of the Shape\n outline.\n \nDefinition of insideness:\n A point is considered to lie inside a\n Shape if and only if:\n \n it lies completely\n inside the Shape boundary or\n\n it lies exactly on the Shape boundary and the\n space immediately adjacent to the\n point in the increasing X direction is\n entirely inside the boundary or\n\n it lies exactly on a horizontal boundary segment and the\n space immediately adjacent to the point in the\n increasing Y direction is inside the boundary.\n \nThe contains and intersects methods\n consider the interior of a Shape to be the area it\n encloses as if it were filled.  This means that these methods\n consider\n unclosed shapes to be implicitly closed for the purpose of\n determining if a shape contains or intersects a rectangle or if a\n shape contains a point.", "codes": ["public interface Shape"], "fields": [], "methods": [{"method_name": "getBounds", "method_sig": "Rectangle getBounds()", "description": "Returns an integer Rectangle that completely encloses the\n Shape.  Note that there is no guarantee that the\n returned Rectangle is the smallest bounding box that\n encloses the Shape, only that the Shape\n lies entirely within the indicated  Rectangle.  The\n returned Rectangle might also fail to completely\n enclose the Shape if the Shape overflows\n the limited range of the integer data type.  The\n getBounds2D method generally returns a\n tighter bounding box due to its greater flexibility in\n representation.\n\n \n Note that the\n \n definition of insideness can lead to situations where points\n on the defining outline of the shape may not be considered\n contained in the returned bounds object, but only in cases\n where those points are also not considered contained in the original\n shape.\n \n\n If a point is inside the shape according to the\n contains(point) method, then\n it must be inside the returned Rectangle bounds object\n according to the contains(point)\n method of the bounds. Specifically:\n \n\nshape.contains(x,y) requires bounds.contains(x,y)\n\n\n If a point is not inside the shape, then it might\n still be contained in the bounds object:\n \n\nbounds.contains(x,y) does not imply shape.contains(x,y)\n"}, {"method_name": "getBounds2D", "method_sig": "Rectangle2D getBounds2D()", "description": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.\n Note that there is no guarantee that the returned\n Rectangle2D is the smallest bounding box that encloses\n the Shape, only that the Shape lies\n entirely within the indicated Rectangle2D.  The\n bounding box returned by this method is usually tighter than that\n returned by the getBounds method and never fails due\n to overflow problems since the return value can be an instance of\n the Rectangle2D that uses double precision values to\n store the dimensions.\n\n \n Note that the\n \n definition of insideness can lead to situations where points\n on the defining outline of the shape may not be considered\n contained in the returned bounds object, but only in cases\n where those points are also not considered contained in the original\n shape.\n \n\n If a point is inside the shape according to the\n contains(point) method, then it must\n be inside the returned Rectangle2D bounds object according\n to the contains(point) method of the\n bounds. Specifically:\n \n\nshape.contains(p) requires bounds.contains(p)\n\n\n If a point is not inside the shape, then it might\n still be contained in the bounds object:\n \n\nbounds.contains(p) does not imply shape.contains(p)\n"}, {"method_name": "contains", "method_sig": "boolean contains (double x,\n                 double y)", "description": "Tests if the specified coordinates are inside the boundary of the\n Shape, as described by the\n \n definition of insideness."}, {"method_name": "contains", "method_sig": "boolean contains (Point2D p)", "description": "Tests if a specified Point2D is inside the boundary\n of the Shape, as described by the\n \n definition of insideness."}, {"method_name": "intersects", "method_sig": "boolean intersects (double x,\n                   double y,\n                   double w,\n                   double h)", "description": "Tests if the interior of the Shape intersects the\n interior of a specified rectangular area.\n The rectangular area is considered to intersect the Shape\n if any point is contained in both the interior of the\n Shape and the specified rectangular area.\n \n The Shape.intersects() method allows a Shape\n implementation to conservatively return true when:\n \n\n there is a high probability that the rectangular area and the\n Shape intersect, but\n \n the calculations to accurately determine this intersection\n are prohibitively expensive.\n \n This means that for some Shapes this method might\n return true even though the rectangular area does not\n intersect the Shape.\n The Area class performs\n more accurate computations of geometric intersection than most\n Shape objects and therefore can be used if a more precise\n answer is required."}, {"method_name": "intersects", "method_sig": "boolean intersects (Rectangle2D r)", "description": "Tests if the interior of the Shape intersects the\n interior of a specified Rectangle2D.\n The Shape.intersects() method allows a Shape\n implementation to conservatively return true when:\n \n\n there is a high probability that the Rectangle2D and the\n Shape intersect, but\n \n the calculations to accurately determine this intersection\n are prohibitively expensive.\n \n This means that for some Shapes this method might\n return true even though the Rectangle2D does not\n intersect the Shape.\n The Area class performs\n more accurate computations of geometric intersection than most\n Shape objects and therefore can be used if a more precise\n answer is required."}, {"method_name": "contains", "method_sig": "boolean contains (double x,\n                 double y,\n                 double w,\n                 double h)", "description": "Tests if the interior of the Shape entirely contains\n the specified rectangular area.  All coordinates that lie inside\n the rectangular area must lie within the Shape for the\n entire rectangular area to be considered contained within the\n Shape.\n \n The Shape.contains() method allows a Shape\n implementation to conservatively return false when:\n \n\n the intersect method returns true and\n \n the calculations to determine whether or not the\n Shape entirely contains the rectangular area are\n prohibitively expensive.\n \n This means that for some Shapes this method might\n return false even though the Shape contains\n the rectangular area.\n The Area class performs\n more accurate geometric computations than most\n Shape objects and therefore can be used if a more precise\n answer is required."}, {"method_name": "contains", "method_sig": "boolean contains (Rectangle2D r)", "description": "Tests if the interior of the Shape entirely contains the\n specified Rectangle2D.\n The Shape.contains() method allows a Shape\n implementation to conservatively return false when:\n \n\n the intersect method returns true and\n \n the calculations to determine whether or not the\n Shape entirely contains the Rectangle2D\n are prohibitively expensive.\n \n This means that for some Shapes this method might\n return false even though the Shape contains\n the Rectangle2D.\n The Area class performs\n more accurate geometric computations than most\n Shape objects and therefore can be used if a more precise\n answer is required."}, {"method_name": "getPathIterator", "method_sig": "PathIterator getPathIterator (AffineTransform at)", "description": "Returns an iterator object that iterates along the\n Shape boundary and provides access to the geometry of the\n Shape outline.  If an optional AffineTransform\n is specified, the coordinates returned in the iteration are\n transformed accordingly.\n \n Each call to this method returns a fresh PathIterator\n object that traverses the geometry of the Shape object\n independently from any other PathIterator objects in use\n at the same time.\n \n It is recommended, but not guaranteed, that objects\n implementing the Shape interface isolate iterations\n that are in process from any changes that might occur to the original\n object's geometry during such iterations."}, {"method_name": "getPathIterator", "method_sig": "PathIterator getPathIterator (AffineTransform at,\n                             double flatness)", "description": "Returns an iterator object that iterates along the Shape\n boundary and provides access to a flattened view of the\n Shape outline geometry.\n \n Only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types are\n returned by the iterator.\n \n If an optional AffineTransform is specified,\n the coordinates returned in the iteration are transformed\n accordingly.\n \n The amount of subdivision of the curved segments is controlled\n by the flatness parameter, which specifies the\n maximum distance that any point on the unflattened transformed\n curve can deviate from the returned flattened path segments.\n Note that a limit on the accuracy of the flattened path might be\n silently imposed, causing very small flattening parameters to be\n treated as larger values.  This limit, if there is one, is\n defined by the particular implementation that is used.\n \n Each call to this method returns a fresh PathIterator\n object that traverses the Shape object geometry\n independently from any other PathIterator objects in use at\n the same time.\n \n It is recommended, but not guaranteed, that objects\n implementing the Shape interface isolate iterations\n that are in process from any changes that might occur to the original\n object's geometry during such iterations."}]}