{"name": "Interface RootPaneContainer", "module": "java.desktop", "package": "javax.swing", "text": "This interface is implemented by components that have a single\n JRootPane child: JDialog, JFrame, JWindow, JApplet, JInternalFrame.\n The methods in  this interface are just covers for the JRootPane\n properties, e.g. getContentPane() is generally implemented\n like this:\n     public Container getContentPane() {\n         return getRootPane().getContentPane();\n     }\n \n This interface serves as a marker for Swing GUI builders\n that need to treat components like JFrame, that contain a\n single JRootPane, specially.  For example in a GUI builder,\n dropping a component on a RootPaneContainer would be interpreted\n as frame.getContentPane().add(child).\n \n As a convenience, the standard classes that implement this interface\n (such as JFrame, JDialog, JWindow, JApplet,\n and JInternalFrame) have their add, remove,\n and setLayout methods overridden, so that they delegate calls\n to the corresponding methods of the ContentPane.\n For example, you can add a child component to a frame as follows:\n \n       frame.add(child);\n \n instead of:\n \n       frame.getContentPane().add(child);\n \n\n The behavior of the add and\n setLayout methods for\n JFrame, JDialog, JWindow,\n JApplet and JInternalFrame is controlled by\n the rootPaneCheckingEnabled property. If this property is\n true (the default), then calls to these methods are\n forwarded to the contentPane; if false, these\n methods operate directly on the RootPaneContainer. This\n property is only intended for subclasses, and is therefore protected.", "codes": ["public interface RootPaneContainer"], "fields": [], "methods": [{"method_name": "getRootPane", "method_sig": "JRootPane getRootPane()", "description": "Return this component's single JRootPane child.  A conventional\n implementation of this interface will have all of the other\n methods indirect through this one.  The rootPane has two\n children: the glassPane and the layeredPane."}, {"method_name": "setContentPane", "method_sig": "void setContentPane (Container contentPane)", "description": "The \"contentPane\" is the primary container for application\n specific components.  Applications should add children to\n the contentPane, set its layout manager, and so on.\n \n The contentPane may not be null.\n \n Generally implemented with\n getRootPane().setContentPane(contentPane);"}, {"method_name": "getContentPane", "method_sig": "Container getContentPane()", "description": "Returns the contentPane."}, {"method_name": "setLayeredPane", "method_sig": "void setLayeredPane (JLayeredPane layeredPane)", "description": "A Container that manages the contentPane and in some cases a menu bar.\n The layeredPane can be used by descendants that want to add a child\n to the RootPaneContainer that isn't layout managed.  For example\n an internal dialog or a drag and drop effect component.\n \n The layeredPane may not be null.\n \n Generally implemented with\n    getRootPane().setLayeredPane(layeredPane);"}, {"method_name": "getLayeredPane", "method_sig": "JLayeredPane getLayeredPane()", "description": "Returns the layeredPane."}, {"method_name": "setGlassPane", "method_sig": "void setGlassPane (Component glassPane)", "description": "The glassPane is always the first child of the rootPane\n and the rootPanes layout manager ensures that it's always\n as big as the rootPane.  By default it's transparent and\n not visible.  It can be used to temporarily grab all keyboard\n and mouse input by adding listeners and then making it visible.\n by default it's not visible.\n \n The glassPane may not be null.\n \n Generally implemented with\n getRootPane().setGlassPane(glassPane);"}, {"method_name": "getGlassPane", "method_sig": "Component getGlassPane()", "description": "Returns the glassPane."}]}