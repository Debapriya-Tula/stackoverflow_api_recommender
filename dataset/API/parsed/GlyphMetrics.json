{"name": "Class GlyphMetrics", "module": "java.desktop", "package": "java.awt.font", "text": "The GlyphMetrics class represents information for a\n single glyph.   A glyph is the visual representation of one or more\n characters.  Many different glyphs can be used to represent a single\n character or combination of characters.  GlyphMetrics\n instances are produced by Font and are applicable\n to a specific glyph in a particular Font.\n \n Glyphs are either STANDARD, LIGATURE, COMBINING, or COMPONENT.\n \nSTANDARD glyphs are commonly used to represent single characters.\n LIGATURE glyphs are used to represent sequences of characters.\n COMPONENT glyphs in a GlyphVector do not correspond to a\n particular character in a text model. Instead, COMPONENT glyphs are\n added for typographical reasons, such as Arabic justification.\n COMBINING glyphs embellish STANDARD or LIGATURE glyphs, such\n as accent marks.  Carets do not appear before COMBINING glyphs.\n \n\n Other metrics available through GlyphMetrics are the\n components of the advance, the visual bounds, and the left and right\n side bearings.\n \n Glyphs for a rotated font, or obtained from a GlyphVector\n which has applied a rotation to the glyph, can have advances that\n contain both X and Y components.  Usually the advance only has one\n component.\n \n The advance of a glyph is the distance from the glyph's origin to the\n origin of the next glyph along the baseline, which is either vertical\n or horizontal.  Note that, in a GlyphVector,\n the distance from a glyph to its following glyph might not be the\n glyph's advance, because of kerning or other positioning adjustments.\n \n The bounds is the smallest rectangle that completely contains the\n outline of the glyph.  The bounds rectangle is relative to the\n glyph's origin.  The left-side bearing is the distance from the glyph\n origin to the left of its bounds rectangle. If the left-side bearing is\n negative, part of the glyph is drawn to the left of its origin.  The\n right-side bearing is the distance from the right side of the bounds\n rectangle to the next glyph origin (the origin plus the advance).  If\n negative, part of the glyph is drawn to the right of the next glyph's\n origin.  Note that the bounds does not necessarily enclose all the pixels\n affected when rendering the glyph, because of rasterization and pixel\n adjustment effects.\n \n Although instances of GlyphMetrics can be directly\n constructed, they are almost always obtained from a\n GlyphVector.  Once constructed, GlyphMetrics\n objects are immutable.\n \nExample:\n Querying a Font for glyph information\n \n Font font = ...;\n int glyphIndex = ...;\n GlyphMetrics metrics = GlyphVector.getGlyphMetrics(glyphIndex);\n int isStandard = metrics.isStandard();\n float glyphAdvance = metrics.getAdvance();\n ", "codes": ["public final class GlyphMetrics\nextends Object"], "fields": [{"field_name": "STANDARD", "field_sig": "public static final\u00a0byte STANDARD", "description": "Indicates a glyph that represents a single standard\n character."}, {"field_name": "LIGATURE", "field_sig": "public static final\u00a0byte LIGATURE", "description": "Indicates a glyph that represents multiple characters\n as a ligature, for example 'fi' or 'ffi'.  It is followed by\n filler glyphs for the remaining characters. Filler and combining\n glyphs can be intermixed to control positioning of accent marks\n on the logically preceding ligature."}, {"field_name": "COMBINING", "field_sig": "public static final\u00a0byte COMBINING", "description": "Indicates a glyph that represents a combining character,\n such as an umlaut.  There is no caret position between this glyph\n and the preceding glyph."}, {"field_name": "COMPONENT", "field_sig": "public static final\u00a0byte COMPONENT", "description": "Indicates a glyph with no corresponding character in the\n backing store.  The glyph is associated with the character\n represented by the logically preceding non-component glyph.  This\n is used for kashida justification or other visual modifications to\n existing glyphs.  There is no caret position between this glyph\n and the preceding glyph."}, {"field_name": "WHITESPACE", "field_sig": "public static final\u00a0byte WHITESPACE", "description": "Indicates a glyph with no visual representation. It can\n be added to the other code values to indicate an invisible glyph."}], "methods": [{"method_name": "getAdvance", "method_sig": "public float getAdvance()", "description": "Returns the advance of the glyph along the baseline (either\n horizontal or vertical)."}, {"method_name": "getAdvanceX", "method_sig": "public float getAdvanceX()", "description": "Returns the x-component of the advance of the glyph."}, {"method_name": "getAdvanceY", "method_sig": "public float getAdvanceY()", "description": "Returns the y-component of the advance of the glyph."}, {"method_name": "getBounds2D", "method_sig": "public Rectangle2D getBounds2D()", "description": "Returns the bounds of the glyph. This is the bounding box of the glyph outline.\n Because of rasterization and pixel alignment effects, it does not necessarily\n enclose the pixels that are affected when rendering the glyph."}, {"method_name": "getLSB", "method_sig": "public float getLSB()", "description": "Returns the left (top) side bearing of the glyph.\n \n This is the distance from 0,\u00a00 to the left (top) of the glyph\n bounds.  If the bounds of the glyph is to the left of (above) the\n origin, the LSB is negative."}, {"method_name": "getRSB", "method_sig": "public float getRSB()", "description": "Returns the right (bottom) side bearing of the glyph.\n \n This is the distance from the right (bottom) of the glyph bounds to\n the advance. If the bounds of the glyph is to the right of (below)\n the advance, the RSB is negative."}, {"method_name": "getType", "method_sig": "public int getType()", "description": "Returns the raw glyph type code."}, {"method_name": "isStandard", "method_sig": "public boolean isStandard()", "description": "Returns true if this is a standard glyph."}, {"method_name": "isLigature", "method_sig": "public boolean isLigature()", "description": "Returns true if this is a ligature glyph."}, {"method_name": "isCombining", "method_sig": "public boolean isCombining()", "description": "Returns true if this is a combining glyph."}, {"method_name": "isComponent", "method_sig": "public boolean isComponent()", "description": "Returns true if this is a component glyph."}, {"method_name": "isWhitespace", "method_sig": "public boolean isWhitespace()", "description": "Returns true if this is a whitespace glyph."}]}