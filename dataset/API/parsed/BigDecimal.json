{"name": "Class BigDecimal", "module": "java.base", "package": "java.math", "text": "Immutable, arbitrary-precision signed decimal numbers.  A\n BigDecimal consists of an arbitrary precision integer\n unscaled value and a 32-bit integer scale.  If zero\n or positive, the scale is the number of digits to the right of the\n decimal point.  If negative, the unscaled value of the number is\n multiplied by ten to the power of the negation of the scale.  The\n value of the number represented by the BigDecimal is\n therefore (unscaledValue \u00d7 10-scale).\n\n The BigDecimal class provides operations for\n arithmetic, scale manipulation, rounding, comparison, hashing, and\n format conversion.  The toString() method provides a\n canonical representation of a BigDecimal.\n\n The BigDecimal class gives its user complete control\n over rounding behavior.  If no rounding mode is specified and the\n exact result cannot be represented, an exception is thrown;\n otherwise, calculations can be carried out to a chosen precision\n and rounding mode by supplying an appropriate MathContext\n object to the operation.  In either case, eight rounding\n modes are provided for the control of rounding.  Using the\n integer fields in this class (such as ROUND_HALF_UP) to\n represent rounding mode is deprecated; the enumeration values\n of the RoundingMode enum, (such as RoundingMode.HALF_UP) should be used instead.\n\n When a MathContext object is supplied with a precision\n setting of 0 (for example, MathContext.UNLIMITED),\n arithmetic operations are exact, as are the arithmetic methods\n which take no MathContext object.  (This is the only\n behavior that was supported in releases prior to 5.)  As a\n corollary of computing the exact result, the rounding mode setting\n of a MathContext object with a precision setting of 0 is\n not used and thus irrelevant.  In the case of divide, the exact\n quotient could have an infinitely long decimal expansion; for\n example, 1 divided by 3.  If the quotient has a nonterminating\n decimal expansion and the operation is specified to return an exact\n result, an ArithmeticException is thrown.  Otherwise, the\n exact result of the division is returned, as done for other\n operations.\n\n When the precision setting is not 0, the rules of\n BigDecimal arithmetic are broadly compatible with selected\n modes of operation of the arithmetic defined in ANSI X3.274-1996\n and ANSI X3.274-1996/AM 1-2000 (section 7.4).  Unlike those\n standards, BigDecimal includes many rounding modes, which\n were mandatory for division in BigDecimal releases prior\n to 5.  Any conflicts between these ANSI standards and the\n BigDecimal specification are resolved in favor of\n BigDecimal.\n\n Since the same numerical value can have different\n representations (with different scales), the rules of arithmetic\n and rounding must specify both the numerical result and the scale\n used in the result's representation.\n\n\n In general the rounding modes and precision setting determine\n how operations return results with a limited number of digits when\n the exact result has more digits (perhaps infinitely many in the\n case of division and square root) than the number of digits returned.\n\n First, the\n total number of digits to return is specified by the\n MathContext's precision setting; this determines\n the result's precision.  The digit count starts from the\n leftmost nonzero digit of the exact result.  The rounding mode\n determines how any discarded trailing digits affect the returned\n result.\n\n For all arithmetic operators , the operation is carried out as\n though an exact intermediate result were first calculated and then\n rounded to the number of digits specified by the precision setting\n (if necessary), using the selected rounding mode.  If the exact\n result is not returned, some digit positions of the exact result\n are discarded.  When rounding increases the magnitude of the\n returned result, it is possible for a new digit position to be\n created by a carry propagating to a leading \"9\" digit.\n For example, rounding the value 999.9 to three digits rounding up\n would be numerically equal to one thousand, represented as\n 100\u00d7101.  In such cases, the new \"1\" is\n the leading digit position of the returned result.\n\n Besides a logical exact result, each arithmetic operation has a\n preferred scale for representing a result.  The preferred\n scale for each operation is listed in the table below.\n\n \nPreferred Scales for Results of Arithmetic Operations\n \n\nOperationPreferred Scale of Result\n\n\nAddmax(addend.scale(), augend.scale())\nSubtractmax(minuend.scale(), subtrahend.scale())\nMultiplymultiplier.scale() + multiplicand.scale()\nDividedividend.scale() - divisor.scale()\nSquare rootradicand.scale()/2\n\n\n\n These scales are the ones used by the methods which return exact\n arithmetic results; except that an exact divide may have to use a\n larger scale since the exact result may have more digits.  For\n example, 1/32 is 0.03125.\n\n Before rounding, the scale of the logical exact intermediate\n result is the preferred scale for that operation.  If the exact\n numerical result cannot be represented in precision\n digits, rounding selects the set of digits to return and the scale\n of the result is reduced from the scale of the intermediate result\n to the least scale which can represent the precision\n digits actually returned.  If the exact result can be represented\n with at most precision digits, the representation\n of the result with the scale closest to the preferred scale is\n returned.  In particular, an exactly representable quotient may be\n represented in fewer than precision digits by removing\n trailing zeros and decreasing the scale.  For example, rounding to\n three digits using the floor\n rounding mode, \n19/100 = 0.19   // integer=19,  scale=2 \n\n but\n21/110 = 0.190  // integer=190, scale=3 \nNote that for add, subtract, and multiply, the reduction in\n scale will equal the number of digit positions of the exact result\n which are discarded. If the rounding causes a carry propagation to\n create a new high-order digit position, an additional digit of the\n result is discarded than when no new digit position is created.\n\n Other methods may have slightly different rounding semantics.\n For example, the result of the pow method using the\n specified algorithm can\n occasionally differ from the rounded mathematical result by more\n than one unit in the last place, one ulp.\n\n Two types of operations are provided for manipulating the scale\n of a BigDecimal: scaling/rounding operations and decimal\n point motion operations.  Scaling/rounding operations (setScale and round) return a\n BigDecimal whose value is approximately (or exactly) equal\n to that of the operand, but whose scale or precision is the\n specified value; that is, they increase or decrease the precision\n of the stored number with minimal effect on its value.  Decimal\n point motion operations (movePointLeft and\n movePointRight) return a\n BigDecimal created from the operand by moving the decimal\n point a specified distance in the specified direction.\n\n For the sake of brevity and clarity, pseudo-code is used\n throughout the descriptions of BigDecimal methods.  The\n pseudo-code expression (i + j) is shorthand for \"a\n BigDecimal whose value is that of the BigDecimal\ni added to that of the BigDecimal\nj.\" The pseudo-code expression (i == j) is\n shorthand for \"true if and only if the\n BigDecimal i represents the same value as the\n BigDecimal j.\" Other pseudo-code expressions\n are interpreted similarly.  Square brackets are used to represent\n the particular BigInteger and scale pair defining a\n BigDecimal value; for example [19, 2] is the\n BigDecimal numerically equal to 0.19 having a scale of 2.\n\n\n All methods and constructors for this class throw\n NullPointerException when passed a null object\n reference for any input parameter.", "codes": ["public class BigDecimal\nextends Number\nimplements Comparable<BigDecimal>"], "fields": [{"field_name": "ZERO", "field_sig": "public static final\u00a0BigDecimal ZERO", "description": "The value 0, with a scale of 0."}, {"field_name": "ONE", "field_sig": "public static final\u00a0BigDecimal ONE", "description": "The value 1, with a scale of 0."}, {"field_name": "TEN", "field_sig": "public static final\u00a0BigDecimal TEN", "description": "The value 10, with a scale of 0."}, {"field_name": "ROUND_UP", "field_sig": "@Deprecated(since=\"9\")\npublic static final\u00a0int ROUND_UP", "description": "Rounding mode to round away from zero.  Always increments the\n digit prior to a nonzero discarded fraction.  Note that this rounding\n mode never decreases the magnitude of the calculated value."}, {"field_name": "ROUND_DOWN", "field_sig": "@Deprecated(since=\"9\")\npublic static final\u00a0int ROUND_DOWN", "description": "Rounding mode to round towards zero.  Never increments the digit\n prior to a discarded fraction (i.e., truncates).  Note that this\n rounding mode never increases the magnitude of the calculated value."}, {"field_name": "ROUND_CEILING", "field_sig": "@Deprecated(since=\"9\")\npublic static final\u00a0int ROUND_CEILING", "description": "Rounding mode to round towards positive infinity.  If the\n BigDecimal is positive, behaves as for\n ROUND_UP; if negative, behaves as for\n ROUND_DOWN.  Note that this rounding mode never\n decreases the calculated value."}, {"field_name": "ROUND_FLOOR", "field_sig": "@Deprecated(since=\"9\")\npublic static final\u00a0int ROUND_FLOOR", "description": "Rounding mode to round towards negative infinity.  If the\n BigDecimal is positive, behave as for\n ROUND_DOWN; if negative, behave as for\n ROUND_UP.  Note that this rounding mode never\n increases the calculated value."}, {"field_name": "ROUND_HALF_UP", "field_sig": "@Deprecated(since=\"9\")\npublic static final\u00a0int ROUND_HALF_UP", "description": "Rounding mode to round towards \"nearest neighbor\"\n unless both neighbors are equidistant, in which case round up.\n Behaves as for ROUND_UP if the discarded fraction is\n \u2265 0.5; otherwise, behaves as for ROUND_DOWN.  Note\n that this is the rounding mode that most of us were taught in\n grade school."}, {"field_name": "ROUND_HALF_DOWN", "field_sig": "@Deprecated(since=\"9\")\npublic static final\u00a0int ROUND_HALF_DOWN", "description": "Rounding mode to round towards \"nearest neighbor\"\n unless both neighbors are equidistant, in which case round\n down.  Behaves as for ROUND_UP if the discarded\n fraction is > 0.5; otherwise, behaves as for\n ROUND_DOWN."}, {"field_name": "ROUND_HALF_EVEN", "field_sig": "@Deprecated(since=\"9\")\npublic static final\u00a0int ROUND_HALF_EVEN", "description": "Rounding mode to round towards the \"nearest neighbor\"\n unless both neighbors are equidistant, in which case, round\n towards the even neighbor.  Behaves as for\n ROUND_HALF_UP if the digit to the left of the\n discarded fraction is odd; behaves as for\n ROUND_HALF_DOWN if it's even.  Note that this is the\n rounding mode that minimizes cumulative error when applied\n repeatedly over a sequence of calculations."}, {"field_name": "ROUND_UNNECESSARY", "field_sig": "@Deprecated(since=\"9\")\npublic static final\u00a0int ROUND_UNNECESSARY", "description": "Rounding mode to assert that the requested operation has an exact\n result, hence no rounding is necessary.  If this rounding mode is\n specified on an operation that yields an inexact result, an\n ArithmeticException is thrown."}], "methods": [{"method_name": "valueOf", "method_sig": "public static BigDecimal valueOf (long unscaledVal,\n                                 int scale)", "description": "Translates a long unscaled value and an\n int scale into a BigDecimal."}, {"method_name": "valueOf", "method_sig": "public static BigDecimal valueOf (long val)", "description": "Translates a long value into a BigDecimal\n with a scale of zero."}, {"method_name": "valueOf", "method_sig": "public static BigDecimal valueOf (double val)", "description": "Translates a double into a BigDecimal, using\n the double's canonical string representation provided\n by the Double.toString(double) method."}, {"method_name": "add", "method_sig": "public BigDecimal add (BigDecimal augend)", "description": "Returns a BigDecimal whose value is (this +\n augend), and whose scale is max(this.scale(),\n augend.scale())."}, {"method_name": "add", "method_sig": "public BigDecimal add (BigDecimal augend,\n                      MathContext mc)", "description": "Returns a BigDecimal whose value is (this + augend),\n with rounding according to the context settings.\n\n If either number is zero and the precision setting is nonzero then\n the other number, rounded if necessary, is used as the result."}, {"method_name": "subtract", "method_sig": "public BigDecimal subtract (BigDecimal subtrahend)", "description": "Returns a BigDecimal whose value is (this -\n subtrahend), and whose scale is max(this.scale(),\n subtrahend.scale())."}, {"method_name": "subtract", "method_sig": "public BigDecimal subtract (BigDecimal subtrahend,\n                           MathContext mc)", "description": "Returns a BigDecimal whose value is (this - subtrahend),\n with rounding according to the context settings.\n\n If subtrahend is zero then this, rounded if necessary, is used as the\n result.  If this is zero then the result is subtrahend.negate(mc)."}, {"method_name": "multiply", "method_sig": "public BigDecimal multiply (BigDecimal multiplicand)", "description": "Returns a BigDecimal whose value is (this \u00d7\n multiplicand), and whose scale is (this.scale() +\n multiplicand.scale())."}, {"method_name": "multiply", "method_sig": "public BigDecimal multiply (BigDecimal multiplicand,\n                           MathContext mc)", "description": "Returns a BigDecimal whose value is (this \u00d7\n multiplicand), with rounding according to the context settings."}, {"method_name": "divide", "method_sig": "@Deprecated(since=\"9\")\npublic BigDecimal divide (BigDecimal divisor,\n                         int scale,\n                         int roundingMode)", "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is as specified.  If rounding must\n be performed to generate a result with the specified scale, the\n specified rounding mode is applied."}, {"method_name": "divide", "method_sig": "public BigDecimal divide (BigDecimal divisor,\n                         int scale,\n                         RoundingMode roundingMode)", "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is as specified.  If rounding must\n be performed to generate a result with the specified scale, the\n specified rounding mode is applied."}, {"method_name": "divide", "method_sig": "@Deprecated(since=\"9\")\npublic BigDecimal divide (BigDecimal divisor,\n                         int roundingMode)", "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is this.scale().  If\n rounding must be performed to generate a result with the given\n scale, the specified rounding mode is applied."}, {"method_name": "divide", "method_sig": "public BigDecimal divide (BigDecimal divisor,\n                         RoundingMode roundingMode)", "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is this.scale().  If\n rounding must be performed to generate a result with the given\n scale, the specified rounding mode is applied."}, {"method_name": "divide", "method_sig": "public BigDecimal divide (BigDecimal divisor)", "description": "Returns a BigDecimal whose value is (this /\n divisor), and whose preferred scale is (this.scale() -\n divisor.scale()); if the exact quotient cannot be\n represented (because it has a non-terminating decimal\n expansion) an ArithmeticException is thrown."}, {"method_name": "divide", "method_sig": "public BigDecimal divide (BigDecimal divisor,\n                         MathContext mc)", "description": "Returns a BigDecimal whose value is (this /\n divisor), with rounding according to the context settings."}, {"method_name": "divideToIntegralValue", "method_sig": "public BigDecimal divideToIntegralValue (BigDecimal divisor)", "description": "Returns a BigDecimal whose value is the integer part\n of the quotient (this / divisor) rounded down.  The\n preferred scale of the result is (this.scale() -\n divisor.scale())."}, {"method_name": "divideToIntegralValue", "method_sig": "public BigDecimal divideToIntegralValue (BigDecimal divisor,\n                                        MathContext mc)", "description": "Returns a BigDecimal whose value is the integer part\n of (this / divisor).  Since the integer part of the\n exact quotient does not depend on the rounding mode, the\n rounding mode does not affect the values returned by this\n method.  The preferred scale of the result is\n (this.scale() - divisor.scale()).  An\n ArithmeticException is thrown if the integer part of\n the exact quotient needs more than mc.precision\n digits."}, {"method_name": "remainder", "method_sig": "public BigDecimal remainder (BigDecimal divisor)", "description": "Returns a BigDecimal whose value is (this % divisor).\n\n The remainder is given by\n this.subtract(this.divideToIntegralValue(divisor).multiply(divisor)).\n Note that this is not the modulo operation (the result can be\n negative)."}, {"method_name": "remainder", "method_sig": "public BigDecimal remainder (BigDecimal divisor,\n                            MathContext mc)", "description": "Returns a BigDecimal whose value is (this %\n divisor), with rounding according to the context settings.\n The MathContext settings affect the implicit divide\n used to compute the remainder.  The remainder computation\n itself is by definition exact.  Therefore, the remainder may\n contain more than mc.getPrecision() digits.\n\n The remainder is given by\n this.subtract(this.divideToIntegralValue(divisor,\n mc).multiply(divisor)).  Note that this is not the modulo\n operation (the result can be negative)."}, {"method_name": "divideAndRemainder", "method_sig": "public BigDecimal[] divideAndRemainder (BigDecimal divisor)", "description": "Returns a two-element BigDecimal array containing the\n result of divideToIntegralValue followed by the result of\n remainder on the two operands.\n\n Note that if both the integer quotient and remainder are\n needed, this method is faster than using the\n divideToIntegralValue and remainder methods\n separately because the division need only be carried out once."}, {"method_name": "divideAndRemainder", "method_sig": "public BigDecimal[] divideAndRemainder (BigDecimal divisor,\n                                       MathContext mc)", "description": "Returns a two-element BigDecimal array containing the\n result of divideToIntegralValue followed by the result of\n remainder on the two operands calculated with rounding\n according to the context settings.\n\n Note that if both the integer quotient and remainder are\n needed, this method is faster than using the\n divideToIntegralValue and remainder methods\n separately because the division need only be carried out once."}, {"method_name": "sqrt", "method_sig": "public BigDecimal sqrt (MathContext mc)", "description": "Returns an approximation to the square root of this\n with rounding according to the context settings.\n\n The preferred scale of the returned result is equal to\n this.scale()/2. The value of the returned result is\n always within one ulp of the exact decimal value for the\n precision in question.  If the rounding mode is HALF_UP, HALF_DOWN, or HALF_EVEN, the\n result is within one half an ulp of the exact decimal value.\n\n Special case:\n \n The square root of a number numerically equal to \n ZERO is numerically equal to ZERO with a preferred\n scale according to the general rule above. In particular, for\n ZERO, ZERO.sqrt(mc).equals(ZERO) is true with\n any MathContext as an argument.\n "}, {"method_name": "pow", "method_sig": "public BigDecimal pow (int n)", "description": "Returns a BigDecimal whose value is\n (thisn), The power is computed exactly, to\n unlimited precision.\n\n The parameter n must be in the range 0 through\n 999999999, inclusive.  ZERO.pow(0) returns ONE.\n\n Note that future releases may expand the allowable exponent\n range of this method."}, {"method_name": "pow", "method_sig": "public BigDecimal pow (int n,\n                      MathContext mc)", "description": "Returns a BigDecimal whose value is\n (thisn).  The current implementation uses\n the core algorithm defined in ANSI standard X3.274-1996 with\n rounding according to the context settings.  In general, the\n returned numerical value is within two ulps of the exact\n numerical value for the chosen precision.  Note that future\n releases may use a different algorithm with a decreased\n allowable error bound and increased allowable exponent range.\n\n The X3.274-1996 algorithm is:\n\n \n An ArithmeticException exception is thrown if\n  \nabs(n) > 999999999\nmc.precision == 0 and n < 0\nmc.precision > 0 and n has more than\n    mc.precision decimal digits\n  \n if n is zero, ONE is returned even if\n this is zero, otherwise\n \n if n is positive, the result is calculated via\n   the repeated squaring technique into a single accumulator.\n   The individual multiplications with the accumulator use the\n   same math context settings as in mc except for a\n   precision increased to mc.precision + elength + 1\n   where elength is the number of decimal digits in\n   n.\n\n    if n is negative, the result is calculated as if\n   n were positive; this value is then divided into one\n   using the working precision specified above.\n\n    The final value from either the positive or negative case\n   is then rounded to the destination precision.\n   \n"}, {"method_name": "abs", "method_sig": "public BigDecimal abs()", "description": "Returns a BigDecimal whose value is the absolute value\n of this BigDecimal, and whose scale is\n this.scale()."}, {"method_name": "abs", "method_sig": "public BigDecimal abs (MathContext mc)", "description": "Returns a BigDecimal whose value is the absolute value\n of this BigDecimal, with rounding according to the\n context settings."}, {"method_name": "negate", "method_sig": "public BigDecimal negate()", "description": "Returns a BigDecimal whose value is (-this),\n and whose scale is this.scale()."}, {"method_name": "negate", "method_sig": "public BigDecimal negate (MathContext mc)", "description": "Returns a BigDecimal whose value is (-this),\n with rounding according to the context settings."}, {"method_name": "plus", "method_sig": "public BigDecimal plus()", "description": "Returns a BigDecimal whose value is (+this), and whose\n scale is this.scale().\n\n This method, which simply returns this BigDecimal\n is included for symmetry with the unary minus method negate()."}, {"method_name": "plus", "method_sig": "public BigDecimal plus (MathContext mc)", "description": "Returns a BigDecimal whose value is (+this),\n with rounding according to the context settings.\n\n The effect of this method is identical to that of the round(MathContext) method."}, {"method_name": "signum", "method_sig": "public int signum()", "description": "Returns the signum function of this BigDecimal."}, {"method_name": "scale", "method_sig": "public int scale()", "description": "Returns the scale of this BigDecimal.  If zero\n or positive, the scale is the number of digits to the right of\n the decimal point.  If negative, the unscaled value of the\n number is multiplied by ten to the power of the negation of the\n scale.  For example, a scale of -3 means the unscaled\n value is multiplied by 1000."}, {"method_name": "precision", "method_sig": "public int precision()", "description": "Returns the precision of this BigDecimal.  (The\n precision is the number of digits in the unscaled value.)\n\n The precision of a zero value is 1."}, {"method_name": "unscaledValue", "method_sig": "public BigInteger unscaledValue()", "description": "Returns a BigInteger whose value is the unscaled\n value of this BigDecimal.  (Computes (this *\n 10this.scale()).)"}, {"method_name": "round", "method_sig": "public BigDecimal round (MathContext mc)", "description": "Returns a BigDecimal rounded according to the\n MathContext settings.  If the precision setting is 0 then\n no rounding takes place.\n\n The effect of this method is identical to that of the\n plus(MathContext) method."}, {"method_name": "setScale", "method_sig": "public BigDecimal setScale (int newScale,\n                           RoundingMode roundingMode)", "description": "Returns a BigDecimal whose scale is the specified\n value, and whose unscaled value is determined by multiplying or\n dividing this BigDecimal's unscaled value by the\n appropriate power of ten to maintain its overall value.  If the\n scale is reduced by the operation, the unscaled value must be\n divided (rather than multiplied), and the value may be changed;\n in this case, the specified rounding mode is applied to the\n division."}, {"method_name": "setScale", "method_sig": "@Deprecated(since=\"9\")\npublic BigDecimal setScale (int newScale,\n                           int roundingMode)", "description": "Returns a BigDecimal whose scale is the specified\n value, and whose unscaled value is determined by multiplying or\n dividing this BigDecimal's unscaled value by the\n appropriate power of ten to maintain its overall value.  If the\n scale is reduced by the operation, the unscaled value must be\n divided (rather than multiplied), and the value may be changed;\n in this case, the specified rounding mode is applied to the\n division."}, {"method_name": "setScale", "method_sig": "public BigDecimal setScale (int newScale)", "description": "Returns a BigDecimal whose scale is the specified\n value, and whose value is numerically equal to this\n BigDecimal's.  Throws an ArithmeticException\n if this is not possible.\n\n This call is typically used to increase the scale, in which\n case it is guaranteed that there exists a BigDecimal\n of the specified scale and the correct value.  The call can\n also be used to reduce the scale if the caller knows that the\n BigDecimal has sufficiently many zeros at the end of\n its fractional part (i.e., factors of ten in its integer value)\n to allow for the rescaling without changing its value.\n\n This method returns the same result as the two-argument\n versions of setScale, but saves the caller the trouble\n of specifying a rounding mode in cases where it is irrelevant."}, {"method_name": "movePointLeft", "method_sig": "public BigDecimal movePointLeft (int n)", "description": "Returns a BigDecimal which is equivalent to this one\n with the decimal point moved n places to the left.  If\n n is non-negative, the call merely adds n to\n the scale.  If n is negative, the call is equivalent\n to movePointRight(-n).  The BigDecimal\n returned by this call has value (this \u00d7\n 10-n) and scale max(this.scale()+n,\n 0)."}, {"method_name": "movePointRight", "method_sig": "public BigDecimal movePointRight (int n)", "description": "Returns a BigDecimal which is equivalent to this one\n with the decimal point moved n places to the right.\n If n is non-negative, the call merely subtracts\n n from the scale.  If n is negative, the call\n is equivalent to movePointLeft(-n).  The\n BigDecimal returned by this call has value (this\n \u00d7 10n) and scale max(this.scale()-n,\n 0)."}, {"method_name": "scaleByPowerOfTen", "method_sig": "public BigDecimal scaleByPowerOfTen (int n)", "description": "Returns a BigDecimal whose numerical value is equal to\n (this * 10n).  The scale of\n the result is (this.scale() - n)."}, {"method_name": "stripTrailingZeros", "method_sig": "public BigDecimal stripTrailingZeros()", "description": "Returns a BigDecimal which is numerically equal to\n this one but with any trailing zeros removed from the\n representation.  For example, stripping the trailing zeros from\n the BigDecimal value 600.0, which has\n [BigInteger, scale] components equals to\n [6000, 1], yields 6E2 with [BigInteger,\n scale] components equals to [6, -2].  If\n this BigDecimal is numerically equal to zero, then\n BigDecimal.ZERO is returned."}, {"method_name": "compareTo", "method_sig": "public int compareTo (BigDecimal val)", "description": "Compares this BigDecimal with the specified\n BigDecimal.  Two BigDecimal objects that are\n equal in value but have a different scale (like 2.0 and 2.00)\n are considered equal by this method.  This method is provided\n in preference to individual methods for each of the six boolean\n comparison operators (<, ==,\n >, >=, !=, <=).  The\n suggested idiom for performing these comparisons is:\n (x.compareTo(y) <op> 0), where\n <op> is one of the six comparison operators."}, {"method_name": "equals", "method_sig": "public boolean equals (Object x)", "description": "Compares this BigDecimal with the specified\n Object for equality.  Unlike compareTo, this method considers two\n BigDecimal objects equal only if they are equal in\n value and scale (thus 2.0 is not equal to 2.00 when compared by\n this method)."}, {"method_name": "min", "method_sig": "public BigDecimal min (BigDecimal val)", "description": "Returns the minimum of this BigDecimal and\n val."}, {"method_name": "max", "method_sig": "public BigDecimal max (BigDecimal val)", "description": "Returns the maximum of this BigDecimal and val."}, {"method_name": "hashCode", "method_sig": "public int hashCode()", "description": "Returns the hash code for this BigDecimal.  Note that\n two BigDecimal objects that are numerically equal but\n differ in scale (like 2.0 and 2.00) will generally not\n have the same hash code."}, {"method_name": "toString", "method_sig": "public String toString()", "description": "Returns the string representation of this BigDecimal,\n using scientific notation if an exponent is needed.\n\n A standard canonical string form of the BigDecimal\n is created as though by the following steps: first, the\n absolute value of the unscaled value of the BigDecimal\n is converted to a string in base ten using the characters\n '0' through '9' with no leading zeros (except\n if its value is zero, in which case a single '0'\n character is used).\n\n Next, an adjusted exponent is calculated; this is the\n negated scale, plus the number of characters in the converted\n unscaled value, less one.  That is,\n -scale+(ulength-1), where ulength is the\n length of the absolute value of the unscaled value in decimal\n digits (its precision).\n\n If the scale is greater than or equal to zero and the\n adjusted exponent is greater than or equal to -6, the\n number will be converted to a character form without using\n exponential notation.  In this case, if the scale is zero then\n no decimal point is added and if the scale is positive a\n decimal point will be inserted with the scale specifying the\n number of characters to the right of the decimal point.\n '0' characters are added to the left of the converted\n unscaled value as necessary.  If no character precedes the\n decimal point after this insertion then a conventional\n '0' character is prefixed.\n\n Otherwise (that is, if the scale is negative, or the\n adjusted exponent is less than -6), the number will be\n converted to a character form using exponential notation.  In\n this case, if the converted BigInteger has more than\n one digit a decimal point is inserted after the first digit.\n An exponent in character form is then suffixed to the converted\n unscaled value (perhaps with inserted decimal point); this\n comprises the letter 'E' followed immediately by the\n adjusted exponent converted to a character form.  The latter is\n in base ten, using the characters '0' through\n '9' with no leading zeros, and is always prefixed by a\n sign character '-' ('\\u002D') if the\n adjusted exponent is negative, '+'\n ('\\u002B') otherwise).\n\n Finally, the entire string is prefixed by a minus sign\n character '-' ('\\u002D') if the unscaled\n value is less than zero.  No sign character is prefixed if the\n unscaled value is zero or positive.\n\n Examples:\nFor each representation [unscaled value, scale]\n on the left, the resulting string is shown on the right.\n \n [123,0]      \"123\"\n [-123,0]     \"-123\"\n [123,-1]     \"1.23E+3\"\n [123,-3]     \"1.23E+5\"\n [123,1]      \"12.3\"\n [123,5]      \"0.00123\"\n [123,10]     \"1.23E-8\"\n [-123,12]    \"-1.23E-10\"\n \nNotes:\n\nThere is a one-to-one mapping between the distinguishable\n BigDecimal values and the result of this conversion.\n That is, every distinguishable BigDecimal value\n (unscaled value and scale) has a unique string representation\n as a result of using toString.  If that string\n representation is converted back to a BigDecimal using\n the BigDecimal(String) constructor, then the original\n value will be recovered.\n\n The string produced for a given number is always the same;\n it is not affected by locale.  This means that it can be used\n as a canonical string representation for exchanging decimal\n data, or as a key for a Hashtable, etc.  Locale-sensitive\n number formatting and parsing is handled by the NumberFormat class and its subclasses.\n\n The toEngineeringString() method may be used for\n presenting numbers with exponents in engineering notation, and the\n setScale method may be used for\n rounding a BigDecimal so it has a known number of digits after\n the decimal point.\n\n The digit-to-character mapping provided by\n Character.forDigit is used.\n\n "}, {"method_name": "toEngineeringString", "method_sig": "public String toEngineeringString()", "description": "Returns a string representation of this BigDecimal,\n using engineering notation if an exponent is needed.\n\n Returns a string that represents the BigDecimal as\n described in the toString() method, except that if\n exponential notation is used, the power of ten is adjusted to\n be a multiple of three (engineering notation) such that the\n integer part of nonzero values will be in the range 1 through\n 999.  If exponential notation is used for zero values, a\n decimal point and one or two fractional zero digits are used so\n that the scale of the zero value is preserved.  Note that\n unlike the output of toString(), the output of this\n method is not guaranteed to recover the same [integer,\n scale] pair of this BigDecimal if the output string is\n converting back to a BigDecimal using the string constructor.  The result of this method meets\n the weaker constraint of always producing a numerically equal\n result from applying the string constructor to the method's output."}, {"method_name": "toPlainString", "method_sig": "public String toPlainString()", "description": "Returns a string representation of this BigDecimal\n without an exponent field.  For values with a positive scale,\n the number of digits to the right of the decimal point is used\n to indicate scale.  For values with a zero or negative scale,\n the resulting string is generated as if the value were\n converted to a numerically equal value with zero scale and as\n if all the trailing zeros of the zero scale value were present\n in the result.\n\n The entire string is prefixed by a minus sign character '-'\n ('\\u002D') if the unscaled value is less than\n zero. No sign character is prefixed if the unscaled value is\n zero or positive.\n\n Note that if the result of this method is passed to the\n string constructor, only the\n numerical value of this BigDecimal will necessarily be\n recovered; the representation of the new BigDecimal\n may have a different scale.  In particular, if this\n BigDecimal has a negative scale, the string resulting\n from this method will have a scale of zero when processed by\n the string constructor.\n\n (This method behaves analogously to the toString\n method in 1.4 and earlier releases.)"}, {"method_name": "toBigInteger", "method_sig": "public BigInteger toBigInteger()", "description": "Converts this BigDecimal to a BigInteger.\n This conversion is analogous to the\n narrowing primitive conversion from double to\n long as defined in\n The Java\u2122 Language Specification:\n any fractional part of this\n BigDecimal will be discarded.  Note that this\n conversion can lose information about the precision of the\n BigDecimal value.\n \n To have an exception thrown if the conversion is inexact (in\n other words if a nonzero fractional part is discarded), use the\n toBigIntegerExact() method."}, {"method_name": "toBigIntegerExact", "method_sig": "public BigInteger toBigIntegerExact()", "description": "Converts this BigDecimal to a BigInteger,\n checking for lost information.  An exception is thrown if this\n BigDecimal has a nonzero fractional part."}, {"method_name": "longValue", "method_sig": "public long longValue()", "description": "Converts this BigDecimal to a long.\n This conversion is analogous to the\n narrowing primitive conversion from double to\n short as defined in\n The Java\u2122 Language Specification:\n any fractional part of this\n BigDecimal will be discarded, and if the resulting\n \"BigInteger\" is too big to fit in a\n long, only the low-order 64 bits are returned.\n Note that this conversion can lose information about the\n overall magnitude and precision of this BigDecimal value as well\n as return a result with the opposite sign."}, {"method_name": "longValueExact", "method_sig": "public long longValueExact()", "description": "Converts this BigDecimal to a long, checking\n for lost information.  If this BigDecimal has a\n nonzero fractional part or is out of the possible range for a\n long result then an ArithmeticException is\n thrown."}, {"method_name": "intValue", "method_sig": "public int intValue()", "description": "Converts this BigDecimal to an int.\n This conversion is analogous to the\n narrowing primitive conversion from double to\n short as defined in\n The Java\u2122 Language Specification:\n any fractional part of this\n BigDecimal will be discarded, and if the resulting\n \"BigInteger\" is too big to fit in an\n int, only the low-order 32 bits are returned.\n Note that this conversion can lose information about the\n overall magnitude and precision of this BigDecimal\n value as well as return a result with the opposite sign."}, {"method_name": "intValueExact", "method_sig": "public int intValueExact()", "description": "Converts this BigDecimal to an int, checking\n for lost information.  If this BigDecimal has a\n nonzero fractional part or is out of the possible range for an\n int result then an ArithmeticException is\n thrown."}, {"method_name": "shortValueExact", "method_sig": "public short shortValueExact()", "description": "Converts this BigDecimal to a short, checking\n for lost information.  If this BigDecimal has a\n nonzero fractional part or is out of the possible range for a\n short result then an ArithmeticException is\n thrown."}, {"method_name": "byteValueExact", "method_sig": "public byte byteValueExact()", "description": "Converts this BigDecimal to a byte, checking\n for lost information.  If this BigDecimal has a\n nonzero fractional part or is out of the possible range for a\n byte result then an ArithmeticException is\n thrown."}, {"method_name": "floatValue", "method_sig": "public float floatValue()", "description": "Converts this BigDecimal to a float.\n This conversion is similar to the\n narrowing primitive conversion from double to\n float as defined in\n The Java\u2122 Language Specification:\n if this BigDecimal has too great a\n magnitude to represent as a float, it will be\n converted to Float.NEGATIVE_INFINITY or Float.POSITIVE_INFINITY as appropriate.  Note that even when\n the return value is finite, this conversion can lose\n information about the precision of the BigDecimal\n value."}, {"method_name": "doubleValue", "method_sig": "public double doubleValue()", "description": "Converts this BigDecimal to a double.\n This conversion is similar to the\n narrowing primitive conversion from double to\n float as defined in\n The Java\u2122 Language Specification:\n if this BigDecimal has too great a\n magnitude represent as a double, it will be\n converted to Double.NEGATIVE_INFINITY or Double.POSITIVE_INFINITY as appropriate.  Note that even when\n the return value is finite, this conversion can lose\n information about the precision of the BigDecimal\n value."}, {"method_name": "ulp", "method_sig": "public BigDecimal ulp()", "description": "Returns the size of an ulp, a unit in the last place, of this\n BigDecimal.  An ulp of a nonzero BigDecimal\n value is the positive distance between this value and the\n BigDecimal value next larger in magnitude with the\n same number of digits.  An ulp of a zero value is numerically\n equal to 1 with the scale of this.  The result is\n stored with the same scale as this so the result\n for zero and nonzero values is equal to [1,\n this.scale()]."}]}