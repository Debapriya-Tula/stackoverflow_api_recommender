{"name": "Class Pattern", "module": "java.base", "package": "java.util.regex", "text": "A compiled representation of a regular expression.\n\n  A regular expression, specified as a string, must first be compiled into\n an instance of this class.  The resulting pattern can then be used to create\n a Matcher object that can match arbitrary character sequences against the regular\n expression.  All of the state involved in performing a match resides in the\n matcher, so many matchers can share the same pattern.\n\n  A typical invocation sequence is thus\n\n \n Pattern p = Pattern.compile(\"a*b\");\n Matcher m = p.matcher(\"aaaaab\");\n boolean b = m.matches();\n A matches method is defined by this class as a\n convenience for when a regular expression is used just once.  This method\n compiles an expression and matches an input sequence against it in a single\n invocation.  The statement\n\n \n boolean b = Pattern.matches(\"a*b\", \"aaaaab\");\n\n is equivalent to the three statements above, though for repeated matches it\n is less efficient since it does not allow the compiled pattern to be reused.\n\n  Instances of this class are immutable and are safe for use by multiple\n concurrent threads.  Instances of the Matcher class are not safe for\n such use.\n\n\n Summary of regular-expression constructs\n\nRegular expression constructs, and what they match\n\n\nConstruct\nMatches\n\n\n\nCharacters\nx\nThe character x\n\\\\\nThe backslash character\n\\0n\nThe character with octal value 0n\n         (0\u00a0<=\u00a0n\u00a0<=\u00a07)\n\\0nn\nThe character with octal value 0nn\n         (0\u00a0<=\u00a0n\u00a0<=\u00a07)\n\\0mnn\nThe character with octal value 0mnn\n         (0\u00a0<=\u00a0m\u00a0<=\u00a03,\n         0\u00a0<=\u00a0n\u00a0<=\u00a07)\n\\xhh\nThe character with hexadecimal value 0xhh\n\\uhhhh\nThe character with hexadecimal\u00a0value\u00a00xhhhh\n\\x{h...h}\nThe character with hexadecimal value 0xh...h\n         (Character.MIN_CODE_POINT\n         \u00a0<=\u00a00xh...h\u00a0<=\u00a0\n          Character.MAX_CODE_POINT)\n\\N{name}\nThe character with Unicode character name 'name'\n\\t\nThe tab character ('\\u0009')\n\\n\nThe newline (line feed) character ('\\u000A')\n\\r\nThe carriage-return character ('\\u000D')\n\\f\nThe form-feed character ('\\u000C')\n\\a\nThe alert (bell) character ('\\u0007')\n\\e\nThe escape character ('\\u001B')\n\\cx\nThe control character corresponding to x\nCharacter classes\n[abc]\na, b, or c (simple class)\n[^abc]\nAny character except a, b, or c (negation)\n[a-zA-Z]\na through z\n         or A through Z, inclusive (range)\n[a-d[m-p]]\na through d,\n      or m through p: [a-dm-p] (union)\n[a-z&&[def]]\nd, e, or f (intersection)\n[a-z&&[^bc]]\na through z,\n         except for b and c: [ad-z] (subtraction)\n[a-z&&[^m-p]]\na through z,\n          and not m through p: [a-lq-z](subtraction)\nPredefined character classes\n.\nAny character (may or may not match line terminators)\n\\d\nA digit: [0-9]\n\\D\nA non-digit: [^0-9]\n\\h\nA horizontal whitespace character:\n     [ \\t\\xA0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000]\n\\H\nA non-horizontal whitespace character: [^\\h]\n\\s\nA whitespace character: [ \\t\\n\\x0B\\f\\r]\n\\S\nA non-whitespace character: [^\\s]\n\\v\nA vertical whitespace character: [\\n\\x0B\\f\\r\\x85\\u2028\\u2029]\n\n\\V\nA non-vertical whitespace character: [^\\v]\n\\w\nA word character: [a-zA-Z_0-9]\n\\W\nA non-word character: [^\\w]\nPOSIX character classes (US-ASCII only)\n\\p{Lower}\nA lower-case alphabetic character: [a-z]\n\\p{Upper}\nAn upper-case alphabetic character:[A-Z]\n\\p{ASCII}\nAll ASCII:[\\x00-\\x7F]\n\\p{Alpha}\nAn alphabetic character:[\\p{Lower}\\p{Upper}]\n\\p{Digit}\nA decimal digit: [0-9]\n\\p{Alnum}\nAn alphanumeric character:[\\p{Alpha}\\p{Digit}]\n\\p{Punct}\nPunctuation: One of !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\n\n\\p{Graph}\nA visible character: [\\p{Alnum}\\p{Punct}]\n\\p{Print}\nA printable character: [\\p{Graph}\\x20]\n\\p{Blank}\nA space or a tab: [ \\t]\n\\p{Cntrl}\nA control character: [\\x00-\\x1F\\x7F]\n\\p{XDigit}\nA hexadecimal digit: [0-9a-fA-F]\n\\p{Space}\nA whitespace character: [ \\t\\n\\x0B\\f\\r]\njava.lang.Character classes (simple java character type)\n\\p{javaLowerCase}\nEquivalent to java.lang.Character.isLowerCase()\n\\p{javaUpperCase}\nEquivalent to java.lang.Character.isUpperCase()\n\\p{javaWhitespace}\nEquivalent to java.lang.Character.isWhitespace()\n\\p{javaMirrored}\nEquivalent to java.lang.Character.isMirrored()\nClasses for Unicode scripts, blocks, categories and binary properties\n\\p{IsLatin}\nA Latin\u00a0script character (script)\n\\p{InGreek}\nA character in the Greek\u00a0block (block)\n\\p{Lu}\nAn uppercase letter (category)\n\\p{IsAlphabetic}\nAn alphabetic character (binary property)\n\\p{Sc}\nA currency symbol\n\\P{InGreek}\nAny character except one in the Greek block (negation)\n[\\p{L}&&[^\\p{Lu}]]\nAny letter except an uppercase letter (subtraction)\nBoundary matchers\n^\nThe beginning of a line\n$\nThe end of a line\n\\b\nA word boundary\n\\b{g}\nA Unicode extended grapheme cluster boundary\n\\B\nA non-word boundary\n\\A\nThe beginning of the input\n\\G\nThe end of the previous match\n\\Z\nThe end of the input but for the final\n         terminator, if\u00a0any\n\\z\nThe end of the input\nLinebreak matcher\n\\R\nAny Unicode linebreak sequence, is equivalent to\n     \\u000D\\u000A|[\\u000A\\u000B\\u000C\\u000D\\u0085\\u2028\\u2029]\n     \nUnicode Extended Grapheme matcher\n\\X\nAny Unicode extended grapheme cluster\nGreedy quantifiers\nX?\nX, once or not at all\nX*\nX, zero or more times\nX+\nX, one or more times\nX{n}\nX, exactly n times\nX{n,}\nX, at least n times\nX{n,m}\nX, at least n but not more than m times\nReluctant quantifiers\nX??\nX, once or not at all\nX*?\nX, zero or more times\nX+?\nX, one or more times\nX{n}?\nX, exactly n times\nX{n,}?\nX, at least n times\nX{n,m}?\nX, at least n but not more than m times\nPossessive quantifiers\nX?+\nX, once or not at all\nX*+\nX, zero or more times\nX++\nX, one or more times\nX{n}+\nX, exactly n times\nX{n,}+\nX, at least n times\nX{n,m}+\nX, at least n but not more than m times\nLogical operators\nXY\nX followed by Y\nX|Y\nEither X or Y\n(X)\nX, as a capturing group\nBack references\n\\n\nWhatever the nth\ncapturing group matched\n\\k<name>\nWhatever the\n     named-capturing group \"name\" matched\nQuotation\n\\\nNothing, but quotes the following character\n\\Q\nNothing, but quotes all characters until \\E\n\\E\nNothing, but ends quoting started by \\Q\n\nSpecial constructs (named-capturing and non-capturing)\n(?<name>X)\nX, as a named-capturing group\n(?:X)\nX, as a non-capturing group\n(?idmsuxU-idmsuxU)\u00a0\nNothing, but turns match flags i\nd m s\nu x U\n on - off\n(?idmsux-idmsux:X)\u00a0\u00a0\nX, as a non-capturing group with the\n         given flags i d\nm s u\nx on - off\n(?=X)\nX, via zero-width positive lookahead\n(?!X)\nX, via zero-width negative lookahead\n(?<=X)\nX, via zero-width positive lookbehind\n(?<!X)\nX, via zero-width negative lookbehind\n(?>X)\nX, as an independent, non-capturing group\n\n\n\nBackslashes, escapes, and quoting\n The backslash character ('\\') serves to introduce escaped\n constructs, as defined in the table above, as well as to quote characters\n that otherwise would be interpreted as unescaped constructs.  Thus the\n expression \\\\ matches a single backslash and \\{ matches a\n left brace.\n\n  It is an error to use a backslash prior to any alphabetic character that\n does not denote an escaped construct; these are reserved for future\n extensions to the regular-expression language.  A backslash may be used\n prior to a non-alphabetic character regardless of whether that character is\n part of an unescaped construct.\n\n  Backslashes within string literals in Java source code are interpreted\n as required by\n The Java\u2122 Language Specification\n as either Unicode escapes (section 3.3) or other character escapes (section 3.10.6)\n It is therefore necessary to double backslashes in string\n literals that represent regular expressions to protect them from\n interpretation by the Java bytecode compiler.  The string literal\n \"\\b\", for example, matches a single backspace character when\n interpreted as a regular expression, while \"\\\\b\" matches a\n word boundary.  The string literal \"\\(hello\\)\" is illegal\n and leads to a compile-time error; in order to match the string\n (hello) the string literal \"\\\\(hello\\\\)\"\n must be used.\n\n Character Classes\n Character classes may appear within other character classes, and\n    may be composed by the union operator (implicit) and the intersection\n    operator (&&).\n    The union operator denotes a class that contains every character that is\n    in at least one of its operand classes.  The intersection operator\n    denotes a class that contains every character that is in both of its\n    operand classes.\n\n     The precedence of character-class operators is as follows, from\n    highest to lowest:\n\n    \nPrecedence of character class operators.\n\nPrecedenceNameExample\n      \n\n1\nLiteral escape\u00a0\u00a0\u00a0\u00a0\n\\x\n2\nGrouping\n[...]\n3\nRange\na-z\n4\nUnion\n[a-e][i-u]\n5\nIntersection\n[a-z&&[aeiou]]\n\n\n Note that a different set of metacharacters are in effect inside\n    a character class than outside a character class. For instance, the\n    regular expression . loses its special meaning inside a\n    character class, while the expression - becomes a range\n    forming metacharacter.\n\n Line terminators\n A line terminator is a one- or two-character sequence that marks\n the end of a line of the input character sequence.  The following are\n recognized as line terminators:\n\n \n A newline (line feed) character ('\\n'),\n\n    A carriage-return character followed immediately by a newline\n   character (\"\\r\\n\"),\n\n    A standalone carriage-return character ('\\r'),\n\n    A next-line character ('\\u0085'),\n\n    A line-separator character ('\\u2028'), or\n\n    A paragraph-separator character ('\\u2029').\n\n \nIf UNIX_LINES mode is activated, then the only line terminators\n recognized are newline characters.\n\n  The regular expression . matches any character except a line\n terminator unless the DOTALL flag is specified.\n\n  By default, the regular expressions ^ and $ ignore\n line terminators and only match at the beginning and the end, respectively,\n of the entire input sequence. If MULTILINE mode is activated then\n ^ matches at the beginning of input and after any line terminator\n except at the end of input. When in MULTILINE mode $\n matches just before a line terminator or the end of the input sequence.\n\n Groups and capturing\nGroup number\n Capturing groups are numbered by counting their opening parentheses from\n left to right.  In the expression ((A)(B(C))), for example, there\n are four such groups: \n\n ((A)(B(C)))\n (A)\n (B(C))\n (C)\n\n Group zero always stands for the entire expression.\n\n  Capturing groups are so named because, during a match, each subsequence\n of the input sequence that matches such a group is saved.  The captured\n subsequence may be used later in the expression, via a back reference, and\n may also be retrieved from the matcher once the match operation is complete.\n\n Group name\nA capturing group can also be assigned a \"name\", a named-capturing group,\n and then be back-referenced later by the \"name\". Group names are composed of\n the following characters. The first character must be a letter.\n\n \n The uppercase letters 'A' through 'Z'\n        ('\\u0041'\u00a0through\u00a0'\\u005a'),\n    The lowercase letters 'a' through 'z'\n        ('\\u0061'\u00a0through\u00a0'\\u007a'),\n    The digits '0' through '9'\n        ('\\u0030'\u00a0through\u00a0'\\u0039'),\n \n A named-capturing group is still numbered as described in\n Group number.\n\n  The captured input associated with a group is always the subsequence\n that the group most recently matched.  If a group is evaluated a second time\n because of quantification then its previously-captured value, if any, will\n be retained if the second evaluation fails.  Matching the string\n \"aba\" against the expression (a(b)?)+, for example, leaves\n group two set to \"b\".  All captured input is discarded at the\n beginning of each match.\n\n  Groups beginning with (? are either pure, non-capturing groups\n that do not capture text and do not count towards the group total, or\n named-capturing group.\n\n  Unicode support \n This class is in conformance with Level 1 of Unicode Technical\n Standard #18: Unicode Regular Expression, plus RL2.1\n Canonical Equivalents.\n \nUnicode escape sequences such as \\u2014 in Java source code\n are processed as described in section 3.3 of\n The Java\u2122 Language Specification.\n Such escape sequences are also implemented directly by the regular-expression\n parser so that Unicode escapes can be used in expressions that are read from\n files or from the keyboard.  Thus the strings \"\\u2014\" and\n \"\\\\u2014\", while not equal, compile into the same pattern, which\n matches the character with hexadecimal value 0x2014.\n \n A Unicode character can also be represented by using its Hex notation\n (hexadecimal code point value) directly as described in construct\n \\x{...}, for example a supplementary character U+2011F can be\n specified as \\x{2011F}, instead of two consecutive Unicode escape\n sequences of the surrogate pair \\uD840\\uDD1F.\n \nUnicode character names are supported by the named character construct\n \\N{...}, for example, \\N{WHITE SMILING FACE}\n specifies character \\u263A. The character names supported\n by this class are the valid Unicode character names matched by\n Character.codePointOf(name).\n \n\nUnicode extended grapheme clusters are supported by the grapheme\n cluster matcher \\X and the corresponding boundary matcher \\b{g}.\n \n Unicode scripts, blocks, categories and binary properties are written with\n the \\p and \\P constructs as in Perl.\n \\p{prop} matches if\n the input has the property prop, while \\P{prop}\n does not match if the input has that property.\n \n Scripts, blocks, categories and binary properties can be used both inside\n and outside of a character class.\n\n \nScripts are specified either with the prefix Is, as in\n IsHiragana, or by using  the script keyword (or its short\n form sc) as in script=Hiragana or sc=Hiragana.\n \n The script names supported by Pattern are the valid script names\n accepted and defined by\n UnicodeScript.forName.\n\n \nBlocks are specified with the prefix In, as in\n InMongolian, or by using the keyword block (or its short\n form blk) as in block=Mongolian or blk=Mongolian.\n \n The block names supported by Pattern are the valid block names\n accepted and defined by\n UnicodeBlock.forName.\n \nCategories may be specified with the optional prefix Is:\n Both \\p{L} and \\p{IsL} denote the category of Unicode\n letters. Same as scripts and blocks, categories can also be specified\n by using the keyword general_category (or its short form\n gc) as in general_category=Lu or gc=Lu.\n \n The supported categories are those of\n \nThe Unicode Standard in the version specified by the\n Character class. The category names are those\n defined in the Standard, both normative and informative.\n \nBinary properties are specified with the prefix Is, as in\n IsAlphabetic. The supported binary properties by Pattern\n are\n \n Alphabetic\n    Ideographic\n    Letter\n    Lowercase\n    Uppercase\n    Titlecase\n    Punctuation\n    Control\n    White_Space\n    Digit\n    Hex_Digit\n    Join_Control\n    Noncharacter_Code_Point\n    Assigned\n \n\n The following Predefined Character classes and POSIX character classes\n are in conformance with the recommendation of Annex C: Compatibility Properties\n of Unicode Regular Expression\n , when UNICODE_CHARACTER_CLASS flag is specified.\n\n \npredefined and posix character classes in Unicode mode\n\n\nClasses\nMatches\n\n\n\n\\p{Lower}\nA lowercase character:\\p{IsLowercase}\n\\p{Upper}\nAn uppercase character:\\p{IsUppercase}\n\\p{ASCII}\nAll ASCII:[\\x00-\\x7F]\n\\p{Alpha}\nAn alphabetic character:\\p{IsAlphabetic}\n\\p{Digit}\nA decimal digit character:\\p{IsDigit}\n\\p{Alnum}\nAn alphanumeric character:[\\p{IsAlphabetic}\\p{IsDigit}]\n\\p{Punct}\nA punctuation character:\\p{IsPunctuation}\n\\p{Graph}\nA visible character: [^\\p{IsWhite_Space}\\p{gc=Cc}\\p{gc=Cs}\\p{gc=Cn}]\n\\p{Print}\nA printable character: [\\p{Graph}\\p{Blank}&&[^\\p{Cntrl}]]\n\\p{Blank}\nA space or a tab: [\\p{IsWhite_Space}&&[^\\p{gc=Zl}\\p{gc=Zp}\\x0a\\x0b\\x0c\\x0d\\x85]]\n\\p{Cntrl}\nA control character: \\p{gc=Cc}\n\\p{XDigit}\nA hexadecimal digit: [\\p{gc=Nd}\\p{IsHex_Digit}]\n\\p{Space}\nA whitespace character:\\p{IsWhite_Space}\n\\d\nA digit: \\p{IsDigit}\n\\D\nA non-digit: [^\\d]\n\\s\nA whitespace character: \\p{IsWhite_Space}\n\\S\nA non-whitespace character: [^\\s]\n\\w\nA word character: [\\p{Alpha}\\p{gc=Mn}\\p{gc=Me}\\p{gc=Mc}\\p{Digit}\\p{gc=Pc}\\p{IsJoin_Control}]\n\\W\nA non-word character: [^\\w]\n\n\n\n\n Categories that behave like the java.lang.Character\n boolean ismethodname methods (except for the deprecated ones) are\n available through the same \\p{prop} syntax where\n the specified property has the name javamethodname.\n\n  Comparison to Perl 5 \nThe Pattern engine performs traditional NFA-based matching\n with ordered alternation as occurs in Perl 5.\n\n  Perl constructs not supported by this class: \n\n The backreference constructs, \\g{n} for\n    the nthcapturing group and\n    \\g{name} for\n    named-capturing group.\n    \n The conditional constructs\n    (?(condition)X) and\n    (?(condition)X|Y),\n    \n The embedded code constructs (?{code})\n    and (??{code}),\n The embedded comment syntax (?#comment), and \n The preprocessing operations \\l \\u,\n    \\L, and \\U.  \n\n Constructs supported by this class but not by Perl: \n\n Character-class union and intersection as described\n    above.\n\n Notable differences from Perl: \n\n In Perl, \\1 through \\9 are always interpreted\n    as back references; a backslash-escaped number greater than 9 is\n    treated as a back reference if at least that many subexpressions exist,\n    otherwise it is interpreted, if possible, as an octal escape.  In this\n    class octal escapes must always begin with a zero. In this class,\n    \\1 through \\9 are always interpreted as back\n    references, and a larger number is accepted as a back reference if at\n    least that many subexpressions exist at that point in the regular\n    expression, otherwise the parser will drop digits until the number is\n    smaller or equal to the existing number of groups or it is one digit.\n    \n Perl uses the g flag to request a match that resumes\n    where the last match left off.  This functionality is provided implicitly\n    by the Matcher class: Repeated invocations of the find method will resume where the last match left off,\n    unless the matcher is reset.  \n In Perl, embedded flags at the top level of an expression affect\n    the whole expression.  In this class, embedded flags always take effect\n    at the point at which they appear, whether they are at the top level or\n    within a group; in the latter case, flags are restored at the end of the\n    group just as in Perl.  \n\n For a more precise description of the behavior of regular expression\n constructs, please see \nMastering Regular Expressions, 3nd Edition, Jeffrey E. F. Friedl,\n O'Reilly and Associates, 2006.\n", "codes": ["public final class Pattern\nextends Object\nimplements Serializable"], "fields": [{"field_name": "UNIX_LINES", "field_sig": "public static final\u00a0int UNIX_LINES", "description": "Enables Unix lines mode.\n\n  In this mode, only the '\\n' line terminator is recognized\n in the behavior of ., ^, and $.\n\n  Unix lines mode can also be enabled via the embedded flag\n expression\u00a0(?d)."}, {"field_name": "CASE_INSENSITIVE", "field_sig": "public static final\u00a0int CASE_INSENSITIVE", "description": "Enables case-insensitive matching.\n\n  By default, case-insensitive matching assumes that only characters\n in the US-ASCII charset are being matched.  Unicode-aware\n case-insensitive matching can be enabled by specifying the UNICODE_CASE flag in conjunction with this flag.\n\n  Case-insensitive matching can also be enabled via the embedded flag\n expression\u00a0(?i).\n\n  Specifying this flag may impose a slight performance penalty.  "}, {"field_name": "COMMENTS", "field_sig": "public static final\u00a0int COMMENTS", "description": "Permits whitespace and comments in pattern.\n\n  In this mode, whitespace is ignored, and embedded comments starting\n with # are ignored until the end of a line.\n\n  Comments mode can also be enabled via the embedded flag\n expression\u00a0(?x)."}, {"field_name": "MULTILINE", "field_sig": "public static final\u00a0int MULTILINE", "description": "Enables multiline mode.\n\n  In multiline mode the expressions ^ and $ match\n just after or just before, respectively, a line terminator or the end of\n the input sequence.  By default these expressions only match at the\n beginning and the end of the entire input sequence.\n\n  Multiline mode can also be enabled via the embedded flag\n expression\u00a0(?m).  "}, {"field_name": "LITERAL", "field_sig": "public static final\u00a0int LITERAL", "description": "Enables literal parsing of the pattern.\n\n  When this flag is specified then the input string that specifies\n the pattern is treated as a sequence of literal characters.\n Metacharacters or escape sequences in the input sequence will be\n given no special meaning.\n\n The flags CASE_INSENSITIVE and UNICODE_CASE retain their impact on\n matching when used in conjunction with this flag. The other flags\n become superfluous.\n\n  There is no embedded flag character for enabling literal parsing."}, {"field_name": "DOTALL", "field_sig": "public static final\u00a0int DOTALL", "description": "Enables dotall mode.\n\n  In dotall mode, the expression . matches any character,\n including a line terminator.  By default this expression does not match\n line terminators.\n\n  Dotall mode can also be enabled via the embedded flag\n expression\u00a0(?s).  (The s is a mnemonic for\n \"single-line\" mode, which is what this is called in Perl.)  "}, {"field_name": "UNICODE_CASE", "field_sig": "public static final\u00a0int UNICODE_CASE", "description": "Enables Unicode-aware case folding.\n\n  When this flag is specified then case-insensitive matching, when\n enabled by the CASE_INSENSITIVE flag, is done in a manner\n consistent with the Unicode Standard.  By default, case-insensitive\n matching assumes that only characters in the US-ASCII charset are being\n matched.\n\n  Unicode-aware case folding can also be enabled via the embedded flag\n expression\u00a0(?u).\n\n  Specifying this flag may impose a performance penalty.  "}, {"field_name": "CANON_EQ", "field_sig": "public static final\u00a0int CANON_EQ", "description": "Enables canonical equivalence.\n\n  When this flag is specified then two characters will be considered\n to match if, and only if, their full canonical decompositions match.\n The expression \"a\\u030A\", for example, will match the\n string \"\\u00E5\" when this flag is specified.  By default,\n matching does not take canonical equivalence into account.\n\n  There is no embedded flag character for enabling canonical\n equivalence.\n\n  Specifying this flag may impose a performance penalty.  "}, {"field_name": "UNICODE_CHARACTER_CLASS", "field_sig": "public static final\u00a0int UNICODE_CHARACTER_CLASS", "description": "Enables the Unicode version of Predefined character classes and\n POSIX character classes.\n\n  When this flag is specified then the (US-ASCII only)\n Predefined character classes and POSIX character classes\n are in conformance with\n Unicode Technical\n Standard #18: Unicode Regular Expression\nAnnex C: Compatibility Properties.\n \n The UNICODE_CHARACTER_CLASS mode can also be enabled via the embedded\n flag expression\u00a0(?U).\n \n The flag implies UNICODE_CASE, that is, it enables Unicode-aware case\n folding.\n \n Specifying this flag may impose a performance penalty.  "}], "methods": [{"method_name": "compile", "method_sig": "public static Pattern compile (String regex)", "description": "Compiles the given regular expression into a pattern."}, {"method_name": "compile", "method_sig": "public static Pattern compile (String regex,\n                              int flags)", "description": "Compiles the given regular expression into a pattern with the given\n flags."}, {"method_name": "pattern", "method_sig": "public String pattern()", "description": "Returns the regular expression from which this pattern was compiled."}, {"method_name": "toString", "method_sig": "public String toString()", "description": "Returns the string representation of this pattern. This\n is the regular expression from which this pattern was\n compiled."}, {"method_name": "matcher", "method_sig": "public Matcher matcher (CharSequence input)", "description": "Creates a matcher that will match the given input against this pattern."}, {"method_name": "flags", "method_sig": "public int flags()", "description": "Returns this pattern's match flags."}, {"method_name": "matches", "method_sig": "public static boolean matches (String regex,\n                              CharSequence input)", "description": "Compiles the given regular expression and attempts to match the given\n input against it.\n\n  An invocation of this convenience method of the form\n\n \n Pattern.matches(regex, input);\n\n behaves in exactly the same way as the expression\n\n \n Pattern.compile(regex).matcher(input).matches()\n If a pattern is to be used multiple times, compiling it once and reusing\n it will be more efficient than invoking this method each time.  "}, {"method_name": "split", "method_sig": "public String[] split (CharSequence input,\n                      int limit)", "description": "Splits the given input sequence around matches of this pattern.\n\n  The array returned by this method contains each substring of the\n input sequence that is terminated by another subsequence that matches\n this pattern or is terminated by the end of the input sequence.  The\n substrings in the array are in the order in which they occur in the\n input. If this pattern does not match any subsequence of the input then\n the resulting array has just one element, namely the input sequence in\n string form.\n\n  When there is a positive-width match at the beginning of the input\n sequence then an empty leading substring is included at the beginning\n of the resulting array. A zero-width match at the beginning however\n never produces such empty leading substring.\n\n  The limit parameter controls the number of times the\n pattern is applied and therefore affects the length of the resulting\n array.\n \n\n    If the limit is positive then the pattern will be applied\n    at most limit\u00a0-\u00a01 times, the array's length will be\n    no greater than limit, and the array's last entry will contain\n    all input beyond the last matched delimiter.\n\n    If the limit is zero then the pattern will be applied as\n    many times as possible, the array can have any length, and trailing\n    empty strings will be discarded.\n\n    If the limit is negative then the pattern will be applied\n    as many times as possible and the array can have any length.\n\n The input \"boo:and:foo\", for example, yields the following\n results with these parameters:\n\n \nSplit example showing regex, limit, and result\n\n\nRegex\nLimit\nResult\n\n\n\n:\n2\n{ \"boo\", \"and:foo\" }\n\n5\n{ \"boo\", \"and\", \"foo\" }\n\n-2\n{ \"boo\", \"and\", \"foo\" }\no\n5\n{ \"b\", \"\", \":and:f\", \"\", \"\" }\n\n-2\n{ \"b\", \"\", \":and:f\", \"\", \"\" }\n\n0\n{ \"b\", \"\", \":and:f\" }\n\n"}, {"method_name": "split", "method_sig": "public String[] split (CharSequence input)", "description": "Splits the given input sequence around matches of this pattern.\n\n  This method works as if by invoking the two-argument split method with the given input\n sequence and a limit argument of zero.  Trailing empty strings are\n therefore not included in the resulting array. \n The input \"boo:and:foo\", for example, yields the following\n results with these expressions:\n\n \nSplit examples showing regex and result\n\n\nRegex\nResult\n\n\n\n:\n{ \"boo\", \"and\", \"foo\" }\no\n{ \"b\", \"\", \":and:f\" }\n\n"}, {"method_name": "quote", "method_sig": "public static String quote (String s)", "description": "Returns a literal pattern String for the specified\n String.\n\n This method produces a String that can be used to\n create a Pattern that would match the string\n s as if it were a literal pattern. Metacharacters\n or escape sequences in the input sequence will be given no special\n meaning."}, {"method_name": "asPredicate", "method_sig": "public Predicate<String> asPredicate()", "description": "Creates a predicate that tests if this pattern is found in a given input\n string."}, {"method_name": "asMatchPredicate", "method_sig": "public Predicate<String> asMatchPredicate()", "description": "Creates a predicate that tests if this pattern matches a given input string."}, {"method_name": "splitAsStream", "method_sig": "public Stream<String> splitAsStream (CharSequence input)", "description": "Creates a stream from the given input sequence around matches of this\n pattern.\n\n  The stream returned by this method contains each substring of the\n input sequence that is terminated by another subsequence that matches\n this pattern or is terminated by the end of the input sequence.  The\n substrings in the stream are in the order in which they occur in the\n input. Trailing empty strings will be discarded and not encountered in\n the stream.\n\n  If this pattern does not match any subsequence of the input then\n the resulting stream has just one element, namely the input sequence in\n string form.\n\n  When there is a positive-width match at the beginning of the input\n sequence then an empty leading substring is included at the beginning\n of the stream. A zero-width match at the beginning however never produces\n such empty leading substring.\n\n  If the input sequence is mutable, it must remain constant during the\n execution of the terminal stream operation.  Otherwise, the result of the\n terminal stream operation is undefined."}]}