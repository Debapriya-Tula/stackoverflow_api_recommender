{"name": "Class Toolkit", "module": "java.desktop", "package": "java.awt", "text": "This class is the abstract superclass of all actual\n implementations of the Abstract Window Toolkit. Subclasses of\n the Toolkit class are used to bind the various components\n to particular native toolkit implementations.\n \n Many GUI events may be delivered to user\n asynchronously, if the opposite is not specified explicitly.\n As well as\n many GUI operations may be performed asynchronously.\n This fact means that if the state of a component is set, and then\n the state immediately queried, the returned value may not yet\n reflect the requested change.  This behavior includes, but is not\n limited to:\n \nScrolling to a specified position.\n For example, calling ScrollPane.setScrollPosition\n     and then getScrollPosition may return an incorrect\n     value if the original request has not yet been processed.\n\n Moving the focus from one component to another.\n For more information, see\n Timing\n Focus Transfers, a section in\n The Swing\n Tutorial.\n\n Making a top-level container visible.\n Calling setVisible(true) on a Window,\n     Frame or Dialog may occur\n     asynchronously.\n\n Setting the size or location of a top-level container.\n Calls to setSize, setBounds or\n     setLocation on a Window,\n     Frame or Dialog are forwarded\n     to the underlying window management system and may be\n     ignored or modified.  See Window for\n     more information.\n \n\n Most applications should not call any of the methods in this\n class directly. The methods defined by Toolkit are\n the \"glue\" that joins the platform-independent classes in the\n java.awt package with their counterparts in\n java.awt.peer. Some methods defined by\n Toolkit query the native operating system directly.", "codes": ["public abstract class Toolkit\nextends Object"], "fields": [{"field_name": "desktopProperties", "field_sig": "protected final\u00a0Map<String,\u200bObject> desktopProperties", "description": "The desktop properties."}, {"field_name": "desktopPropsSupport", "field_sig": "protected final\u00a0PropertyChangeSupport desktopPropsSupport", "description": "The desktop properties change support."}], "methods": [{"method_name": "loadSystemColors", "method_sig": "protected void loadSystemColors (int[] systemColors)\n                         throws HeadlessException", "description": "Fills in the integer array that is supplied as an argument\n with the current system color values."}, {"method_name": "setDynamicLayout", "method_sig": "public void setDynamicLayout (boolean dynamic)\n                      throws HeadlessException", "description": "Controls whether the layout of Containers is validated dynamically\n during resizing, or statically, after resizing is complete.\n Use isDynamicLayoutActive() to detect if this feature enabled\n in this program and is supported by this operating system\n and/or window manager.\n Note that this feature is supported not on all platforms, and\n conversely, that this feature cannot be turned off on some platforms.\n On these platforms where dynamic layout during resizing is not supported\n (or is always supported), setting this property has no effect.\n Note that this feature can be set or unset as a property of the\n operating system or window manager on some platforms.  On such\n platforms, the dynamic resize property must be set at the operating\n system or window manager level before this method can take effect.\n This method does not change support or settings of the underlying\n operating system or\n window manager.  The OS/WM support can be\n queried using getDesktopProperty(\"awt.dynamicLayoutSupported\") method."}, {"method_name": "isDynamicLayoutSet", "method_sig": "protected boolean isDynamicLayoutSet()\n                              throws HeadlessException", "description": "Returns whether the layout of Containers is validated dynamically\n during resizing, or statically, after resizing is complete.\n Note: this method returns the value that was set programmatically;\n it does not reflect support at the level of the operating system\n or window manager for dynamic layout on resizing, or the current\n operating system or window manager settings.  The OS/WM support can\n be queried using getDesktopProperty(\"awt.dynamicLayoutSupported\")."}, {"method_name": "isDynamicLayoutActive", "method_sig": "public boolean isDynamicLayoutActive()\n                              throws HeadlessException", "description": "Returns whether dynamic layout of Containers on resize is currently\n enabled on the underlying operating system and/or window manager. If the\n platform supports it, setDynamicLayout(boolean) may be used to\n programmatically enable or disable platform dynamic layout. Regardless of\n whether that toggling is supported, or whether true or \n false is specified as an argument, or has never been called at all, this\n method will return the active current platform behavior and which will be\n followed by the JDK in determining layout policy during resizing.\n \n If dynamic layout is currently inactive then Containers re-layout their\n components when resizing is completed. As a result the\n Component.validate() method will be invoked only once per resize.\n If dynamic layout is currently active then Containers re-layout their\n components on every native resize event and the validate() method\n will be invoked each time. The OS/WM support can be queried using the\n getDesktopProperty(\"awt.dynamicLayoutSupported\") method. This property\n will reflect the platform capability but is not sufficient to tell if it\n is presently enabled."}, {"method_name": "getScreenSize", "method_sig": "public abstract Dimension getScreenSize()\n                                 throws HeadlessException", "description": "Gets the size of the screen.  On systems with multiple displays, the\n primary display is used.  Multi-screen aware display dimensions are\n available from GraphicsConfiguration and\n GraphicsDevice."}, {"method_name": "getScreenResolution", "method_sig": "public abstract int getScreenResolution()\n                                 throws HeadlessException", "description": "Returns the screen resolution in dots-per-inch."}, {"method_name": "getScreenInsets", "method_sig": "public Insets getScreenInsets (GraphicsConfiguration gc)\n                       throws HeadlessException", "description": "Gets the insets of the screen."}, {"method_name": "getColorModel", "method_sig": "public abstract ColorModel getColorModel()\n                                  throws HeadlessException", "description": "Determines the color model of this toolkit's screen.\n \nColorModel is an abstract class that\n encapsulates the ability to translate between the\n pixel values of an image and its red, green, blue,\n and alpha components.\n \n This toolkit method is called by the\n getColorModel method\n of the Component class."}, {"method_name": "getFontList", "method_sig": "@Deprecated\npublic abstract String[] getFontList()", "description": "Returns the names of the available fonts in this toolkit.\n For 1.1, the following font names are deprecated (the replacement\n name follows):\n \nTimesRoman (use Serif)\n Helvetica (use SansSerif)\n Courier (use Monospaced)\n \n The ZapfDingbats fontname is also deprecated in 1.1 but the characters\n are defined in Unicode starting at 0x2700, and as of 1.1 Java supports\n those characters."}, {"method_name": "getFontMetrics", "method_sig": "@Deprecated\npublic abstract FontMetrics getFontMetrics (Font font)", "description": "Gets the screen device metrics for rendering of the font."}, {"method_name": "sync", "method_sig": "public abstract void sync()", "description": "Synchronizes this toolkit's graphics state. Some window systems\n may do buffering of graphics events.\n \n This method ensures that the display is up-to-date. It is useful\n for animation."}, {"method_name": "getDefaultToolkit", "method_sig": "public static Toolkit getDefaultToolkit()", "description": "Gets the default toolkit.\n \n If a system property named \"java.awt.headless\" is set\n to true then the headless implementation\n of Toolkit is used,\n otherwise the default platform-specific implementation of\n Toolkit is used.\n \n If this Toolkit is not a headless implementation and if they exist, service\n providers of AccessibilityProvider will be loaded\n if specified by the system property\n javax.accessibility.assistive_technologies.\n \n An example of setting this property is to invoke Java with\n -Djavax.accessibility.assistive_technologies=MyServiceProvider.\n In addition to MyServiceProvider other service providers can be specified\n using a comma separated list.  Service providers are loaded after the AWT\n toolkit is created. All errors are handled via an AWTError exception.\n \n The names specified in the assistive_technologies property are used to query\n each service provider implementation.  If the requested name matches the\n name of the service provider, the\n AccessibilityProvider.activate() method will be invoked to activate the\n matching service provider."}, {"method_name": "getImage", "method_sig": "public abstract Image getImage (String filename)", "description": "Returns an image which gets pixel data from the specified file,\n whose format can be either GIF, JPEG or PNG.\n The underlying toolkit attempts to resolve multiple requests\n with the same filename to the same returned Image.\n \n Since the mechanism required to facilitate this sharing of\n Image objects may continue to hold onto images\n that are no longer in use for an indefinite period of time,\n developers are encouraged to implement their own caching of\n images by using the createImage\n variant wherever available.\n If the image data contained in the specified file changes,\n the Image object returned from this method may\n still contain stale information which was loaded from the\n file after a prior call.\n Previously loaded image data can be manually discarded by\n calling the flush method on the\n returned Image.\n \n This method first checks if there is a security manager installed.\n If so, the method calls the security manager's\n checkRead method with the file specified to ensure\n that the access to the image is allowed."}, {"method_name": "getImage", "method_sig": "public abstract Image getImage (URL url)", "description": "Returns an image which gets pixel data from the specified URL.\n The pixel data referenced by the specified URL must be in one\n of the following formats: GIF, JPEG or PNG.\n The underlying toolkit attempts to resolve multiple requests\n with the same URL to the same returned Image.\n \n Since the mechanism required to facilitate this sharing of\n Image objects may continue to hold onto images\n that are no longer in use for an indefinite period of time,\n developers are encouraged to implement their own caching of\n images by using the createImage\n variant wherever available.\n If the image data stored at the specified URL changes,\n the Image object returned from this method may\n still contain stale information which was fetched from the\n URL after a prior call.\n Previously loaded image data can be manually discarded by\n calling the flush method on the\n returned Image.\n \n This method first checks if there is a security manager installed.\n If so, the method calls the security manager's\n checkPermission method with the corresponding\n permission to ensure that the access to the image is allowed.\n If the connection to the specified URL requires\n either URLPermission or SocketPermission,\n then URLPermission is used for security checks."}, {"method_name": "createImage", "method_sig": "public abstract Image createImage (String filename)", "description": "Returns an image which gets pixel data from the specified file.\n The returned Image is a new object which will not be shared\n with any other caller of this method or its getImage variant.\n \n This method first checks if there is a security manager installed.\n If so, the method calls the security manager's\n checkRead method with the specified file to ensure\n that the image creation is allowed."}, {"method_name": "createImage", "method_sig": "public abstract Image createImage (URL url)", "description": "Returns an image which gets pixel data from the specified URL.\n The returned Image is a new object which will not be shared\n with any other caller of this method or its getImage variant.\n \n This method first checks if there is a security manager installed.\n If so, the method calls the security manager's\n checkPermission method with the corresponding\n permission to ensure that the image creation is allowed.\n If the connection to the specified URL requires\n either URLPermission or SocketPermission,\n then URLPermission is used for security checks."}, {"method_name": "prepareImage", "method_sig": "public abstract boolean prepareImage (Image image,\n                                     int width,\n                                     int height,\n                                     ImageObserver observer)", "description": "Prepares an image for rendering.\n \n If the values of the width and height arguments are both\n -1, this method prepares the image for rendering\n on the default screen; otherwise, this method prepares an image\n for rendering on the default screen at the specified width and height.\n \n The image data is downloaded asynchronously in another thread,\n and an appropriately scaled screen representation of the image is\n generated.\n \n This method is called by components prepareImage\n methods.\n \n Information on the flags returned by this method can be found\n with the definition of the ImageObserver interface."}, {"method_name": "checkImage", "method_sig": "public abstract int checkImage (Image image,\n                               int width,\n                               int height,\n                               ImageObserver observer)", "description": "Indicates the construction status of a specified image that is\n being prepared for display.\n \n If the values of the width and height arguments are both\n -1, this method returns the construction status of\n a screen representation of the specified image in this toolkit.\n Otherwise, this method returns the construction status of a\n scaled representation of the image at the specified width\n and height.\n \n This method does not cause the image to begin loading.\n An application must call prepareImage to force\n the loading of an image.\n \n This method is called by the component's checkImage\n methods.\n \n Information on the flags returned by this method can be found\n with the definition of the ImageObserver interface."}, {"method_name": "createImage", "method_sig": "public abstract Image createImage (ImageProducer producer)", "description": "Creates an image with the specified image producer."}, {"method_name": "createImage", "method_sig": "public Image createImage (byte[] imagedata)", "description": "Creates an image which decodes the image stored in the specified\n byte array.\n \n The data must be in some image format, such as GIF or JPEG,\n that is supported by this toolkit."}, {"method_name": "createImage", "method_sig": "public abstract Image createImage (byte[] imagedata,\n                                  int imageoffset,\n                                  int imagelength)", "description": "Creates an image which decodes the image stored in the specified\n byte array, and at the specified offset and length.\n The data must be in some image format, such as GIF or JPEG,\n that is supported by this toolkit."}, {"method_name": "getPrintJob", "method_sig": "public abstract PrintJob getPrintJob (Frame frame,\n                                     String jobtitle,\n                                     Properties props)", "description": "Gets a PrintJob object which is the result of initiating\n a print operation on the toolkit's platform.\n \n Each actual implementation of this method should first check if there\n is a security manager installed. If there is, the method should call\n the security manager's checkPrintJobAccess method to\n ensure initiation of a print operation is allowed. If the default\n implementation of checkPrintJobAccess is used (that is,\n that method is not overriden), then this results in a call to the\n security manager's checkPermission method with a\n RuntimePermission(\"queuePrintJob\") permission."}, {"method_name": "getPrintJob", "method_sig": "public PrintJob getPrintJob (Frame frame,\n                            String jobtitle,\n                            JobAttributes jobAttributes,\n                            PageAttributes pageAttributes)", "description": "Gets a PrintJob object which is the result of initiating\n a print operation on the toolkit's platform.\n \n Each actual implementation of this method should first check if there\n is a security manager installed. If there is, the method should call\n the security manager's checkPrintJobAccess method to\n ensure initiation of a print operation is allowed. If the default\n implementation of checkPrintJobAccess is used (that is,\n that method is not overriden), then this results in a call to the\n security manager's checkPermission method with a\n RuntimePermission(\"queuePrintJob\") permission."}, {"method_name": "beep", "method_sig": "public abstract void beep()", "description": "Emits an audio beep depending on native system settings and hardware\n capabilities."}, {"method_name": "getSystemClipboard", "method_sig": "public abstract Clipboard getSystemClipboard()\n                                      throws HeadlessException", "description": "Gets the singleton instance of the system Clipboard which interfaces\n with clipboard facilities provided by the native platform. This\n clipboard enables data transfer between Java programs and native\n applications which use native clipboard facilities.\n \n In addition to any and all default formats text returned by the system\n Clipboard's getTransferData() method is available in the\n following flavors:\n \nDataFlavor.stringFlavor\nDataFlavor.plainTextFlavor (deprecated)\n\n As with java.awt.datatransfer.StringSelection, if the\n requested flavor is DataFlavor.plainTextFlavor, or an\n equivalent flavor, a Reader is returned. Note: The behavior of\n the system Clipboard's getTransferData() method for\n DataFlavor.plainTextFlavor, and equivalent DataFlavors, is\n inconsistent with the definition of DataFlavor.plainTextFlavor.\n Because of this, support for\n DataFlavor.plainTextFlavor, and equivalent flavors, is\n deprecated.\n \n Each actual implementation of this method should first check if there\n is a security manager installed. If there is, the method should call\n the security manager's checkPermission method to check AWTPermission(\"accessClipboard\")."}, {"method_name": "getSystemSelection", "method_sig": "public Clipboard getSystemSelection()\n                             throws HeadlessException", "description": "Gets the singleton instance of the system selection as a\n Clipboard object. This allows an application to read and\n modify the current, system-wide selection.\n \n An application is responsible for updating the system selection whenever\n the user selects text, using either the mouse or the keyboard.\n Typically, this is implemented by installing a\n FocusListener on all Components which support\n text selection, and, between FOCUS_GAINED and\n FOCUS_LOST events delivered to that Component,\n updating the system selection Clipboard when the selection\n changes inside the Component. Properly updating the system\n selection ensures that a Java application will interact correctly with\n native applications and other Java applications running simultaneously\n on the system. Note that java.awt.TextComponent and\n javax.swing.text.JTextComponent already adhere to this\n policy. When using these classes, and their subclasses, developers need\n not write any additional code.\n \n Some platforms do not support a system selection Clipboard.\n On those platforms, this method will return null. In such a\n case, an application is absolved from its responsibility to update the\n system selection Clipboard as described above.\n \n Each actual implementation of this method should first check if there\n is a security manager installed. If there is, the method should call\n the security manager's checkPermission method to check AWTPermission(\"accessClipboard\")."}, {"method_name": "getMenuShortcutKeyMask", "method_sig": "@Deprecated(since=\"10\")\npublic int getMenuShortcutKeyMask()\n                           throws HeadlessException", "description": "Determines which modifier key is the appropriate accelerator\n key for menu shortcuts.\n \n Menu shortcuts, which are embodied in the\n MenuShortcut class, are handled by the\n MenuBar class.\n \n By default, this method returns Event.CTRL_MASK.\n Toolkit implementations should override this method if the\n Control key isn't the correct key for accelerators."}, {"method_name": "getMenuShortcutKeyMaskEx", "method_sig": "public int getMenuShortcutKeyMaskEx()\n                             throws HeadlessException", "description": "Determines which extended modifier key is the appropriate accelerator\n key for menu shortcuts.\n \n Menu shortcuts, which are embodied in the MenuShortcut class, are\n handled by the MenuBar class.\n \n By default, this method returns InputEvent.CTRL_DOWN_MASK.\n Toolkit implementations should override this method if the\n Control key isn't the correct key for accelerators."}, {"method_name": "getLockingKeyState", "method_sig": "public boolean getLockingKeyState (int keyCode)\n                           throws UnsupportedOperationException", "description": "Returns whether the given locking key on the keyboard is currently in\n its \"on\" state.\n Valid key codes are\n VK_CAPS_LOCK,\n VK_NUM_LOCK,\n VK_SCROLL_LOCK, and\n VK_KANA_LOCK."}, {"method_name": "setLockingKeyState", "method_sig": "public void setLockingKeyState (int keyCode,\n                               boolean on)\n                        throws UnsupportedOperationException", "description": "Sets the state of the given locking key on the keyboard.\n Valid key codes are\n VK_CAPS_LOCK,\n VK_NUM_LOCK,\n VK_SCROLL_LOCK, and\n VK_KANA_LOCK.\n \n Depending on the platform, setting the state of a locking key may\n involve event processing and therefore may not be immediately\n observable through getLockingKeyState."}, {"method_name": "getNativeContainer", "method_sig": "protected static Container getNativeContainer (Component c)", "description": "Give native peers the ability to query the native container\n given a native component (eg the direct parent may be lightweight)."}, {"method_name": "createCustomCursor", "method_sig": "public Cursor createCustomCursor (Image cursor,\n                                 Point hotSpot,\n                                 String name)\n                          throws IndexOutOfBoundsException,\n                                 HeadlessException", "description": "Creates a new custom cursor object.\n If the image to display is invalid, the cursor will be hidden (made\n completely transparent), and the hotspot will be set to (0, 0).\n\n Note that multi-frame images are invalid and may cause this\n method to hang."}, {"method_name": "getBestCursorSize", "method_sig": "public Dimension getBestCursorSize (int preferredWidth,\n                                   int preferredHeight)\n                            throws HeadlessException", "description": "Returns the supported cursor dimension which is closest to the desired\n sizes.  Systems which only support a single cursor size will return that\n size regardless of the desired sizes.  Systems which don't support custom\n cursors will return a dimension of 0, 0. \n Note:  if an image is used whose dimensions don't match a supported size\n (as returned by this method), the Toolkit implementation will attempt to\n resize the image to a supported size.\n Since converting low-resolution images is difficult,\n no guarantees are made as to the quality of a cursor image which isn't a\n supported size.  It is therefore recommended that this method\n be called and an appropriate image used so no image conversion is made."}, {"method_name": "getMaximumCursorColors", "method_sig": "public int getMaximumCursorColors()\n                           throws HeadlessException", "description": "Returns the maximum number of colors the Toolkit supports in a custom cursor\n palette.\n Note: if an image is used which has more colors in its palette than\n the supported maximum, the Toolkit implementation will attempt to flatten the\n palette to the maximum.  Since converting low-resolution images is difficult,\n no guarantees are made as to the quality of a cursor image which has more\n colors than the system supports.  It is therefore recommended that this method\n be called and an appropriate image used so no image conversion is made."}, {"method_name": "isFrameStateSupported", "method_sig": "public boolean isFrameStateSupported (int state)\n                              throws HeadlessException", "description": "Returns whether Toolkit supports this state for\n Frames.  This method tells whether the UI\n concept of, say, maximization or iconification is\n supported.  It will always return false for \"compound\" states\n like Frame.ICONIFIED|Frame.MAXIMIZED_VERT.\n In other words, the rule of thumb is that only queries with a\n single frame state constant as an argument are meaningful.\n Note that supporting a given concept is a platform-\n dependent feature. Due to native limitations the Toolkit\n object may report a particular state as supported, however at\n the same time the Toolkit object will be unable to apply the\n state to a given frame.  This circumstance has two following\n consequences:\n \nOnly the return value of false for the present\n method actually indicates that the given state is not\n supported. If the method returns true the given state\n may still be unsupported and/or unavailable for a particular\n frame.\n The developer should consider examining the value of the\n WindowEvent.getNewState() method of the\n WindowEvent received through the WindowStateListener, rather than assuming\n that the state given to the setExtendedState() method\n will be definitely applied. For more information see the\n documentation for the Frame.setExtendedState(int) method.\n "}, {"method_name": "getProperty", "method_sig": "public static String getProperty (String key,\n                                 String defaultValue)", "description": "Gets a property with the specified key and default.\n This method returns defaultValue if the property is not found."}, {"method_name": "getSystemEventQueue", "method_sig": "public final EventQueue getSystemEventQueue()", "description": "Get the application's or applet's EventQueue instance.\n Depending on the Toolkit implementation, different EventQueues\n may be returned for different applets.  Applets should\n therefore not assume that the EventQueue instance returned\n by this method will be shared by other applets or the system.\n\n  If there is a security manager then its\n checkPermission method\n is called to check AWTPermission(\"accessEventQueue\")."}, {"method_name": "getSystemEventQueueImpl", "method_sig": "protected abstract EventQueue getSystemEventQueueImpl()", "description": "Gets the application's or applet's EventQueue\n instance, without checking access.  For security reasons,\n this can only be called from a Toolkit subclass."}, {"method_name": "createDragGestureRecognizer", "method_sig": "public <T extends DragGestureRecognizer> T createDragGestureRecognizer (Class<T> abstractRecognizerClass,\n                                                                       DragSource ds,\n                                                                       Component c,\n                                                                       int srcActions,\n                                                                       DragGestureListener dgl)", "description": "Creates a concrete, platform dependent, subclass of the abstract\n DragGestureRecognizer class requested, and associates it with the\n DragSource, Component and DragGestureListener specified.\n\n subclasses should override this to provide their own implementation"}, {"method_name": "getDesktopProperty", "method_sig": "public final Object getDesktopProperty (String propertyName)", "description": "Obtains a value for the specified desktop property.\n\n A desktop property is a uniquely named value for a resource that\n is Toolkit global in nature. Usually it also is an abstract\n representation for an underlying platform dependent desktop setting.\n For more information on desktop properties supported by the AWT see\n AWT Desktop Properties."}, {"method_name": "setDesktopProperty", "method_sig": "protected final void setDesktopProperty (String name,\n                                        Object newValue)", "description": "Sets the named desktop property to the specified value and fires a\n property change event to notify any listeners that the value has changed."}, {"method_name": "lazilyLoadDesktopProperty", "method_sig": "protected Object lazilyLoadDesktopProperty (String name)", "description": "An opportunity to lazily evaluate desktop property values."}, {"method_name": "initializeDesktopProperties", "method_sig": "protected void initializeDesktopProperties()", "description": "initializeDesktopProperties"}, {"method_name": "addPropertyChangeListener", "method_sig": "public void addPropertyChangeListener (String name,\n                                      PropertyChangeListener pcl)", "description": "Adds the specified property change listener for the named desktop\n property. When a PropertyChangeListenerProxy object is added,\n its property name is ignored, and the wrapped listener is added.\n If name is null or pcl is null,\n no exception is thrown and no action is performed."}, {"method_name": "removePropertyChangeListener", "method_sig": "public void removePropertyChangeListener (String name,\n                                         PropertyChangeListener pcl)", "description": "Removes the specified property change listener for the named\n desktop property. When a PropertyChangeListenerProxy object\n is removed, its property name is ignored, and\n the wrapped listener is removed.\n If name is null or pcl is null,\n no exception is thrown and no action is performed."}, {"method_name": "getPropertyChangeListeners", "method_sig": "public PropertyChangeListener[] getPropertyChangeListeners()", "description": "Returns an array of all the property change listeners\n registered on this toolkit. The returned array\n contains PropertyChangeListenerProxy objects\n that associate listeners with the names of desktop properties."}, {"method_name": "getPropertyChangeListeners", "method_sig": "public PropertyChangeListener[] getPropertyChangeListeners (String propertyName)", "description": "Returns an array of all property change listeners\n associated with the specified name of a desktop property."}, {"method_name": "isAlwaysOnTopSupported", "method_sig": "public boolean isAlwaysOnTopSupported()", "description": "Returns whether the always-on-top mode is supported by this toolkit.\n To detect whether the always-on-top mode is supported for a\n particular Window, use Window.isAlwaysOnTopSupported()."}, {"method_name": "isModalityTypeSupported", "method_sig": "public abstract boolean isModalityTypeSupported (Dialog.ModalityType modalityType)", "description": "Returns whether the given modality type is supported by this toolkit. If\n a dialog with unsupported modality type is created, then\n Dialog.ModalityType.MODELESS is used instead."}, {"method_name": "isModalExclusionTypeSupported", "method_sig": "public abstract boolean isModalExclusionTypeSupported (Dialog.ModalExclusionType modalExclusionType)", "description": "Returns whether the given modal exclusion type is supported by this\n toolkit. If an unsupported modal exclusion type property is set on a window,\n then Dialog.ModalExclusionType.NO_EXCLUDE is used instead."}, {"method_name": "addAWTEventListener", "method_sig": "public void addAWTEventListener (AWTEventListener listener,\n                                long eventMask)", "description": "Adds an AWTEventListener to receive all AWTEvents dispatched\n system-wide that conform to the given eventMask.\n \n First, if there is a security manager, its checkPermission\n method is called with an\n AWTPermission(\"listenToAllAWTEvents\") permission.\n This may result in a SecurityException.\n \neventMask is a bitmask of event types to receive.\n It is constructed by bitwise OR-ing together the event masks\n defined in AWTEvent.\n \n Note:  event listener use is not recommended for normal\n application use, but are intended solely to support special\n purpose facilities including support for accessibility,\n event record/playback, and diagnostic tracing.\n\n If listener is null, no exception is thrown and no action is performed."}, {"method_name": "removeAWTEventListener", "method_sig": "public void removeAWTEventListener (AWTEventListener listener)", "description": "Removes an AWTEventListener from receiving dispatched AWTEvents.\n \n First, if there is a security manager, its checkPermission\n method is called with an\n AWTPermission(\"listenToAllAWTEvents\") permission.\n This may result in a SecurityException.\n \n Note:  event listener use is not recommended for normal\n application use, but are intended solely to support special\n purpose facilities including support for accessibility,\n event record/playback, and diagnostic tracing.\n\n If listener is null, no exception is thrown and no action is performed."}, {"method_name": "getAWTEventListeners", "method_sig": "public AWTEventListener[] getAWTEventListeners()", "description": "Returns an array of all the AWTEventListeners\n registered on this toolkit.\n If there is a security manager, its checkPermission\n method is called with an\n AWTPermission(\"listenToAllAWTEvents\") permission.\n This may result in a SecurityException.\n Listeners can be returned\n within AWTEventListenerProxy objects, which also contain\n the event mask for the given listener.\n Note that listener objects\n added multiple times appear only once in the returned array."}, {"method_name": "getAWTEventListeners", "method_sig": "public AWTEventListener[] getAWTEventListeners (long eventMask)", "description": "Returns an array of all the AWTEventListeners\n registered on this toolkit which listen to all of the event\n types specified in the eventMask argument.\n If there is a security manager, its checkPermission\n method is called with an\n AWTPermission(\"listenToAllAWTEvents\") permission.\n This may result in a SecurityException.\n Listeners can be returned\n within AWTEventListenerProxy objects, which also contain\n the event mask for the given listener.\n Note that listener objects\n added multiple times appear only once in the returned array."}, {"method_name": "mapInputMethodHighlight", "method_sig": "public abstract Map<TextAttribute, ?> mapInputMethodHighlight (InputMethodHighlight highlight)\n                                                            throws HeadlessException", "description": "Returns a map of visual attributes for the abstract level description\n of the given input method highlight, or null if no mapping is found.\n The style field of the input method highlight is ignored. The map\n returned is unmodifiable."}, {"method_name": "areExtraMouseButtonsEnabled", "method_sig": "public boolean areExtraMouseButtonsEnabled()\n                                    throws HeadlessException", "description": "Reports whether events from extra mouse buttons are allowed to be processed and posted into\n EventQueue.\n \n To change the returned value it is necessary to set the sun.awt.enableExtraMouseButtons\n property before the Toolkit class initialization. This setting could be done on the application\n startup by the following command:\n \n java -Dsun.awt.enableExtraMouseButtons=false Application\n \n Alternatively, the property could be set in the application by using the following code:\n \n System.setProperty(\"sun.awt.enableExtraMouseButtons\", \"true\");\n \n before the Toolkit class initialization.\n If not set by the time of the Toolkit class initialization, this property will be\n initialized with true.\n Changing this value after the Toolkit class initialization will have no effect."}]}