{"name": "Class RMIClassLoader", "module": "java.rmi", "package": "java.rmi.server", "text": "RMIClassLoader comprises static methods to support\n dynamic class loading with RMI.  Included are methods for loading\n classes from a network location (one or more URLs) and obtaining\n the location from which an existing class should be loaded by\n remote parties.  These methods are used by the RMI runtime when\n marshalling and unmarshalling classes contained in the arguments\n and return values of remote method calls, and they also may be\n invoked directly by applications in order to mimic RMI's dynamic\n class loading behavior.\n\n The implementation of the following static methods\n\n \nloadClass(URL,String)\nloadClass(String,String)\nloadClass(String,String,ClassLoader)\nloadProxyClass(String,String[],ClassLoader)\ngetClassLoader(String)\ngetClassAnnotation(Class)\n\n\n is provided by an instance of RMIClassLoaderSpi, the\n service provider interface for those methods.  When one of the\n methods is invoked, its behavior is to delegate to a corresponding\n method on the service provider instance.  The details of how each\n method delegates to the provider instance is described in the\n documentation for each particular method.\n\n The service provider instance is chosen as follows:\n\n \nIf the system property\n java.rmi.server.RMIClassLoaderSpi is defined, then if\n its value equals the string \"default\", the provider\n instance will be the value returned by an invocation of the getDefaultProviderInstance() method, and for any other value, if\n a class named with the value of the property can be loaded by the\n system class loader (see ClassLoader.getSystemClassLoader())\n and that class is assignable to RMIClassLoaderSpi and has a\n public no-argument constructor, then that constructor will be\n invoked to create the provider instance.  If the property is\n defined but any other of those conditions are not true, then an\n unspecified Error will be thrown to code that attempts\n to use RMIClassLoader, indicating the failure to\n obtain a provider instance.\n\n If a resource named\n META-INF/services/java.rmi.server.RMIClassLoaderSpi is\n visible to the system class loader, then the contents of that\n resource are interpreted as a provider-configuration file, and the\n first class name specified in that file is used as the provider\n class name.  If a class with that name can be loaded by the system\n class loader and that class is assignable to RMIClassLoaderSpi and has a public no-argument constructor, then\n that constructor will be invoked to create the provider instance.\n If the resource is found but a provider cannot be instantiated as\n described, then an unspecified Error will be thrown to\n code that attempts to use RMIClassLoader, indicating\n the failure to obtain a provider instance.\n\n Otherwise, the provider instance will be the value returned by\n an invocation of the getDefaultProviderInstance() method.\n\n ", "codes": ["public class RMIClassLoader\nextends Object"], "fields": [], "methods": [{"method_name": "loadClass", "method_sig": "@Deprecated\npublic static Class<?> loadClass (String name)\n                          throws MalformedURLException,\n                                 ClassNotFoundException", "description": "Loads the class with the specified name.\n\n This method delegates to loadClass(String,String),\n passing null as the first argument and\n name as the second argument."}, {"method_name": "loadClass", "method_sig": "public static Class<?> loadClass (URL codebase,\n                                 String name)\n                          throws MalformedURLException,\n                                 ClassNotFoundException", "description": "Loads a class from a codebase URL.\n\n If codebase is null, then this method\n will behave the same as loadClass(String,String) with a\n null codebase and the given class name.\n\n This method delegates to the\n RMIClassLoaderSpi.loadClass(String,String,ClassLoader)\n method of the provider instance, passing the result of invoking\n URL.toString() on the given URL (or null if\n codebase is null) as the first argument,\n name as the second argument,\n and null as the third argument."}, {"method_name": "loadClass", "method_sig": "public static Class<?> loadClass (String codebase,\n                                 String name)\n                          throws MalformedURLException,\n                                 ClassNotFoundException", "description": "Loads a class from a codebase URL path.\n\n This method delegates to the\n RMIClassLoaderSpi.loadClass(String,String,ClassLoader)\n method of the provider instance, passing codebase\n as the first argument, name as the second argument,\n and null as the third argument."}, {"method_name": "loadClass", "method_sig": "public static Class<?> loadClass (String codebase,\n                                 String name,\n                                 ClassLoader defaultLoader)\n                          throws MalformedURLException,\n                                 ClassNotFoundException", "description": "Loads a class from a codebase URL path, optionally using the\n supplied loader.\n\n This method should be used when the caller would like to make\n available to the provider implementation an additional contextual\n class loader to consider, such as the loader of a caller on the\n stack.  Typically, a provider implementation will attempt to\n resolve the named class using the given defaultLoader,\n if specified, before attempting to resolve the class from the\n codebase URL path.\n\n This method delegates to the\n RMIClassLoaderSpi.loadClass(String,String,ClassLoader)\n method of the provider instance, passing codebase\n as the first argument, name as the second argument,\n and defaultLoader as the third argument."}, {"method_name": "loadProxyClass", "method_sig": "public static Class<?> loadProxyClass (String codebase,\n                                      String[] interfaces,\n                                      ClassLoader defaultLoader)\n                               throws ClassNotFoundException,\n                                      MalformedURLException", "description": "Loads a dynamic proxy class (see Proxy)\n that implements a set of interfaces with the given names\n from a codebase URL path.\n\n The interfaces will be resolved similar to classes loaded via\n the loadClass(String,String) method using the given\n codebase.\n\n This method delegates to the\n RMIClassLoaderSpi.loadProxyClass(String,String[],ClassLoader)\n method of the provider instance, passing codebase\n as the first argument, interfaces as the second argument,\n and defaultLoader as the third argument."}, {"method_name": "getClassLoader", "method_sig": "public static ClassLoader getClassLoader (String codebase)\n                                  throws MalformedURLException,\n                                         SecurityException", "description": "Returns a class loader that loads classes from the given codebase\n URL path.\n\n The class loader returned is the class loader that the\n loadClass(String,String) method would use to load classes\n for the same codebase argument.\n\n This method delegates to the\n RMIClassLoaderSpi.getClassLoader(String) method\n of the provider instance, passing codebase as the argument.\n\n If there is a security manger, its checkPermission\n method will be invoked with a\n RuntimePermission(\"getClassLoader\") permission;\n this could result in a SecurityException.\n The provider implementation of this method may also perform further\n security checks to verify that the calling context has permission to\n connect to all of the URLs in the codebase URL path."}, {"method_name": "getClassAnnotation", "method_sig": "public static String getClassAnnotation (Class<?> cl)", "description": "Returns the annotation string (representing a location for\n the class definition) that RMI will use to annotate the class\n descriptor when marshalling objects of the given class.\n\n This method delegates to the\n RMIClassLoaderSpi.getClassAnnotation(Class) method\n of the provider instance, passing cl as the argument."}, {"method_name": "getDefaultProviderInstance", "method_sig": "public static RMIClassLoaderSpi getDefaultProviderInstance()", "description": "Returns the canonical instance of the default provider\n for the service provider interface RMIClassLoaderSpi.\n If the system property java.rmi.server.RMIClassLoaderSpi\n is not defined, then the RMIClassLoader static\n methods\n\n \nloadClass(URL,String)\nloadClass(String,String)\nloadClass(String,String,ClassLoader)\nloadProxyClass(String,String[],ClassLoader)\ngetClassLoader(String)\ngetClassAnnotation(Class)\n\n\n will use the canonical instance of the default provider\n as the service provider instance.\n\n If there is a security manager, its\n checkPermission method will be invoked with a\n RuntimePermission(\"setFactory\") permission; this\n could result in a SecurityException.\n\n The default service provider instance implements\n RMIClassLoaderSpi as follows:\n\n \nThe getClassAnnotation method returns a String\n representing the codebase URL path that a remote party should\n use to download the definition for the specified class.  The\n format of the returned string is a path of URLs separated by\n spaces.\n\n The codebase string returned depends on the defining class\n loader of the specified class:\n\n \nIf the class loader is the system class loader (see\n ClassLoader.getSystemClassLoader()), a parent of the\n system class loader such as the loader used for installed\n extensions, or the bootstrap class loader (which may be\n represented by null), then the value of the\n java.rmi.server.codebase property (or possibly an\n earlier cached value) is returned, or\n null is returned if that property is not set.\n\n Otherwise, if the class loader is an instance of\n URLClassLoader, then the returned string is a\n space-separated list of the external forms of the URLs returned\n by invoking the getURLs methods of the loader.  If\n the URLClassLoader was created by this provider to\n service an invocation of its loadClass or\n loadProxyClass methods, then no permissions are\n required to get the associated codebase string.  If it is an\n arbitrary other URLClassLoader instance, then if\n there is a security manager, its checkPermission\n method will be invoked once for each URL returned by the\n getURLs method, with the permission returned by\n invoking openConnection().getPermission() on each\n URL; if any of those invocations throws a\n SecurityException or an IOException,\n then the value of the java.rmi.server.codebase\n property (or possibly an earlier cached value) is returned, or\n null is returned if that property is not set.\n\n Finally, if the class loader is not an instance of\n URLClassLoader, then the value of the\n java.rmi.server.codebase property (or possibly an\n earlier cached value) is returned, or\n null is returned if that property is not set.\n\n \nFor the implementations of the methods described below,\n which all take a String parameter named\n codebase that is a space-separated list of URLs,\n each invocation has an associated codebase loader that\n is identified using the codebase argument in\n conjunction with the current thread's context class loader (see\n Thread.getContextClassLoader()).  When there is a\n security manager, this provider maintains an internal table of\n class loader instances (which are at least instances of URLClassLoader) keyed by the pair of their parent\n class loader and their codebase URL path (an ordered list of\n URLs).  If the codebase argument is null,\n the codebase URL path is the value of the system property\n java.rmi.server.codebase or possibly an\n earlier cached value.  For a given codebase URL path passed as the\n codebase argument to an invocation of one of the\n below methods in a given context, the codebase loader is the\n loader in the table with the specified codebase URL path and\n the current thread's context class loader as its parent.  If no\n such loader exists, then one is created and added to the table.\n The table does not maintain strong references to its contained\n loaders, in order to allow them and their defined classes to be\n garbage collected when not otherwise reachable.  In order to\n prevent arbitrary untrusted code from being implicitly loaded\n into a virtual machine with no security manager, if there is no\n security manager set, the codebase loader is just the current\n thread's context class loader (the supplied codebase URL path\n is ignored, so remote class loading is disabled).\n\n The getClassLoader method returns the codebase loader for the\n specified codebase URL path.  If there is a security manager,\n then if the calling context does not have permission to connect\n to all of the URLs in the codebase URL path, a\n SecurityException will be thrown.\n\n The loadClass method attempts to load the class with the\n specified name as follows:\n\n \n\n If the defaultLoader argument is\n non-null, it first attempts to load the class with the\n specified name using the\n defaultLoader, such as by evaluating\n\n \n     Class.forName(name, false, defaultLoader)\n \n\n If the class is successfully loaded from the\n defaultLoader, that class is returned.  If an\n exception other than ClassNotFoundException is\n thrown, that exception is thrown to the caller.\n\n Next, the loadClass method attempts to load the\n class with the specified name using the codebase\n loader for the specified codebase URL path.\n If there is a security manager, then the calling context\n must have permission to connect to all of the URLs in the\n codebase URL path; otherwise, the current thread's context\n class loader will be used instead of the codebase loader.\n\n \nThe loadProxyClass method attempts to return a dynamic proxy\n class with the named interface as follows:\n\n \nIf the defaultLoader argument is\n non-null and all of the named interfaces can be\n resolved through that loader, then,\n\n \nif all of the resolved interfaces are public,\n then it first attempts to obtain a dynamic proxy class (using\n Proxy.getProxyClass) for the resolved interfaces defined in\n the codebase loader; if that attempt throws an\n IllegalArgumentException, it then attempts to\n obtain a dynamic proxy class for the resolved interfaces\n defined in the defaultLoader.  If both attempts\n throw IllegalArgumentException, then this method\n throws a ClassNotFoundException.  If any other\n exception is thrown, that exception is thrown to the caller.\n\n if all of the non-public resolved interfaces\n are defined in the same class loader, then it attempts to\n obtain a dynamic proxy class for the resolved interfaces\n defined in that loader.\n\n otherwise, a LinkageError is thrown (because a\n class that implements all of the specified interfaces cannot be\n defined in any loader).\n\n \nOtherwise, if all of the named interfaces can be resolved\n through the codebase loader, then,\n\n \nif all of the resolved interfaces are public,\n then it attempts to obtain a dynamic proxy class for the\n resolved interfaces in the codebase loader.  If the attempt\n throws an IllegalArgumentException, then this\n method throws a ClassNotFoundException.\n\n if all of the non-public resolved interfaces\n are defined in the same class loader, then it attempts to\n obtain a dynamic proxy class for the resolved interfaces\n defined in that loader.\n\n otherwise, a LinkageError is thrown (because a\n class that implements all of the specified interfaces cannot be\n defined in any loader).\n\n \nOtherwise, a ClassNotFoundException is thrown\n for one of the named interfaces that could not be resolved.\n\n \n"}, {"method_name": "getSecurityContext", "method_sig": "@Deprecated\npublic static Object getSecurityContext (ClassLoader loader)", "description": "Returns the security context of the given class loader."}]}