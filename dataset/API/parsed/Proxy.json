{"name": "Class Proxy", "module": "java.base", "package": "java.lang.reflect", "text": "Proxy provides static methods for creating objects that act like instances\n of interfaces but allow for customized method invocation.\n To create a proxy instance for some interface Foo:\n \n     InvocationHandler handler = new MyInvocationHandler(...);\n     Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),\n                                          new Class<?>[] { Foo.class },\n                                          handler);\n \n\n A proxy class is a class created at runtime that implements a specified\n list of interfaces, known as proxy interfaces. A proxy instance\n is an instance of a proxy class.\n\n Each proxy instance has an associated invocation handler\n object, which implements the interface InvocationHandler.\n A method invocation on a proxy instance through one of its proxy\n interfaces will be dispatched to the invoke method of the instance's invocation handler, passing the proxy\n instance, a java.lang.reflect.Method object identifying\n the method that was invoked, and an array of type Object\n containing the arguments.  The invocation handler processes the\n encoded method invocation as appropriate and the result that it\n returns will be returned as the result of the method invocation on\n the proxy instance.\n\n A proxy class has the following properties:\n\n \nThe unqualified name of a proxy class is unspecified.  The space\n of class names that begin with the string \"$Proxy\"\n should be, however, reserved for proxy classes.\n\n The package and module in which a proxy class is defined is specified\n below.\n\n A proxy class is final and non-abstract.\n\n A proxy class extends java.lang.reflect.Proxy.\n\n A proxy class implements exactly the interfaces specified at its\n creation, in the same order. Invoking getInterfaces\n on its Class object will return an array containing the same\n list of interfaces (in the order specified at its creation), invoking\n getMethods on its Class object will return\n an array of Method objects that include all of the\n methods in those interfaces, and invoking getMethod will\n find methods in the proxy interfaces as would be expected.\n\n The ProtectionDomain of a proxy class\n is the same as that of system classes loaded by the bootstrap class\n loader, such as java.lang.Object, because the code for a\n proxy class is generated by trusted system code.  This protection\n domain will typically be granted java.security.AllPermission.\n\n The Proxy.isProxyClass method can be used\n to determine if a given class is a proxy class.\n \nA proxy instance has the following properties:\n\n \nGiven a proxy instance proxy and one of the\n interfaces, Foo, implemented by its proxy class, the\n following expression will return true:\n \n     proxy instanceof Foo\n \n and the following cast operation will succeed (rather than throwing\n a ClassCastException):\n \n     (Foo) proxy\n \nEach proxy instance has an associated invocation handler, the one\n that was passed to its constructor.  The static\n Proxy.getInvocationHandler method\n will return the invocation handler associated with the proxy instance\n passed as its argument.\n\n An interface method invocation on a proxy instance will be\n encoded and dispatched to the invocation handler's invoke method as described in the\n documentation for that method.\n\n An invocation of the hashCode,\n equals, or toString methods declared in\n java.lang.Object on a proxy instance will be encoded and\n dispatched to the invocation handler's invoke method in\n the same manner as interface method invocations are encoded and\n dispatched, as described above.  The declaring class of the\n Method object passed to invoke will be\n java.lang.Object.  Other public methods of a proxy\n instance inherited from java.lang.Object are not\n overridden by a proxy class, so invocations of those methods behave\n like they do for instances of java.lang.Object.\n \nPackage and Module Membership of Proxy Class\n\n The package and module to which a proxy class belongs are chosen such that\n the accessibility of the proxy class is in line with the accessibility of\n the proxy interfaces. Specifically, the package and the module membership\n of a proxy class defined via the\n getProxyClass(ClassLoader, Class[]) or\n newProxyInstance(ClassLoader, Class[], InvocationHandler)\n methods is specified as follows:\n\n \nIf all the proxy interfaces are in exported or open\n     packages:\n \nif all the proxy interfaces are public, then the proxy class is\n     public in a package exported by the\n     unnamed module of the specified\n     loader. The name of the package is unspecified.\nif at least one of all the proxy interfaces is non-public, then\n     the proxy class is non-public in the package and module of the\n     non-public interfaces. All the non-public interfaces must be in the same\n     package and module; otherwise, proxying them is\n     not possible.\n\n\nIf at least one proxy interface is in a package that is\n     non-exported and non-open:\n \nif all the proxy interfaces are public, then the proxy class is\n     public in a non-exported, non-open package of\n     dynamic module.\n     The names of the package and the module are unspecified.\nif at least one of all the proxy interfaces is non-public, then\n     the proxy class is non-public in the package and module of the\n     non-public interfaces. All the non-public interfaces must be in the same\n     package and module; otherwise, proxying them is\n     not possible.\n\n\n\n\n Note that if proxy interfaces with a mix of accessibilities -- for example,\n an exported public interface and a non-exported non-public interface -- are\n proxied by the same instance, then the proxy class's accessibility is\n governed by the least accessible proxy interface.\n \n Note that it is possible for arbitrary code to obtain access to a proxy class\n in an open package with setAccessible,\n whereas a proxy class in a non-open package is never accessible to\n code outside the module of the proxy class.\n\n \n Throughout this specification, a \"non-exported package\" refers to a package\n that is not exported to all modules, and a \"non-open package\" refers to\n a package that is not open to all modules.  Specifically, these terms refer to\n a package that either is not exported/open by its containing module or is\n exported/open in a qualified fashion by its containing module.\n\n Dynamic Modules\n\n A dynamic module is a named module generated at runtime. A proxy class\n defined in a dynamic module is encapsulated and not accessible to any module.\n Calling Constructor.newInstance(Object...) on a proxy class in\n a dynamic module will throw IllegalAccessException;\n Proxy.newProxyInstance method should be used instead.\n\n \n A dynamic module can read the modules of all of the superinterfaces of a proxy\n class and the modules of the types referenced by all public method signatures\n of a proxy class.  If a superinterface or a referenced type, say T,\n is in a non-exported package, the module of T is\n updated to export the package of T to the dynamic module.\n\n Methods Duplicated in Multiple Proxy Interfaces\nWhen two or more proxy interfaces contain a method with\n the same name and parameter signature, the order of the proxy class's\n interfaces becomes significant.  When such a duplicate method\n is invoked on a proxy instance, the Method object passed\n to the invocation handler will not necessarily be the one whose\n declaring class is assignable from the reference type of the interface\n that the proxy's method was invoked through.  This limitation exists\n because the corresponding method implementation in the generated proxy\n class cannot determine which interface it was invoked through.\n Therefore, when a duplicate method is invoked on a proxy instance,\n the Method object for the method in the foremost interface\n that contains the method (either directly or inherited through a\n superinterface) in the proxy class's list of interfaces is passed to\n the invocation handler's invoke method, regardless of the\n reference type through which the method invocation occurred.\n\n If a proxy interface contains a method with the same name and\n parameter signature as the hashCode, equals,\n or toString methods of java.lang.Object,\n when such a method is invoked on a proxy instance, the\n Method object passed to the invocation handler will have\n java.lang.Object as its declaring class.  In other words,\n the public, non-final methods of java.lang.Object\n logically precede all of the proxy interfaces for the determination of\n which Method object to pass to the invocation handler.\n\n Note also that when a duplicate method is dispatched to an\n invocation handler, the invoke method may only throw\n checked exception types that are assignable to one of the exception\n types in the throws clause of the method in all of\n the proxy interfaces that it can be invoked through.  If the\n invoke method throws a checked exception that is not\n assignable to any of the exception types declared by the method in one\n of the proxy interfaces that it can be invoked through, then an\n unchecked UndeclaredThrowableException will be thrown by\n the invocation on the proxy instance.  This restriction means that not\n all of the exception types returned by invoking\n getExceptionTypes on the Method object\n passed to the invoke method can necessarily be thrown\n successfully by the invoke method.", "codes": ["public class Proxy\nextends Object\nimplements Serializable"], "fields": [{"field_name": "h", "field_sig": "protected\u00a0InvocationHandler h", "description": "the invocation handler for this proxy instance."}], "methods": [{"method_name": "getProxyClass", "method_sig": "@Deprecated\npublic static Class<?> getProxyClass (ClassLoader loader,\n                                     Class<?>... interfaces)\n                              throws IllegalArgumentException", "description": "Returns the java.lang.Class object for a proxy class\n given a class loader and an array of interfaces.  The proxy class\n will be defined by the specified class loader and will implement\n all of the supplied interfaces.  If any of the given interfaces\n is non-public, the proxy class will be non-public. If a proxy class\n for the same permutation of interfaces has already been defined by the\n class loader, then the existing proxy class will be returned; otherwise,\n a proxy class for those interfaces will be generated dynamically\n and defined by the class loader."}, {"method_name": "newProxyInstance", "method_sig": "public static Object newProxyInstance (ClassLoader loader,\n                                      Class<?>[] interfaces,\n                                      InvocationHandler h)", "description": "Returns a proxy instance for the specified interfaces\n that dispatches method invocations to the specified invocation\n handler.\n \nIllegalArgumentException will be thrown\n if any of the following restrictions is violated:\n\nAll of Class objects in the given interfaces array\n must represent interfaces, not classes or primitive types.\n\n No two elements in the interfaces array may\n refer to identical Class objects.\n\n All of the interface types must be visible by name through the\n specified class loader. In other words, for class loader\n cl and every interface i, the following\n expression must be true:\nClass.forName(i.getName(), false, cl) == i\nAll of the types referenced by all\n public method signatures of the specified interfaces\n and those inherited by their superinterfaces\n must be visible by name through the specified class loader.\n\n All non-public interfaces must be in the same package\n and module, defined by the specified class loader and\n the module of the non-public interfaces can access all of\n the interface types; otherwise, it would not be possible for\n the proxy class to implement all of the interfaces,\n regardless of what package it is defined in.\n\n For any set of member methods of the specified interfaces\n that have the same signature:\n \nIf the return type of any of the methods is a primitive\n type or void, then all of the methods must have that same\n return type.\n Otherwise, one of the methods must have a return type that\n is assignable to all of the return types of the rest of the\n methods.\n \nThe resulting proxy class must not exceed any limits imposed\n on classes by the virtual machine.  For example, the VM may limit\n the number of interfaces that a class may implement to 65535; in\n that case, the size of the interfaces array must not\n exceed 65535.\n \nNote that the order of the specified proxy interfaces is\n significant: two requests for a proxy class with the same combination\n of interfaces but in a different order will result in two distinct\n proxy classes."}, {"method_name": "isProxyClass", "method_sig": "public static boolean isProxyClass (Class<?> cl)", "description": "Returns true if the given class is a proxy class."}, {"method_name": "getInvocationHandler", "method_sig": "public static InvocationHandler getInvocationHandler (Object proxy)\n                                              throws IllegalArgumentException", "description": "Returns the invocation handler for the specified proxy instance."}]}