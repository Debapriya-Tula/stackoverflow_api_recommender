{"name": "Interface CompositeDataView", "module": "java.management", "package": "javax.management.openmbean", "text": "A Java class can implement this interface to indicate how it is\n to be converted into a CompositeData by the MXBean framework.\nA typical way to use this class is to add extra items to the\n CompositeData in addition to the ones that are declared in the\n CompositeType supplied by the MXBean framework.  To do this,\n you must create another CompositeType that has all the same items,\n plus your extra items.\nFor example, suppose you have a class Measure that consists of\n a String called units and a value that is either a\n long or a double.  It might look like this:\n\n public class Measure implements CompositeDataView {\n     private String units;\n     private Number value; // a Long or a Double\n\n     public Measure(String units, Number value) {\n         this.units = units;\n         this.value = value;\n     }\n\n     public static Measure from(CompositeData cd) {\n         return new Measure((String) cd.get(\"units\"),\n                            (Number) cd.get(\"value\"));\n     }\n\n     public String getUnits() {\n         return units;\n     }\n\n     // Can't be called getValue(), because Number is not a valid type\n     // in an MXBean, so the implied \"value\" property would be rejected.\n     public Number _getValue() {\n         return value;\n     }\n\n     public CompositeData toCompositeData(CompositeType ct) {\n         try {\n             List<String> itemNames = new ArrayList<String>(ct.keySet());\n             List<String> itemDescriptions = new ArrayList<String>();\n             List<OpenType<?>> itemTypes = new ArrayList<OpenType<?>>();\n             for (String item : itemNames) {\n                 itemDescriptions.add(ct.getDescription(item));\n                 itemTypes.add(ct.getType(item));\n             }\n             itemNames.add(\"value\");\n             itemDescriptions.add(\"long or double value of the measure\");\n             itemTypes.add((value instanceof Long) ? SimpleType.LONG :\n                           SimpleType.DOUBLE);\n             CompositeType xct =\n                 new CompositeType(ct.getTypeName(),\n                                   ct.getDescription(),\n                                   itemNames.toArray(new String[0]),\n                                   itemDescriptions.toArray(new String[0]),\n                                   itemTypes.toArray(new OpenType<?>[0]));\n             CompositeData cd =\n                 new CompositeDataSupport(xct,\n                                          new String[] {\"units\", \"value\"},\n                                          new Object[] {units, value});\n             assert ct.isValue(cd);  // check we've done it right\n             return cd;\n         } catch (Exception e) {\n             throw new RuntimeException(e);\n         }\n     }\n }\n \nThe CompositeType that will appear in the openType field\n of the Descriptor for an attribute or\n operation of this type will show only the units item, but the actual\n CompositeData that is generated will have both units and\n value.", "codes": ["public interface CompositeDataView"], "fields": [], "methods": [{"method_name": "toCompositeData", "method_sig": "CompositeData toCompositeData (CompositeType ct)", "description": "Return a CompositeData corresponding to the values in\n this object.  The returned value should usually be an instance of\n CompositeDataSupport, or a class that serializes as a\n CompositeDataSupport via a writeReplace method.\n Otherwise, a remote client that receives the object might not be\n able to reconstruct it."}]}