{"name": "Interface TypeInfo", "module": "java.xml", "package": "org.w3c.dom", "text": "The TypeInfo interface represents a type referenced from\n Element or Attr nodes, specified in the schemas\n associated with the document. The type is a pair of a namespace URI and\n name properties, and depends on the document's schema.\n  If the document's schema is an XML DTD [XML 1.0], the values\n are computed as follows:\n \n If this type is referenced from an\n Attr node, typeNamespace is\n \"http://www.w3.org/TR/REC-xml\" and typeName\n represents the [attribute type] property in the [XML Information Set]\n . If there is no declaration for the attribute, typeNamespace\n  and typeName are null.\n \n If this type is\n referenced from an Element node, typeNamespace\n and typeName are null.\n \n\n If the document's schema is an XML Schema [XML Schema Part 1]\n , the values are computed as follows using the post-schema-validation\n infoset contributions (also called PSVI contributions):\n \n If the [validity] property exists AND is \"invalid\" or \"notKnown\": the {target namespace} and {name} properties of the declared type if\n available, otherwise null.\n Note:  At the time of writing, the XML Schema specification does\n not require exposing the declared type. Thus, DOM implementations might\n choose not to provide type information if validity is not valid.\n \n If the [validity] property exists and is \"valid\":\n \n If [member type definition] exists:\n \nIf {name} is not absent, then expose {name} and {target\n namespace} properties of the [member type definition] property;\n \nOtherwise, expose the namespace and local name of the\n corresponding anonymous type name.\n \n\n\n If the [type definition] property exists:\n \nIf {name} is not absent, then expose {name} and {target\n namespace} properties of the [type definition] property;\n \nOtherwise, expose the namespace and local name of the\n corresponding anonymous type name.\n \n\n\n If the [member type definition anonymous] exists:\n \nIf it is false, then expose [member type definition name] and [member type definition namespace] properties;\n \nOtherwise, expose the namespace and local name of the\n corresponding anonymous type name.\n \n\n\n If the [type definition anonymous] exists:\n \nIf it is false, then expose [type definition name] and [type definition namespace] properties;\n \nOtherwise, expose the namespace and local name of the\n corresponding anonymous type name.\n \n\n\n\n\n\nNote:  Other schema languages are outside the scope of the W3C\n and therefore should define how to represent their type systems using\n TypeInfo.\n See also the Document Object Model (DOM) Level 3 Core Specification.", "codes": ["public interface TypeInfo"], "fields": [{"field_name": "DERIVATION_RESTRICTION", "field_sig": "static final\u00a0int DERIVATION_RESTRICTION", "description": "If the document's schema is an XML Schema [XML Schema Part 1]\n , this constant represents the derivation by \n restriction if complex types are involved, or a \n restriction if simple types are involved.\n   The reference type definition is derived by restriction from the\n other type definition if the other type definition is the same as the\n reference type definition, or if the other type definition can be\n reached recursively following the {base type definition} property\n from the reference type definition, and all the derivation methods involved are restriction."}, {"field_name": "DERIVATION_EXTENSION", "field_sig": "static final\u00a0int DERIVATION_EXTENSION", "description": "If the document's schema is an XML Schema [XML Schema Part 1]\n , this constant represents the derivation by \n extension.\n   The reference type definition is derived by extension from the\n other type definition if the other type definition can be reached\n recursively following the {base type definition} property from the\n reference type definition, and at least one of the derivation methods involved is an extension."}, {"field_name": "DERIVATION_UNION", "field_sig": "static final\u00a0int DERIVATION_UNION", "description": "If the document's schema is an XML Schema [XML Schema Part 1]\n , this constant represents the \n union if simple types are involved.\n  The reference type definition is derived by union from the other\n type definition if there exists two type definitions T1 and T2 such\n as the reference type definition is derived from T1 by\n DERIVATION_RESTRICTION or\n DERIVATION_EXTENSION, T2 is derived from the other type\n definition by DERIVATION_RESTRICTION, T1 has {variety} union, and one of the {member type definitions} is T2. Note that T1 could be\n the same as the reference type definition, and T2 could be the same\n as the other type definition."}, {"field_name": "DERIVATION_LIST", "field_sig": "static final\u00a0int DERIVATION_LIST", "description": "If the document's schema is an XML Schema [XML Schema Part 1]\n , this constant represents the list.\n  The reference type definition is derived by list from the other\n type definition if there exists two type definitions T1 and T2 such\n as the reference type definition is derived from T1 by\n DERIVATION_RESTRICTION or\n DERIVATION_EXTENSION, T2 is derived from the other type\n definition by DERIVATION_RESTRICTION, T1 has {variety} list, and T2 is the {item type definition}. Note that T1 could be the same as\n the reference type definition, and T2 could be the same as the other\n type definition."}], "methods": [{"method_name": "getTypeName", "method_sig": "String getTypeName()", "description": "The name of a type declared for the associated element or attribute,\n or null if unknown."}, {"method_name": "getTypeNamespace", "method_sig": "String getTypeNamespace()", "description": "The namespace of the type declared for the associated element or\n attribute or null if the element does not have\n declaration or if no namespace information is available."}, {"method_name": "isDerivedFrom", "method_sig": "boolean isDerivedFrom (String typeNamespaceArg,\n                      String typeNameArg,\n                      int derivationMethod)", "description": "This method returns if there is a derivation between the reference\n type definition, i.e. the TypeInfo on which the method\n is being called, and the other type definition, i.e. the one passed\n as parameters."}]}