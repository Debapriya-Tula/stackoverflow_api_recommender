{"name": "Interface Spliterator<T>", "module": "java.base", "package": "java.util", "text": "An object for traversing and partitioning elements of a source.  The source\n of elements covered by a Spliterator could be, for example, an array, a\n Collection, an IO channel, or a generator function.\n\n A Spliterator may traverse elements individually (tryAdvance()) or sequentially in bulk\n (forEachRemaining()).\n\n A Spliterator may also partition off some of its elements (using\n trySplit()) as another Spliterator, to be used in\n possibly-parallel operations.  Operations using a Spliterator that\n cannot split, or does so in a highly imbalanced or inefficient\n manner, are unlikely to benefit from parallelism.  Traversal\n and splitting exhaust elements; each Spliterator is useful for only a single\n bulk computation.\n\n A Spliterator also reports a set of characteristics() of its\n structure, source, and elements from among ORDERED,\n DISTINCT, SORTED, SIZED, NONNULL,\n IMMUTABLE, CONCURRENT, and SUBSIZED. These may\n be employed by Spliterator clients to control, specialize or simplify\n computation.  For example, a Spliterator for a Collection would\n report SIZED, a Spliterator for a Set would report\n DISTINCT, and a Spliterator for a SortedSet would also\n report SORTED.  Characteristics are reported as a simple unioned bit\n set.\n\n Some characteristics additionally constrain method behavior; for example if\n ORDERED, traversal methods must conform to their documented ordering.\n New characteristics may be defined in the future, so implementors should not\n assign meanings to unlisted values.\n\n A Spliterator that does not report IMMUTABLE or\n CONCURRENT is expected to have a documented policy concerning:\n when the spliterator binds to the element source; and detection of\n structural interference of the element source detected after binding.  A\n late-binding Spliterator binds to the source of elements at the\n point of first traversal, first split, or first query for estimated size,\n rather than at the time the Spliterator is created.  A Spliterator that is\n not late-binding binds to the source of elements at the point of\n construction or first invocation of any method.  Modifications made to the\n source prior to binding are reflected when the Spliterator is traversed.\n After binding a Spliterator should, on a best-effort basis, throw\n ConcurrentModificationException if structural interference is\n detected.  Spliterators that do this are called fail-fast.  The\n bulk traversal method (forEachRemaining()) of a\n Spliterator may optimize traversal and check for structural interference\n after all elements have been traversed, rather than checking per-element and\n failing immediately.\n\n Spliterators can provide an estimate of the number of remaining elements\n via the estimateSize() method.  Ideally, as reflected in characteristic\n SIZED, this value corresponds exactly to the number of elements\n that would be encountered in a successful traversal.  However, even when not\n exactly known, an estimated value may still be useful to operations\n being performed on the source, such as helping to determine whether it is\n preferable to split further or traverse the remaining elements sequentially.\n\n Despite their obvious utility in parallel algorithms, spliterators are not\n expected to be thread-safe; instead, implementations of parallel algorithms\n using spliterators should ensure that the spliterator is only used by one\n thread at a time.  This is generally easy to attain via serial\n thread-confinement, which often is a natural consequence of typical\n parallel algorithms that work by recursive decomposition.  A thread calling\n trySplit() may hand over the returned Spliterator to another thread,\n which in turn may traverse or further split that Spliterator.  The behaviour\n of splitting and traversal is undefined if two or more threads operate\n concurrently on the same spliterator.  If the original thread hands a\n spliterator off to another thread for processing, it is best if that handoff\n occurs before any elements are consumed with tryAdvance(), as certain guarantees (such as the accuracy of\n estimateSize() for SIZED spliterators) are only valid before\n traversal has begun.\n\n Primitive subtype specializations of Spliterator are provided for\n int, long, and double values.\n The subtype default implementations of\n tryAdvance(java.util.function.Consumer)\n and forEachRemaining(java.util.function.Consumer) box\n primitive values to instances of their corresponding wrapper class.  Such\n boxing may undermine any performance advantages gained by using the primitive\n specializations.  To avoid boxing, the corresponding primitive-based methods\n should be used.  For example,\n Spliterator.OfPrimitive.tryAdvance(java.util.function.IntConsumer)\n and Spliterator.OfPrimitive.forEachRemaining(java.util.function.IntConsumer)\n should be used in preference to\n Spliterator.OfInt.tryAdvance(java.util.function.Consumer) and\n Spliterator.OfInt.forEachRemaining(java.util.function.Consumer).\n Traversal of primitive values using boxing-based methods\n tryAdvance() and\n forEachRemaining()\n does not affect the order in which the values, transformed to boxed values,\n are encountered.", "codes": ["public interface Spliterator<T>"], "fields": [{"field_name": "ORDERED", "field_sig": "static final\u00a0int ORDERED", "description": "Characteristic value signifying that an encounter order is defined for\n elements. If so, this Spliterator guarantees that method\n trySplit() splits a strict prefix of elements, that method\n tryAdvance(java.util.function.Consumer<? super T>) steps by one element in prefix order, and that\n forEachRemaining(java.util.function.Consumer<? super T>) performs actions in encounter order.\n\n A Collection has an encounter order if the corresponding\n Collection.iterator() documents an order. If so, the encounter\n order is the same as the documented order. Otherwise, a collection does\n not have an encounter order."}, {"field_name": "DISTINCT", "field_sig": "static final\u00a0int DISTINCT", "description": "Characteristic value signifying that, for each pair of\n encountered elements x, y, !x.equals(y). This\n applies for example, to a Spliterator based on a Set."}, {"field_name": "SORTED", "field_sig": "static final\u00a0int SORTED", "description": "Characteristic value signifying that encounter order follows a defined\n sort order. If so, method getComparator() returns the associated\n Comparator, or null if all elements are Comparable and\n are sorted by their natural ordering.\n\n A Spliterator that reports SORTED must also report\n ORDERED."}, {"field_name": "SIZED", "field_sig": "static final\u00a0int SIZED", "description": "Characteristic value signifying that the value returned from\n estimateSize() prior to traversal or splitting represents a\n finite size that, in the absence of structural source modification,\n represents an exact count of the number of elements that would be\n encountered by a complete traversal."}, {"field_name": "NONNULL", "field_sig": "static final\u00a0int NONNULL", "description": "Characteristic value signifying that the source guarantees that\n encountered elements will not be null. (This applies,\n for example, to most concurrent collections, queues, and maps.)"}, {"field_name": "IMMUTABLE", "field_sig": "static final\u00a0int IMMUTABLE", "description": "Characteristic value signifying that the element source cannot be\n structurally modified; that is, elements cannot be added, replaced, or\n removed, so such changes cannot occur during traversal. A Spliterator\n that does not report IMMUTABLE or CONCURRENT is expected\n to have a documented policy (for example throwing\n ConcurrentModificationException) concerning structural\n interference detected during traversal."}, {"field_name": "CONCURRENT", "field_sig": "static final\u00a0int CONCURRENT", "description": "Characteristic value signifying that the element source may be safely\n concurrently modified (allowing additions, replacements, and/or removals)\n by multiple threads without external synchronization. If so, the\n Spliterator is expected to have a documented policy concerning the impact\n of modifications during traversal.\n\n A top-level Spliterator should not report both CONCURRENT and\n SIZED, since the finite size, if known, may change if the source\n is concurrently modified during traversal. Such a Spliterator is\n inconsistent and no guarantees can be made about any computation using\n that Spliterator. Sub-spliterators may report SIZED if the\n sub-split size is known and additions or removals to the source are not\n reflected when traversing.\n\n A top-level Spliterator should not report both CONCURRENT and\n IMMUTABLE, since they are mutually exclusive. Such a Spliterator\n is inconsistent and no guarantees can be made about any computation using\n that Spliterator. Sub-spliterators may report IMMUTABLE if\n additions or removals to the source are not reflected when traversing."}, {"field_name": "SUBSIZED", "field_sig": "static final\u00a0int SUBSIZED", "description": "Characteristic value signifying that all Spliterators resulting from\n trySplit() will be both SIZED and SUBSIZED.\n (This means that all child Spliterators, whether direct or indirect, will\n be SIZED.)\n\n A Spliterator that does not report SIZED as required by\n SUBSIZED is inconsistent and no guarantees can be made about any\n computation using that Spliterator."}], "methods": [{"method_name": "tryAdvance", "method_sig": "boolean tryAdvance (Consumer<? super T> action)", "description": "If a remaining element exists, performs the given action on it,\n returning true; else returns false.  If this\n Spliterator is ORDERED the action is performed on the\n next element in encounter order.  Exceptions thrown by the\n action are relayed to the caller."}, {"method_name": "forEachRemaining", "method_sig": "default void forEachRemaining (Consumer<? super T> action)", "description": "Performs the given action for each remaining element, sequentially in\n the current thread, until all elements have been processed or the action\n throws an exception.  If this Spliterator is ORDERED, actions\n are performed in encounter order.  Exceptions thrown by the action\n are relayed to the caller."}, {"method_name": "trySplit", "method_sig": "Spliterator<T> trySplit()", "description": "If this spliterator can be partitioned, returns a Spliterator\n covering elements, that will, upon return from this method, not\n be covered by this Spliterator.\n\n If this Spliterator is ORDERED, the returned Spliterator\n must cover a strict prefix of the elements.\n\n Unless this Spliterator covers an infinite number of elements,\n repeated calls to trySplit() must eventually return null.\n Upon non-null return:\n \nthe value reported for estimateSize() before splitting,\n must, after splitting, be greater than or equal to estimateSize()\n for this and the returned Spliterator; and\nif this Spliterator is SUBSIZED, then estimateSize()\n for this spliterator before splitting must be equal to the sum of\n estimateSize() for this and the returned Spliterator after\n splitting.\n\nThis method may return null for any reason,\n including emptiness, inability to split after traversal has\n commenced, data structure constraints, and efficiency\n considerations."}, {"method_name": "estimateSize", "method_sig": "long estimateSize()", "description": "Returns an estimate of the number of elements that would be\n encountered by a forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute.\n\n If this Spliterator is SIZED and has not yet been partially\n traversed or split, or this Spliterator is SUBSIZED and has\n not yet been partially traversed, this estimate must be an accurate\n count of elements that would be encountered by a complete traversal.\n Otherwise, this estimate may be arbitrarily inaccurate, but must decrease\n as specified across invocations of trySplit()."}, {"method_name": "getExactSizeIfKnown", "method_sig": "default long getExactSizeIfKnown()", "description": "Convenience method that returns estimateSize() if this\n Spliterator is SIZED, else -1."}, {"method_name": "characteristics", "method_sig": "int characteristics()", "description": "Returns a set of characteristics of this Spliterator and its\n elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED,\n NONNULL, IMMUTABLE, CONCURRENT,\n SUBSIZED.  Repeated calls to characteristics() on\n a given spliterator, prior to or in-between calls to trySplit,\n should always return the same result.\n\n If a Spliterator reports an inconsistent set of\n characteristics (either those returned from a single invocation\n or across multiple invocations), no guarantees can be made\n about any computation using this Spliterator."}, {"method_name": "hasCharacteristics", "method_sig": "default boolean hasCharacteristics (int characteristics)", "description": "Returns true if this Spliterator's characteristics() contain all of the given characteristics."}, {"method_name": "getComparator", "method_sig": "default Comparator<? super T> getComparator()", "description": "If this Spliterator's source is SORTED by a Comparator,\n returns that Comparator. If the source is SORTED in\n natural order, returns null.  Otherwise,\n if the source is not SORTED, throws IllegalStateException."}]}