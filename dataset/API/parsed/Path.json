{"name": "Interface Path", "module": "java.base", "package": "java.nio.file", "text": "An object that may be used to locate a file in a file system. It will\n typically represent a system dependent file path.\n\n  A Path represents a path that is hierarchical and composed of a\n sequence of directory and file name elements separated by a special separator\n or delimiter. A root component, that identifies a file system\n hierarchy, may also be present. The name element that is farthest\n from the root of the directory hierarchy is the name of a file or directory.\n The other name elements are directory names. A Path can represent a\n root, a root and a sequence of names, or simply one or more name elements.\n A Path is considered to be an empty path if it consists\n solely of one name element that is empty. Accessing a file using an\n empty path is equivalent to accessing the default directory of the\n file system. Path defines the getFileName,\n getParent, getRoot, and subpath methods to access the path components or a subsequence of its name\n elements.\n\n  In addition to accessing the components of a path, a Path also\n defines the resolve and resolveSibling methods to combine paths. The relativize\n method that can be used to construct a relative path between two paths.\n Paths can be compared, and tested against each other using\n the startsWith and endsWith methods.\n\n  This interface extends Watchable interface so that a directory\n located by a path can be registered with a WatchService and entries in the directory watched. \n WARNING: This interface is only intended to be implemented by\n those developing custom file system implementations. Methods may be added to\n this interface in future releases. \nAccessing Files\n Paths may be used with the Files class to operate on files,\n directories, and other types of files. For example, suppose we want a BufferedReader to read text from a file \"access.log\". The\n file is located in a directory \"logs\" relative to the current working\n directory and is UTF-8 encoded.\n \n     Path path = FileSystems.getDefault().getPath(\"logs\", \"access.log\");\n     BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);\n \nInteroperability\n Paths associated with the default provider are generally interoperable\n with the java.io.File class. Paths created by other\n providers are unlikely to be interoperable with the abstract path names\n represented by java.io.File. The toPath\n method may be used to obtain a Path from the abstract path name\n represented by a java.io.File object. The resulting Path can\n be used to operate on the same file as the java.io.File object. In\n addition, the toFile method is useful to construct a \n File from the String representation of a Path.\n\n Concurrency\n Implementations of this interface are immutable and safe for use by\n multiple concurrent threads.", "codes": ["public interface Path\nextends Comparable<Path>, Iterable<Path>, Watchable"], "fields": [], "methods": [{"method_name": "of", "method_sig": "static Path of (String first,\n               String... more)", "description": "Returns a Path by converting a path string, or a sequence of\n strings that when joined form a path string. If more does not\n specify any elements then the value of the first parameter is\n the path string to convert. If more specifies one or more\n elements then each non-empty string, including first, is\n considered to be a sequence of name elements and is joined to form a\n path string. The details as to how the Strings are joined is provider\n specific but typically they will be joined using the\n name-separator as the separator.\n For example, if the name separator is \"/\" and\n getPath(\"/foo\",\"bar\",\"gus\") is invoked, then the path string\n \"/foo/bar/gus\" is converted to a Path. A Path\n representing an empty path is returned if first is the empty\n string and more does not contain any non-empty strings.\n\n  The Path is obtained by invoking the getPath method of the default FileSystem.\n\n  Note that while this method is very convenient, using it will imply\n an assumed reference to the default FileSystem and limit the\n utility of the calling code. Hence it should not be used in library code\n intended for flexible reuse. A more flexible alternative is to use an\n existing Path instance as an anchor, such as:\n \n     Path dir = ...\n     Path path = dir.resolve(\"file\");\n "}, {"method_name": "of", "method_sig": "static Path of (URI uri)", "description": "Returns a Path by converting a URI.\n\n  This method iterates over the installed providers to locate the provider that is identified by the\n URI scheme of the given URI. URI schemes are\n compared without regard to case. If the provider is found then its getPath method is invoked to convert the\n URI.\n\n  In the case of the default provider, identified by the URI scheme\n \"file\", the given URI has a non-empty path component, and undefined query\n and fragment components. Whether the authority component may be present\n is platform specific. The returned Path is associated with the\n default file system.\n\n  The default provider provides a similar round-trip guarantee\n to the File class. For a given Path p it\n is guaranteed that\n \n Path.of(p.toUri()).equals(\np.toAbsolutePath())\n\n so long as the original Path, the URI, and the new \n Path are all created in (possibly different invocations of) the same\n Java virtual machine. Whether other providers make any guarantees is\n provider specific and therefore unspecified."}, {"method_name": "getFileSystem", "method_sig": "FileSystem getFileSystem()", "description": "Returns the file system that created this object."}, {"method_name": "isAbsolute", "method_sig": "boolean isAbsolute()", "description": "Tells whether or not this path is absolute.\n\n  An absolute path is complete in that it doesn't need to be combined\n with other path information in order to locate a file."}, {"method_name": "getRoot", "method_sig": "Path getRoot()", "description": "Returns the root component of this path as a Path object,\n or null if this path does not have a root component."}, {"method_name": "getFileName", "method_sig": "Path getFileName()", "description": "Returns the name of the file or directory denoted by this path as a\n Path object. The file name is the farthest element from\n the root in the directory hierarchy."}, {"method_name": "getParent", "method_sig": "Path getParent()", "description": "Returns the parent path, or null if this path does not\n have a parent.\n\n  The parent of this path object consists of this path's root\n component, if any, and each element in the path except for the\n farthest from the root in the directory hierarchy. This method\n does not access the file system; the path or its parent may not exist.\n Furthermore, this method does not eliminate special names such as \".\"\n and \"..\" that may be used in some implementations. On UNIX for example,\n the parent of \"/a/b/c\" is \"/a/b\", and the parent of\n \"x/y/.\" is \"x/y\". This method may be used with the normalize method, to eliminate redundant names, for cases where\n shell-like navigation is required.\n\n  If this path has more than one element, and no root component, then\n this method is equivalent to evaluating the expression:\n \n subpath(0,\u00a0getNameCount()-1);\n "}, {"method_name": "getNameCount", "method_sig": "int getNameCount()", "description": "Returns the number of name elements in the path."}, {"method_name": "getName", "method_sig": "Path getName (int index)", "description": "Returns a name element of this path as a Path object.\n\n  The index parameter is the index of the name element to return.\n The element that is closest to the root in the directory hierarchy\n has index 0. The element that is farthest from the root\n has index count-1."}, {"method_name": "subpath", "method_sig": "Path subpath (int beginIndex,\n             int endIndex)", "description": "Returns a relative Path that is a subsequence of the name\n elements of this path.\n\n  The beginIndex and endIndex parameters specify the\n subsequence of name elements. The name that is closest to the root\n in the directory hierarchy has index 0. The name that is\n farthest from the root has index count-1. The returned Path object has the name elements\n that begin at beginIndex and extend to the element at index \n endIndex-1."}, {"method_name": "startsWith", "method_sig": "boolean startsWith (Path other)", "description": "Tests if this path starts with the given path.\n\n  This path starts with the given path if this path's root\n component starts with the root component of the given path,\n and this path starts with the same name elements as the given path.\n If the given path has more name elements than this path then false\n is returned.\n\n  Whether or not the root component of this path starts with the root\n component of the given path is file system specific. If this path does\n not have a root component and the given path has a root component then\n this path does not start with the given path.\n\n  If the given path is associated with a different FileSystem\n to this path then false is returned."}, {"method_name": "startsWith", "method_sig": "default boolean startsWith (String other)", "description": "Tests if this path starts with a Path, constructed by converting\n the given path string, in exactly the manner specified by the startsWith(Path) method. On UNIX for example, the path\n \"foo/bar\" starts with \"foo\" and \"foo/bar\". It\n does not start with \"f\" or \"fo\"."}, {"method_name": "endsWith", "method_sig": "boolean endsWith (Path other)", "description": "Tests if this path ends with the given path.\n\n  If the given path has N elements, and no root component,\n and this path has N or more elements, then this path ends with\n the given path if the last N elements of each path, starting at\n the element farthest from the root, are equal.\n\n  If the given path has a root component then this path ends with the\n given path if the root component of this path ends with the root\n component of the given path, and the corresponding elements of both paths\n are equal. Whether or not the root component of this path ends with the\n root component of the given path is file system specific. If this path\n does not have a root component and the given path has a root component\n then this path does not end with the given path.\n\n  If the given path is associated with a different FileSystem\n to this path then false is returned."}, {"method_name": "endsWith", "method_sig": "default boolean endsWith (String other)", "description": "Tests if this path ends with a Path, constructed by converting\n the given path string, in exactly the manner specified by the endsWith(Path) method. On UNIX for example, the path\n \"foo/bar\" ends with \"foo/bar\" and \"bar\". It does\n not end with \"r\" or \"/bar\". Note that trailing separators\n are not taken into account, and so invoking this method on the \n Path\"foo/bar\" with the String \"bar/\" returns\n true."}, {"method_name": "normalize", "method_sig": "Path normalize()", "description": "Returns a path that is this path with redundant name elements eliminated.\n\n  The precise definition of this method is implementation dependent but\n in general it derives from this path, a path that does not contain\n redundant name elements. In many file systems, the \".\"\n and \"..\" are special names used to indicate the current directory\n and parent directory. In such file systems all occurrences of \".\"\n are considered redundant. If a \"..\" is preceded by a\n non-\"..\" name then both names are considered redundant (the\n process to identify such names is repeated until it is no longer\n applicable).\n\n  This method does not access the file system; the path may not locate\n a file that exists. Eliminating \"..\" and a preceding name from a\n path may result in the path that locates a different file than the original\n path. This can arise when the preceding name is a symbolic link."}, {"method_name": "resolve", "method_sig": "Path resolve (Path other)", "description": "Resolve the given path against this path.\n\n  If the other parameter is an absolute\n path then this method trivially returns other. If other\n is an empty path then this method trivially returns this path.\n Otherwise this method considers this path to be a directory and resolves\n the given path against this path. In the simplest case, the given path\n does not have a root component, in which case this method\n joins the given path to this path and returns a resulting path\n that ends with the given path. Where the given path has\n a root component then resolution is highly implementation dependent and\n therefore unspecified."}, {"method_name": "resolve", "method_sig": "default Path resolve (String other)", "description": "Converts a given path string to a Path and resolves it against\n this Path in exactly the manner specified by the resolve method. For example, suppose that the name\n separator is \"/\" and a path represents \"foo/bar\", then\n invoking this method with the path string \"gus\" will result in\n the Path \"foo/bar/gus\"."}, {"method_name": "resolveSibling", "method_sig": "default Path resolveSibling (Path other)", "description": "Resolves the given path against this path's parent\n path. This is useful where a file name needs to be replaced with\n another file name. For example, suppose that the name separator is\n \"/\" and a path represents \"dir1/dir2/foo\", then invoking\n this method with the Path \"bar\" will result in the \n Path \"dir1/dir2/bar\". If this path does not have a parent path,\n or other is absolute, then this method\n returns other. If other is an empty path then this method\n returns this path's parent, or where this path doesn't have a parent, the\n empty path."}, {"method_name": "resolveSibling", "method_sig": "default Path resolveSibling (String other)", "description": "Converts a given path string to a Path and resolves it against\n this path's parent path in exactly the manner\n specified by the resolveSibling method."}, {"method_name": "relativize", "method_sig": "Path relativize (Path other)", "description": "Constructs a relative path between this path and a given path.\n\n  Relativization is the inverse of resolution.\n This method attempts to construct a relative path\n that when resolved against this path, yields a\n path that locates the same file as the given path. For example, on UNIX,\n if this path is \"/a/b\" and the given path is \"/a/b/c/d\"\n then the resulting relative path would be \"c/d\". Where this\n path and the given path do not have a root component,\n then a relative path can be constructed. A relative path cannot be\n constructed if only one of the paths have a root component. Where both\n paths have a root component then it is implementation dependent if a\n relative path can be constructed. If this path and the given path are\n equal then an empty path is returned.\n\n  For any two normalized paths p and\n q, where q does not have a root component,\n \np.relativize(p\n.resolve(q)).equals(q)\n\n When symbolic links are supported, then whether the resulting path,\n when resolved against this path, yields a path that can be used to locate\n the same file as other is implementation\n dependent. For example, if this path is  \"/a/b\" and the given\n path is \"/a/x\" then the resulting relative path may be \n \"../x\". If \"b\" is a symbolic link then is implementation\n dependent if \"a/b/../x\" would locate the same file as \"/a/x\"."}, {"method_name": "toUri", "method_sig": "URI toUri()", "description": "Returns a URI to represent this path.\n\n  This method constructs an absolute URI with a scheme equal to the URI scheme that identifies the\n provider. The exact form of the scheme specific part is highly provider\n dependent.\n\n  In the case of the default provider, the URI is hierarchical with\n a path component that is absolute. The query and\n fragment components are undefined. Whether the authority component is\n defined or not is implementation dependent. There is no guarantee that\n the URI may be used to construct a java.io.File.\n In particular, if this path represents a Universal Naming Convention (UNC)\n path, then the UNC server name may be encoded in the authority component\n of the resulting URI. In the case of the default provider, and the file\n exists, and it can be determined that the file is a directory, then the\n resulting URI will end with a slash.\n\n  The default provider provides a similar round-trip guarantee\n to the File class. For a given Path p it\n is guaranteed that\n \nPath.of(p.toUri()).equals(p\n.toAbsolutePath())\n\n so long as the original Path, the URI, and the new \n Path are all created in (possibly different invocations of) the same\n Java virtual machine. Whether other providers make any guarantees is\n provider specific and therefore unspecified.\n\n  When a file system is constructed to access the contents of a file\n as a file system then it is highly implementation specific if the returned\n URI represents the given path in the file system or it represents a\n compound URI that encodes the URI of the enclosing file system.\n A format for compound URIs is not defined in this release; such a scheme\n may be added in a future release."}, {"method_name": "toAbsolutePath", "method_sig": "Path toAbsolutePath()", "description": "Returns a Path object representing the absolute path of this\n path.\n\n  If this path is already absolute then this\n method simply returns this path. Otherwise, this method resolves the path\n in an implementation dependent manner, typically by resolving the path\n against a file system default directory. Depending on the implementation,\n this method may throw an I/O error if the file system is not accessible."}, {"method_name": "toRealPath", "method_sig": "Path toRealPath (LinkOption... options)\n         throws IOException", "description": "Returns the real path of an existing file.\n\n  The precise definition of this method is implementation dependent but\n in general it derives from this path, an absolute\n path that locates the same file as this path, but\n with name elements that represent the actual name of the directories\n and the file. For example, where filename comparisons on a file system\n are case insensitive then the name elements represent the names in their\n actual case. Additionally, the resulting path has redundant name\n elements removed.\n\n  If this path is relative then its absolute path is first obtained,\n as if by invoking the toAbsolutePath method.\n\n  The options array may be used to indicate how symbolic links\n are handled. By default, symbolic links are resolved to their final\n target. If the option NOFOLLOW_LINKS is\n present then this method does not resolve symbolic links.\n\n Some implementations allow special names such as \"..\" to refer to\n the parent directory. When deriving the real path, and a\n \"..\" (or equivalent) is preceded by a non-\"..\" name then\n an implementation will typically cause both names to be removed. When\n not resolving symbolic links and the preceding name is a symbolic link\n then the names are only removed if it guaranteed that the resulting path\n will locate the same file as this path."}, {"method_name": "toFile", "method_sig": "default File toFile()", "description": "Returns a File object representing this path. Where this \n Path is associated with the default provider, then this method is\n equivalent to returning a File object constructed with the\n String representation of this path.\n\n  If this path was created by invoking the File toPath method then there is no guarantee that the \n File object returned by this method is equal to the\n original File."}, {"method_name": "register", "method_sig": "WatchKey register (WatchService watcher,\n                  WatchEvent.Kind<?>[] events,\n                  WatchEvent.Modifier... modifiers)\n           throws IOException", "description": "Registers the file located by this path with a watch service.\n\n  In this release, this path locates a directory that exists. The\n directory is registered with the watch service so that entries in the\n directory can be watched. The events parameter is the events to\n register and may contain the following events:\n \nENTRY_CREATE -\n       entry created or moved into the directory\nENTRY_DELETE -\n        entry deleted or moved out of the directory\nENTRY_MODIFY -\n        entry in directory was modified\n\n The context for these events is the\n relative path between the directory located by this path, and the path\n that locates the directory entry that is created, deleted, or modified.\n\n  The set of events may include additional implementation specific\n event that are not defined by the enum StandardWatchEventKinds\n The modifiers parameter specifies modifiers that\n qualify how the directory is registered. This release does not define any\n standard modifiers. It may contain implementation specific\n modifiers.\n\n  Where a file is registered with a watch service by means of a symbolic\n link then it is implementation specific if the watch continues to depend\n on the existence of the symbolic link after it is registered."}, {"method_name": "register", "method_sig": "default WatchKey register (WatchService watcher,\n                          WatchEvent.Kind<?>... events)\n                   throws IOException", "description": "Registers the file located by this path with a watch service.\n\n  An invocation of this method behaves in exactly the same way as the\n invocation\n \n     watchable.register(watcher, events, new WatchEvent.Modifier[0]);\n \n Usage Example:\n Suppose we wish to register a directory for entry create, delete, and modify\n events:\n \n     Path dir = ...\n     WatchService watcher = ...\n\n     WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n "}, {"method_name": "iterator", "method_sig": "default Iterator<Path> iterator()", "description": "Returns an iterator over the name elements of this path.\n\n  The first element returned by the iterator represents the name\n element that is closest to the root in the directory hierarchy, the\n second element is the next closest, and so on. The last element returned\n is the name of the file or directory denoted by this path. The root component, if present, is not returned by the iterator."}, {"method_name": "compareTo", "method_sig": "int compareTo (Path other)", "description": "Compares two abstract paths lexicographically. The ordering defined by\n this method is provider specific, and in the case of the default\n provider, platform specific. This method does not access the file system\n and neither file is required to exist.\n\n  This method may not be used to compare paths that are associated\n with different file system providers."}, {"method_name": "equals", "method_sig": "boolean equals (Object other)", "description": "Tests this path for equality with the given object.\n\n  If the given object is not a Path, or is a Path associated with a\n different FileSystem, then this method returns false.\n\n  Whether or not two path are equal depends on the file system\n implementation. In some cases the paths are compared without regard\n to case, and others are case sensitive. This method does not access the\n file system and the file is not required to exist. Where required, the\n isSameFile method may be used to check if two\n paths locate the same file.\n\n  This method satisfies the general contract of the Object.equals method. "}, {"method_name": "hashCode", "method_sig": "int hashCode()", "description": "Computes a hash code for this path.\n\n  The hash code is based upon the components of the path, and\n satisfies the general contract of the Object.hashCode method."}, {"method_name": "toString", "method_sig": "String toString()", "description": "Returns the string representation of this path.\n\n  If this path was created by converting a path string using the\n getPath method then the path string returned\n by this method may differ from the original String used to create the path.\n\n  The returned path string uses the default name separator to separate names in the path."}]}