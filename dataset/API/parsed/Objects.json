{"name": "Class Objects", "module": "java.base", "package": "java.util", "text": "This class consists of static utility methods for operating\n on objects, or checking certain conditions before operation.  These utilities\n include null-safe or null-tolerant methods for computing the\n hash code of an object, returning a string for an object, comparing two\n objects, and checking if indexes or sub-range values are out of bounds.", "codes": ["public final class Objects\nextends Object"], "fields": [], "methods": [{"method_name": "equals", "method_sig": "public static boolean equals (Object a,\n                             Object b)", "description": "Returns true if the arguments are equal to each other\n and false otherwise.\n Consequently, if both arguments are null, true\n is returned and if exactly one argument is null, \n false is returned.  Otherwise, equality is determined by using\n the equals method of the first\n argument."}, {"method_name": "deepEquals", "method_sig": "public static boolean deepEquals (Object a,\n                                 Object b)", "description": "Returns true if the arguments are deeply equal to each other\n and false otherwise.\n\n Two null values are deeply equal.  If both arguments are\n arrays, the algorithm in Arrays.deepEquals is used to determine equality.\n Otherwise, equality is determined by using the equals method of the first argument."}, {"method_name": "hashCode", "method_sig": "public static int hashCode (Object o)", "description": "Returns the hash code of a non-null argument and 0 for\n a null argument."}, {"method_name": "hash", "method_sig": "public static int hash (Object... values)", "description": "Generates a hash code for a sequence of input values. The hash\n code is generated as if all the input values were placed into an\n array, and that array were hashed by calling Arrays.hashCode(Object[]).\n\n This method is useful for implementing Object.hashCode() on objects containing multiple fields. For\n example, if an object that has three fields, x, \n y, and z, one could write:\n\n \n @Override public int hashCode() {\n     return Objects.hash(x, y, z);\n }\n \nWarning: When a single object reference is supplied, the returned\n value does not equal the hash code of that object reference. This\n value can be computed by calling hashCode(Object)."}, {"method_name": "toString", "method_sig": "public static String toString (Object o)", "description": "Returns the result of calling toString for a non-\n null argument and \"null\" for a null argument."}, {"method_name": "toString", "method_sig": "public static String toString (Object o,\n                              String nullDefault)", "description": "Returns the result of calling toString on the first\n argument if the first argument is not null and returns\n the second argument otherwise."}, {"method_name": "compare", "method_sig": "public static <T> int compare (T a,\n                              T b,\n                              Comparator<? super T> c)", "description": "Returns 0 if the arguments are identical and \n c.compare(a, b) otherwise.\n Consequently, if both arguments are null 0\n is returned.\n\n Note that if one of the arguments is null, a \n NullPointerException may or may not be thrown depending on\n what ordering policy, if any, the Comparator\n chooses to have for null values."}, {"method_name": "requireNonNull", "method_sig": "public static <T> T requireNonNull (T obj)", "description": "Checks that the specified object reference is not null. This\n method is designed primarily for doing parameter validation in methods\n and constructors, as demonstrated below:\n \n public Foo(Bar bar) {\n     this.bar = Objects.requireNonNull(bar);\n }\n "}, {"method_name": "requireNonNull", "method_sig": "public static <T> T requireNonNull (T obj,\n                                   String message)", "description": "Checks that the specified object reference is not null and\n throws a customized NullPointerException if it is. This method\n is designed primarily for doing parameter validation in methods and\n constructors with multiple parameters, as demonstrated below:\n \n public Foo(Bar bar, Baz baz) {\n     this.bar = Objects.requireNonNull(bar, \"bar must not be null\");\n     this.baz = Objects.requireNonNull(baz, \"baz must not be null\");\n }\n "}, {"method_name": "isNull", "method_sig": "public static boolean isNull (Object obj)", "description": "Returns true if the provided reference is null otherwise\n returns false."}, {"method_name": "nonNull", "method_sig": "public static boolean nonNull (Object obj)", "description": "Returns true if the provided reference is non-null\n otherwise returns false."}, {"method_name": "requireNonNullElse", "method_sig": "public static <T> T requireNonNullElse (T obj,\n                                       T defaultObj)", "description": "Returns the first argument if it is non-null and\n otherwise returns the non-null second argument."}, {"method_name": "requireNonNullElseGet", "method_sig": "public static <T> T requireNonNullElseGet (T obj,\n                                          Supplier<? extends T> supplier)", "description": "Returns the first argument if it is non-null and otherwise\n returns the non-null value of supplier.get()."}, {"method_name": "requireNonNull", "method_sig": "public static <T> T requireNonNull (T obj,\n                                   Supplier<String> messageSupplier)", "description": "Checks that the specified object reference is not null and\n throws a customized NullPointerException if it is.\n\n Unlike the method requireNonNull(Object, String),\n this method allows creation of the message to be deferred until\n after the null check is made. While this may confer a\n performance advantage in the non-null case, when deciding to\n call this method care should be taken that the costs of\n creating the message supplier are less than the cost of just\n creating the string message directly."}, {"method_name": "checkIndex", "method_sig": "public static int checkIndex (int index,\n                             int length)", "description": "Checks if the index is within the bounds of the range from\n 0 (inclusive) to length (exclusive).\n\n The index is defined to be out of bounds if any of the\n following inequalities is true:\n \nindex < 0\nindex >= length\nlength < 0, which is implied from the former inequalities\n"}, {"method_name": "checkFromToIndex", "method_sig": "public static int checkFromToIndex (int fromIndex,\n                                   int toIndex,\n                                   int length)", "description": "Checks if the sub-range from fromIndex (inclusive) to\n toIndex (exclusive) is within the bounds of range from 0\n (inclusive) to length (exclusive).\n\n The sub-range is defined to be out of bounds if any of the following\n inequalities is true:\n \nfromIndex < 0\nfromIndex > toIndex\ntoIndex > length\nlength < 0, which is implied from the former inequalities\n"}, {"method_name": "checkFromIndexSize", "method_sig": "public static int checkFromIndexSize (int fromIndex,\n                                     int size,\n                                     int length)", "description": "Checks if the sub-range from fromIndex (inclusive) to\n fromIndex + size (exclusive) is within the bounds of range from\n 0 (inclusive) to length (exclusive).\n\n The sub-range is defined to be out of bounds if any of the following\n inequalities is true:\n \nfromIndex < 0\nsize < 0\nfromIndex + size > length, taking into account integer overflow\nlength < 0, which is implied from the former inequalities\n"}]}