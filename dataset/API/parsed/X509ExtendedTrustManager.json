{"name": "Class X509ExtendedTrustManager", "module": "java.base", "package": "javax.net.ssl", "text": "Extensions to the X509TrustManager interface to support\n SSL/TLS/DTLS connection sensitive trust management.\n \n To prevent man-in-the-middle attacks, hostname checks can be done\n to verify that the hostname in an end-entity certificate matches the\n targeted hostname.  TLS/DTLS does not require such checks, but some\n protocols over TLS/DTLS (such as HTTPS) do.  In earlier versions of the\n JDK, the certificate chain checks were done at the SSL/TLS/DTLS layer,\n and the hostname verification checks were done at the layer over TLS/DTLS.\n This class allows for the checking to be done during a single call to\n this class.\n \n RFC 2830 defines the server identification specification for the \"LDAPS\"\n algorithm. RFC 2818 defines both the server identification and the\n client identification specification for the \"HTTPS\" algorithm.", "codes": ["public abstract class X509ExtendedTrustManager\nextends Object\nimplements X509TrustManager"], "fields": [], "methods": [{"method_name": "checkClientTrusted", "method_sig": "public abstract void checkClientTrusted (X509Certificate[] chain,\n                                        String authType,\n                                        Socket socket)\n                                 throws CertificateException", "description": "Given the partial or complete certificate chain provided by the\n peer, build and validate the certificate path based on the\n authentication type and ssl parameters.\n \n The authentication type is determined by the actual certificate\n used. For instance, if RSAPublicKey is used, the authType\n should be \"RSA\". Checking is case-sensitive.\n \n If the socket parameter is an instance of\n SSLSocket, and the endpoint identification\n algorithm of the SSLParameters is non-empty, to prevent\n man-in-the-middle attacks, the address that the socket\n connected to should be checked against the peer's identity presented\n in the end-entity X509 certificate, as specified in the endpoint\n identification algorithm.\n \n If the socket parameter is an instance of\n SSLSocket, and the algorithm constraints of the\n SSLParameters is non-null, for every certificate in the\n certification path, fields such as subject public key, the signature\n algorithm, key usage, extended key usage, etc. need to conform to the\n algorithm constraints in place on this socket."}, {"method_name": "checkServerTrusted", "method_sig": "public abstract void checkServerTrusted (X509Certificate[] chain,\n                                        String authType,\n                                        Socket socket)\n                                 throws CertificateException", "description": "Given the partial or complete certificate chain provided by the\n peer, build and validate the certificate path based on the\n authentication type and ssl parameters.\n \n The authentication type is the key exchange algorithm portion\n of the cipher suites represented as a String, such as \"RSA\",\n \"DHE_DSS\". Note: for some exportable cipher suites, the key\n exchange algorithm is determined at run time during the\n handshake. For instance, for TLS_RSA_EXPORT_WITH_RC4_40_MD5,\n the authType should be RSA_EXPORT when an ephemeral RSA key is\n used for the key exchange, and RSA when the key from the server\n certificate is used. Checking is case-sensitive.\n \n If the socket parameter is an instance of\n SSLSocket, and the endpoint identification\n algorithm of the SSLParameters is non-empty, to prevent\n man-in-the-middle attacks, the address that the socket\n connected to should be checked against the peer's identity presented\n in the end-entity X509 certificate, as specified in the endpoint\n identification algorithm.\n \n If the socket parameter is an instance of\n SSLSocket, and the algorithm constraints of the\n  SSLParameters is non-null, for every certificate in the\n certification path, fields such as subject public key, the signature\n algorithm, key usage, extended key usage, etc. need to conform to the\n algorithm constraints in place on this socket."}, {"method_name": "checkClientTrusted", "method_sig": "public abstract void checkClientTrusted (X509Certificate[] chain,\n                                        String authType,\n                                        SSLEngine engine)\n                                 throws CertificateException", "description": "Given the partial or complete certificate chain provided by the\n peer, build and validate the certificate path based on the\n authentication type and ssl parameters.\n \n The authentication type is determined by the actual certificate\n used. For instance, if RSAPublicKey is used, the authType\n should be \"RSA\". Checking is case-sensitive.\n \n If the engine parameter is available, and the endpoint\n identification algorithm of the SSLParameters is\n non-empty, to prevent man-in-the-middle attacks, the address that\n the engine connected to should be checked against\n the peer's identity presented in the end-entity X509 certificate,\n as specified in the endpoint identification algorithm.\n \n If the engine parameter is available, and the algorithm\n constraints of the SSLParameters is non-null, for every\n certificate in the certification path, fields such as subject public\n key, the signature algorithm, key usage, extended key usage, etc.\n need to conform to the algorithm constraints in place on this engine."}, {"method_name": "checkServerTrusted", "method_sig": "public abstract void checkServerTrusted (X509Certificate[] chain,\n                                        String authType,\n                                        SSLEngine engine)\n                                 throws CertificateException", "description": "Given the partial or complete certificate chain provided by the\n peer, build and validate the certificate path based on the\n authentication type and ssl parameters.\n \n The authentication type is the key exchange algorithm portion\n of the cipher suites represented as a String, such as \"RSA\",\n \"DHE_DSS\". Note: for some exportable cipher suites, the key\n exchange algorithm is determined at run time during the\n handshake. For instance, for TLS_RSA_EXPORT_WITH_RC4_40_MD5,\n the authType should be RSA_EXPORT when an ephemeral RSA key is\n used for the key exchange, and RSA when the key from the server\n certificate is used. Checking is case-sensitive.\n \n If the engine parameter is available, and the endpoint\n identification algorithm of the SSLParameters is\n non-empty, to prevent man-in-the-middle attacks, the address that\n the engine connected to should be checked against\n the peer's identity presented in the end-entity X509 certificate,\n as specified in the endpoint identification algorithm.\n \n If the engine parameter is available, and the algorithm\n constraints of the SSLParameters is non-null, for every\n certificate in the certification path, fields such as subject public\n key, the signature algorithm, key usage, extended key usage, etc.\n need to conform to the algorithm constraints in place on this engine."}]}