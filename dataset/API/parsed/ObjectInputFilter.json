{"name": "Interface ObjectInputFilter", "module": "java.base", "package": "java.io", "text": "Filter classes, array lengths, and graph metrics during deserialization.\n\n Warning: Deserialization of untrusted data is inherently dangerous\n and should be avoided. Untrusted data should be carefully validated according to the\n \"Serialization and Deserialization\" section of the\n Secure Coding Guidelines for Java SE.\n Serialization Filtering describes best\n practices for defensive use of serial filters.\n \n\n If set on an ObjectInputStream, the checkInput(FilterInfo)\n method is called to validate classes, the length of each array,\n the number of objects being read from the stream, the depth of the graph,\n and the total number of bytes read from the stream.\n \n A filter can be set via setObjectInputFilter\n for an individual ObjectInputStream.\n A filter can be set via Config.setSerialFilter\n to affect every ObjectInputStream that does not otherwise set a filter.\n \n A filter determines whether the arguments are ALLOWED\n or REJECTED and should return the appropriate status.\n If the filter cannot determine the status it should return\n UNDECIDED.\n Filters should be designed for the specific use case and expected types.\n A filter designed for a particular use may be passed a class that is outside\n of the scope of the filter. If the purpose of the filter is to black-list classes\n then it can reject a candidate class that matches and report UNDECIDED for others.\n A filter may be called with class equals null, arrayLength equal -1,\n the depth, number of references, and stream size and return a status\n that reflects only one or only some of the values.\n This allows a filter to specific about the choice it is reporting and\n to use other filters without forcing either allowed or rejected status.\n\n \n Typically, a custom filter should check if a process-wide filter\n is configured and defer to it if so. For example,\n \n ObjectInputFilter.Status checkInput(FilterInfo info) {\n     ObjectInputFilter serialFilter = ObjectInputFilter.Config.getSerialFilter();\n     if (serialFilter != null) {\n         ObjectInputFilter.Status status = serialFilter.checkInput(info);\n         if (status != ObjectInputFilter.Status.UNDECIDED) {\n             // The process-wide filter overrides this filter\n             return status;\n         }\n     }\n     if (info.serialClass() != null &&\n         Remote.class.isAssignableFrom(info.serialClass())) {\n         return Status.REJECTED;      // Do not allow Remote objects\n     }\n     return Status.UNDECIDED;\n }\n\n\n Unless otherwise noted, passing a null argument to a\n method in this interface and its nested classes will cause a\n NullPointerException to be thrown.", "codes": ["@FunctionalInterface\npublic interface ObjectInputFilter"], "fields": [], "methods": [{"method_name": "checkInput", "method_sig": "ObjectInputFilter.Status checkInput (ObjectInputFilter.FilterInfo filterInfo)", "description": "Check the class, array length, number of object references, depth,\n stream size, and other available filtering information.\n Implementations of this method check the contents of the object graph being created\n during deserialization. The filter returns Status.ALLOWED,\n Status.REJECTED, or Status.UNDECIDED."}]}