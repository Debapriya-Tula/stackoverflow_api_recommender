{"name": "Interface ExecutorService", "module": "java.base", "package": "java.util.concurrent", "text": "An Executor that provides methods to manage termination and\n methods that can produce a Future for tracking progress of\n one or more asynchronous tasks.\n\n An ExecutorService can be shut down, which will cause\n it to reject new tasks.  Two different methods are provided for\n shutting down an ExecutorService. The shutdown()\n method will allow previously submitted tasks to execute before\n terminating, while the shutdownNow() method prevents waiting\n tasks from starting and attempts to stop currently executing tasks.\n Upon termination, an executor has no tasks actively executing, no\n tasks awaiting execution, and no new tasks can be submitted.  An\n unused ExecutorService should be shut down to allow\n reclamation of its resources.\n\n Method submit extends base method Executor.execute(Runnable) by creating and returning a Future\n that can be used to cancel execution and/or wait for completion.\n Methods invokeAny and invokeAll perform the most\n commonly useful forms of bulk execution, executing a collection of\n tasks and then waiting for at least one, or all, to\n complete. (Class ExecutorCompletionService can be used to\n write customized variants of these methods.)\n\n The Executors class provides factory methods for the\n executor services provided in this package.\n\n Usage Examples\n\n Here is a sketch of a network service in which threads in a thread\n pool service incoming requests. It uses the preconfigured Executors.newFixedThreadPool(int) factory method:\n\n  \n class NetworkService implements Runnable {\n   private final ServerSocket serverSocket;\n   private final ExecutorService pool;\n\n   public NetworkService(int port, int poolSize)\n       throws IOException {\n     serverSocket = new ServerSocket(port);\n     pool = Executors.newFixedThreadPool(poolSize);\n   }\n\n   public void run() { // run the service\n     try {\n       for (;;) {\n         pool.execute(new Handler(serverSocket.accept()));\n       }\n     } catch (IOException ex) {\n       pool.shutdown();\n     }\n   }\n }\n\n class Handler implements Runnable {\n   private final Socket socket;\n   Handler(Socket socket) { this.socket = socket; }\n   public void run() {\n     // read and service request on socket\n   }\n }\n\n The following method shuts down an ExecutorService in two phases,\n first by calling shutdown to reject incoming tasks, and then\n calling shutdownNow, if necessary, to cancel any lingering tasks:\n\n  \n void shutdownAndAwaitTermination(ExecutorService pool) {\n   pool.shutdown(); // Disable new tasks from being submitted\n   try {\n     // Wait a while for existing tasks to terminate\n     if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {\n       pool.shutdownNow(); // Cancel currently executing tasks\n       // Wait a while for tasks to respond to being cancelled\n       if (!pool.awaitTermination(60, TimeUnit.SECONDS))\n           System.err.println(\"Pool did not terminate\");\n     }\n   } catch (InterruptedException ie) {\n     // (Re-)Cancel if current thread also interrupted\n     pool.shutdownNow();\n     // Preserve interrupt status\n     Thread.currentThread().interrupt();\n   }\n }\nMemory consistency effects: Actions in a thread prior to the\n submission of a Runnable or Callable task to an\n ExecutorService\nhappen-before\n any actions taken by that task, which in turn happen-before the\n result is retrieved via Future.get().", "codes": ["public interface ExecutorService\nextends Executor"], "fields": [], "methods": [{"method_name": "shutdown", "method_sig": "void shutdown()", "description": "Initiates an orderly shutdown in which previously submitted\n tasks are executed, but no new tasks will be accepted.\n Invocation has no additional effect if already shut down.\n\n This method does not wait for previously submitted tasks to\n complete execution.  Use awaitTermination\n to do that."}, {"method_name": "shutdownNow", "method_sig": "List<Runnable> shutdownNow()", "description": "Attempts to stop all actively executing tasks, halts the\n processing of waiting tasks, and returns a list of the tasks\n that were awaiting execution.\n\n This method does not wait for actively executing tasks to\n terminate.  Use awaitTermination to\n do that.\n\n There are no guarantees beyond best-effort attempts to stop\n processing actively executing tasks.  For example, typical\n implementations will cancel via Thread.interrupt(), so any\n task that fails to respond to interrupts may never terminate."}, {"method_name": "isShutdown", "method_sig": "boolean isShutdown()", "description": "Returns true if this executor has been shut down."}, {"method_name": "isTerminated", "method_sig": "boolean isTerminated()", "description": "Returns true if all tasks have completed following shut down.\n Note that isTerminated is never true unless\n either shutdown or shutdownNow was called first."}, {"method_name": "awaitTermination", "method_sig": "boolean awaitTermination (long timeout,\n                         TimeUnit unit)\n                  throws InterruptedException", "description": "Blocks until all tasks have completed execution after a shutdown\n request, or the timeout occurs, or the current thread is\n interrupted, whichever happens first."}, {"method_name": "submit", "method_sig": "<T> Future<T> submit (Callable<T> task)", "description": "Submits a value-returning task for execution and returns a\n Future representing the pending results of the task. The\n Future's get method will return the task's result upon\n successful completion.\n\n \n If you would like to immediately block waiting\n for a task, you can use constructions of the form\n result = exec.submit(aCallable).get();\nNote: The Executors class includes a set of methods\n that can convert some other common closure-like objects,\n for example, PrivilegedAction to\n Callable form so they can be submitted."}, {"method_name": "submit", "method_sig": "<T> Future<T> submit (Runnable task,\n                     T result)", "description": "Submits a Runnable task for execution and returns a Future\n representing that task. The Future's get method will\n return the given result upon successful completion."}, {"method_name": "submit", "method_sig": "Future<?> submit (Runnable task)", "description": "Submits a Runnable task for execution and returns a Future\n representing that task. The Future's get method will\n return null upon successful completion."}, {"method_name": "invokeAll", "method_sig": "<T> List<Future<T>> invokeAll (Collection<? extends Callable<T>> tasks)\n                       throws InterruptedException", "description": "Executes the given tasks, returning a list of Futures holding\n their status and results when all complete.\n Future.isDone() is true for each\n element of the returned list.\n Note that a completed task could have\n terminated either normally or by throwing an exception.\n The results of this method are undefined if the given\n collection is modified while this operation is in progress."}, {"method_name": "invokeAll", "method_sig": "<T> List<Future<T>> invokeAll (Collection<? extends Callable<T>> tasks,\n                              long timeout,\n                              TimeUnit unit)\n                       throws InterruptedException", "description": "Executes the given tasks, returning a list of Futures holding\n their status and results\n when all complete or the timeout expires, whichever happens first.\n Future.isDone() is true for each\n element of the returned list.\n Upon return, tasks that have not completed are cancelled.\n Note that a completed task could have\n terminated either normally or by throwing an exception.\n The results of this method are undefined if the given\n collection is modified while this operation is in progress."}, {"method_name": "invokeAny", "method_sig": "<T> T invokeAny (Collection<? extends Callable<T>> tasks)\n         throws InterruptedException,\n                ExecutionException", "description": "Executes the given tasks, returning the result\n of one that has completed successfully (i.e., without throwing\n an exception), if any do. Upon normal or exceptional return,\n tasks that have not completed are cancelled.\n The results of this method are undefined if the given\n collection is modified while this operation is in progress."}, {"method_name": "invokeAny", "method_sig": "<T> T invokeAny (Collection<? extends Callable<T>> tasks,\n                long timeout,\n                TimeUnit unit)\n         throws InterruptedException,\n                ExecutionException,\n                TimeoutException", "description": "Executes the given tasks, returning the result\n of one that has completed successfully (i.e., without throwing\n an exception), if any do before the given timeout elapses.\n Upon normal or exceptional return, tasks that have not\n completed are cancelled.\n The results of this method are undefined if the given\n collection is modified while this operation is in progress."}]}