{"name": "Class NamespaceOperation", "module": "jdk.dynalink", "package": "jdk.dynalink", "text": "Describes an operation that operates on at least one Namespace of\n an object. E.g. a property getter would be described as\n \n Operation propertyGetter = new NamespaceOperation(\n     StandardOperation.GET,\n     StandardNamespace.PROPERTY);\n \n They are often combined with NamedOperation, e.g. to express a\n property getter for a property named \"color\", you would construct:\n \n Operation colorPropertyGetter = new NamedOperation(\n     new NamespaceOperation(\n         StandardOperation.GET,\n         StandardNamespace.PROPERTY),\n     \"color\");\n \nWhile NamespaceOperation can be constructed directly, it is often convenient\n to use the Operation.withNamespace(Namespace) and Operation.withNamespaces(Namespace...) factory\n methods instead, e.g.:\n \n Operation getElementOrPropertyEmpty =\n     StandardOperation.GET\n         .withNamespace(StandardNamespace.PROPERTY)\n         .named(\"color\");\n \nOperations on multiple namespaces\n If multiple namespaces are specified, the namespaces are treated as\n alternatives to each other in order of preference. The semantics of\n such operation is \"first applicable\".\n That is, a composite of GET:PROPERTY|ELEMENT:color should be\n interpreted as get the property named \"color\" on the object, but if the\n property does not exist, then get the collection element named \"color\"\n instead.\n \n Operations with multiple namespaces are helpful in implementation of languages that\n don't distinguish between one or more of the namespaces, or when expressing operations\n against objects that can be considered both ordinary objects and collections, e.g. Java\n Map objects. A GET:PROPERTY|ELEMENT:empty operation\n against a Java map will always match\n the Map.isEmpty() property, but\n GET:ELEMENT|PROPERTY:empty will actually match a map element with\n key \"empty\" if the map contains that key, and only fall back to the\n isEmpty() property getter if the map does not contain the key. If\n the source language mandates this semantics, it can be easily achieved using\n operations on multiple namespaces.\n \n Even if the language itself doesn't distinguish between some of the\n namespaces, it can be helpful to map different syntaxes to different namespace orderings.\n E.g. the source expression obj.color could map to\n GET:PROPERTY|ELEMENT|METHOD:color, but a different source\n expression that looks like collection element access obj[key] could\n be expressed instead as GET:ELEMENT|PROPERTY|METHOD in order to favor the\n element semantics. Finally, if the retrieved value is subsequently called, then it makes sense\n to bring METHOD to the front of the namespace list: the getter part of the\n source expression obj.color() could be\n GET:METHOD|PROPERTY|ELEMENT:color and the one for\n obj[key]() could be GET:METHOD|ELEMENT|PROPERTY.\n \n The base operation of a namespace operation can not itself be a namespace or named\n operation, but rather one of simple operations such are elements of\n StandardOperation. A namespace operation itself can serve as the base\n operation of a named operation, though; a typical way to construct e.g. the\n GET:ELEMENT|PROPERTY:empty from above would be:\n \n Operation getElementOrPropertyEmpty = StandardOperation.GET\n     .withNamespaces(\n         StandardNamespace.ELEMENT,\n         StandardNamespace.PROPERTY)\n     .named(\"empty\");\n ", "codes": ["public final class NamespaceOperation\nextends Object\nimplements Operation"], "fields": [], "methods": [{"method_name": "getBaseOperation", "method_sig": "public Operation getBaseOperation()", "description": "Returns the base operation of this named operation."}, {"method_name": "getNamespaces", "method_sig": "public Namespace[] getNamespaces()", "description": "Returns the namespaces in this namespace operation. The returned\n array is a copy and changes to it don't have effect on this\n object."}, {"method_name": "getNamespaceCount", "method_sig": "public int getNamespaceCount()", "description": "Returns the number of namespaces in this namespace operation."}, {"method_name": "getNamespace", "method_sig": "public Namespace getNamespace (int i)", "description": "Returns the i-th namespace in this namespace operation."}, {"method_name": "contains", "method_sig": "public boolean contains (Namespace namespace)", "description": "Returns true if this namespace operation contains a namespace equal to\n the specified namespace."}, {"method_name": "equals", "method_sig": "public boolean equals (Object obj)", "description": "Returns true if the other object is also a namespace operation and their\n base operation and namespaces are equal."}, {"method_name": "hashCode", "method_sig": "public int hashCode()", "description": "Returns the hash code of this namespace operation. Defined to be equal\n to baseOperation.hashCode() + 31 * Arrays.hashCode(namespaces)."}, {"method_name": "toString", "method_sig": "public String toString()", "description": "Returns the string representation of this namespace operation. Defined to\n be the toString of its base operation, followed by a colon character,\n followed with the list of its namespaces separated with the vertical line\n character (e.g. \"GET:PROPERTY|ELEMENT\")."}, {"method_name": "getBaseOperation", "method_sig": "public static Operation getBaseOperation (Operation op)", "description": "If the passed operation is a namespace operation, returns its\n getBaseOperation(), otherwise returns the operation as is."}, {"method_name": "getNamespaces", "method_sig": "public static Namespace[] getNamespaces (Operation op)", "description": "If the passed operation is a namespace operation, returns its\n getNamespaces(), otherwise returns an empty array."}, {"method_name": "contains", "method_sig": "public static boolean contains (Operation op,\n                               Operation baseOperation,\n                               Namespace namespace)", "description": "Returns true if the specified operation is a NamespaceOperation\n and its base operation is equal to the specified operation, and it\n contains the specified namespace. If it is not a NamespaceOperation,\n then it returns false."}]}