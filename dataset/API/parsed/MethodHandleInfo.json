{"name": "Interface MethodHandleInfo", "module": "java.base", "package": "java.lang.invoke", "text": "A symbolic reference obtained by cracking a direct method handle\n into its consitutent symbolic parts.\n To crack a direct method handle, call Lookup.revealDirect.\n Direct Method Handles\n A direct method handle represents a method, constructor, or field without\n any intervening argument bindings or other transformations.\n The method, constructor, or field referred to by a direct method handle is called\n its underlying member.\n Direct method handles may be obtained in any of these ways:\n \nBy executing an ldc instruction on a CONSTANT_MethodHandle constant.\n     (See the Java Virtual Machine Specification, sections 4.4.8 and 5.4.3.)\n By calling one of the Lookup Factory Methods,\n     such as Lookup.findVirtual,\n     to resolve a symbolic reference into a method handle.\n     A symbolic reference consists of a class, name string, and type.\n By calling the factory method Lookup.unreflect\n     or Lookup.unreflectSpecial\n     to convert a Method into a method handle.\n By calling the factory method Lookup.unreflectConstructor\n     to convert a Constructor into a method handle.\n By calling the factory method Lookup.unreflectGetter\n     or Lookup.unreflectSetter\n     to convert a Field into a method handle.\n \nRestrictions on Cracking\n Given a suitable Lookup object, it is possible to crack any direct method handle\n to recover a symbolic reference for the underlying method, constructor, or field.\n Cracking must be done via a Lookup object equivalent to that which created\n the target method handle, or which has enough access permissions to recreate\n an equivalent method handle.\n \n If the underlying method is caller sensitive,\n the direct method handle will have been \"bound\" to a particular caller class, the\n lookup class\n of the lookup object used to create it.\n Cracking this method handle with a different lookup class will fail\n even if the underlying method is public (like Class.forName).\n \n The requirement of lookup object matching provides a \"fast fail\" behavior\n for programs which may otherwise trust erroneous revelation of a method\n handle with symbolic information (or caller binding) from an unexpected scope.\n Use MethodHandles.reflectAs(java.lang.Class<T>, java.lang.invoke.MethodHandle) to override this limitation.\n\n Reference kinds\n The Lookup Factory Methods\n correspond to all major use cases for methods, constructors, and fields.\n These use cases may be distinguished using small integers as follows:\n \nreference kinds\n\nreference kinddescriptive namescopememberbehavior\n\n\n\n1REF_getFieldclass\nFT f;(T) this.f;\n\n\n2REF_getStaticclass or interface\nstaticFT f;(T) C.f;\n\n\n3REF_putFieldclass\nFT f;this.f = x;\n\n\n4REF_putStaticclass\nstaticFT f;C.f = arg;\n\n\n5REF_invokeVirtualclass\nT m(A*);(T) this.m(arg*);\n\n\n6REF_invokeStaticclass or interface\nstaticT m(A*);(T) C.m(arg*);\n\n\n7REF_invokeSpecialclass or interface\nT m(A*);(T) super.m(arg*);\n\n\n8REF_newInvokeSpecialclass\nC(A*);new C(arg*);\n\n\n9REF_invokeInterfaceinterface\nT m(A*);(T) this.m(arg*);\n\n\n", "codes": ["public interface MethodHandleInfo"], "fields": [{"field_name": "REF_getField", "field_sig": "static final\u00a0int REF_getField", "description": "A direct method handle reference kind,\n as defined in the table above."}, {"field_name": "REF_getStatic", "field_sig": "static final\u00a0int REF_getStatic", "description": "A direct method handle reference kind,\n as defined in the table above."}, {"field_name": "REF_putField", "field_sig": "static final\u00a0int REF_putField", "description": "A direct method handle reference kind,\n as defined in the table above."}, {"field_name": "REF_putStatic", "field_sig": "static final\u00a0int REF_putStatic", "description": "A direct method handle reference kind,\n as defined in the table above."}, {"field_name": "REF_invokeVirtual", "field_sig": "static final\u00a0int REF_invokeVirtual", "description": "A direct method handle reference kind,\n as defined in the table above."}, {"field_name": "REF_invokeStatic", "field_sig": "static final\u00a0int REF_invokeStatic", "description": "A direct method handle reference kind,\n as defined in the table above."}, {"field_name": "REF_invokeSpecial", "field_sig": "static final\u00a0int REF_invokeSpecial", "description": "A direct method handle reference kind,\n as defined in the table above."}, {"field_name": "REF_newInvokeSpecial", "field_sig": "static final\u00a0int REF_newInvokeSpecial", "description": "A direct method handle reference kind,\n as defined in the table above."}, {"field_name": "REF_invokeInterface", "field_sig": "static final\u00a0int REF_invokeInterface", "description": "A direct method handle reference kind,\n as defined in the table above."}], "methods": [{"method_name": "getReferenceKind", "method_sig": "int getReferenceKind()", "description": "Returns the reference kind of the cracked method handle, which in turn\n determines whether the method handle's underlying member was a constructor, method, or field.\n See the table above for definitions."}, {"method_name": "getDeclaringClass", "method_sig": "Class<?> getDeclaringClass()", "description": "Returns the class in which the cracked method handle's underlying member was defined."}, {"method_name": "getName", "method_sig": "String getName()", "description": "Returns the name of the cracked method handle's underlying member.\n This is \"<init>\" if the underlying member was a constructor,\n else it is a simple method name or field name."}, {"method_name": "getMethodType", "method_sig": "MethodType getMethodType()", "description": "Returns the nominal type of the cracked symbolic reference, expressed as a method type.\n If the reference is to a constructor, the return type will be void.\n If it is to a non-static method, the method type will not mention the this parameter.\n If it is to a field and the requested access is to read the field,\n the method type will have no parameters and return the field type.\n If it is to a field and the requested access is to write the field,\n the method type will have one parameter of the field type and return void.\n \n Note that original direct method handle may include a leading this parameter,\n or (in the case of a constructor) will replace the void return type\n with the constructed class.\n The nominal type does not include any this parameter,\n and (in the case of a constructor) will return void."}, {"method_name": "reflectAs", "method_sig": "<T extends Member> T reflectAs (Class<T> expected,\n                               MethodHandles.Lookup lookup)", "description": "Reflects the underlying member as a method, constructor, or field object.\n If the underlying member is public, it is reflected as if by\n getMethod, getConstructor, or getField.\n Otherwise, it is reflected as if by\n getDeclaredMethod, getDeclaredConstructor, or getDeclaredField.\n The underlying member must be accessible to the given lookup object."}, {"method_name": "getModifiers", "method_sig": "int getModifiers()", "description": "Returns the access modifiers of the underlying member."}, {"method_name": "isVarArgs", "method_sig": "default boolean isVarArgs()", "description": "Determines if the underlying member was a variable arity method or constructor.\n Such members are represented by method handles that are varargs collectors."}, {"method_name": "referenceKindToString", "method_sig": "static String referenceKindToString (int referenceKind)", "description": "Returns the descriptive name of the given reference kind,\n as defined in the table above.\n The conventional prefix \"REF_\" is omitted."}, {"method_name": "toString", "method_sig": "static String toString (int kind,\n                       Class<?> defc,\n                       String name,\n                       MethodType type)", "description": "Returns a string representation for a MethodHandleInfo,\n given the four parts of its symbolic reference.\n This is defined to be of the form \"RK C.N:MT\", where RK is the\n reference kind string for kind,\n C is the name of defc\nN is the name, and\n MT is the type.\n These four values may be obtained from the\n reference kind,\n declaring class,\n member name,\n and method type\n of a MethodHandleInfo object."}]}