{"name": "Class GapContent", "module": "java.desktop", "package": "javax.swing.text", "text": "An implementation of the AbstractDocument.Content interface\n implemented using a gapped buffer similar to that used by emacs.\n The underlying storage is a array of unicode characters with\n a gap somewhere.  The gap is moved to the location of changes\n to take advantage of common behavior where most changes are\n in the same location.  Changes that occur at a gap boundary are\n generally cheap and moving the gap is generally cheaper than\n moving the array contents directly to accommodate the change.\n \n The positions tracking change are also generally cheap to\n maintain.  The Position implementations (marks) store the array\n index and can easily calculate the sequential position from\n the current gap location.  Changes only require update to the\n the marks between the old and new gap boundaries when the gap\n is moved, so generally updating the marks is pretty cheap.\n The marks are stored sorted so they can be located quickly\n with a binary search.  This increases the cost of adding a\n mark, and decreases the cost of keeping the mark updated.", "codes": ["public class GapContent\nextends Object\nimplements AbstractDocument.Content, Serializable"], "fields": [], "methods": [{"method_name": "allocateArray", "method_sig": "protected Object allocateArray (int len)", "description": "Allocate an array to store items of the type\n appropriate (which is determined by the subclass)."}, {"method_name": "getArrayLength", "method_sig": "protected int getArrayLength()", "description": "Get the length of the allocated array."}, {"method_name": "length", "method_sig": "public int length()", "description": "Returns the length of the content."}, {"method_name": "insertString", "method_sig": "public UndoableEdit insertString (int where,\n                                 String str)\n                          throws BadLocationException", "description": "Inserts a string into the content."}, {"method_name": "remove", "method_sig": "public UndoableEdit remove (int where,\n                           int nitems)\n                    throws BadLocationException", "description": "Removes part of the content."}, {"method_name": "getString", "method_sig": "public String getString (int where,\n                        int len)\n                 throws BadLocationException", "description": "Retrieves a portion of the content."}, {"method_name": "getChars", "method_sig": "public void getChars (int where,\n                     int len,\n                     Segment chars)\n              throws BadLocationException", "description": "Retrieves a portion of the content.  If the desired content spans\n the gap, we copy the content.  If the desired content does not\n span the gap, the actual store is returned to avoid the copy since\n it is contiguous."}, {"method_name": "createPosition", "method_sig": "public Position createPosition (int offset)\n                        throws BadLocationException", "description": "Creates a position within the content that will\n track change as the content is mutated."}, {"method_name": "shiftEnd", "method_sig": "protected void shiftEnd (int newSize)", "description": "Make the gap bigger, moving any necessary data and updating\n the appropriate marks"}, {"method_name": "shiftGap", "method_sig": "protected void shiftGap (int newGapStart)", "description": "Move the start of the gap to a new location,\n without changing the size of the gap.  This\n moves the data in the array and updates the\n marks accordingly."}, {"method_name": "resetMarksAtZero", "method_sig": "protected void resetMarksAtZero()", "description": "Resets all the marks that have an offset of 0 to have an index of\n zero as well."}, {"method_name": "shiftGapStartDown", "method_sig": "protected void shiftGapStartDown (int newGapStart)", "description": "Adjust the gap end downward.  This doesn't move\n any data, but it does update any marks affected\n by the boundary change.  All marks from the old\n gap start down to the new gap start are squeezed\n to the end of the gap (their location has been\n removed)."}, {"method_name": "shiftGapEndUp", "method_sig": "protected void shiftGapEndUp (int newGapEnd)", "description": "Adjust the gap end upward.  This doesn't move\n any data, but it does update any marks affected\n by the boundary change. All marks from the old\n gap end up to the new gap end are squeezed\n to the end of the gap (their location has been\n removed)."}, {"method_name": "getPositionsInRange", "method_sig": "protected Vector getPositionsInRange (Vector v,\n                                     int offset,\n                                     int length)", "description": "Returns a Vector containing instances of UndoPosRef for the\n Positions in the range\n offset to offset + length.\n If v is not null the matching Positions are placed in\n there. The vector with the resulting Positions are returned."}, {"method_name": "updateUndoPositions", "method_sig": "protected void updateUndoPositions (Vector positions,\n                                   int offset,\n                                   int length)", "description": "Resets the location for all the UndoPosRef instances\n in positions.\n \n This is meant for internal usage, and is generally not of interest\n to subclasses."}, {"method_name": "getArray", "method_sig": "protected final Object getArray()", "description": "Access to the array.  The actual type\n of the array is known only by the subclass."}, {"method_name": "getGapStart", "method_sig": "protected final int getGapStart()", "description": "Access to the start of the gap."}, {"method_name": "getGapEnd", "method_sig": "protected final int getGapEnd()", "description": "Access to the end of the gap."}, {"method_name": "replace", "method_sig": "protected void replace (int position,\n                       int rmSize,\n                       Object addItems,\n                       int addSize)", "description": "Replace the given logical position in the storage with\n the given new items.  This will move the gap to the area\n being changed if the gap is not currently located at the\n change location."}]}