{"name": "Class CallSite", "module": "java.base", "package": "java.lang.invoke", "text": "A CallSite is a holder for a variable MethodHandle,\n which is called its target.\n An invokedynamic instruction linked to a CallSite delegates\n all calls to the site's current target.\n A CallSite may be associated with several invokedynamic\n instructions, or it may be \"free floating\", associated with none.\n In any case, it may be invoked through an associated method handle\n called its dynamic invoker.\n \nCallSite is an abstract class which does not allow\n direct subclassing by users.  It has three immediate,\n concrete subclasses that may be either instantiated or subclassed.\n \nIf a mutable target is not required, an invokedynamic instruction\n may be permanently bound by means of a constant call site.\n If a mutable target is required which has volatile variable semantics,\n because updates to the target must be immediately and reliably witnessed by other threads,\n a volatile call site may be used.\n Otherwise, if a mutable target is required,\n a mutable call site may be used.\n \n\n A non-constant call site may be relinked by changing its target.\n The new target must have the same type\n as the previous target.\n Thus, though a call site can be relinked to a series of\n successive targets, it cannot change its type.\n \n Here is a sample use of call sites and bootstrap methods which links every\n dynamic call site to print its arguments:\n\nstatic void test() throws Throwable {\n    // THE FOLLOWING LINE IS PSEUDOCODE FOR A JVM INSTRUCTION\n    InvokeDynamic[#bootstrapDynamic].baz(\"baz arg\", 2, 3.14);\n}\nprivate static void printArgs(Object... args) {\n  System.out.println(java.util.Arrays.deepToString(args));\n}\nprivate static final MethodHandle printArgs;\nstatic {\n  MethodHandles.Lookup lookup = MethodHandles.lookup();\n  Class thisClass = lookup.lookupClass();  // (who am I?)\n  printArgs = lookup.findStatic(thisClass,\n      \"printArgs\", MethodType.methodType(void.class, Object[].class));\n}\nprivate static CallSite bootstrapDynamic(MethodHandles.Lookup caller, String name, MethodType type) {\n  // ignore caller and name, but match the type:\n  return new ConstantCallSite(printArgs.asType(type));\n}\n", "codes": ["public abstract class CallSite\nextends Object"], "fields": [], "methods": [{"method_name": "type", "method_sig": "public MethodType type()", "description": "Returns the type of this call site's target.\n Although targets may change, any call site's type is permanent, and can never change to an unequal type.\n The setTarget method enforces this invariant by refusing any new target that does\n not have the previous target's type."}, {"method_name": "getTarget", "method_sig": "public abstract MethodHandle getTarget()", "description": "Returns the target method of the call site, according to the\n behavior defined by this call site's specific class.\n The immediate subclasses of CallSite document the\n class-specific behaviors of this method."}, {"method_name": "setTarget", "method_sig": "public abstract void setTarget (MethodHandle newTarget)", "description": "Updates the target method of this call site, according to the\n behavior defined by this call site's specific class.\n The immediate subclasses of CallSite document the\n class-specific behaviors of this method.\n \n The type of the new target must be equal to\n the type of the old target."}, {"method_name": "dynamicInvoker", "method_sig": "public abstract MethodHandle dynamicInvoker()", "description": "Produces a method handle equivalent to an invokedynamic instruction\n which has been linked to this call site.\n \n This method is equivalent to the following code:\n \n MethodHandle getTarget, invoker, result;\n getTarget = MethodHandles.publicLookup().bind(this, \"getTarget\", MethodType.methodType(MethodHandle.class));\n invoker = MethodHandles.exactInvoker(this.type());\n result = MethodHandles.foldArguments(invoker, getTarget)\n "}]}