{"name": "Interface CachedRowSet", "module": "java.sql.rowset", "package": "javax.sql.rowset", "text": "The interface that all standard implementations of\n CachedRowSet must implement.\n \n The reference implementation of the CachedRowSet interface provided\n by Oracle Corporation is a standard implementation. Developers may use this implementation\n just as it is, they may extend it, or they may choose to write their own implementations\n of this interface.\n \n A CachedRowSet object is a container for rows of data\n that caches its rows in memory, which makes it possible to operate without always being\n connected to its data source. Further, it is a\n JavaBeans\u2122 component and is scrollable,\n updatable, and serializable. A CachedRowSet object typically\n contains rows from a result set, but it can also contain rows from any file\n with a tabular format, such as a spread sheet.  The reference implementation\n supports getting data only from a ResultSet object, but\n developers can extend the SyncProvider implementations to provide\n access to other tabular data sources.\n \n An application can modify the data in a CachedRowSet object, and\n those modifications can then be propagated back to the source of the data.\n \n A CachedRowSet object is a disconnected rowset, which means\n that it makes use of a connection to its data source only briefly. It connects to its\n data source while it is reading data to populate itself with rows and again\n while it is propagating changes back to its underlying data source. The rest\n of the time, a CachedRowSet object is disconnected, including\n while its data is being modified. Being disconnected makes a RowSet\n object much leaner and therefore much easier to pass to another component.  For\n example, a disconnected RowSet object can be serialized and passed\n over the wire to a thin client such as a personal digital assistant (PDA).\n\n\n 1.0 Creating a CachedRowSet Object\n The following line of code uses the default constructor for\n CachedRowSet\n supplied in the reference implementation (RI) to create a default\n CachedRowSet object.\n \n     CachedRowSetImpl crs = new CachedRowSetImpl();\n \n This new CachedRowSet object will have its properties set to the\n default properties of a BaseRowSet object, and, in addition, it will\n have an RIOptimisticProvider object as its synchronization provider.\n RIOptimisticProvider, one of two SyncProvider\n implementations included in the RI, is the default provider that the\n SyncFactory singleton will supply when no synchronization\n provider is specified.\n \n A SyncProvider object provides a CachedRowSet object\n with a reader (a RowSetReader object) for reading data from a\n data source to populate itself with data. A reader can be implemented to read\n data from a ResultSet object or from a file with a tabular format.\n A SyncProvider object also provides\n a writer (a RowSetWriter object) for synchronizing any\n modifications to the CachedRowSet object's data made while it was\n disconnected with the data in the underlying data source.\n \n A writer can be implemented to exercise various degrees of care in checking\n for conflicts and in avoiding them.\n (A conflict occurs when a value in the data source has been changed after\n the rowset populated itself with that value.)\n The RIOptimisticProvider implementation assumes there will be\n few or no conflicts and therefore sets no locks. It updates the data source\n with values from the CachedRowSet object only if there are no\n conflicts.\n Other writers can be implemented so that they always write modified data to\n the data source, which can be accomplished either by not checking for conflicts\n or, on the other end of the spectrum, by setting locks sufficient to prevent data\n in the data source from being changed. Still other writer implementations can be\n somewhere in between.\n \n A CachedRowSet object may use any\n SyncProvider implementation that has been registered\n with the SyncFactory singleton. An application\n can find out which SyncProvider implementations have been\n registered by calling the following line of code.\n \n      java.util.Enumeration providers = SyncFactory.getRegisteredProviders();\n \n\n There are two ways for a CachedRowSet object to specify which\n SyncProvider object it will use.\n \nSupplying the name of the implementation to the constructor\n     The following line of code creates the CachedRowSet\n     object crs2 that is initialized with default values except that its\n     SyncProvider object is the one specified.\n     \n          CachedRowSetImpl crs2 = new CachedRowSetImpl(\n                                 \"com.fred.providers.HighAvailabilityProvider\");\n     \nSetting the SyncProvider using the CachedRowSet\n         method setSyncProvider\n      The following line of code resets the SyncProvider object\n      for crs, the CachedRowSet object created with the\n      default constructor.\n      \n           crs.setSyncProvider(\"com.fred.providers.HighAvailabilityProvider\");\n      \n\n See the comments for SyncFactory and SyncProvider for\n more details.\n\n\n 2.0 Retrieving Data from a CachedRowSet Object\n Data is retrieved from a CachedRowSet object by using the\n getter methods inherited from the ResultSet\n interface.  The following examples, in which crs is a\n CachedRowSet\n object, demonstrate how to iterate through the rows, retrieving the column\n values in each row.  The first example uses the version of the\n getter methods that take a column number; the second example\n uses the version that takes a column name. Column numbers are generally\n used when the RowSet object's command\n is of the form SELECT * FROM TABLENAME; column names are most\n commonly used when the command specifies columns by name.\n \n    while (crs.next()) {\n        String name = crs.getString(1);\n        int id = crs.getInt(2);\n        Clob comment = crs.getClob(3);\n        short dept = crs.getShort(4);\n        System.out.println(name + \"  \" + id + \"  \" + comment + \"  \" + dept);\n    }\n \n\n    while (crs.next()) {\n        String name = crs.getString(\"NAME\");\n        int id = crs.getInt(\"ID\");\n        Clob comment = crs.getClob(\"COM\");\n        short dept = crs.getShort(\"DEPT\");\n        System.out.println(name + \"  \" + id + \"  \" + comment + \"  \" + dept);\n    }\n \n2.1 Retrieving RowSetMetaData\n An application can get information about the columns in a CachedRowSet\n object by calling ResultSetMetaData and RowSetMetaData\n methods on a RowSetMetaData object. The following code fragment,\n in which crs is a CachedRowSet object, illustrates the process.\n The first line creates a RowSetMetaData object with information\n about the columns in crs.  The method getMetaData,\n inherited from the ResultSet interface, returns a\n ResultSetMetaData object, which is cast to a\n RowSetMetaData object before being assigned to the variable\n rsmd.  The second line finds out how many columns jrs has, and\n the third line gets the JDBC type of values stored in the second column of\n jrs.\n \n     RowSetMetaData rsmd = (RowSetMetaData)crs.getMetaData();\n     int count = rsmd.getColumnCount();\n     int type = rsmd.getColumnType(2);\n \n The RowSetMetaData interface differs from the\n ResultSetMetaData interface in two ways.\n \nIt includes setter methods: A RowSet\n   object uses these methods internally when it is populated with data from a\n   different ResultSet object.\n\n   It contains fewer getter methods: Some\n   ResultSetMetaData methods to not apply to a RowSet\n   object. For example, methods retrieving whether a column value is writable\n   or read only do not apply because all of a RowSet object's\n   columns will be writable or read only, depending on whether the rowset is\n   updatable or not.\n \n NOTE: In order to return a RowSetMetaData object, implementations must\n override the getMetaData() method defined in\n java.sql.ResultSet and return a RowSetMetaData object.\n\n 3.0 Updating a CachedRowSet Object\n Updating a CachedRowSet object is similar to updating a\n ResultSet object, but because the rowset is not connected to\n its data source while it is being updated, it must take an additional step\n to effect changes in its underlying data source. After calling the method\n updateRow or insertRow, a\n CachedRowSet\n object must also call the method acceptChanges to have updates\n written to the data source. The following example, in which the cursor is\n on a row in the CachedRowSet object crs, shows\n the code required to update two column values in the current row and also\n update the RowSet object's underlying data source.\n \n     crs.updateShort(3, 58);\n     crs.updateInt(4, 150000);\n     crs.updateRow();\n     crs.acceptChanges();\n \n\n The next example demonstrates moving to the insert row, building a new\n row on the insert row, inserting it into the rowset, and then calling the\n method acceptChanges to add the new row to the underlying data\n source.  Note that as with the getter methods, the  updater methods may take\n either a column index or a column name to designate the column being acted upon.\n \n     crs.moveToInsertRow();\n     crs.updateString(\"Name\", \"Shakespeare\");\n     crs.updateInt(\"ID\", 10098347);\n     crs.updateShort(\"Age\", 58);\n     crs.updateInt(\"Sal\", 150000);\n     crs.insertRow();\n     crs.moveToCurrentRow();\n     crs.acceptChanges();\n \n\n NOTE: Where the insertRow() method inserts the contents of a\n CachedRowSet object's insert row is implementation-defined.\n The reference implementation for the CachedRowSet interface\n inserts a new row immediately following the current row, but it could be\n implemented to insert new rows in any number of other places.\n \n Another thing to note about these examples is how they use the method\n acceptChanges.  It is this method that propagates changes in\n a CachedRowSet object back to the underlying data source,\n calling on the RowSet object's writer internally to write\n changes to the data source. To do this, the writer has to incur the expense\n of establishing a connection with that data source. The\n preceding two code fragments call the method acceptChanges\n immediately after calling updateRow or insertRow.\n However, when there are multiple rows being changed, it is more efficient to call\n acceptChanges after all calls to updateRow\n and insertRow have been made.  If acceptChanges\n is called only once, only one connection needs to be established.\n\n 4.0 Updating the Underlying Data Source\n When the method acceptChanges is executed, the\n CachedRowSet object's writer, a RowSetWriterImpl\n object, is called behind the scenes to write the changes made to the\n rowset to the underlying data source. The writer is implemented to make a\n connection to the data source and write updates to it.\n \n A writer is made available through an implementation of the\n SyncProvider interface, as discussed in section 1,\n \"Creating a CachedRowSet Object.\"\n The default reference implementation provider, RIOptimisticProvider,\n has its writer implemented to use an optimistic concurrency control\n mechanism. That is, it maintains no locks in the underlying database while\n the rowset is disconnected from the database and simply checks to see if there\n are any conflicts before writing data to the data source.  If there are any\n conflicts, it does not write anything to the data source.\n \n The reader/writer facility\n provided by the SyncProvider class is pluggable, allowing for the\n customization of data retrieval and updating. If a different concurrency\n control mechanism is desired, a different implementation of\n SyncProvider can be plugged in using the method\n setSyncProvider.\n \n In order to use the optimistic concurrency control routine, the\n RIOptimisticProvider maintains both its current\n value and its original value (the value it had immediately preceding the\n current value). Note that if no changes have been made to the data in a\n RowSet object, its current values and its original values are the same,\n both being the values with which the RowSet object was initially\n populated.  However, once any values in the RowSet object have been\n changed, the current values and the original values will be different, though at\n this stage, the original values are still the initial values. With any subsequent\n changes to data in a RowSet object, its original values and current\n values will still differ, but its original values will be the values that\n were previously the current values.\n \n Keeping track of original values allows the writer to compare the RowSet\n object's original value with the value in the database. If the values in\n the database differ from the RowSet object's original values, which means that\n the values in the database have been changed, there is a conflict.\n Whether a writer checks for conflicts, what degree of checking it does, and how\n it handles conflicts all depend on how it is implemented.\n\n 5.0 Registering and Notifying Listeners\n Being JavaBeans components, all rowsets participate in the JavaBeans event\n model, inheriting methods for registering listeners and notifying them of\n changes from the BaseRowSet class.  A listener for a\n CachedRowSet object is a component that wants to be notified\n whenever there is a change in the rowset.  For example, if a\n CachedRowSet object contains the results of a query and\n those\n results are being displayed in, say, a table and a bar graph, the table and\n bar graph could be registered as listeners with the rowset so that they can\n update themselves to reflect changes. To become listeners, the table and\n bar graph classes must implement the RowSetListener interface.\n Then they can be added to the CachedRowSet object's list of\n listeners, as is illustrated in the following lines of code.\n \n    crs.addRowSetListener(table);\n    crs.addRowSetListener(barGraph);\n \n Each CachedRowSet method that moves the cursor or changes\n data also notifies registered listeners of the changes, so\n table and barGraph will be notified when there is\n a change in crs.\n\n 6.0 Passing Data to Thin Clients\n One of the main reasons to use a CachedRowSet object is to\n pass data between different components of an application. Because it is\n serializable, a CachedRowSet object can be used, for example,\n to send the result of a query executed by an enterprise JavaBeans component\n running in a server environment over a network to a client running in a\n web browser.\n \n While a CachedRowSet object is disconnected, it can be much\n leaner than a ResultSet object with the same data.\n As a result, it can be especially suitable for sending data to a thin client\n such as a PDA, where it would be inappropriate to use a JDBC driver\n due to resource limitations or security considerations.\n Thus, a CachedRowSet object provides a means to \"get rows in\"\n without the need to implement the full JDBC API.\n\n 7.0 Scrolling and Updating\n A second major use for CachedRowSet objects is to provide\n scrolling and updating for ResultSet objects that\n do not provide these capabilities themselves.  In other words, a\n CachedRowSet object can be used to augment the\n capabilities of a JDBC technology-enabled driver (hereafter called a\n \"JDBC driver\") when the DBMS does not provide full support for scrolling and\n updating. To achieve the effect of making a non-scrollable and read-only\n ResultSet object scrollable and updatable, a programmer\n simply needs to create a CachedRowSet object populated\n with that ResultSet object's data.  This is demonstrated\n in the following code fragment, where stmt is a\n Statement object.\n \n    ResultSet rs = stmt.executeQuery(\"SELECT * FROM EMPLOYEES\");\n    CachedRowSetImpl crs = new CachedRowSetImpl();\n    crs.populate(rs);\n \n\n The object crs now contains the data from the table\n EMPLOYEES, just as the object rs does.\n The difference is that the cursor for crs can be moved\n forward, backward, or to a particular row even if the cursor for\n rs can move only forward.  In addition, crs is\n updatable even if rs is not because by default, a\n CachedRowSet object is both scrollable and updatable.\n \n In summary, a CachedRowSet object can be thought of as simply\n a disconnected set of rows that are being cached outside of a data source.\n Being thin and serializable, it can easily be sent across a wire,\n and it is well suited to sending data to a thin client. However, a\n CachedRowSet object does have a limitation: It is limited in\n size by the amount of data it can store in memory at one time.\n\n 8.0 Getting Universal Data Access\n Another advantage of the CachedRowSet class is that it makes it\n possible to retrieve and store data from sources other than a relational\n database. The reader for a rowset can be implemented to read and populate\n its rowset with data from any tabular data source, including a spreadsheet\n or flat file.\n Because both a CachedRowSet object and its metadata can be\n created from scratch, a component that acts as a factory for rowsets\n can use this capability to create a rowset containing data from\n non-SQL data sources. Nevertheless, it is expected that most of the time,\n CachedRowSet objects will contain data that was fetched\n from an SQL database using the JDBC API.\n\n 9.0 Setting Properties\n All rowsets maintain a set of properties, which will usually be set using\n a tool.  The number and kinds of properties a rowset has will vary,\n depending on what the rowset does and how it gets its data.  For example,\n rowsets that get their data from a ResultSet object need to\n set the properties that are required for making a database connection.\n If a rowset uses the DriverManager facility to make a\n connection, it needs to set a property for the JDBC URL that identifies\n the appropriate driver, and it needs to set the properties that give the\n user name and password.\n If, on the other hand, the rowset uses a DataSource object\n to make the connection, which is the preferred method, it does not need to\n set the property for the JDBC URL.  Instead, it needs to set\n properties for the logical name of the data source, for the user name,\n and for the password.\n \n NOTE:  In order to use a DataSource object for making a\n connection, the DataSource object must have been registered\n with a naming service that uses the Java Naming and Directory\n Interface\u2122 (JNDI) API.  This registration\n is usually done by a person acting in the capacity of a system\n administrator.\n \n In order to be able to populate itself with data from a database, a rowset\n needs to set a command property.  This property is a query that is a\n PreparedStatement object, which allows the query to have\n parameter placeholders that are set at run time, as opposed to design time.\n To set these placeholder parameters with values, a rowset provides\n setter methods for setting values of each data type,\n similar to the setter methods provided by the PreparedStatement\n interface.\n \n The following code fragment illustrates how the CachedRowSet\n object crs might have its command property set.  Note that if a\n tool is used to set properties, this is the code that the tool would use.\n \n    crs.setCommand(\"SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS \" +\n                   \"WHERE CREDIT_LIMIT > ? AND REGION = ?\");\n  \n\n The values that will be used to set the command's placeholder parameters are\n contained in the RowSet object's params field, which is a\n Vector object.\n The CachedRowSet class provides a set of setter\n methods for setting the elements in its params field.  The\n following code fragment demonstrates setting the two parameters in the\n query from the previous example.\n \n    crs.setInt(1, 5000);\n    crs.setString(2, \"West\");\n \n\n The params field now contains two elements, each of which is\n an array two elements long.  The first element is the parameter number;\n the second is the value to be set.\n In this case, the first element of params is\n 1, 5000, and the second element is 2,\n \"West\".  When an application calls the method\n execute, it will in turn call on this RowSet object's reader,\n which will in turn invoke its readData method. As part of\n its implementation, readData will get the values in\n params and use them to set the command's placeholder\n parameters.\n The following code fragment gives an idea of how the reader\n does this, after obtaining the Connection object\n con.\n \n    PreparedStatement pstmt = con.prepareStatement(crs.getCommand());\n    reader.decodeParams();\n    // decodeParams figures out which setter methods to use and does something\n    // like the following:\n    //    for (i = 0; i < params.length; i++) {\n    //        pstmt.setObject(i + 1, params[i]);\n    //    }\n \n\n At this point, the command for crs is the query \"SELECT\n FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS WHERE CREDIT_LIMIT > 5000\n AND REGION = \"West\".  After the readData method executes\n this command with the following line of code, it will have the data from\n rs with which to populate crs.\n \n     ResultSet rs = pstmt.executeQuery();\n \n\n The preceding code fragments give an idea of what goes on behind the\n scenes; they would not appear in an application, which would not invoke\n methods like readData and decodeParams.\n In contrast, the following code fragment shows what an application might do.\n It sets the rowset's command, sets the command's parameters, and executes\n the command. Simply by calling the execute method,\n crs populates itself with the requested data from the\n table CUSTOMERS.\n \n    crs.setCommand(\"SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS\" +\n                   \"WHERE CREDIT_LIMIT > ? AND REGION = ?\");\n    crs.setInt(1, 5000);\n    crs.setString(2, \"West\");\n    crs.execute();\n \n10.0 Paging Data\n Because a CachedRowSet object stores data in memory,\n the amount of data that it can contain at any one\n time is determined by the amount of memory available. To get around this limitation,\n a CachedRowSet object can retrieve data from a ResultSet\n object in chunks of data, called pages. To take advantage of this mechanism,\n an application sets the number of rows to be included in a page using the method\n setPageSize. In other words, if the page size is set to five, a chunk\n of five rows of\n data will be fetched from the data source at one time. An application can also\n optionally set the maximum number of rows that may be fetched at one time.  If the\n maximum number of rows is set to zero, or no maximum number of rows is set, there is\n no limit to the number of rows that may be fetched at a time.\n \n After properties have been set,\n the CachedRowSet object must be populated with data\n using either the method populate or the method execute.\n The following lines of code demonstrate using the method populate.\n Note that this version of the method takes two parameters, a ResultSet\n handle and the row in the ResultSet object from which to start\n retrieving rows.\n \n     CachedRowSet crs = new CachedRowSetImpl();\n     crs.setMaxRows(20);\n     crs.setPageSize(4);\n     crs.populate(rsHandle, 10);\n \n When this code runs, crs will be populated with four rows from\n rsHandle starting with the tenth row.\n \n The next code fragment shows populating a CachedRowSet object using the\n method execute, which may or may not take a Connection\n object as a parameter.  This code passes execute the Connection\n object conHandle.\n \n Note that there are two differences between the following code\n fragment and the previous one. First, the method setMaxRows is not\n called, so there is no limit set for the number of rows that crs may contain.\n (Remember that crs always has the overriding limit of how much data it can\n store in memory.) The second difference is that the you cannot pass the method\n execute the number of the row in the ResultSet object\n from which to start retrieving rows. This method always starts with the first row.\n \n     CachedRowSet crs = new CachedRowSetImpl();\n     crs.setPageSize(5);\n     crs.execute(conHandle);\n \n After this code has run, crs will contain five rows of data from the\n ResultSet object produced by the command for crs. The writer\n for crs will use conHandle to connect to the data source and\n execute the command for crs. An application is then able to operate on the\n data in crs in the same way that it would operate on data in any other\n CachedRowSet object.\n \n To access the next page (chunk of data), an application calls the method\n nextPage.  This method creates a new CachedRowSet object\n and fills it with the next page of data.  For example, assume that the\n CachedRowSet object's command returns a ResultSet object\n rs with 1000 rows of data.  If the page size has been set to 100, the first\n  call to the method nextPage will create a CachedRowSet object\n containing the first 100 rows of rs. After doing what it needs to do with the\n data in these first 100 rows, the application can again call the method\n nextPage to create another CachedRowSet object\n with the second 100 rows from rs. The data from the first CachedRowSet\n object will no longer be in memory because it is replaced with the data from the\n second CachedRowSet object. After the tenth call to the method nextPage,\n the tenth CachedRowSet object will contain the last 100 rows of data from\n rs, which are stored in memory. At any given time, the data from only one\n CachedRowSet object is stored in memory.\n \n The method nextPage returns true as long as the current\n page is not the last page of rows and false when there are no more pages.\n It can therefore be used in a while loop to retrieve all of the pages,\n as is demonstrated in the following lines of code.\n \n     CachedRowSet crs = CachedRowSetImpl();\n     crs.setPageSize(100);\n     crs.execute(conHandle);\n\n     while(crs.nextPage()) {\n         while(crs.next()) {\n             . . . // operate on chunks (of 100 rows each) in crs,\n                   // row by row\n         }\n     }\n \n After this code fragment has been run, the application will have traversed all\n 1000 rows, but it will have had no more than 100 rows in memory at a time.\n \n The CachedRowSet interface also defines the method previousPage.\n Just as the method nextPage is analogous to the ResultSet\n method next, the method previousPage is analogous to\n the ResultSet method previous.  Similar to the method\n nextPage, previousPage creates a CachedRowSet\n object containing the number of rows set as the page size.  So, for instance, the\n method previousPage could be used in a while loop at\n the end of the preceding code fragment to navigate back through the pages from the last\n page to the first page.\n The method previousPage is also similar to nextPage\n in that it can be used in a while\n loop, except that it returns true as long as there is another page\n preceding it and false when there are no more pages ahead of it.\n \n By positioning the cursor after the last row for each page,\n as is done in the following code fragment, the method previous\n navigates from the last row to the first row in each page.\n The code could also have left the cursor before the first row on each page and then\n used the method next in a while loop to navigate each page\n from the first row to the last row.\n \n The following code fragment assumes a continuation from the previous code fragment,\n meaning that the cursor for the tenth CachedRowSet object is on the\n last row.  The code moves the cursor to after the last row so that the first\n call to the method previous will put the cursor back on the last row.\n After going through all of the rows in the last page (the CachedRowSet\n object crs), the code then enters\n the while loop to get to the ninth page, go through the rows backwards,\n go to the eighth page, go through the rows backwards, and so on to the first row\n of the first page.\n\n \n     crs.afterLast();\n     while(crs.previous())  {\n         . . . // navigate through the rows, last to first\n     {\n     while(crs.previousPage())  {\n         crs.afterLast();\n         while(crs.previous())  {\n             . . . // go from the last row to the first row of each page\n         }\n     }\n ", "codes": ["public interface CachedRowSet\nextends RowSet, Joinable"], "fields": [{"field_name": "COMMIT_ON_ACCEPT_CHANGES", "field_sig": "@Deprecated\nstatic final\u00a0boolean COMMIT_ON_ACCEPT_CHANGES", "description": "Causes the CachedRowSet object's SyncProvider\n to commit the changes when acceptChanges() is called. If\n set to false, the changes will not be committed until one of the\n CachedRowSet interface transaction methods is called."}], "methods": [{"method_name": "populate", "method_sig": "void populate (ResultSet data)\n       throws SQLException", "description": "Populates this CachedRowSet object with data from\n the given ResultSet object.\n \n This method can be used as an alternative to the execute method when an\n application has a connection to an open ResultSet object.\n Using the method populate can be more efficient than using\n the version of the execute method that takes no parameters\n because it does not open a new connection and re-execute this\n CachedRowSet object's command. Using the populate\n method is more a matter of convenience when compared to using the version\n of execute that takes a ResultSet object."}, {"method_name": "execute", "method_sig": "void execute (Connection conn)\n      throws SQLException", "description": "Populates this CachedRowSet object with data, using the\n given connection to produce the result set from which the data will be read.\n This method should close any database connections that it creates to\n ensure that this CachedRowSet object is disconnected except when\n it is reading data from its data source or writing data to its data source.\n \n The reader for this CachedRowSet object\n will use conn to establish a connection to the data source\n so that it can execute the rowset's command and read data from the\n the resulting ResultSet object into this\n CachedRowSet object. This method also closes conn\n after it has populated this CachedRowSet object.\n \n If this method is called when an implementation has already been\n populated, the contents and the metadata are (re)set. Also, if this method is\n called before the method acceptChanges has been called\n to commit outstanding updates, those updates are lost."}, {"method_name": "acceptChanges", "method_sig": "void acceptChanges()\n            throws SyncProviderException", "description": "Propagates row update, insert and delete changes made to this\n CachedRowSet object to the underlying data source.\n \n This method calls on this CachedRowSet object's writer\n to do the work behind the scenes.\n Standard CachedRowSet implementations should use the\n SyncFactory singleton\n to obtain a SyncProvider instance providing a\n RowSetWriter object (writer).  The writer will attempt\n to propagate changes made in this CachedRowSet object\n back to the data source.\n \n When the method acceptChanges executes successfully, in\n addition to writing changes to the data source, it\n makes the values in the current row be the values in the original row.\n \n Depending on the synchronization level of the SyncProvider\n implementation being used, the writer will compare the original values\n with those in the data source to check for conflicts. When there is a conflict,\n the RIOptimisticProvider implementation, for example, throws a\n SyncProviderException and does not write anything to the\n data source.\n \n An application may choose to catch the SyncProviderException\n object and retrieve the SyncResolver object it contains.\n The SyncResolver object lists the conflicts row by row and\n sets a lock on the data source to avoid further conflicts while the\n current conflicts are being resolved.\n Further, for each conflict, it provides methods for examining the conflict\n and setting the value that should be persisted in the data source.\n After all conflicts have been resolved, an application must call the\n acceptChanges method again to write resolved values to the\n data source.  If all of the values in the data source are already the\n values to be persisted, the method acceptChanges does nothing.\n \n Some provider implementations may use locks to ensure that there are no\n conflicts.  In such cases, it is guaranteed that the writer will succeed in\n writing changes to the data source when the method acceptChanges\n is called.  This method may be called immediately after the methods\n updateRow, insertRow, or deleteRow\n have been called, but it is more efficient to call it only once after\n all changes have been made so that only one connection needs to be\n established.\n \n Note: The acceptChanges() method will determine if the\n COMMIT_ON_ACCEPT_CHANGES is set to true or not. If it is set\n to true, all updates in the synchronization are committed to the data\n source. Otherwise, the application must explicitly call the\n commit() or rollback() methods as appropriate."}, {"method_name": "acceptChanges", "method_sig": "void acceptChanges (Connection con)\n            throws SyncProviderException", "description": "Propagates all row update, insert and delete changes to the\n data source backing this CachedRowSet object\n using the specified Connection object to establish a\n connection to the data source.\n \n The other version of the acceptChanges method is not passed\n a connection because it uses\n the Connection object already defined within the RowSet\n object, which is the connection used for populating it initially.\n \n This form of the method acceptChanges is similar to the\n form that takes no arguments; however, unlike the other form, this form\n can be used only when the underlying data source is a JDBC data source.\n The updated Connection properties must be used by the\n SyncProvider to reset the RowSetWriter\n configuration to ensure that the contents of the CachedRowSet\n object are synchronized correctly.\n \n When the method acceptChanges executes successfully, in\n addition to writing changes to the data source, it\n makes the values in the current row be the values in the original row.\n \n Depending on the synchronization level of the SyncProvider\n implementation being used, the writer will compare the original values\n with those in the data source to check for conflicts. When there is a conflict,\n the RIOptimisticProvider implementation, for example, throws a\n SyncProviderException and does not write anything to the\n data source.\n \n An application may choose to catch the SyncProviderException\n object and retrieve the SyncResolver object it contains.\n The SyncResolver object lists the conflicts row by row and\n sets a lock on the data source to avoid further conflicts while the\n current conflicts are being resolved.\n Further, for each conflict, it provides methods for examining the conflict\n and setting the value that should be persisted in the data source.\n After all conflicts have been resolved, an application must call the\n acceptChanges method again to write resolved values to the\n data source.  If all of the values in the data source are already the\n values to be persisted, the method acceptChanges does nothing.\n \n Some provider implementations may use locks to ensure that there are no\n conflicts.  In such cases, it is guaranteed that the writer will succeed in\n writing changes to the data source when the method acceptChanges\n is called.  This method may be called immediately after the methods\n updateRow, insertRow, or deleteRow\n have been called, but it is more efficient to call it only once after\n all changes have been made so that only one connection needs to be\n established.\n \n Note: The acceptChanges() method will determine if the\n COMMIT_ON_ACCEPT_CHANGES is set to true or not. If it is set\n to true, all updates in the synchronization are committed to the data\n source. Otherwise, the application must explicitly call the\n commit or rollback methods as appropriate."}, {"method_name": "restoreOriginal", "method_sig": "void restoreOriginal()\n              throws SQLException", "description": "Restores this CachedRowSet object to its original\n value, that is, its value before the last set of changes. If there\n have been no changes to the rowset or only one set of changes,\n the original value is the value with which this CachedRowSet object\n was populated; otherwise, the original value is\n the value it had immediately before its current value.\n \n When this method is called, a CachedRowSet implementation\n must ensure that all updates, inserts, and deletes to the current\n rowset instance are replaced by the previous values. In addition,\n the cursor should be\n reset to the first row and a rowSetChanged event\n should be fired to notify all registered listeners."}, {"method_name": "release", "method_sig": "void release()\n      throws SQLException", "description": "Releases the current contents of this CachedRowSet\n object and sends a rowSetChanged event to all\n registered listeners. Any outstanding updates are discarded and\n the rowset contains no rows after this method is called. There\n are no interactions with the underlying data source, and any rowset\n content, metadata, and content updates should be non-recoverable.\n \n This CachedRowSet object should lock until its contents and\n associated updates are fully cleared, thus preventing 'dirty' reads by\n other components that hold a reference to this RowSet object.\n In addition, the contents cannot be released\n until all components reading this CachedRowSet object\n have completed their reads. This CachedRowSet object\n should be returned to normal behavior after firing the\n rowSetChanged event.\n \n The metadata, including JDBC properties and Synchronization SPI\n properties, are maintained for future use. It is important that\n properties such as the command property be\n relevant to the originating data source from which this CachedRowSet\n object was originally established.\n \n This method empties a rowset, as opposed to the close method,\n which marks the entire rowset as recoverable to allow the garbage collector\n the rowset's Java VM resources."}, {"method_name": "undoDelete", "method_sig": "void undoDelete()\n         throws SQLException", "description": "Cancels the deletion of the current row and notifies listeners that\n a row has changed. After this method is called, the current row is\n no longer marked for deletion. This method can be called at any\n time during the lifetime of the rowset.\n \n In addition, multiple cancellations of row deletions can be made\n by adjusting the position of the cursor using any of the cursor\n position control methods such as:\n \nCachedRowSet.absolute\nCachedRowSet.first\nCachedRowSet.last\n"}, {"method_name": "undoInsert", "method_sig": "void undoInsert()\n         throws SQLException", "description": "Immediately removes the current row from this CachedRowSet\n object if the row has been inserted, and also notifies listeners that a\n row has changed. This method can be called at any time during the\n lifetime of a rowset and assuming the current row is within\n the exception limitations (see below), it cancels the row insertion\n of the current row.\n \n In addition, multiple cancellations of row insertions can be made\n by adjusting the position of the cursor using any of the cursor\n position control methods such as:\n \nCachedRowSet.absolute\nCachedRowSet.first\nCachedRowSet.last\n"}, {"method_name": "undoUpdate", "method_sig": "void undoUpdate()\n         throws SQLException", "description": "Immediately reverses the last update operation if the\n row has been modified. This method can be\n called to reverse updates on all columns until all updates in a row have\n been rolled back to their state just prior to the last synchronization\n (acceptChanges) or population. This method may also be called\n while performing updates to the insert row.\n \nundoUpdate may be called at any time during the lifetime of a\n rowset; however, after a synchronization has occurred, this method has no\n effect until further modification to the rowset data has occurred."}, {"method_name": "columnUpdated", "method_sig": "boolean columnUpdated (int idx)\n               throws SQLException", "description": "Indicates whether the designated column in the current row of this\n CachedRowSet object has been updated."}, {"method_name": "columnUpdated", "method_sig": "boolean columnUpdated (String columnName)\n               throws SQLException", "description": "Indicates whether the designated column in the current row of this\n CachedRowSet object has been updated."}, {"method_name": "toCollection", "method_sig": "Collection<?> toCollection()\n                    throws SQLException", "description": "Converts this CachedRowSet object to a Collection\n object that contains all of this CachedRowSet object's data.\n Implementations have some latitude in\n how they can represent this Collection object because of the\n abstract nature of the Collection framework.\n Each row must be fully represented in either a\n general purpose Collection implementation or a specialized\n Collection implementation, such as a TreeMap\n object or a Vector object.\n An SQL NULL column value must be represented as a null\n in the Java programming language.\n \n The standard reference implementation for the CachedRowSet\n interface uses a TreeMap object for the rowset, with the\n values in each row being contained in  Vector objects. It is\n expected that most implementations will do the same.\n \n The TreeMap type of collection guarantees that the map will be in\n ascending key order, sorted according to the natural order for the\n key's class.\n Each key references a Vector object that corresponds to one\n row of a RowSet object. Therefore, the size of each\n Vector object  must be exactly equal to the number of\n columns in the RowSet object.\n The key used by the TreeMap collection is determined by the\n implementation, which may choose to leverage a set key that is\n available within the internal RowSet tabular structure by\n virtue of a key already set either on the RowSet object\n itself or on the underlying SQL data."}, {"method_name": "toCollection", "method_sig": "Collection<?> toCollection (int column)\n                    throws SQLException", "description": "Converts the designated column in this CachedRowSet object\n to a Collection object. Implementations have some latitude in\n how they can represent this Collection object because of the\n abstract nature of the Collection framework.\n Each column value should be fully represented in either a\n general purpose Collection implementation or a specialized\n Collection implementation, such as a Vector object.\n An SQL NULL column value must be represented as a null\n in the Java programming language.\n \n The standard reference implementation uses a Vector object\n to contain the column values, and it is expected\n that most implementations will do the same. If a Vector object\n is used, it size must be exactly equal to the number of rows\n in this CachedRowSet object."}, {"method_name": "toCollection", "method_sig": "Collection<?> toCollection (String column)\n                    throws SQLException", "description": "Converts the designated column in this CachedRowSet object\n to a Collection object. Implementations have some latitude in\n how they can represent this Collection object because of the\n abstract nature of the Collection framework.\n Each column value should be fully represented in either a\n general purpose Collection implementation or a specialized\n Collection implementation, such as a Vector object.\n An SQL NULL column value must be represented as a null\n in the Java programming language.\n \n The standard reference implementation uses a Vector object\n to contain the column values, and it is expected\n that most implementations will do the same. If a Vector object\n is used, it size must be exactly equal to the number of rows\n in this CachedRowSet object."}, {"method_name": "getSyncProvider", "method_sig": "SyncProvider getSyncProvider()\n                      throws SQLException", "description": "Retrieves the SyncProvider implementation for this\n CachedRowSet object. Internally, this method is used by a rowset\n to trigger read or write actions between the rowset\n and the data source. For example, a rowset may need to get a handle\n on the rowset reader (RowSetReader object) from the\n SyncProvider to allow the rowset to be populated.\n \n     RowSetReader rowsetReader = null;\n     SyncProvider provider =\n         SyncFactory.getInstance(\"javax.sql.rowset.provider.RIOptimisticProvider\");\n         if (provider instanceof RIOptimisticProvider) {\n             rowsetReader = provider.getRowSetReader();\n         }\n \n Assuming rowsetReader is a private, accessible field within\n the rowset implementation, when an application calls the execute\n method, it in turn calls on the reader's readData method\n to populate the RowSet object.\n\n     rowsetReader.readData((RowSetInternal)this);\n \n\n In addition, an application can use the SyncProvider object\n returned by this method to call methods that return information about the\n SyncProvider object, including information about the\n vendor, version, provider identification, synchronization grade, and locks\n it currently has set."}, {"method_name": "setSyncProvider", "method_sig": "void setSyncProvider (String provider)\n              throws SQLException", "description": "Sets the SyncProvider object for this CachedRowSet\n object to the one specified.  This method\n allows the SyncProvider object to be reset.\n \n A CachedRowSet implementation should always be instantiated\n with an available SyncProvider mechanism, but there are\n cases where resetting the SyncProvider object is desirable\n or necessary. For example, an application might want to use the default\n SyncProvider object for a time and then choose to use a provider\n that has more recently become available and better fits its needs.\n \n Resetting the SyncProvider object causes the\n RowSet object to request a new SyncProvider implementation\n from the SyncFactory. This has the effect of resetting\n all previous connections and relationships with the originating\n data source and can potentially drastically change the synchronization\n behavior of a disconnected rowset."}, {"method_name": "size", "method_sig": "int size()", "description": "Returns the number of rows in this CachedRowSet\n object."}, {"method_name": "setMetaData", "method_sig": "void setMetaData (RowSetMetaData md)\n          throws SQLException", "description": "Sets the metadata for this CachedRowSet object with\n the given RowSetMetaData object. When a\n RowSetReader object is reading the contents of a rowset,\n it creates a RowSetMetaData object and initializes\n it using the methods in the RowSetMetaData implementation.\n The reference implementation uses the RowSetMetaDataImpl\n class. When the reader has completed reading the rowset contents,\n this method is called internally to pass the RowSetMetaData\n object to the rowset."}, {"method_name": "getOriginal", "method_sig": "ResultSet getOriginal()\n               throws SQLException", "description": "Returns a ResultSet object containing the original value of this\n CachedRowSet object.\n \n The cursor for the ResultSet\n object should be positioned before the first row.\n In addition, the returned ResultSet object should have the following\n properties:\n \nResultSet.TYPE_SCROLL_INSENSITIVE\n ResultSet.CONCUR_UPDATABLE\n \n\n The original value for a RowSet object is the value it had before\n the last synchronization with the underlying data source.  If there have been\n no synchronizations, the original value will be the value with which the\n RowSet object was populated.  This method is called internally\n when an application calls the method acceptChanges and the\n SyncProvider object has been implemented to check for conflicts.\n If this is the case, the writer compares the original value with the value\n currently in the data source to check for conflicts."}, {"method_name": "getOriginalRow", "method_sig": "ResultSet getOriginalRow()\n                  throws SQLException", "description": "Returns a ResultSet object containing the original value for the\n current row only of this CachedRowSet object.\n \n The cursor for the ResultSet\n object should be positioned before the first row.\n In addition, the returned ResultSet object should have the following\n properties:\n \nResultSet.TYPE_SCROLL_INSENSITIVE\n ResultSet.CONCUR_UPDATABLE\n "}, {"method_name": "setOriginalRow", "method_sig": "void setOriginalRow()\n             throws SQLException", "description": "Sets the current row in this CachedRowSet object as the original\n row.\n \n This method is called internally after the any modified values in the current\n row have been synchronized with the data source. The current row must be tagged\n as no longer inserted, deleted or updated.\n \n A call to setOriginalRow is irreversible."}, {"method_name": "getTableName", "method_sig": "String getTableName()\n             throws SQLException", "description": "Returns an identifier for the object (table) that was used to\n create this CachedRowSet object. This name may be set on multiple occasions,\n and the specification imposes no limits on how many times this\n may occur or whether standard implementations should keep track\n of previous table names."}, {"method_name": "setTableName", "method_sig": "void setTableName (String tabName)\n           throws SQLException", "description": "Sets the identifier for the table from which this CachedRowSet\n object was derived to the given table name. The writer uses this name to\n determine which table to use when comparing the values in the data source with the\n CachedRowSet object's values during a synchronization attempt.\n The table identifier also indicates where modified values from this\n CachedRowSet object should be written.\n \n The implementation of this CachedRowSet object may obtain the\n the name internally from the RowSetMetaDataImpl object."}, {"method_name": "getKeyColumns", "method_sig": "int[] getKeyColumns()\n             throws SQLException", "description": "Returns an array containing one or more column numbers indicating the columns\n that form a key that uniquely\n identifies a row in this CachedRowSet object."}, {"method_name": "setKeyColumns", "method_sig": "void setKeyColumns (int[] keys)\n            throws SQLException", "description": "Sets this CachedRowSet object's keyCols\n field with the given array of column numbers, which forms a key\n for uniquely identifying a row in this CachedRowSet object.\n \n If a CachedRowSet object becomes part of a JoinRowSet\n object, the keys defined by this method and the resulting constraints are\n maintained if the columns designated as key columns also become match\n columns."}, {"method_name": "createShared", "method_sig": "RowSet createShared()\n             throws SQLException", "description": "Returns a new RowSet object backed by the same data as\n that of this CachedRowSet object. In effect, both\n CachedRowSet objects have a cursor over the same data.\n As a result, any changes made by a duplicate are visible to the original\n and to any other duplicates, just as a change made by the original is visible\n to all of its duplicates. If a duplicate calls a method that changes the\n underlying data, the method it calls notifies all registered listeners\n just as it would when it is called by the original CachedRowSet\n object.\n \n In addition, any RowSet object\n created by this method will have the same properties as this\n CachedRowSet object. For example, if this CachedRowSet\n object is read-only, all of its duplicates will also be read-only. If it is\n changed to be updatable, the duplicates also become updatable.\n \n NOTE: If multiple threads access RowSet objects created from\n the createShared() method, the following behavior is specified\n to preserve shared data integrity: reads and writes of all\n shared RowSet objects should be made serially between each\n object and the single underlying tabular structure."}, {"method_name": "createCopy", "method_sig": "CachedRowSet createCopy()\n                 throws SQLException", "description": "Creates a RowSet object that is a deep copy of the data in\n this CachedRowSet object. In contrast to\n the RowSet object generated from a createShared\n call, updates made to the copy of the original RowSet object\n must not be visible to the original RowSet object. Also, any\n event listeners that are registered with the original\n RowSet must not have scope over the new\n RowSet copies. In addition, any constraint restrictions\n established must be maintained."}, {"method_name": "createCopySchema", "method_sig": "CachedRowSet createCopySchema()\n                       throws SQLException", "description": "Creates a CachedRowSet object that is an empty copy of this\n CachedRowSet object.  The copy\n must not contain any contents but only represent the table\n structure of the original CachedRowSet object. In addition, primary\n or foreign key constraints set in the originating CachedRowSet object must\n be equally enforced in the new empty CachedRowSet object.\n In contrast to\n the RowSet object generated from a createShared method\n call, updates made to a copy of this CachedRowSet object with the\n createCopySchema method must not be visible to it.\n \n Applications can form a WebRowSet object from the CachedRowSet\n object returned by this method in order\n to export the RowSet schema definition to XML for future use."}, {"method_name": "createCopyNoConstraints", "method_sig": "CachedRowSet createCopyNoConstraints()\n                              throws SQLException", "description": "Creates a CachedRowSet object that is a deep copy of\n this CachedRowSet object's data but is independent of it.\n In contrast to\n the RowSet object generated from a createShared\n method call, updates made to a copy of this CachedRowSet object\n must not be visible to it. Also, any\n event listeners that are registered with this\n CachedRowSet object must not have scope over the new\n RowSet object. In addition, any constraint restrictions\n established for this CachedRowSet object must not be maintained\n in the copy."}, {"method_name": "getRowSetWarnings", "method_sig": "RowSetWarning getRowSetWarnings()\n                         throws SQLException", "description": "Retrieves the first warning reported by calls on this RowSet object.\n Subsequent warnings on this RowSet object will be chained to the\n RowSetWarning object that this method returns.\n\n The warning chain is automatically cleared each time a new row is read.\n This method may not be called on a RowSet object that has been closed;\n doing so will cause a SQLException to be thrown."}, {"method_name": "getShowDeleted", "method_sig": "boolean getShowDeleted()\n                throws SQLException", "description": "Retrieves a boolean indicating whether rows marked\n for deletion appear in the set of current rows. If true is\n returned, deleted rows are visible with the current rows. If\n false is returned, rows are not visible with the set of\n current rows. The default value is false.\n \n Standard rowset implementations may choose to restrict this behavior\n due to security considerations or to better fit certain deployment\n scenarios. This is left as implementation defined and does not\n represent standard behavior.\n \n Note: Allowing deleted rows to remain visible complicates the behavior\n of some standard JDBC RowSet Implementations methods.\n However, most rowset users can simply ignore this extra detail because\n only very specialized applications will likely want to take advantage of\n this feature."}, {"method_name": "setShowDeleted", "method_sig": "void setShowDeleted (boolean b)\n             throws SQLException", "description": "Sets the property showDeleted to the given\n boolean value, which determines whether\n rows marked for deletion appear in the set of current rows.\n If the value is set to true, deleted rows are immediately\n visible with the set of current rows. If the value is set to\n false, the deleted rows are set as invisible with the\n current set of rows.\n \n Standard rowset implementations may choose to restrict this behavior\n due to security considerations or to better fit certain deployment\n scenarios. This is left as implementations defined and does not\n represent standard behavior."}, {"method_name": "commit", "method_sig": "void commit()\n     throws SQLException", "description": "Each CachedRowSet object's SyncProvider contains\n a Connection object from the ResultSet or JDBC\n properties passed to it's constructors. This method wraps the\n Connection commit method to allow flexible\n auto commit or non auto commit transactional control support.\n \n Makes all changes that are performed by the acceptChanges()\n method since the previous commit/rollback permanent. This method should\n be used only when auto-commit mode has been disabled."}, {"method_name": "rollback", "method_sig": "void rollback()\n       throws SQLException", "description": "Each CachedRowSet object's SyncProvider contains\n a Connection object from the original ResultSet\n or JDBC properties passed to it.\n \n Undoes all changes made in the current transaction.  This method\n should be used only when auto-commit mode has been disabled."}, {"method_name": "rollback", "method_sig": "void rollback (Savepoint s)\n       throws SQLException", "description": "Each CachedRowSet object's SyncProvider contains\n a Connection object from the original ResultSet\n or JDBC properties passed to it.\n \n Undoes all changes made in the current transaction back to the last\n Savepoint transaction marker. This method should be used only\n when auto-commit mode has been disabled."}, {"method_name": "rowSetPopulated", "method_sig": "void rowSetPopulated (RowSetEvent event,\n                     int numRows)\n              throws SQLException", "description": "Notifies registered listeners that a RowSet object in the given RowSetEvent\n object has populated a number of additional rows. The numRows parameter\n ensures that this event will only be fired every numRow.\n \n The source of the event can be retrieved with the method event.getSource."}, {"method_name": "populate", "method_sig": "void populate (ResultSet rs,\n              int startRow)\n       throws SQLException", "description": "Populates this CachedRowSet object with data from\n the given ResultSet object. While related to the populate(ResultSet)\n method, an additional parameter is provided to allow starting position within\n the ResultSet from where to populate the CachedRowSet\n instance.\n \n This method can be used as an alternative to the execute method when an\n application has a connection to an open ResultSet object.\n Using the method populate can be more efficient than using\n the version of the execute method that takes no parameters\n because it does not open a new connection and re-execute this\n CachedRowSet object's command. Using the populate\n  method is more a matter of convenience when compared to using the version\n of execute that takes a ResultSet object."}, {"method_name": "setPageSize", "method_sig": "void setPageSize (int size)\n          throws SQLException", "description": "Sets the CachedRowSet object's page-size. A CachedRowSet\n may be configured to populate itself in page-size sized batches of rows. When\n either populate() or execute() are called, the\n CachedRowSet fetches an additional page according to the\n original SQL query used to populate the RowSet."}, {"method_name": "getPageSize", "method_sig": "int getPageSize()", "description": "Returns the page-size for the CachedRowSet object"}, {"method_name": "nextPage", "method_sig": "boolean nextPage()\n          throws SQLException", "description": "Increments the current page of the CachedRowSet. This causes\n the CachedRowSet implementation to fetch the next page-size\n rows and populate the RowSet, if remaining rows remain within scope of the\n original SQL query used to populated the RowSet."}, {"method_name": "previousPage", "method_sig": "boolean previousPage()\n              throws SQLException", "description": "Decrements the current page of the CachedRowSet. This causes\n the CachedRowSet implementation to fetch the previous page-size\n rows and populate the RowSet. The amount of rows returned in the previous\n page must always remain within scope of the original SQL query used to\n populate the RowSet."}]}