{"name": "Interface ListIterator<E>", "module": "java.base", "package": "java.util", "text": "An iterator for lists that allows the programmer\n to traverse the list in either direction, modify\n the list during iteration, and obtain the iterator's\n current position in the list. A ListIterator\n has no current element; its cursor position always\n lies between the element that would be returned by a call\n to previous() and the element that would be\n returned by a call to next().\n An iterator for a list of length n has n+1 possible\n cursor positions, as illustrated by the carets (^) below:\n \n                      Element(0)   Element(1)   Element(2)   ... Element(n-1)\n cursor positions:  ^            ^            ^            ^                  ^\n \n Note that the remove() and set(Object) methods are\n not defined in terms of the cursor position;  they are defined to\n operate on the last element returned by a call to next() or\n previous().\n\n This interface is a member of the\n \n Java Collections Framework.", "codes": ["public interface ListIterator<E>\nextends Iterator<E>"], "fields": [], "methods": [{"method_name": "hasNext", "method_sig": "boolean hasNext()", "description": "Returns true if this list iterator has more elements when\n traversing the list in the forward direction. (In other words,\n returns true if next() would return an element rather\n than throwing an exception.)"}, {"method_name": "next", "method_sig": "E next()", "description": "Returns the next element in the list and advances the cursor position.\n This method may be called repeatedly to iterate through the list,\n or intermixed with calls to previous() to go back and forth.\n (Note that alternating calls to next and previous\n will return the same element repeatedly.)"}, {"method_name": "hasPrevious", "method_sig": "boolean hasPrevious()", "description": "Returns true if this list iterator has more elements when\n traversing the list in the reverse direction.  (In other words,\n returns true if previous() would return an element\n rather than throwing an exception.)"}, {"method_name": "previous", "method_sig": "E previous()", "description": "Returns the previous element in the list and moves the cursor\n position backwards.  This method may be called repeatedly to\n iterate through the list backwards, or intermixed with calls to\n next() to go back and forth.  (Note that alternating calls\n to next and previous will return the same\n element repeatedly.)"}, {"method_name": "nextIndex", "method_sig": "int nextIndex()", "description": "Returns the index of the element that would be returned by a\n subsequent call to next(). (Returns list size if the list\n iterator is at the end of the list.)"}, {"method_name": "previousIndex", "method_sig": "int previousIndex()", "description": "Returns the index of the element that would be returned by a\n subsequent call to previous(). (Returns -1 if the list\n iterator is at the beginning of the list.)"}, {"method_name": "remove", "method_sig": "void remove()", "description": "Removes from the list the last element that was returned by next() or previous() (optional operation).  This call can\n only be made once per call to next or previous.\n It can be made only if add(E) has not been\n called after the last call to next or previous."}, {"method_name": "set", "method_sig": "void set (E e)", "description": "Replaces the last element returned by next() or\n previous() with the specified element (optional operation).\n This call can be made only if neither remove() nor add(E) have been called after the last call to next or\n previous."}, {"method_name": "add", "method_sig": "void add (E e)", "description": "Inserts the specified element into the list (optional operation).\n The element is inserted immediately before the element that\n would be returned by next(), if any, and after the element\n that would be returned by previous(), if any.  (If the\n list contains no elements, the new element becomes the sole element\n on the list.)  The new element is inserted before the implicit\n cursor: a subsequent call to next would be unaffected, and a\n subsequent call to previous would return the new element.\n (This call increases by one the value that would be returned by a\n call to nextIndex or previousIndex.)"}]}