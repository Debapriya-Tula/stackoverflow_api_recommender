{"name": "Class SwingWorker<T,\u200bV>", "module": "java.desktop", "package": "javax.swing", "text": "An abstract class to perform lengthy GUI-interaction tasks in a\n background thread. Several background threads can be used to execute such\n tasks. However, the exact strategy of choosing a thread for any particular\n SwingWorker is unspecified and should not be relied on.\n \n When writing a multi-threaded application using Swing, there are\n two constraints to keep in mind:\n (refer to\n \n   Concurrency in Swing\n  for more details):\n \n Time-consuming tasks should not be run on the Event\n        Dispatch Thread. Otherwise the application becomes unresponsive.\n   \n Swing components should be accessed  on the Event\n        Dispatch Thread only.\n   \n\n\n These constraints mean that a GUI application with time intensive\n computing needs at least two threads:  1) a thread to perform the lengthy\n task and 2) the Event Dispatch Thread (EDT) for all GUI-related\n activities.  This involves inter-thread communication which can be\n tricky to implement.\n\n \nSwingWorker is designed for situations where you need to have a long\n running task run in a background thread and provide updates to the UI\n either when done, or while processing.\n Subclasses of SwingWorker must implement\n the doInBackground() method to perform the background computation.\n\n\n \nWorkflow\n\n There are three threads involved in the life cycle of a\n SwingWorker :\n \n\n\nCurrent thread: The execute() method is\n called on this thread. It schedules SwingWorker for the execution on a\n worker\n thread and returns immediately. One can wait for the SwingWorker to\n complete using the get methods.\n \n\nWorker thread: The doInBackground()\n method is called on this thread.\n This is where all background activities should happen. To notify\n PropertyChangeListeners about bound properties changes use the\n firePropertyChange and\n getPropertyChangeSupport() methods. By default there are two bound\n properties available: state and progress.\n \n\nEvent Dispatch Thread:  All Swing related activities occur\n on this thread. SwingWorker invokes the\n process and done() methods and notifies\n any PropertyChangeListeners on this thread.\n \n\n Often, the Current thread is the Event Dispatch\n Thread.\n\n\n \n Before the doInBackground method is invoked on a worker thread,\n SwingWorker notifies any PropertyChangeListeners about the\n state property change to StateValue.STARTED.  After the\n doInBackground method is finished the done method is\n executed.  Then SwingWorker notifies any PropertyChangeListeners\n about the state property change to StateValue.DONE.\n\n \nSwingWorker is only designed to be executed once.  Executing a\n SwingWorker more than once will not result in invoking the\n doInBackground method twice.\n\n \nSample Usage\n\n The following example illustrates the simplest use case.  Some\n processing is done in the background and when done you update a Swing\n component.\n\n \n Say we want to find the \"Meaning of Life\" and display the result in\n a JLabel.\n\n \n   final JLabel label;\n   class MeaningOfLifeFinder extends SwingWorker<String, Object> {\n       @Override\n       public String doInBackground() {\n           return findTheMeaningOfLife();\n       }\n\n       @Override\n       protected void done() {\n           try {\n               label.setText(get());\n           } catch (Exception ignore) {\n           }\n       }\n   }\n\n   (new MeaningOfLifeFinder()).execute();\n \n\n The next example is useful in situations where you wish to process data\n as it is ready on the Event Dispatch Thread.\n\n \n Now we want to find the first N prime numbers and display the results in a\n JTextArea.  While this is computing, we want to update our\n progress in a JProgressBar.  Finally, we also want to print\n the prime numbers to System.out.\n \n class PrimeNumbersTask extends\n         SwingWorker<List<Integer>, Integer> {\n     PrimeNumbersTask(JTextArea textArea, int numbersToFind) {\n         //initialize\n     }\n\n     @Override\n     public List<Integer> doInBackground() {\n         while (! enough && ! isCancelled()) {\n                 number = nextPrimeNumber();\n                 publish(number);\n                 setProgress(100 * numbers.size() / numbersToFind);\n             }\n         }\n         return numbers;\n     }\n\n     @Override\n     protected void process(List<Integer> chunks) {\n         for (int number : chunks) {\n             textArea.append(number + \"\\n\");\n         }\n     }\n }\n\n JTextArea textArea = new JTextArea();\n final JProgressBar progressBar = new JProgressBar(0, 100);\n PrimeNumbersTask task = new PrimeNumbersTask(textArea, N);\n task.addPropertyChangeListener(\n     new PropertyChangeListener() {\n         public  void propertyChange(PropertyChangeEvent evt) {\n             if (\"progress\".equals(evt.getPropertyName())) {\n                 progressBar.setValue((Integer)evt.getNewValue());\n             }\n         }\n     });\n\n task.execute();\n System.out.println(task.get()); //prints all prime numbers we have got\n \n\n Because SwingWorker implements Runnable, a\n SwingWorker can be submitted to an\n Executor for execution.", "codes": ["public abstract class SwingWorker<T, V>\nextends Object\nimplements RunnableFuture<T>"], "fields": [], "methods": [{"method_name": "doInBackground", "method_sig": "protected abstract T doInBackground()\n                             throws Exception", "description": "Computes a result, or throws an exception if unable to do so.\n\n \n Note that this method is executed only once.\n\n \n Note: this method is executed in a background thread."}, {"method_name": "run", "method_sig": "public final void run()", "description": "Sets this Future to the result of computation unless\n it has been cancelled."}, {"method_name": "publish", "method_sig": "@SafeVarargs\nprotected final void publish (V... chunks)", "description": "Sends data chunks to the process(java.util.List<V>) method. This method is to be\n used from inside the doInBackground method to deliver\n intermediate results\n for processing on the Event Dispatch Thread inside the\n process method.\n\n \n Because the process method is invoked asynchronously on\n the Event Dispatch Thread\n multiple invocations to the publish method\n might occur before the process method is executed. For\n performance purposes all these invocations are coalesced into one\n invocation with concatenated arguments.\n\n \n For example:\n\n \n publish(\"1\");\n publish(\"2\", \"3\");\n publish(\"4\", \"5\", \"6\");\n \n\n might result in:\n\n \n process(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\")\n \n\nSample Usage. This code snippet loads some tabular data and\n updates DefaultTableModel with it. Note that it safe to mutate\n the tableModel from inside the process method because it is\n invoked on the Event Dispatch Thread.\n\n \n class TableSwingWorker extends\n         SwingWorker<DefaultTableModel, Object[]> {\n     private final DefaultTableModel tableModel;\n\n     public TableSwingWorker(DefaultTableModel tableModel) {\n         this.tableModel = tableModel;\n     }\n\n     @Override\n     protected DefaultTableModel doInBackground() throws Exception {\n         for (Object[] row = loadData();\n                  ! isCancelled() && row != null;\n                  row = loadData()) {\n             publish((Object[]) row);\n         }\n         return tableModel;\n     }\n\n     @Override\n     protected void process(List<Object[]> chunks) {\n         for (Object[] row : chunks) {\n             tableModel.addRow(row);\n         }\n     }\n }\n "}, {"method_name": "process", "method_sig": "protected void process (List<V> chunks)", "description": "Receives data chunks from the publish method asynchronously on the\n Event Dispatch Thread.\n\n \n Please refer to the publish(V...) method for more details."}, {"method_name": "done", "method_sig": "protected void done()", "description": "Executed on the Event Dispatch Thread after the doInBackground\n method is finished. The default\n implementation does nothing. Subclasses may override this method to\n perform completion actions on the Event Dispatch Thread. Note\n that you can query status inside the implementation of this method to\n determine the result of this task or whether this task has been cancelled."}, {"method_name": "setProgress", "method_sig": "protected final void setProgress (int progress)", "description": "Sets the progress bound property.\n The value should be from 0 to 100.\n\n \n Because PropertyChangeListeners are notified asynchronously on\n the Event Dispatch Thread multiple invocations to the\n setProgress method might occur before any\n PropertyChangeListeners are invoked. For performance purposes\n all these invocations are coalesced into one invocation with the last\n invocation argument only.\n\n \n For example, the following invokations:\n\n \n setProgress(1);\n setProgress(2);\n setProgress(3);\n \n\n might result in a single PropertyChangeListener notification with\n the value 3."}, {"method_name": "getProgress", "method_sig": "public final int getProgress()", "description": "Returns the progress bound property."}, {"method_name": "execute", "method_sig": "public final void execute()", "description": "Schedules this SwingWorker for execution on a worker\n thread. There are a number of worker threads available. In the\n event all worker threads are busy handling other\n SwingWorkers this SwingWorker is placed in a waiting\n queue.\n\n \n Note:\n SwingWorker is only designed to be executed once.  Executing a\n SwingWorker more than once will not result in invoking the\n doInBackground method twice."}, {"method_name": "get", "method_sig": "public final T get()\n            throws InterruptedException,\n                   ExecutionException", "description": "Waits if necessary for the computation to complete, and then\n retrieves its result.\n \n Note: calling get on the Event Dispatch Thread blocks\n all events, including repaints, from being processed until this\n SwingWorker is complete.\n\n \n When you want the SwingWorker to block on the Event\n Dispatch Thread we recommend that you use a modal dialog.\n\n \n For example:\n\n \n class SwingWorkerCompletionWaiter implements PropertyChangeListener {\n     private JDialog dialog;\n\n     public SwingWorkerCompletionWaiter(JDialog dialog) {\n         this.dialog = dialog;\n     }\n\n     public void propertyChange(PropertyChangeEvent event) {\n         if (\"state\".equals(event.getPropertyName())\n                 && SwingWorker.StateValue.DONE == event.getNewValue()) {\n             dialog.setVisible(false);\n             dialog.dispose();\n         }\n     }\n }\n JDialog dialog = new JDialog(owner, true);\n swingWorker.addPropertyChangeListener(\n     new SwingWorkerCompletionWaiter(dialog));\n swingWorker.execute();\n //the dialog will be visible until the SwingWorker is done\n dialog.setVisible(true);\n "}, {"method_name": "get", "method_sig": "public final T get (long timeout,\n                   TimeUnit unit)\n            throws InterruptedException,\n                   ExecutionException,\n                   TimeoutException", "description": "Waits if necessary for at most the given time for the computation\n to complete, and then retrieves its result, if available.\n \n Please refer to get() for more details."}, {"method_name": "addPropertyChangeListener", "method_sig": "public final void addPropertyChangeListener (PropertyChangeListener listener)", "description": "Adds a PropertyChangeListener to the listener list. The listener\n is registered for all properties. The same listener object may be added\n more than once, and will be called as many times as it is added. If\n listener is null, no exception is thrown and no action is taken.\n\n \n Note: This is merely a convenience wrapper. All work is delegated to\n PropertyChangeSupport from getPropertyChangeSupport()."}, {"method_name": "removePropertyChangeListener", "method_sig": "public final void removePropertyChangeListener (PropertyChangeListener listener)", "description": "Removes a PropertyChangeListener from the listener list. This\n removes a PropertyChangeListener that was registered for all\n properties. If listener was added more than once to the same\n event source, it will be notified one less time after being removed. If\n listener is null, or was never added, no exception is\n thrown and no action is taken.\n\n \n Note: This is merely a convenience wrapper. All work is delegated to\n PropertyChangeSupport from getPropertyChangeSupport()."}, {"method_name": "firePropertyChange", "method_sig": "public final void firePropertyChange (String propertyName,\n                                     Object oldValue,\n                                     Object newValue)", "description": "Reports a bound property update to any registered listeners. No event is\n fired if old and new are equal and non-null.\n\n \n This SwingWorker will be the source for\n any generated events.\n\n \n When called off the Event Dispatch Thread\nPropertyChangeListeners are notified asynchronously on\n the Event Dispatch Thread.\n \n Note: This is merely a convenience wrapper. All work is delegated to\n PropertyChangeSupport from getPropertyChangeSupport()."}, {"method_name": "getPropertyChangeSupport", "method_sig": "public final PropertyChangeSupport getPropertyChangeSupport()", "description": "Returns the PropertyChangeSupport for this SwingWorker.\n This method is used when flexible access to bound properties support is\n needed.\n \n This SwingWorker will be the source for\n any generated events.\n\n \n Note: The returned PropertyChangeSupport notifies any\n PropertyChangeListeners asynchronously on the Event Dispatch\n Thread in the event that firePropertyChange or\n fireIndexedPropertyChange are called off the Event Dispatch\n Thread."}, {"method_name": "getState", "method_sig": "public final SwingWorker.StateValue getState()", "description": "Returns the SwingWorker state bound property."}]}