{"name": "Interface SaslServer", "module": "java.security.sasl", "package": "javax.security.sasl", "text": "Performs SASL authentication as a server.\n\n A server such an LDAP server gets an instance of this\n class in order to perform authentication defined by a specific SASL\n mechanism. Invoking methods on the SaslServer instance\n generates challenges according to the SASL\n mechanism implemented by the SaslServer.\n As the authentication proceeds, the instance\n encapsulates the state of a SASL server's authentication exchange.\n\n Here's an example of how an LDAP server might use a SaslServer.\n It first gets an instance of a SaslServer for the SASL mechanism\n requested by the client:\n\n SaslServer ss = Sasl.createSaslServer(mechanism,\n     \"ldap\", myFQDN, props, callbackHandler);\n\n It can then proceed to use the server for authentication.\n For example, suppose the LDAP server received an LDAP BIND request\n containing the name of the SASL mechanism and an (optional) initial\n response. It then might use the server as follows:\n\n while (!ss.isComplete()) {\n     try {\n         byte[] challenge = ss.evaluateResponse(response);\n         if (ss.isComplete()) {\n             status = ldap.sendBindResponse(mechanism, challenge, SUCCESS);\n         } else {\n             status = ldap.sendBindResponse(mechanism, challenge,\n                   SASL_BIND_IN_PROGRESS);\n             response = ldap.readBindRequest();\n         }\n     } catch (SaslException e) {\n          status = ldap.sendErrorResponse(e);\n          break;\n     }\n }\n if (ss.isComplete() && status == SUCCESS) {\n    String qop = (String) sc.getNegotiatedProperty(Sasl.QOP);\n    if (qop != null\n        && (qop.equalsIgnoreCase(\"auth-int\")\n            || qop.equalsIgnoreCase(\"auth-conf\"))) {\n\n      // Use SaslServer.wrap() and SaslServer.unwrap() for future\n      // communication with client\n      ldap.in = new SecureInputStream(ss, ldap.in);\n      ldap.out = new SecureOutputStream(ss, ldap.out);\n    }\n }\n", "codes": ["public interface SaslServer"], "fields": [], "methods": [{"method_name": "getMechanismName", "method_sig": "String getMechanismName()", "description": "Returns the IANA-registered mechanism name of this SASL server.\n (e.g. \"CRAM-MD5\", \"GSSAPI\")."}, {"method_name": "evaluateResponse", "method_sig": "byte[] evaluateResponse (byte[] response)\n                 throws SaslException", "description": "Evaluates the response data and generates a challenge.\n\n If a response is received from the client during the authentication\n process, this method is called to prepare an appropriate next\n challenge to submit to the client. The challenge is null if the\n authentication has succeeded and no more challenge data is to be sent\n to the client. It is non-null if the authentication must be continued\n by sending a challenge to the client, or if the authentication has\n succeeded but challenge data needs to be processed by the client.\n isComplete() should be called\n after each call to evaluateResponse(),to determine if any further\n response is needed from the client."}, {"method_name": "isComplete", "method_sig": "boolean isComplete()", "description": "Determines whether the authentication exchange has completed.\n This method is typically called after each invocation of\n evaluateResponse() to determine whether the\n authentication has completed successfully or should be continued."}, {"method_name": "getAuthorizationID", "method_sig": "String getAuthorizationID()", "description": "Reports the authorization ID in effect for the client of this\n session.\n This method can only be called if isComplete() returns true."}, {"method_name": "unwrap", "method_sig": "byte[] unwrap (byte[] incoming,\n              int offset,\n              int len)\n       throws SaslException", "description": "Unwraps a byte array received from the client.\n This method can be called only after the authentication exchange has\n completed (i.e., when isComplete() returns true) and only if\n the authentication exchange has negotiated integrity and/or privacy\n as the quality of protection; otherwise,\n an IllegalStateException is thrown.\n\nincoming is the contents of the SASL buffer as defined in RFC 2222\n without the leading four octet field that represents the length.\n offset and len specify the portion of incoming\n to use."}, {"method_name": "wrap", "method_sig": "byte[] wrap (byte[] outgoing,\n            int offset,\n            int len)\n     throws SaslException", "description": "Wraps a byte array to be sent to the client.\n This method can be called only after the authentication exchange has\n completed (i.e., when isComplete() returns true) and only if\n the authentication exchange has negotiated integrity and/or privacy\n as the quality of protection; otherwise, a SaslException is thrown.\n\n The result of this method\n will make up the contents of the SASL buffer as defined in RFC 2222\n without the leading four octet field that represents the length.\n offset and len specify the portion of outgoing\n to use."}, {"method_name": "getNegotiatedProperty", "method_sig": "Object getNegotiatedProperty (String propName)", "description": "Retrieves the negotiated property.\n This method can be called only after the authentication exchange has\n completed (i.e., when isComplete() returns true); otherwise, an\n IllegalStateException is thrown.\n \n The Sasl class includes several well-known property names\n (For example, Sasl.QOP). A SASL provider can support other\n properties which are specific to the vendor and/or a mechanism."}, {"method_name": "dispose", "method_sig": "void dispose()\n      throws SaslException", "description": "Disposes of any system resources or security-sensitive information\n the SaslServer might be using. Invoking this method invalidates\n the SaslServer instance. This method is idempotent."}]}