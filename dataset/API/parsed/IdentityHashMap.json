{"name": "Class IdentityHashMap<K,\u200bV>", "module": "java.base", "package": "java.util", "text": "This class implements the Map interface with a hash table, using\n reference-equality in place of object-equality when comparing keys (and\n values).  In other words, in an IdentityHashMap, two keys\n k1 and k2 are considered equal if and only if\n (k1==k2).  (In normal Map implementations (like\n HashMap) two keys k1 and k2 are considered equal\n if and only if (k1==null ? k2==null : k1.equals(k2)).)\n\n This class is not a general-purpose Map\n implementation!  While this class implements the Map interface, it\n intentionally violates Map's general contract, which mandates the\n use of the equals method when comparing objects.  This class is\n designed for use only in the rare cases wherein reference-equality\n semantics are required.\nA typical use of this class is topology-preserving object graph\n transformations, such as serialization or deep-copying.  To perform such\n a transformation, a program must maintain a \"node table\" that keeps track\n of all the object references that have already been processed.  The node\n table must not equate distinct objects even if they happen to be equal.\n Another typical use of this class is to maintain proxy objects.  For\n example, a debugging facility might wish to maintain a proxy object for\n each object in the program being debugged.\n\n This class provides all of the optional map operations, and permits\n null values and the null key.  This class makes no\n guarantees as to the order of the map; in particular, it does not guarantee\n that the order will remain constant over time.\n\n This class provides constant-time performance for the basic\n operations (get and put), assuming the system\n identity hash function (System.identityHashCode(Object))\n disperses elements properly among the buckets.\n\n This class has one tuning parameter (which affects performance but not\n semantics): expected maximum size.  This parameter is the maximum\n number of key-value mappings that the map is expected to hold.  Internally,\n this parameter is used to determine the number of buckets initially\n comprising the hash table.  The precise relationship between the expected\n maximum size and the number of buckets is unspecified.\n\n If the size of the map (the number of key-value mappings) sufficiently\n exceeds the expected maximum size, the number of buckets is increased.\n Increasing the number of buckets (\"rehashing\") may be fairly expensive, so\n it pays to create identity hash maps with a sufficiently large expected\n maximum size.  On the other hand, iteration over collection views requires\n time proportional to the number of buckets in the hash table, so it\n pays not to set the expected maximum size too high if you are especially\n concerned with iteration performance or memory usage.\n\n Note that this implementation is not synchronized.\n If multiple threads access an identity hash map concurrently, and at\n least one of the threads modifies the map structurally, it must\n be synchronized externally.  (A structural modification is any operation\n that adds or deletes one or more mappings; merely changing the value\n associated with a key that an instance already contains is not a\n structural modification.)  This is typically accomplished by\n synchronizing on some object that naturally encapsulates the map.\n\n If no such object exists, the map should be \"wrapped\" using the\n Collections.synchronizedMap\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the map:\n   Map m = Collections.synchronizedMap(new IdentityHashMap(...));\nThe iterators returned by the iterator method of the\n collections returned by all of this class's \"collection view\n methods\" are fail-fast: if the map is structurally modified\n at any time after the iterator is created, in any way except\n through the iterator's own remove method, the iterator\n will throw a ConcurrentModificationException.  Thus, in the\n face of concurrent modification, the iterator fails quickly and\n cleanly, rather than risking arbitrary, non-deterministic behavior\n at an undetermined time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness: fail-fast iterators should be used only\n to detect bugs.\nImplementation note: This is a simple linear-probe hash table,\n as described for example in texts by Sedgewick and Knuth.  The array\n alternates holding keys and values.  (This has better locality for large\n tables than does using separate arrays.)  For many JRE implementations\n and operation mixes, this class will yield better performance than\n HashMap (which uses chaining rather than linear-probing).\n\n This class is a member of the\n \n Java Collections Framework.", "codes": ["public class IdentityHashMap<K, V>\nextends AbstractMap<K, V>\nimplements Map<K, V>, Serializable, Cloneable"], "fields": [], "methods": [{"method_name": "size", "method_sig": "public int size()", "description": "Returns the number of key-value mappings in this identity hash map."}, {"method_name": "isEmpty", "method_sig": "public boolean isEmpty()", "description": "Returns true if this identity hash map contains no key-value\n mappings."}, {"method_name": "get", "method_sig": "public V get (Object key)", "description": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.\n\n More formally, if this map contains a mapping from a key\n k to a value v such that (key == k),\n then this method returns v; otherwise it returns\n null.  (There can be at most one such mapping.)\n\n A return value of null does not necessarily\n indicate that the map contains no mapping for the key; it's also\n possible that the map explicitly maps the key to null.\n The containsKey operation may be used to\n distinguish these two cases."}, {"method_name": "containsKey", "method_sig": "public boolean containsKey (Object key)", "description": "Tests whether the specified object reference is a key in this identity\n hash map."}, {"method_name": "containsValue", "method_sig": "public boolean containsValue (Object value)", "description": "Tests whether the specified object reference is a value in this identity\n hash map."}, {"method_name": "put", "method_sig": "public V put (K key,\n             V value)", "description": "Associates the specified value with the specified key in this identity\n hash map.  If the map previously contained a mapping for the key, the\n old value is replaced."}, {"method_name": "putAll", "method_sig": "public void putAll (Map<? extends K, ? extends V> m)", "description": "Copies all of the mappings from the specified map to this map.\n These mappings will replace any mappings that this map had for\n any of the keys currently in the specified map."}, {"method_name": "remove", "method_sig": "public V remove (Object key)", "description": "Removes the mapping for this key from this map if present."}, {"method_name": "clear", "method_sig": "public void clear()", "description": "Removes all of the mappings from this map.\n The map will be empty after this call returns."}, {"method_name": "equals", "method_sig": "public boolean equals (Object o)", "description": "Compares the specified object with this map for equality.  Returns\n true if the given object is also a map and the two maps\n represent identical object-reference mappings.  More formally, this\n map is equal to another map m if and only if\n this.entrySet().equals(m.entrySet()).\n\n Owing to the reference-equality-based semantics of this map it is\n possible that the symmetry and transitivity requirements of the\n Object.equals contract may be violated if this map is compared\n to a normal map.  However, the Object.equals contract is\n guaranteed to hold among IdentityHashMap instances."}, {"method_name": "hashCode", "method_sig": "public int hashCode()", "description": "Returns the hash code value for this map.  The hash code of a map is\n defined to be the sum of the hash codes of each entry in the map's\n entrySet() view.  This ensures that m1.equals(m2)\n implies that m1.hashCode()==m2.hashCode() for any two\n IdentityHashMap instances m1 and m2, as\n required by the general contract of Object.hashCode().\n\n Owing to the reference-equality-based semantics of the\n Map.Entry instances in the set returned by this map's\n entrySet method, it is possible that the contractual\n requirement of Object.hashCode mentioned in the previous\n paragraph will be violated if one of the two objects being compared is\n an IdentityHashMap instance and the other is a normal map."}, {"method_name": "clone", "method_sig": "public Object clone()", "description": "Returns a shallow copy of this identity hash map: the keys and values\n themselves are not cloned."}, {"method_name": "keySet", "method_sig": "public Set<K> keySet()", "description": "Returns an identity-based set view of the keys contained in this map.\n The set is backed by the map, so changes to the map are reflected in\n the set, and vice-versa.  If the map is modified while an iteration\n over the set is in progress, the results of the iteration are\n undefined.  The set supports element removal, which removes the\n corresponding mapping from the map, via the Iterator.remove,\n Set.remove, removeAll, retainAll, and\n clear methods.  It does not support the add or\n addAll methods.\n\n While the object returned by this method implements the\n Set interface, it does not obey Set's general\n contract.  Like its backing map, the set returned by this method\n defines element equality as reference-equality rather than\n object-equality.  This affects the behavior of its contains,\n remove, containsAll, equals, and\n hashCode methods.\nThe equals method of the returned set returns true\n only if the specified object is a set containing exactly the same\n object references as the returned set.  The symmetry and transitivity\n requirements of the Object.equals contract may be violated if\n the set returned by this method is compared to a normal set.  However,\n the Object.equals contract is guaranteed to hold among sets\n returned by this method.\nThe hashCode method of the returned set returns the sum of\n the identity hashcodes of the elements in the set, rather than\n the sum of their hashcodes.  This is mandated by the change in the\n semantics of the equals method, in order to enforce the\n general contract of the Object.hashCode method among sets\n returned by this method."}, {"method_name": "values", "method_sig": "public Collection<V> values()", "description": "Returns a Collection view of the values contained in this map.\n The collection is backed by the map, so changes to the map are\n reflected in the collection, and vice-versa.  If the map is\n modified while an iteration over the collection is in progress,\n the results of the iteration are undefined.  The collection\n supports element removal, which removes the corresponding\n mapping from the map, via the Iterator.remove,\n Collection.remove, removeAll,\n retainAll and clear methods.  It does not\n support the add or addAll methods.\n\n While the object returned by this method implements the\n Collection interface, it does not obey\n Collection's general contract.  Like its backing map,\n the collection returned by this method defines element equality as\n reference-equality rather than object-equality.  This affects the\n behavior of its contains, remove and\n containsAll methods."}, {"method_name": "entrySet", "method_sig": "public Set<Map.Entry<K, V>> entrySet()", "description": "Returns a Set view of the mappings contained in this map.\n Each element in the returned set is a reference-equality-based\n Map.Entry.  The set is backed by the map, so changes\n to the map are reflected in the set, and vice-versa.  If the\n map is modified while an iteration over the set is in progress,\n the results of the iteration are undefined.  The set supports\n element removal, which removes the corresponding mapping from\n the map, via the Iterator.remove, Set.remove,\n removeAll, retainAll and clear\n methods.  It does not support the add or\n addAll methods.\n\n Like the backing map, the Map.Entry objects in the set\n returned by this method define key and value equality as\n reference-equality rather than object-equality.  This affects the\n behavior of the equals and hashCode methods of these\n Map.Entry objects.  A reference-equality based Map.Entry\n e is equal to an object o if and only if o is a\n Map.Entry and e.getKey()==o.getKey() &&\n e.getValue()==o.getValue().  To accommodate these equals\n semantics, the hashCode method returns\n System.identityHashCode(e.getKey()) ^\n System.identityHashCode(e.getValue()).\n\n Owing to the reference-equality-based semantics of the\n Map.Entry instances in the set returned by this method,\n it is possible that the symmetry and transitivity requirements of\n the Object.equals(Object) contract may be violated if any of\n the entries in the set is compared to a normal map entry, or if\n the set returned by this method is compared to a set of normal map\n entries (such as would be returned by a call to this method on a normal\n map).  However, the Object.equals contract is guaranteed to\n hold among identity-based map entries, and among sets of such entries.\n "}]}