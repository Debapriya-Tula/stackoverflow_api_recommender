{"name": "Class NimbusStyle", "module": "java.desktop", "package": "javax.swing.plaf.nimbus", "text": "A SynthStyle implementation used by Nimbus. Each Region that has been\n registered with the NimbusLookAndFeel will have an associated NimbusStyle.\n Third party components that are registered with the NimbusLookAndFeel will\n therefore be handed a NimbusStyle from the look and feel from the\n #getStyle(JComponent, Region) method.\nThis class properly reads and retrieves values placed in the UIDefaults\n according to the standard Nimbus naming conventions. It will create and\n retrieve painters, fonts, colors, and other data stored there.\nNimbusStyle also supports the ability to override settings on a per\n component basis. NimbusStyle checks the component's client property map for\n \"Nimbus.Overrides\". If the value associated with this key is an instance of\n UIDefaults, then the values in that defaults table will override the standard\n Nimbus defaults in UIManager, but for that component instance only.\nOptionally, you may specify the client property\n \"Nimbus.Overrides.InheritDefaults\". If true, this client property indicates\n that the defaults located in UIManager should first be read, and then\n replaced with defaults located in the component client properties. If false,\n then only the defaults located in the component client property map will\n be used. If not specified, it is assumed to be true.\nYou must specify \"Nimbus.Overrides\" for \"Nimbus.Overrides.InheritDefaults\"\n to have any effect. \"Nimbus.Overrides\" indicates whether there are any\n overrides, while \"Nimbus.Overrides.InheritDefaults\" indicates whether those\n overrides should first be initialized with the defaults from UIManager.\nThe NimbusStyle is reloaded whenever a property change event is fired\n for a component for \"Nimbus.Overrides\" or \"Nimbus.Overrides.InheritDefaults\".\n So for example, setting a new UIDefaults on a component would cause the\n style to be reloaded.\nThe values are only read out of UIManager once, and then cached. If\n you need to read the values again (for example, if the UI is being reloaded),\n then discard this NimbusStyle and read a new one from NimbusLookAndFeel\n using NimbusLookAndFeel.getStyle.\nThe primary API of interest in this class for 3rd party component authors\n are the three methods which retrieve painters: #getBackgroundPainter,\n #getForegroundPainter, and #getBorderPainter.\nNimbusStyle allows you to specify custom states, or modify the order of\n states. Synth (and thus Nimbus) has the concept of a \"state\". For example,\n a JButton might be in the \"MOUSE_OVER\" state, or the \"ENABLED\" state, or the\n \"DISABLED\" state. These are all \"standard\" states which are defined in synth,\n and which apply to all synth Regions.\nSometimes, however, you need to have a custom state. For example, you\n want JButton to render differently if it's parent is a JToolbar. In Nimbus,\n you specify these custom states by including a special key in UIDefaults.\n The following UIDefaults entries define three states for this button:\n\n     JButton.States = Enabled, Disabled, Toolbar\n     JButton[Enabled].backgroundPainter = somePainter\n     JButton[Disabled].background = BLUE\n     JButton[Toolbar].backgroundPainter = someOtherPaint\n \nAs you can see, the JButton.States entry lists the states\n that the JButton style will support. You then specify the settings for\n each state. If you do not specify the JButton.States entry,\n then the standard Synth states will be assumed. If you specify the entry\n but the list of states is empty or null, then the standard synth states\n will be assumed.", "codes": ["public final class NimbusStyle\nextends SynthStyle"], "fields": [{"field_name": "LARGE_KEY", "field_sig": "public static final\u00a0String LARGE_KEY", "description": "Large key"}, {"field_name": "SMALL_KEY", "field_sig": "public static final\u00a0String SMALL_KEY", "description": "Small key"}, {"field_name": "MINI_KEY", "field_sig": "public static final\u00a0String MINI_KEY", "description": "Mini key"}, {"field_name": "LARGE_SCALE", "field_sig": "public static final\u00a0double LARGE_SCALE", "description": "Large scale"}, {"field_name": "SMALL_SCALE", "field_sig": "public static final\u00a0double SMALL_SCALE", "description": "Small scale"}, {"field_name": "MINI_SCALE", "field_sig": "public static final\u00a0double MINI_SCALE", "description": "Mini scale"}], "methods": [{"method_name": "installDefaults", "method_sig": "public void installDefaults (SynthContext ctx)", "description": "Installs the necessary state from this Style on the\n JComponent from context.\n\n Overridden to cause this style to populate itself with data from\n UIDefaults, if necessary."}, {"method_name": "getInsets", "method_sig": "public Insets getInsets (SynthContext ctx,\n                        Insets in)", "description": "Returns the Insets that are used to calculate sizing information.\n\n Overridden to cause this style to populate itself with data from\n UIDefaults, if necessary."}, {"method_name": "getColorForState", "method_sig": "protected Color getColorForState (SynthContext ctx,\n                                 ColorType type)", "description": "Returns the color for the specified state. This should NOT call any\n methods on the JComponent.\n\n Overridden to cause this style to populate itself with data from\n UIDefaults, if necessary.\nIn addition, NimbusStyle handles ColorTypes slightly differently from\n Synth.\n\nColorType.BACKGROUND will equate to the color stored in UIDefaults\n      named \"background\".\nColorType.TEXT_BACKGROUND will equate to the color stored in\n      UIDefaults named \"textBackground\".\nColorType.FOREGROUND will equate to the color stored in UIDefaults\n      named \"textForeground\".\nColorType.TEXT_FOREGROUND will equate to the color stored in\n      UIDefaults named \"textForeground\".\n"}, {"method_name": "getFontForState", "method_sig": "protected Font getFontForState (SynthContext ctx)", "description": "Returns the font for the specified state. This should NOT call any\n method on the JComponent.\n\n Overridden to cause this style to populate itself with data from\n UIDefaults, if necessary. If a value named \"font\" is not found in\n UIDefaults, then the \"defaultFont\" font in UIDefaults will be returned\n instead."}, {"method_name": "getPainter", "method_sig": "public SynthPainter getPainter (SynthContext ctx)", "description": "Returns the SynthPainter that will be used for painting.\n This may return null.\n\n Returns the SynthPainter for this style, which ends up delegating to\n the Painters installed in this style."}, {"method_name": "isOpaque", "method_sig": "public boolean isOpaque (SynthContext ctx)", "description": "Returns true if the region is opaque.\n\n Overridden to cause this style to populate itself with data from\n UIDefaults, if necessary. If opacity is not specified in UI defaults,\n then it defaults to being non-opaque."}, {"method_name": "get", "method_sig": "public Object get (SynthContext ctx,\n                  Object key)", "description": "Getter for a region specific style property.\n\n Overridden to cause this style to populate itself with data from\n UIDefaults, if necessary.\nProperties in UIDefaults may be specified in a chained manner. For\n example:\n \n background\n Button.opacity\n Button.Enabled.foreground\n Button.Enabled+Selected.background\n \nIn this example, suppose you were in the Enabled+Selected state and\n searched for \"foreground\". In this case, we first check for\n Button.Enabled+Selected.foreground, but no such color exists. We then\n fall back to the next valid state, in this case,\n Button.Enabled.foreground, and have a match. So we return it.\nAgain, if we were in the state Enabled and looked for \"background\", we\n wouldn't find it in Button.Enabled, or in Button, but would at the top\n level in UIManager. So we return that value.\nOne special note: the \"key\" passed to this method could be of the form\n \"background\" or \"Button.background\" where \"Button\" equals the prefix\n passed to the NimbusStyle constructor. In either case, it looks for\n \"background\"."}, {"method_name": "getBackgroundPainter", "method_sig": "public Painter<Object> getBackgroundPainter (SynthContext ctx)", "description": "Gets the appropriate background Painter, if there is one, for the state\n specified in the given SynthContext. This method does appropriate\n fallback searching, as described in #get."}, {"method_name": "getForegroundPainter", "method_sig": "public Painter<Object> getForegroundPainter (SynthContext ctx)", "description": "Gets the appropriate foreground Painter, if there is one, for the state\n specified in the given SynthContext. This method does appropriate\n fallback searching, as described in #get."}, {"method_name": "getBorderPainter", "method_sig": "public Painter<Object> getBorderPainter (SynthContext ctx)", "description": "Gets the appropriate border Painter, if there is one, for the state\n specified in the given SynthContext. This method does appropriate\n fallback searching, as described in #get."}]}