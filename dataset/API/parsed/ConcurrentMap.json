{"name": "Interface ConcurrentMap<K,\u200bV>", "module": "java.base", "package": "java.util.concurrent", "text": "A Map providing thread safety and atomicity guarantees.\n\n To maintain the specified guarantees, default implementations of\n methods including putIfAbsent(K, V) inherited from Map\n must be overridden by implementations of this interface. Similarly,\n implementations of the collections returned by methods Map.keySet(), Map.values(), and Map.entrySet() must override\n methods such as removeIf when necessary to\n preserve atomicity guarantees.\n\n Memory consistency effects: As with other concurrent\n collections, actions in a thread prior to placing an object into a\n ConcurrentMap as a key or value\n happen-before\n actions subsequent to the access or removal of that object from\n the ConcurrentMap in another thread.\n\n This interface is a member of the\n \n Java Collections Framework.", "codes": ["public interface ConcurrentMap<K, V>\nextends Map<K, V>"], "fields": [], "methods": [{"method_name": "getOrDefault", "method_sig": "default V getOrDefault (Object key,\n                       V defaultValue)", "description": "Returns the value to which the specified key is mapped, or\n defaultValue if this map contains no mapping for the key."}, {"method_name": "forEach", "method_sig": "default void forEach (BiConsumer<? super K, ? super V> action)", "description": "Performs the given action for each entry in this map until all entries\n have been processed or the action throws an exception.   Unless\n otherwise specified by the implementing class, actions are performed in\n the order of entry set iteration (if an iteration order is specified.)\n Exceptions thrown by the action are relayed to the caller."}, {"method_name": "putIfAbsent", "method_sig": "V putIfAbsent (K key,\n              V value)", "description": "If the specified key is not already associated\n with a value, associates it with the given value.\n This is equivalent to, for this map:\n  \n if (!map.containsKey(key))\n   return map.put(key, value);\n else\n   return map.get(key);\n\n except that the action is performed atomically."}, {"method_name": "remove", "method_sig": "boolean remove (Object key,\n               Object value)", "description": "Removes the entry for a key only if currently mapped to a given value.\n This is equivalent to, for this map:\n  \n if (map.containsKey(key)\n     && Objects.equals(map.get(key), value)) {\n   map.remove(key);\n   return true;\n } else {\n   return false;\n }\n\n except that the action is performed atomically."}, {"method_name": "replace", "method_sig": "boolean replace (K key,\n                V oldValue,\n                V newValue)", "description": "Replaces the entry for a key only if currently mapped to a given value.\n This is equivalent to, for this map:\n  \n if (map.containsKey(key)\n     && Objects.equals(map.get(key), oldValue)) {\n   map.put(key, newValue);\n   return true;\n } else {\n   return false;\n }\n\n except that the action is performed atomically."}, {"method_name": "replace", "method_sig": "V replace (K key,\n          V value)", "description": "Replaces the entry for a key only if currently mapped to some value.\n This is equivalent to, for this map:\n  \n if (map.containsKey(key))\n   return map.put(key, value);\n else\n   return null;\n\n except that the action is performed atomically."}, {"method_name": "replaceAll", "method_sig": "default void replaceAll (BiFunction<? super K, ? super V, ? extends V> function)", "description": "Replaces each entry's value with the result of invoking the given\n function on that entry until all entries have been processed or the\n function throws an exception.  Exceptions thrown by the function are\n relayed to the caller."}, {"method_name": "computeIfAbsent", "method_sig": "default V computeIfAbsent (K key,\n                          Function<? super K, ? extends V> mappingFunction)", "description": "If the specified key is not already associated with a value (or is mapped\n to null), attempts to compute its value using the given mapping\n function and enters it into this map unless null.\n\n If the mapping function returns null, no mapping is recorded.\n If the mapping function itself throws an (unchecked) exception, the\n exception is rethrown, and no mapping is recorded.  The most\n common usage is to construct a new object serving as an initial\n mapped value or memoized result, as in:\n\n  \n map.computeIfAbsent(key, k -> new Value(f(k)));\n \nOr to implement a multi-value map, Map<K,Collection<V>>,\n supporting multiple values per key:\n\n  \n map.computeIfAbsent(key, k -> new HashSet<V>()).add(v);\n \nThe mapping function should not modify this map during computation."}, {"method_name": "computeIfPresent", "method_sig": "default V computeIfPresent (K key,\n                           BiFunction<? super K, ? super V, ? extends V> remappingFunction)", "description": "If the value for the specified key is present and non-null, attempts to\n compute a new mapping given the key and its current mapped value.\n\n If the remapping function returns null, the mapping is removed.\n If the remapping function itself throws an (unchecked) exception, the\n exception is rethrown, and the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation."}, {"method_name": "compute", "method_sig": "default V compute (K key,\n                  BiFunction<? super K, ? super V, ? extends V> remappingFunction)", "description": "Attempts to compute a mapping for the specified key and its current\n mapped value (or null if there is no current mapping). For\n example, to either create or append a String msg to a value\n mapping:\n\n  \n map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg))\n (Method merge() is often simpler to use for such purposes.)\n\n If the remapping function returns null, the mapping is removed\n (or remains absent if initially absent).  If the remapping function\n itself throws an (unchecked) exception, the exception is rethrown, and\n the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation."}, {"method_name": "merge", "method_sig": "default V merge (K key,\n                V value,\n                BiFunction<? super V, ? super V, ? extends V> remappingFunction)", "description": "If the specified key is not already associated with a value or is\n associated with null, associates it with the given non-null value.\n Otherwise, replaces the associated value with the results of the given\n remapping function, or removes if the result is null. This\n method may be of use when combining multiple mapped values for a key.\n For example, to either create or append a String msg to a\n value mapping:\n\n  \n map.merge(key, msg, String::concat)\n \nIf the remapping function returns null, the mapping is removed.\n If the remapping function itself throws an (unchecked) exception, the\n exception is rethrown, and the current mapping is left unchanged.\n\n The remapping function should not modify this map during computation."}]}