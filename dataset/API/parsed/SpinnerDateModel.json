{"name": "Class SpinnerDateModel", "module": "java.desktop", "package": "javax.swing", "text": "A SpinnerModel for sequences of Dates.\n The upper and lower bounds of the sequence are defined by properties called\n start and end and the size\n of the increase or decrease computed by the nextValue\n and previousValue methods is defined by a property\n called calendarField.  The start\n and end properties can be null to\n indicate that the sequence has no lower or upper limit.\n \n The value of the calendarField property must be one of the\n java.util.Calendar constants that specify a field\n within a Calendar.  The getNextValue\n and getPreviousValue\n methods change the date forward or backwards by this amount.\n For example, if calendarField is Calendar.DAY_OF_WEEK,\n then nextValue produces a Date that's 24\n hours after the current value, and previousValue\n produces a Date that's 24 hours earlier.\n \n The legal values for calendarField are:\n \nCalendar.ERA\nCalendar.YEAR\nCalendar.MONTH\nCalendar.WEEK_OF_YEAR\nCalendar.WEEK_OF_MONTH\nCalendar.DAY_OF_MONTH\nCalendar.DAY_OF_YEAR\nCalendar.DAY_OF_WEEK\nCalendar.DAY_OF_WEEK_IN_MONTH\nCalendar.AM_PM\nCalendar.HOUR\nCalendar.HOUR_OF_DAY\nCalendar.MINUTE\nCalendar.SECOND\nCalendar.MILLISECOND\n\n However some UIs may set the calendarField before committing the edit\n to spin the field under the cursor. If you only want one field to\n spin you can subclass and ignore the setCalendarField calls.\n \n This model inherits a ChangeListener.  The\n ChangeListeners are notified whenever the models\n value, calendarField,\n start, or end properties changes.", "codes": ["public class SpinnerDateModel\nextends AbstractSpinnerModel\nimplements Serializable"], "fields": [], "methods": [{"method_name": "setStart", "method_sig": "public void setStart (Comparable<Date> start)", "description": "Changes the lower limit for Dates in this sequence.\n If start is null,\n then there is no lower limit.  No bounds checking is done here:\n the new start value may invalidate the\n (start <= value <= end)\n invariant enforced by the constructors.  This is to simplify updating\n the model.  Naturally one should ensure that the invariant is true\n before calling the nextValue, previousValue,\n or setValue methods.\n \n Typically this property is a Date however it's possible to use\n a Comparable with a compareTo method for Dates.\n For example start might be an instance of a class like this:\n \n MyStartDate implements Comparable {\n     long t = 12345;\n     public int compareTo(Date d) {\n            return (t < d.getTime() ? -1 : (t == d.getTime() ? 0 : 1));\n     }\n     public int compareTo(Object o) {\n            return compareTo((Date)o);\n     }\n }\n \n Note that the above example will throw a ClassCastException\n if the Object passed to compareTo(Object)\n is not a Date.\n \n This method fires a ChangeEvent if the\n start has changed."}, {"method_name": "getStart", "method_sig": "public Comparable<Date> getStart()", "description": "Returns the first Date in the sequence."}, {"method_name": "setEnd", "method_sig": "public void setEnd (Comparable<Date> end)", "description": "Changes the upper limit for Dates in this sequence.\n If start is null, then there is no upper\n limit.  No bounds checking is done here: the new\n start value may invalidate the (start <= value <= end)\n invariant enforced by the constructors.  This is to simplify updating\n the model.  Naturally, one should ensure that the invariant is true\n before calling the nextValue, previousValue,\n or setValue methods.\n \n Typically this property is a Date however it's possible to use\n Comparable with a compareTo method for\n Dates.  See setStart for an example.\n \n This method fires a ChangeEvent if the end\n has changed."}, {"method_name": "getEnd", "method_sig": "public Comparable<Date> getEnd()", "description": "Returns the last Date in the sequence."}, {"method_name": "setCalendarField", "method_sig": "public void setCalendarField (int calendarField)", "description": "Changes the size of the date value change computed\n by the nextValue and previousValue methods.\n The calendarField parameter must be one of the\n Calendar field constants like Calendar.MONTH\n or Calendar.MINUTE.\n The nextValue and previousValue methods\n simply move the specified Calendar field forward or backward\n by one unit with the Calendar.add method.\n You should use this method with care as some UIs may set the\n calendarField before committing the edit to spin the field under\n the cursor. If you only want one field to spin you can subclass\n and ignore the setCalendarField calls."}, {"method_name": "getCalendarField", "method_sig": "public int getCalendarField()", "description": "Returns the Calendar field that is added to or subtracted from\n by the nextValue and previousValue methods."}, {"method_name": "getNextValue", "method_sig": "public Object getNextValue()", "description": "Returns the next Date in the sequence, or null if\n the next date is after end."}, {"method_name": "getPreviousValue", "method_sig": "public Object getPreviousValue()", "description": "Returns the previous Date in the sequence, or null\n if the previous date is before start."}, {"method_name": "getDate", "method_sig": "public Date getDate()", "description": "Returns the current element in this sequence of Dates.\n This method is equivalent to (Date)getValue."}, {"method_name": "getValue", "method_sig": "public Object getValue()", "description": "Returns the current element in this sequence of Dates."}, {"method_name": "setValue", "method_sig": "public void setValue (Object value)", "description": "Sets the current Date for this sequence.\n If value is null,\n an IllegalArgumentException is thrown.  No bounds\n checking is done here:\n the new value may invalidate the (start <= value < end)\n invariant enforced by the constructors.  Naturally, one should ensure\n that the (start <= value <= maximum) invariant is true\n before calling the nextValue, previousValue,\n or setValue methods.\n \n This method fires a ChangeEvent if the\n value has changed."}]}