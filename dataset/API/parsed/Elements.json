{"name": "Interface Elements", "module": "java.compiler", "package": "javax.lang.model.util", "text": "Utility methods for operating on program elements.\n\n Compatibility Note: Methods may be added to this interface\n in future releases of the platform.", "codes": ["public interface Elements"], "fields": [], "methods": [{"method_name": "getPackageElement", "method_sig": "PackageElement getPackageElement (CharSequence name)", "description": "Returns a package given its fully qualified name if the package is unique in the environment.\n If running with modules, all modules in the modules graph are searched for matching packages."}, {"method_name": "getPackageElement", "method_sig": "default PackageElement getPackageElement (ModuleElement module,\n                                         CharSequence name)", "description": "Returns a package given its fully qualified name, as seen from the given module."}, {"method_name": "getAllPackageElements", "method_sig": "default Set<? extends PackageElement> getAllPackageElements (CharSequence name)", "description": "Returns all package elements with the given canonical name.\n\n There may be more than one package element with the same canonical\n name if the package elements are in different modules."}, {"method_name": "getTypeElement", "method_sig": "TypeElement getTypeElement (CharSequence name)", "description": "Returns a type element given its canonical name if the type element is unique in the environment.\n If running with modules, all modules in the modules graph are searched for matching\n type elements."}, {"method_name": "getTypeElement", "method_sig": "default TypeElement getTypeElement (ModuleElement module,\n                                   CharSequence name)", "description": "Returns a type element given its canonical name, as seen from the given module."}, {"method_name": "getAllTypeElements", "method_sig": "default Set<? extends TypeElement> getAllTypeElements (CharSequence name)", "description": "Returns all type elements with the given canonical name.\n\n There may be more than one type element with the same canonical\n name if the type elements are in different modules."}, {"method_name": "getModuleElement", "method_sig": "default ModuleElement getModuleElement (CharSequence name)", "description": "Returns a module element given its fully qualified name.\n\n If the named module cannot be found, null is\n returned. One situation where a module cannot be found is if\n the environment does not include modules, such as an annotation\n processing environment configured for a source version without modules."}, {"method_name": "getAllModuleElements", "method_sig": "default Set<? extends ModuleElement> getAllModuleElements()", "description": "Returns all module elements in the current environment.\n\n If no modules are present, an empty set is returned. One\n situation where no modules are present occurs when the\n environment does not include modules, such as an annotation\n processing environment configured for a source version without modules."}, {"method_name": "getElementValuesWithDefaults", "method_sig": "Map<? extends ExecutableElement, ? extends AnnotationValue> getElementValuesWithDefaults (AnnotationMirror a)", "description": "Returns the values of an annotation's elements, including defaults."}, {"method_name": "getDocComment", "method_sig": "String getDocComment (Element e)", "description": "Returns the text of the documentation (\"Javadoc\")\n comment of an element.\n\n  A documentation comment of an element is a comment that\n begins with \"/**\" , ends with a separate\n \"*/\", and immediately precedes the element,\n ignoring white space.  Therefore, a documentation comment\n contains at least three\"*\" characters.  The text\n returned for the documentation comment is a processed form of\n the comment as it appears in source code.  The leading \"\n /**\" and trailing \"*/\" are removed.  For lines\n of the comment starting after the initial \"/**\",\n leading white space characters are discarded as are any\n consecutive \"*\" characters appearing after the white\n space or starting the line.  The processed lines are then\n concatenated together (including line terminators) and\n returned."}, {"method_name": "isDeprecated", "method_sig": "boolean isDeprecated (Element e)", "description": "Returns true if the element is deprecated, false otherwise."}, {"method_name": "getOrigin", "method_sig": "default Elements.Origin getOrigin (Element e)", "description": "Returns the origin of the given element.\n\n Note that if this method returns EXPLICIT and the element was created from a class file, then\n the element may not, in fact, correspond to an explicitly\n declared construct in source code. This is due to limitations\n of the fidelity of the class file format in preserving\n information from source code. For example, at least some\n versions of the class file format do not preserve whether a\n constructor was explicitly declared by the programmer or was\n implicitly declared as the default constructor."}, {"method_name": "getOrigin", "method_sig": "default Elements.Origin getOrigin (AnnotatedConstruct c,\n                                  AnnotationMirror a)", "description": "Returns the origin of the given annotation mirror.\n\n An annotation mirror is mandated\n if it is an implicitly declared container annotation\n used to hold repeated annotations of a repeatable annotation\n type.\n\n Note that if this method returns EXPLICIT and the annotation mirror was created from a class\n file, then the element may not, in fact, correspond to an\n explicitly declared construct in source code. This is due to\n limitations of the fidelity of the class file format in\n preserving information from source code. For example, at least\n some versions of the class file format do not preserve whether\n an annotation was explicitly declared by the programmer or was\n implicitly declared as a container annotation."}, {"method_name": "getOrigin", "method_sig": "default Elements.Origin getOrigin (ModuleElement m,\n                                  ModuleElement.Directive directive)", "description": "Returns the origin of the given module directive.\n\n Note that if this method returns EXPLICIT and the module directive was created from a class\n file, then the module directive may not, in fact, correspond to\n an explicitly declared construct in source code. This is due to\n limitations of the fidelity of the class file format in\n preserving information from source code. For example, at least\n some versions of the class file format do not preserve whether\n a uses directive was explicitly declared by the\n programmer or was added as a synthetic construct.\n\n Note that an implementation may not be able to reliably\n determine the origin status of the directive if the directive\n is created from a class file due to limitations of the fidelity\n of the class file format in preserving information from source\n code."}, {"method_name": "isBridge", "method_sig": "default boolean isBridge (ExecutableElement e)", "description": "Returns true if the executable element is a bridge\n method, false otherwise."}, {"method_name": "getBinaryName", "method_sig": "Name getBinaryName (TypeElement type)", "description": "Returns the binary name of a type element."}, {"method_name": "getPackageOf", "method_sig": "PackageElement getPackageOf (Element type)", "description": "Returns the package of an element.  The package of a package is\n itself."}, {"method_name": "getModuleOf", "method_sig": "default ModuleElement getModuleOf (Element type)", "description": "Returns the module of an element.  The module of a module is\n itself.\n If there is no module for the element, null is returned. One situation where there is\n no module for an element is if the environment does not include modules, such as\n an annotation processing environment configured for\n a source version without modules."}, {"method_name": "getAllMembers", "method_sig": "List<? extends Element> getAllMembers (TypeElement type)", "description": "Returns all members of a type element, whether inherited or\n declared directly.  For a class the result also includes its\n constructors, but not local or anonymous classes."}, {"method_name": "getAllAnnotationMirrors", "method_sig": "List<? extends AnnotationMirror> getAllAnnotationMirrors (Element e)", "description": "Returns all annotations present on an element, whether\n directly present or present via inheritance."}, {"method_name": "hides", "method_sig": "boolean hides (Element hider,\n              Element hidden)", "description": "Tests whether one type, method, or field hides another."}, {"method_name": "overrides", "method_sig": "boolean overrides (ExecutableElement overrider,\n                  ExecutableElement overridden,\n                  TypeElement type)", "description": "Tests whether one method, as a member of a given type,\n overrides another method.\n When a non-abstract method overrides an abstract one, the\n former is also said to implement the latter.\n\n  In the simplest and most typical usage, the value of the\n type parameter will simply be the class or interface\n directly enclosing overrider (the possibly-overriding\n method).  For example, suppose m1 represents the method\n String.hashCode and m2 represents \n Object.hashCode.  We can then ask whether m1 overrides\n m2 within the class String (it does):\n\n \nassert elements.overrides(m1, m2,\n          elements.getTypeElement(\"java.lang.String\")); \n\n\n A more interesting case can be illustrated by the following example\n in which a method in type A does not override a\n like-named method in type B:\n\n \nclass A { public void m() {} } \ninterface B { void m(); } \n ...\nm1 = ...;  // A.m \nm2 = ...;  // B.m \nassert ! elements.overrides(m1, m2,\n          elements.getTypeElement(\"A\")); \n\n\n When viewed as a member of a third type C, however,\n the method in A does override the one in B:\n\n \nclass C extends A implements B {} \n ...\nassert elements.overrides(m1, m2,\n          elements.getTypeElement(\"C\")); \n"}, {"method_name": "getConstantExpression", "method_sig": "String getConstantExpression (Object value)", "description": "Returns the text of a constant expression representing a\n primitive value or a string.\n The text returned is in a form suitable for representing the value\n in source code."}, {"method_name": "printElements", "method_sig": "void printElements (Writer w,\n                   Element... elements)", "description": "Prints a representation of the elements to the given writer in\n the specified order.  The main purpose of this method is for\n diagnostics.  The exact format of the output is not\n specified and is subject to change."}, {"method_name": "getName", "method_sig": "Name getName (CharSequence cs)", "description": "Return a name with the same sequence of characters as the\n argument."}, {"method_name": "isFunctionalInterface", "method_sig": "boolean isFunctionalInterface (TypeElement type)", "description": "Returns true if the type element is a functional interface, false otherwise."}]}