{"name": "Interface ContentHandler", "module": "java.xml", "package": "org.xml.sax", "text": "Receive notification of the logical content of a document.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n See http://www.saxproject.org\n for further information.\n \nThis is the main interface that most SAX applications\n implement: if the application needs to be informed of basic parsing\n events, it implements this interface and registers an instance with\n the SAX parser using the setContentHandler method.  The parser uses the instance to report\n basic document-related events like the start and end of elements\n and character data.\nThe order of events in this interface is very important, and\n mirrors the order of information in the document itself.  For\n example, all of an element's content (character data, processing\n instructions, and/or subelements) will appear, in order, between\n the startElement event and the corresponding endElement event.\nThis interface is similar to the now-deprecated SAX 1.0\n DocumentHandler interface, but it adds support for Namespaces\n and for reporting skipped entities (in non-validating XML\n processors).\nImplementors should note that there is also a\n ContentHandler class in the java.net\n package; that means that it's probably a bad idea to do\nimport java.net.*;\n import org.xml.sax.*;\n \nIn fact, \"import ...*\" is usually a sign of sloppy programming\n anyway, so the user should consider this a feature rather than a\n bug.", "codes": ["public interface ContentHandler"], "fields": [], "methods": [{"method_name": "setDocumentLocator", "method_sig": "void setDocumentLocator (Locator locator)", "description": "Receive an object for locating the origin of SAX document events.\n\n SAX parsers are strongly encouraged (though not absolutely\n required) to supply a locator: if it does so, it must supply\n the locator to the application by invoking this method before\n invoking any of the other methods in the ContentHandler\n interface.\nThe locator allows the application to determine the end\n position of any document-related event, even if the parser is\n not reporting an error.  Typically, the application will\n use this information for reporting its own errors (such as\n character content that does not match an application's\n business rules).  The information returned by the locator\n is probably not sufficient for use with a search engine.\nNote that the locator will return correct information only\n during the invocation SAX event callbacks after\n startDocument returns and before\n endDocument is called.  The\n application should not attempt to use it at any other time."}, {"method_name": "startDocument", "method_sig": "void startDocument()\n            throws SAXException", "description": "Receive notification of the beginning of a document.\n\n The SAX parser will invoke this method only once, before any\n other event callbacks (except for setDocumentLocator)."}, {"method_name": "endDocument", "method_sig": "void endDocument()\n          throws SAXException", "description": "Receive notification of the end of a document.\n\n There is an apparent contradiction between the\n documentation for this method and the documentation for ErrorHandler.fatalError(org.xml.sax.SAXParseException).  Until this ambiguity is\n resolved in a future major release, clients should make no\n assumptions about whether endDocument() will or will not be\n invoked when the parser has reported a fatalError() or thrown\n an exception.\nThe SAX parser will invoke this method only once, and it will\n be the last method invoked during the parse.  The parser shall\n not invoke this method until it has either abandoned parsing\n (because of an unrecoverable error) or reached the end of\n input."}, {"method_name": "startPrefixMapping", "method_sig": "void startPrefixMapping (String prefix,\n                        String uri)\n                 throws SAXException", "description": "Begin the scope of a prefix-URI Namespace mapping.\n\n The information from this event is not necessary for\n normal Namespace processing: the SAX XML reader will\n automatically replace prefixes for element and attribute\n names when the http://xml.org/sax/features/namespaces\n feature is true (the default).\nThere are cases, however, when applications need to\n use prefixes in character data or in attribute values,\n where they cannot safely be expanded automatically; the\n start/endPrefixMapping event supplies the information\n to the application to expand prefixes in those contexts\n itself, if necessary.\nNote that start/endPrefixMapping events are not\n guaranteed to be properly nested relative to each other:\n all startPrefixMapping events will occur immediately before the\n corresponding startElement event,\n and all endPrefixMapping\n events will occur immediately after the corresponding\n endElement event,\n but their order is not otherwise\n guaranteed.\nThere should never be start/endPrefixMapping events for the\n \"xml\" prefix, since it is predeclared and immutable."}, {"method_name": "endPrefixMapping", "method_sig": "void endPrefixMapping (String prefix)\n               throws SAXException", "description": "End the scope of a prefix-URI mapping.\n\n See startPrefixMapping for\n details.  These events will always occur immediately after the\n corresponding endElement event, but the order of\n endPrefixMapping events is not otherwise\n guaranteed."}, {"method_name": "startElement", "method_sig": "void startElement (String uri,\n                  String localName,\n                  String qName,\n                  Attributes atts)\n           throws SAXException", "description": "Receive notification of the beginning of an element.\n\n The Parser will invoke this method at the beginning of every\n element in the XML document; there will be a corresponding\n endElement event for every startElement event\n (even when the element is empty). All of the element's content will be\n reported, in order, before the corresponding endElement\n event.\nThis event allows up to three name components for each\n element:\n\nthe Namespace URI;\nthe local name; and\nthe qualified (prefixed) name.\n\nAny or all of these may be provided, depending on the\n values of the http://xml.org/sax/features/namespaces\n and the http://xml.org/sax/features/namespace-prefixes\n properties:\n\nthe Namespace URI and local name are required when\n the namespaces property is true (the default), and are\n optional when the namespaces property is false (if one is\n specified, both must be);\nthe qualified name is required when the namespace-prefixes property\n is true, and is optional when the namespace-prefixes property\n is false (the default).\n\nNote that the attribute list provided will contain only\n attributes with explicit values (specified or defaulted):\n #IMPLIED attributes will be omitted.  The attribute list\n will contain attributes used for Namespace declarations\n (xmlns* attributes) only if the\n http://xml.org/sax/features/namespace-prefixes\n property is true (it is false by default, and support for a\n true value is optional).\nLike characters(), attribute values may have\n characters that need more than one char value.  "}, {"method_name": "endElement", "method_sig": "void endElement (String uri,\n                String localName,\n                String qName)\n         throws SAXException", "description": "Receive notification of the end of an element.\n\n The SAX parser will invoke this method at the end of every\n element in the XML document; there will be a corresponding\n startElement event for every endElement\n event (even when the element is empty).\nFor information on the names, see startElement."}, {"method_name": "characters", "method_sig": "void characters (char[] ch,\n                int start,\n                int length)\n         throws SAXException", "description": "Receive notification of character data.\n\n The Parser will call this method to report each chunk of\n character data.  SAX parsers may return all contiguous character\n data in a single chunk, or they may split it into several\n chunks; however, all of the characters in any single event\n must come from the same external entity so that the Locator\n provides useful information.\nThe application must not attempt to read from the array\n outside of the specified range.\nIndividual characters may consist of more than one Java\n char value.  There are two important cases where this\n happens, because characters can't be represented in just sixteen bits.\n In one case, characters are represented in a Surrogate Pair,\n using two special Unicode values. Such characters are in the so-called\n \"Astral Planes\", with a code point above U+FFFF.  A second case involves\n composite characters, such as a base character combining with one or\n more accent characters. \n Your code should not assume that algorithms using\n char-at-a-time idioms will be working in character\n units; in some cases they will split characters.  This is relevant\n wherever XML permits arbitrary characters, such as attribute values,\n processing instruction data, and comments as well as in data reported\n from this method.  It's also generally relevant whenever Java code\n manipulates internationalized text; the issue isn't unique to XML.\nNote that some parsers will report whitespace in element\n content using the ignorableWhitespace\n method rather than this one (validating parsers must\n do so)."}, {"method_name": "ignorableWhitespace", "method_sig": "void ignorableWhitespace (char[] ch,\n                         int start,\n                         int length)\n                  throws SAXException", "description": "Receive notification of ignorable whitespace in element content.\n\n Validating Parsers must use this method to report each chunk\n of whitespace in element content (see the W3C XML 1.0\n recommendation, section 2.10): non-validating parsers may also\n use this method if they are capable of parsing and using\n content models.\nSAX parsers may return all contiguous whitespace in a single\n chunk, or they may split it into several chunks; however, all of\n the characters in any single event must come from the same\n external entity, so that the Locator provides useful\n information.\nThe application must not attempt to read from the array\n outside of the specified range."}, {"method_name": "processingInstruction", "method_sig": "void processingInstruction (String target,\n                           String data)\n                    throws SAXException", "description": "Receive notification of a processing instruction.\n\n The Parser will invoke this method once for each processing\n instruction found: note that processing instructions may occur\n before or after the main document element.\nA SAX parser must never report an XML declaration (XML 1.0,\n section 2.8) or a text declaration (XML 1.0, section 4.3.1)\n using this method.\nLike characters(), processing instruction\n data may have characters that need more than one char\n value. "}, {"method_name": "skippedEntity", "method_sig": "void skippedEntity (String name)\n            throws SAXException", "description": "Receive notification of a skipped entity.\n This is not called for entity references within markup constructs\n such as element start tags or markup declarations.  (The XML\n recommendation requires reporting skipped external entities.\n SAX also reports internal entity expansion/non-expansion, except\n within markup constructs.)\n\n The Parser will invoke this method each time the entity is\n skipped.  Non-validating processors may skip entities if they\n have not seen the declarations (because, for example, the\n entity was declared in an external DTD subset).  All processors\n may skip external entities, depending on the values of the\n http://xml.org/sax/features/external-general-entities\n and the\n http://xml.org/sax/features/external-parameter-entities\n properties."}]}