{"name": "Class TreeSet<E>", "module": "java.base", "package": "java.util", "text": "A NavigableSet implementation based on a TreeMap.\n The elements are ordered using their natural\n ordering, or by a Comparator provided at set creation\n time, depending on which constructor is used.\n\n This implementation provides guaranteed log(n) time cost for the basic\n operations (add, remove and contains).\n\n Note that the ordering maintained by a set (whether or not an explicit\n comparator is provided) must be consistent with equals if it is to\n correctly implement the Set interface.  (See Comparable\n or Comparator for a precise definition of consistent with\n equals.)  This is so because the Set interface is defined in\n terms of the equals operation, but a TreeSet instance\n performs all element comparisons using its compareTo (or\n compare) method, so two elements that are deemed equal by this method\n are, from the standpoint of the set, equal.  The behavior of a set\n is well-defined even if its ordering is inconsistent with equals; it\n just fails to obey the general contract of the Set interface.\n\n Note that this implementation is not synchronized.\n If multiple threads access a tree set concurrently, and at least one\n of the threads modifies the set, it must be synchronized\n externally.  This is typically accomplished by synchronizing on some\n object that naturally encapsulates the set.\n If no such object exists, the set should be \"wrapped\" using the\n Collections.synchronizedSortedSet\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the set: \n   SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));\nThe iterators returned by this class's iterator method are\n fail-fast: if the set is modified at any time after the iterator is\n created, in any way except through the iterator's own remove\n method, the iterator will throw a ConcurrentModificationException.\n Thus, in the face of concurrent modification, the iterator fails quickly\n and cleanly, rather than risking arbitrary, non-deterministic behavior at\n an undetermined time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness:   the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.", "codes": ["public class TreeSet<E>\nextends AbstractSet<E>\nimplements NavigableSet<E>, Cloneable, Serializable"], "fields": [], "methods": [{"method_name": "iterator", "method_sig": "public Iterator<E> iterator()", "description": "Returns an iterator over the elements in this set in ascending order."}, {"method_name": "descendingIterator", "method_sig": "public Iterator<E> descendingIterator()", "description": "Returns an iterator over the elements in this set in descending order."}, {"method_name": "descendingSet", "method_sig": "public NavigableSet<E> descendingSet()", "description": "Description copied from interface:\u00a0NavigableSet"}, {"method_name": "size", "method_sig": "public int size()", "description": "Returns the number of elements in this set (its cardinality)."}, {"method_name": "isEmpty", "method_sig": "public boolean isEmpty()", "description": "Returns true if this set contains no elements."}, {"method_name": "contains", "method_sig": "public boolean contains (Object o)", "description": "Returns true if this set contains the specified element.\n More formally, returns true if and only if this set\n contains an element e such that\n Objects.equals(o, e)."}, {"method_name": "add", "method_sig": "public boolean add (E e)", "description": "Adds the specified element to this set if it is not already present.\n More formally, adds the specified element e to this set if\n the set contains no element e2 such that\n Objects.equals(e, e2).\n If this set already contains the element, the call leaves the set\n unchanged and returns false."}, {"method_name": "remove", "method_sig": "public boolean remove (Object o)", "description": "Removes the specified element from this set if it is present.\n More formally, removes an element e such that\n Objects.equals(o, e),\n if this set contains such an element.  Returns true if\n this set contained the element (or equivalently, if this set\n changed as a result of the call).  (This set will not contain the\n element once the call returns.)"}, {"method_name": "clear", "method_sig": "public void clear()", "description": "Removes all of the elements from this set.\n The set will be empty after this call returns."}, {"method_name": "addAll", "method_sig": "public boolean addAll (Collection<? extends E> c)", "description": "Adds all of the elements in the specified collection to this set."}, {"method_name": "subSet", "method_sig": "public NavigableSet<E> subSet (E fromElement,\n                              boolean fromInclusive,\n                              E toElement,\n                              boolean toInclusive)", "description": "Description copied from interface:\u00a0NavigableSet"}, {"method_name": "headSet", "method_sig": "public NavigableSet<E> headSet (E toElement,\n                               boolean inclusive)", "description": "Description copied from interface:\u00a0NavigableSet"}, {"method_name": "tailSet", "method_sig": "public NavigableSet<E> tailSet (E fromElement,\n                               boolean inclusive)", "description": "Description copied from interface:\u00a0NavigableSet"}, {"method_name": "subSet", "method_sig": "public SortedSet<E> subSet (E fromElement,\n                           E toElement)", "description": "Description copied from interface:\u00a0NavigableSet"}, {"method_name": "headSet", "method_sig": "public SortedSet<E> headSet (E toElement)", "description": "Description copied from interface:\u00a0NavigableSet"}, {"method_name": "tailSet", "method_sig": "public SortedSet<E> tailSet (E fromElement)", "description": "Description copied from interface:\u00a0NavigableSet"}, {"method_name": "first", "method_sig": "public E first()", "description": "Description copied from interface:\u00a0SortedSet"}, {"method_name": "last", "method_sig": "public E last()", "description": "Description copied from interface:\u00a0SortedSet"}, {"method_name": "lower", "method_sig": "public E lower (E e)", "description": "Description copied from interface:\u00a0NavigableSet"}, {"method_name": "floor", "method_sig": "public E floor (E e)", "description": "Description copied from interface:\u00a0NavigableSet"}, {"method_name": "ceiling", "method_sig": "public E ceiling (E e)", "description": "Description copied from interface:\u00a0NavigableSet"}, {"method_name": "higher", "method_sig": "public E higher (E e)", "description": "Description copied from interface:\u00a0NavigableSet"}, {"method_name": "pollFirst", "method_sig": "public E pollFirst()", "description": "Description copied from interface:\u00a0NavigableSet"}, {"method_name": "pollLast", "method_sig": "public E pollLast()", "description": "Description copied from interface:\u00a0NavigableSet"}, {"method_name": "clone", "method_sig": "public Object clone()", "description": "Returns a shallow copy of this TreeSet instance. (The elements\n themselves are not cloned.)"}, {"method_name": "spliterator", "method_sig": "public Spliterator<E> spliterator()", "description": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n set.\n\n The Spliterator reports Spliterator.SIZED,\n Spliterator.DISTINCT, Spliterator.SORTED, and\n Spliterator.ORDERED.  Overriding implementations should document\n the reporting of additional characteristic values.\n\n The spliterator's comparator (see\n Spliterator.getComparator()) is null if\n the tree set's comparator (see SortedSet.comparator()) is null.\n Otherwise, the spliterator's comparator is the same as or imposes the\n same total ordering as the tree set's comparator."}]}