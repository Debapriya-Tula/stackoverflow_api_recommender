{"name": "Class Buffer", "module": "java.base", "package": "java.nio", "text": "A container for data of a specific primitive type.\n\n  A buffer is a linear, finite sequence of elements of a specific\n primitive type.  Aside from its content, the essential properties of a\n buffer are its capacity, limit, and position: \n\n A buffer's capacity is the number of elements it contains.  The\n   capacity of a buffer is never negative and never changes.  \n A buffer's limit is the index of the first element that should\n   not be read or written.  A buffer's limit is never negative and is never\n   greater than its capacity.  \n A buffer's position is the index of the next element to be\n   read or written.  A buffer's position is never negative and is never\n   greater than its limit.  \n\n There is one subclass of this class for each non-boolean primitive type.\n\n\n  Transferring data \n Each subclass of this class defines two categories of get and\n put operations: \n\n Relative operations read or write one or more elements starting\n   at the current position and then increment the position by the number of\n   elements transferred.  If the requested transfer exceeds the limit then a\n   relative get operation throws a BufferUnderflowException\n   and a relative put operation throws a BufferOverflowException; in either case, no data is transferred.  \n Absolute operations take an explicit element index and do not\n   affect the position.  Absolute get and put operations throw\n   an IndexOutOfBoundsException if the index argument exceeds the\n   limit.  \n\n Data may also, of course, be transferred in to or out of a buffer by the\n I/O operations of an appropriate channel, which are always relative to the\n current position.\n\n\n  Marking and resetting \n A buffer's mark is the index to which its position will be reset\n when the reset method is invoked.  The mark is not always\n defined, but when it is defined it is never negative and is never greater\n than the position.  If the mark is defined then it is discarded when the\n position or the limit is adjusted to a value smaller than the mark.  If the\n mark is not defined then invoking the reset method causes an\n InvalidMarkException to be thrown.\n\n\n  Invariants \n The following invariant holds for the mark, position, limit, and\n capacity values:\n\n \n0 <=\nmark <=\nposition <=\nlimit <=\ncapacity\n\n A newly-created buffer always has a position of zero and a mark that is\n undefined.  The initial limit may be zero, or it may be some other value\n that depends upon the type of the buffer and the manner in which it is\n constructed.  Each element of a newly-allocated buffer is initialized\n to zero.\n\n\n  Additional operations \n In addition to methods for accessing the position, limit, and capacity\n values and for marking and resetting, this class also defines the following\n operations upon buffers:\n\n \n clear() makes a buffer ready for a new sequence of\n   channel-read or relative put operations: It sets the limit to the\n   capacity and the position to zero.  \n flip() makes a buffer ready for a new sequence of\n   channel-write or relative get operations: It sets the limit to the\n   current position and then sets the position to zero.  \n rewind() makes a buffer ready for re-reading the data that\n   it already contains: It leaves the limit unchanged and sets the position\n   to zero.  \n slice() creates a subsequence of a buffer: It leaves the\n   limit and the position unchanged. \n duplicate() creates a shallow copy of a buffer: It leaves\n   the limit and the position unchanged. \n\n Read-only buffers \n Every buffer is readable, but not every buffer is writable.  The\n mutation methods of each buffer class are specified as optional\n operations that will throw a ReadOnlyBufferException when\n invoked upon a read-only buffer.  A read-only buffer does not allow its\n content to be changed, but its mark, position, and limit values are mutable.\n Whether or not a buffer is read-only may be determined by invoking its\n isReadOnly method.\n\n\n  Thread safety \n Buffers are not safe for use by multiple concurrent threads.  If a\n buffer is to be used by more than one thread then access to the buffer\n should be controlled by appropriate synchronization.\n\n\n  Invocation chaining \n Methods in this class that do not otherwise have a value to return are\n specified to return the buffer upon which they are invoked.  This allows\n method invocations to be chained; for example, the sequence of statements\n\n \n b.flip();\n b.position(23);\n b.limit(42);\n\n can be replaced by the single, more compact statement\n\n \n b.flip().position(23).limit(42);", "codes": ["public abstract class Buffer\nextends Object"], "fields": [], "methods": [{"method_name": "capacity", "method_sig": "public final int capacity()", "description": "Returns this buffer's capacity."}, {"method_name": "position", "method_sig": "public final int position()", "description": "Returns this buffer's position."}, {"method_name": "position", "method_sig": "public Buffer position (int newPosition)", "description": "Sets this buffer's position.  If the mark is defined and larger than the\n new position then it is discarded."}, {"method_name": "limit", "method_sig": "public final int limit()", "description": "Returns this buffer's limit."}, {"method_name": "limit", "method_sig": "public Buffer limit (int newLimit)", "description": "Sets this buffer's limit.  If the position is larger than the new limit\n then it is set to the new limit.  If the mark is defined and larger than\n the new limit then it is discarded."}, {"method_name": "mark", "method_sig": "public Buffer mark()", "description": "Sets this buffer's mark at its position."}, {"method_name": "reset", "method_sig": "public Buffer reset()", "description": "Resets this buffer's position to the previously-marked position.\n\n  Invoking this method neither changes nor discards the mark's\n value. "}, {"method_name": "clear", "method_sig": "public Buffer clear()", "description": "Clears this buffer.  The position is set to zero, the limit is set to\n the capacity, and the mark is discarded.\n\n  Invoke this method before using a sequence of channel-read or\n put operations to fill this buffer.  For example:\n\n \n buf.clear();     // Prepare buffer for reading\n in.read(buf);    // Read data\n This method does not actually erase the data in the buffer, but it\n is named as if it did because it will most often be used in situations\n in which that might as well be the case. "}, {"method_name": "flip", "method_sig": "public Buffer flip()", "description": "Flips this buffer.  The limit is set to the current position and then\n the position is set to zero.  If the mark is defined then it is\n discarded.\n\n  After a sequence of channel-read or put operations, invoke\n this method to prepare for a sequence of channel-write or relative\n get operations.  For example:\n\n \n buf.put(magic);    // Prepend header\n in.read(buf);      // Read data into rest of buffer\n buf.flip();        // Flip buffer\n out.write(buf);    // Write header + data to channel\n This method is often used in conjunction with the compact method when transferring data from\n one place to another.  "}, {"method_name": "rewind", "method_sig": "public Buffer rewind()", "description": "Rewinds this buffer.  The position is set to zero and the mark is\n discarded.\n\n  Invoke this method before a sequence of channel-write or get\n operations, assuming that the limit has already been set\n appropriately.  For example:\n\n \n out.write(buf);    // Write remaining data\n buf.rewind();      // Rewind buffer\n buf.get(array);    // Copy data into array"}, {"method_name": "remaining", "method_sig": "public final int remaining()", "description": "Returns the number of elements between the current position and the\n limit."}, {"method_name": "hasRemaining", "method_sig": "public final boolean hasRemaining()", "description": "Tells whether there are any elements between the current position and\n the limit."}, {"method_name": "isReadOnly", "method_sig": "public abstract boolean isReadOnly()", "description": "Tells whether or not this buffer is read-only."}, {"method_name": "hasArray", "method_sig": "public abstract boolean hasArray()", "description": "Tells whether or not this buffer is backed by an accessible\n array.\n\n  If this method returns true then the array\n and arrayOffset methods may safely be invoked.\n "}, {"method_name": "array", "method_sig": "public abstract Object array()", "description": "Returns the array that backs this\n buffer\u00a0\u00a0(optional operation).\n\n  This method is intended to allow array-backed buffers to be\n passed to native code more efficiently. Concrete subclasses\n provide more strongly-typed return values for this method.\n\n  Modifications to this buffer's content will cause the returned\n array's content to be modified, and vice versa.\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array.  "}, {"method_name": "arrayOffset", "method_sig": "public abstract int arrayOffset()", "description": "Returns the offset within this buffer's backing array of the first\n element of the buffer\u00a0\u00a0(optional operation).\n\n  If this buffer is backed by an array then buffer position p\n corresponds to array index p\u00a0+\u00a0arrayOffset().\n\n  Invoke the hasArray method before invoking this\n method in order to ensure that this buffer has an accessible backing\n array.  "}, {"method_name": "isDirect", "method_sig": "public abstract boolean isDirect()", "description": "Tells whether or not this buffer is\n direct."}, {"method_name": "slice", "method_sig": "public abstract Buffer slice()", "description": "Creates a new buffer whose content is a shared subsequence of\n this buffer's content.\n\n  The content of the new buffer will start at this buffer's current\n position.  Changes to this buffer's content will be visible in the new\n buffer, and vice versa; the two buffers' position, limit, and mark\n values will be independent.\n\n  The new buffer's position will be zero, its capacity and its limit\n will be the number of elements remaining in this buffer, its mark will be\n undefined. The new buffer will be direct if, and only if, this buffer is\n direct, and it will be read-only if, and only if, this buffer is\n read-only.  "}, {"method_name": "duplicate", "method_sig": "public abstract Buffer duplicate()", "description": "Creates a new buffer that shares this buffer's content.\n\n  The content of the new buffer will be that of this buffer.  Changes\n to this buffer's content will be visible in the new buffer, and vice\n versa; the two buffers' position, limit, and mark values will be\n independent.\n\n  The new buffer's capacity, limit, position and mark values will be\n identical to those of this buffer. The new buffer will be direct if, and\n only if, this buffer is direct, and it will be read-only if, and only if,\n this buffer is read-only.  "}]}