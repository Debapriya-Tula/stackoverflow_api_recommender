{"name": "Class CardChannel", "module": "java.smartcardio", "package": "javax.smartcardio", "text": "A logical channel connection to a Smart Card. It is used to exchange APDUs\n with a Smart Card.\n A CardChannel object can be obtained by calling the method\n Card.getBasicChannel() or Card.openLogicalChannel().", "codes": ["public abstract class CardChannel\nextends Object"], "fields": [], "methods": [{"method_name": "getCard", "method_sig": "public abstract Card getCard()", "description": "Returns the Card this channel is associated with."}, {"method_name": "getChannelNumber", "method_sig": "public abstract int getChannelNumber()", "description": "Returns the channel number of this CardChannel. A channel number of\n 0 indicates the basic logical channel."}, {"method_name": "transmit", "method_sig": "public abstract ResponseAPDU transmit (CommandAPDU command)\n                               throws CardException", "description": "Transmits the specified command APDU to the Smart Card and returns the\n response APDU.\n\n The CLA byte of the command APDU is automatically adjusted to\n match the channel number of this CardChannel.\n\n Note that this method cannot be used to transmit\n MANAGE CHANNEL APDUs. Logical channels should be managed\n using the Card.openLogicalChannel() and CardChannel.close() methods.\n\n Implementations should transparently handle artifacts\n of the transmission protocol.\n For example, when using the T=0 protocol, the following processing\n should occur as described in ISO/IEC 7816-4:\n\n \nif the response APDU has an SW1 of 61, the\n implementation should issue a GET RESPONSE command\n using SW2 as the Lefield.\n This process is repeated as long as an SW1 of 61 is\n received. The response body of these exchanges is concatenated\n to form the final response body.\n\n if the response APDU is 6C XX, the implementation\n should reissue the command using XX as the\n Le field.\n \nThe ResponseAPDU returned by this method is the result\n after this processing has been performed."}, {"method_name": "transmit", "method_sig": "public abstract int transmit (ByteBuffer command,\n                             ByteBuffer response)\n                      throws CardException", "description": "Transmits the command APDU stored in the command ByteBuffer and receives\n the response APDU in the response ByteBuffer.\n\n The command buffer must contain valid command APDU data starting\n at command.position() and the APDU must be\n command.remaining() bytes long.\n Upon return, the command buffer's position will be equal\n to its limit; its limit will not have changed. The output buffer\n will have received the response APDU bytes. Its position will have\n advanced by the number of bytes received, which is also the return\n value of this method.\n\n The CLA byte of the command APDU is automatically adjusted to\n match the channel number of this CardChannel.\n\n Note that this method cannot be used to transmit\n MANAGE CHANNEL APDUs. Logical channels should be managed\n using the Card.openLogicalChannel() and CardChannel.close() methods.\n\n See transmit() for a discussion of the handling\n of response APDUs with the SW1 values 61 or 6C."}, {"method_name": "close", "method_sig": "public abstract void close()\n                    throws CardException", "description": "Closes this CardChannel. The logical channel is closed by issuing\n a MANAGE CHANNEL command that should use the format\n [xx 70 80 0n] where n is the channel number\n of this channel and xx is the CLA\n byte that encodes this logical channel and has all other bits set to 0.\n After this method returns, calling other\n methods in this class will raise an IllegalStateException.\n\n Note that the basic logical channel cannot be closed using this\n method. It can be closed by calling Card.disconnect(boolean)."}]}