{"name": "Class SctpChannel", "module": "jdk.sctp", "package": "com.sun.nio.sctp", "text": "A selectable channel for message-oriented connected SCTP sockets.\n\n  An SCTP channel can only control one SCTP association.\n An SCTPChannel is created by invoking one of the\n open methods of this class. A newly-created channel is open but\n not yet connected, that is, there is no association setup with a remote peer.\n An attempt to invoke an I/O operation upon an unconnected\n channel will cause a NotYetConnectedException to be\n thrown. An association can be setup by connecting the channel using one of\n its connect methods. Once connected, the channel remains\n connected until it is closed. Whether or not a channel is connected may be\n determined by invoking getRemoteAddresses.\n\n  SCTP channels support non-blocking connection:\u00a0A\n channel may be created and the process of establishing the link to\n the remote socket may be initiated via the connect method\n for later completion by the finishConnect method.\n Whether or not a connection operation is in progress may be determined by\n invoking the isConnectionPending method.\n\n  Socket options are configured using the\n setOption method. An SCTP\n channel support the following options:\n \n\nSocket options\n\n\nOption Name\nDescription\n\n\n\n\n SCTP_DISABLE_FRAGMENTS \n Enables or disables message fragmentation \n\n\n SCTP_EXPLICIT_COMPLETE \n Enables or disables explicit message completion \n\n\n SCTP_FRAGMENT_INTERLEAVE \n Controls how the presentation of messages occur for the message\n          receiver \n\n\n SCTP_INIT_MAXSTREAMS \n The maximum number of streams requested by the local endpoint during\n          association initialization \n\n\n SCTP_NODELAY \n Enables or disable a Nagle-like algorithm \n\n\n SCTP_PRIMARY_ADDR \n Requests that the local SCTP stack use the given peer address as the\n          association primary \n\n\n SCTP_SET_PEER_PRIMARY_ADDR \n Requests that the peer mark the enclosed address as the association\n          primary \n\n\n SO_SNDBUF \n The size of the socket send buffer \n\n\n SO_RCVBUF \n The size of the socket receive buffer \n\n\n SO_LINGER \n Linger on close if data is present (when configured in blocking mode\n          only) \n\n\n\n\n Additional (implementation specific) options may also be supported. The list\n of options supported is obtained by invoking the supportedOptions  method.\n\n  SCTP channels are safe for use by multiple concurrent threads.\n They support concurrent reading and writing, though at most one thread may be\n reading and at most one thread may be writing at any given time. The\n connect and finishConnect methods are mutually synchronized against each other, and\n an attempt to initiate a send or receive operation while an invocation of one\n of these methods is in progress will block until that invocation is complete.", "codes": ["public abstract class SctpChannel\nextends AbstractSelectableChannel"], "fields": [], "methods": [{"method_name": "open", "method_sig": "public static SctpChannel open()\n                        throws IOException", "description": "Opens an SCTP channel.\n\n  The new channel is unbound and unconnected."}, {"method_name": "open", "method_sig": "public static SctpChannel open (SocketAddress remote,\n                               int maxOutStreams,\n                               int maxInStreams)\n                        throws IOException", "description": "Opens an SCTP channel and connects it to a remote address.\n\n  This is a convenience method and is equivalent to evaluating the\n following expression:\n \n open().connect(remote, maxOutStreams, maxInStreams);\n "}, {"method_name": "association", "method_sig": "public abstract Association association()\n                                 throws IOException", "description": "Returns the association on this channel's socket."}, {"method_name": "bind", "method_sig": "public abstract SctpChannel bind (SocketAddress local)\n                          throws IOException", "description": "Binds the channel's socket to a local address.\n\n  This method is used to establish a relationship between the socket\n and the local addresses. Once a relationship is established then\n the socket remains bound until the channel is closed. This relationship\n may not necesssarily be with the address local as it may be removed\n by unbindAddress, but there will always be at least\n one local address bound to the channel's socket once an invocation of\n this method successfully completes.\n\n  Once the channel's socket has been successfully bound to a specific\n address, that is not automatically assigned, more addresses\n may be bound to it using bindAddress, or removed\n using unbindAddress."}, {"method_name": "bindAddress", "method_sig": "public abstract SctpChannel bindAddress (InetAddress address)\n                                 throws IOException", "description": "Adds the given address to the bound addresses for the channel's\n socket.\n\n  The given address must not be the wildcard address.\n The channel must be first bound using bind before\n invoking this method, otherwise NotYetBoundException is thrown. The bind\n method takes a SocketAddress as its argument which typically\n contains a port number as well as an address. Addresses subquently bound\n using this method are simply addresses as the SCTP port number remains\n the same for the lifetime of the channel.\n\n  Adding addresses to a connected association is optional functionality.\n If the endpoint supports dynamic address reconfiguration then it may\n send the appropriate message to the peer to change the peers address\n lists."}, {"method_name": "unbindAddress", "method_sig": "public abstract SctpChannel unbindAddress (InetAddress address)\n                                   throws IOException", "description": "Removes the given address from the bound addresses for the channel's\n socket.\n\n  The given address must not be the wildcard address.\n The channel must be first bound using bind before\n invoking this method, otherwise NotYetBoundException\n is thrown. If this method is invoked on a channel that does not have\n address as one of its bound addresses or that has only one\n local address bound to it, then this method throws\n IllegalUnbindException.\n The initial address that the channel's socket is bound to using bind may be removed from the bound addresses for the channel's socket.\n\n  Removing addresses from a connected association is optional\n functionality. If the endpoint supports dynamic address reconfiguration\n then it may send the appropriate message to the peer to change the peers\n address lists."}, {"method_name": "connect", "method_sig": "public abstract boolean connect (SocketAddress remote)\n                         throws IOException", "description": "Connects this channel's socket.\n\n  If this channel is in non-blocking mode then an invocation of this\n method initiates a non-blocking connection operation.  If the connection\n is established immediately, as can happen with a local connection, then\n this method returns true.  Otherwise this method returns\n false and the connection operation must later be completed by\n invoking the finishConnect method.\n\n  If this channel is in blocking mode then an invocation of this\n method will block until the connection is established or an I/O error\n occurs.\n\n  If a security manager has been installed then this method verifies\n that its checkConnect\n method permits connecting to the address and port number of the given\n remote peer.\n\n  This method may be invoked at any time. If a send or\n receive operation upon this channel is invoked while an\n invocation of this method is in progress then that operation will first\n block until this invocation is complete.  If a connection attempt is\n initiated but fails, that is, if an invocation of this method throws a\n checked exception, then the channel will be closed."}, {"method_name": "connect", "method_sig": "public abstract boolean connect (SocketAddress remote,\n                                int maxOutStreams,\n                                int maxInStreams)\n                         throws IOException", "description": "Connects this channel's socket.\n\n  This is a convience method and is equivalent to evaluating the\n following expression:\n \n setOption(SctpStandardSocketOptions.SCTP_INIT_MAXSTREAMS, SctpStandardSocketOption.InitMaxStreams.create(maxInStreams, maxOutStreams))\n  .connect(remote);\n \n The maxOutStreams and maxInStreams parameters\n represent the maximum number of streams that the application wishes to be\n able to send to and receive from. They are negotiated with the remote\n peer and may be limited by the operating system."}, {"method_name": "isConnectionPending", "method_sig": "public abstract boolean isConnectionPending()", "description": "Tells whether or not a connection operation is in progress on this channel."}, {"method_name": "finishConnect", "method_sig": "public abstract boolean finishConnect()\n                               throws IOException", "description": "Finishes the process of connecting an SCTP channel.\n\n  A non-blocking connection operation is initiated by placing a socket\n channel in non-blocking mode and then invoking one of its connect methods.  Once the connection is established, or the attempt has\n failed, the channel will become connectable and this method may\n be invoked to complete the connection sequence.  If the connection\n operation failed then invoking this method will cause an appropriate\n IOException to be thrown.\n\n  If this channel is already connected then this method will not block\n and will immediately return true.  If this channel is in\n non-blocking mode then this method will return false if the\n connection process is not yet complete.  If this channel is in blocking\n mode then this method will block until the connection either completes\n or fails, and will always either return true or throw a checked\n exception describing the failure.\n\n  This method may be invoked at any time. If a send or receive\n operation upon this channel is invoked while an invocation of this\n method is in progress then that operation will first block until this\n invocation is complete.  If a connection attempt fails, that is, if an\n invocation of this method throws a checked exception, then the channel\n will be closed."}, {"method_name": "getAllLocalAddresses", "method_sig": "public abstract Set<SocketAddress> getAllLocalAddresses()\n                                                 throws IOException", "description": "Returns all of the socket addresses to which this channel's socket is\n bound."}, {"method_name": "getRemoteAddresses", "method_sig": "public abstract Set<SocketAddress> getRemoteAddresses()\n                                               throws IOException", "description": "Returns all of the remote addresses to which this channel's socket\n is connected.\n\n  If the channel is connected to a remote peer that is bound to\n multiple addresses then it is these addresses that the channel's socket\n is connected."}, {"method_name": "shutdown", "method_sig": "public abstract SctpChannel shutdown()\n                              throws IOException", "description": "Shutdown a connection without closing the channel.\n\n  Sends a shutdown command to the remote peer, effectively preventing\n any new data from being written to the socket by either peer. Further\n sends will throw ClosedChannelException. The\n channel remains open to allow the for any data (and notifications) to be\n received that may have been sent by the peer before it received the\n shutdown command. If the channel is already shutdown then invoking this\n method has no effect."}, {"method_name": "getOption", "method_sig": "public abstract <T> T getOption (SctpSocketOption<T> name)\n                         throws IOException", "description": "Returns the value of a socket option."}, {"method_name": "setOption", "method_sig": "public abstract <T> SctpChannel setOption (SctpSocketOption<T> name,\n                                          T value)\n                                   throws IOException", "description": "Sets the value of a socket option."}, {"method_name": "supportedOptions", "method_sig": "public abstract Set<SctpSocketOption<?>> supportedOptions()", "description": "Returns a set of the socket options supported by this channel.\n\n  This method will continue to return the set of options even after the\n channel has been closed."}, {"method_name": "validOps", "method_sig": "public final int validOps()", "description": "Returns an operation set identifying this channel's supported operations.\n\n  SCTP channels support connecting, reading, and writing, so this\n method returns (SelectionKey.OP_CONNECT\n|\u00a0SelectionKey.OP_READ |\u00a0SelectionKey.OP_WRITE)."}, {"method_name": "receive", "method_sig": "public abstract <T> MessageInfo receive (ByteBuffer dst,\n                                        T attachment,\n                                        NotificationHandler<T> handler)\n                                 throws IOException", "description": "Receives a message into the given buffer and/or handles a notification.\n\n  If a message or notification is immediately available, or if this\n channel is in blocking mode and one eventually becomes available, then\n the message or notification is returned or handled, respectively. If this\n channel is in non-blocking mode and a message or notification is not\n immediately available then this method immediately returns null.\n\n  If this method receives a message it is copied into the given byte\n buffer. The message is transferred into the given byte buffer starting at\n its current position and the buffers position is incremented by the\n number of bytes read. If there are fewer bytes remaining in the buffer\n than are required to hold the message, or the underlying input buffer\n does not contain the complete message, then an invocation of isComplete on the returned \n MessageInfo will return false, and more invocations of this\n method will be necessary to completely consume the messgae. Only\n one message at a time will be partially delivered in any stream. The\n socket option SCTP_FRAGMENT_INTERLEAVE controls various aspects of what interlacing of\n messages occurs.\n\n  If this method receives a notification then the appropriate method of\n the given handler, if there is one, is invoked. If the handler returns\n CONTINUE then this method will try to\n receive another message/notification, otherwise, if RETURN is returned this method will return \n null. If an uncaught exception is thrown by the handler it will be\n propagated up the stack through this method.\n\n  This method may be invoked at any time. If another thread has\n already initiated a receive operation upon this channel, then an\n invocation of this method will block until the first operation is\n complete. The given handler is invoked without holding any locks used\n to enforce the above synchronization policy, that way handlers\n will not stall other threads from receiving. A handler should not invoke\n the receive method of this channel, if it does an\n IllegalReceiveException will be thrown."}, {"method_name": "send", "method_sig": "public abstract int send (ByteBuffer src,\n                         MessageInfo messageInfo)\n                  throws IOException", "description": "Sends a message via this channel.\n\n  If this channel is in non-blocking mode and there is sufficient room\n in the underlying output buffer, or if this channel is in blocking mode\n and sufficient room becomes available, then the remaining bytes in the\n given byte buffer are transmitted as a single message. Sending a message\n is atomic unless explicit message completion SCTP_EXPLICIT_COMPLETE\n socket option is enabled on this channel's socket.\n\n  The message is transferred from the byte buffer as if by a regular\n write operation.\n\n  The bytes will be written to the stream number that is specified by\n streamNumber in the given \n messageInfo.\n\n  This method may be invoked at any time. If another thread has already\n initiated a send operation upon this channel, then an invocation of\n this method will block until the first operation is complete."}]}