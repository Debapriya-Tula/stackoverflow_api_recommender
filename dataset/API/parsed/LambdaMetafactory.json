{"name": "Class LambdaMetafactory", "module": "java.base", "package": "java.lang.invoke", "text": "Methods to facilitate the creation of simple \"function objects\" that\n implement one or more interfaces by delegation to a provided MethodHandle,\n possibly after type adaptation and partial evaluation of arguments.  These\n methods are typically used as bootstrap methods for invokedynamic\n call sites, to support the lambda expression and method\n reference expression features of the Java Programming Language.\n\n Indirect access to the behavior specified by the provided MethodHandle\n proceeds in order through three phases:\n \nLinkage occurs when the methods in this class are invoked.\n     They take as arguments an interface to be implemented (typically a\n     functional interface, one with a single abstract method), a\n     name and signature of a method from that interface to be implemented, a\n     method handle describing the desired implementation behavior\n     for that method, and possibly other additional metadata, and produce a\n     CallSite whose target can be used to create suitable function\n     objects.  Linkage may involve dynamically loading a new class that\n     implements the target interface. The CallSite can be considered a\n     \"factory\" for function objects and so these linkage methods are referred\n     to as \"metafactories\".\nCapture occurs when the CallSite's target is\n     invoked, typically through an invokedynamic call site,\n     producing a function object.  This may occur many times for\n     a single factory CallSite.  Capture may involve allocation of a\n     new function object, or may return an existing function object.  The\n     behavior MethodHandle may have additional parameters beyond those\n     of the specified interface method; these are referred to as captured\n     parameters, which must be provided as arguments to the\n     CallSite target, and which may be early-bound to the behavior\n     MethodHandle.  The number of captured parameters and their types\n     are determined during linkage.\n     The identity of a function object produced by invoking the\n     CallSite's target is unpredictable, and therefore\n     identity-sensitive operations (such as reference equality, object\n     locking, and System.identityHashCode() may produce different\n     results in different implementations, or even upon different invocations\n     in the same implementation.\nInvocation occurs when an implemented interface method\n     is invoked on a function object.  This may occur many times for a single\n     function object.  The method referenced by the behavior MethodHandle\n     is invoked with the captured arguments and any additional arguments\n     provided on invocation, as if by MethodHandle.invoke(Object...).\n\nIt is sometimes useful to restrict the set of inputs or results permitted\n at invocation.  For example, when the generic interface Predicate<T>\n is parameterized as Predicate<String>, the input must be a\n String, even though the method to implement allows any Object.\n At linkage time, an additional MethodType parameter describes the\n \"instantiated\" method type; on invocation, the arguments and eventual result\n are checked against this MethodType.\n\n This class provides two forms of linkage methods: a standard version\n (metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType))\n using an optimized protocol, and an alternate version\n altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)).\n The alternate version is a generalization of the standard version, providing\n additional control over the behavior of the generated function objects via\n flags and additional arguments.  The alternate version adds the ability to\n manage the following attributes of function objects:\n\n \nBridging.  It is sometimes useful to implement multiple\n     variations of the method signature, involving argument or return type\n     adaptation.  This occurs when multiple distinct VM signatures for a method\n     are logically considered to be the same method by the language.  The\n     flag FLAG_BRIDGES indicates that a list of additional\n     MethodTypes will be provided, each of which will be implemented\n     by the resulting function object.  These methods will share the same\n     name and instantiated type.\nMultiple interfaces.  If needed, more than one interface\n     can be implemented by the function object.  (These additional interfaces\n     are typically marker interfaces with no methods.)  The flag FLAG_MARKERS\n     indicates that a list of additional interfaces will be provided, each of\n     which should be implemented by the resulting function object.\nSerializability.  The generated function objects do not\n     generally support serialization.  If desired, FLAG_SERIALIZABLE\n     can be used to indicate that the function objects should be serializable.\n     Serializable function objects will use, as their serialized form,\n     instances of the class SerializedLambda, which requires additional\n     assistance from the capturing class (the class described by the\n     MethodHandles.Lookup parameter caller); see\n     SerializedLambda for details.\n\nAssume the linkage arguments are as follows:\n \ninvokedType (describing the CallSite signature) has\n      K parameters of types (D1..Dk) and return type Rd;\nsamMethodType (describing the implemented method type) has N\n      parameters, of types (U1..Un) and return type Ru;\nimplMethod (the MethodHandle providing the\n      implementation has M parameters, of types (A1..Am) and return type Ra\n      (if the method describes an instance method, the method type of this\n      method handle already includes an extra first argument corresponding to\n      the receiver);\ninstantiatedMethodType (allowing restrictions on invocation)\n      has N parameters, of types (T1..Tn) and return type Rt.\n\nThen the following linkage invariants must hold:\n \nRd is an interface\nimplMethod is a direct method handle\nsamMethodType and instantiatedMethodType have the same\n     arity N, and for i=1..N, Ti and Ui are the same type, or Ti and Ui are\n     both reference types and Ti is a subtype of Ui\nEither Rt and Ru are the same type, or both are reference types and\n     Rt is a subtype of Ru\nK + N = M\nFor i=1..K, Di = Ai\nFor i=1..N, Ti is adaptable to Aj, where j=i+k\nThe return type Rt is void, or the return type Ra is not void and is\n     adaptable to Rt\n\nFurther, at capture time, if implMethod corresponds to an instance\n method, and there are any capture arguments (K > 0), then the first\n capture argument (corresponding to the receiver) must be non-null.\n\n A type Q is considered adaptable to S as follows:\n \nadaptable types\n\nQSLink-time checksInvocation-time checks\n\n\n\nPrimitivePrimitive\nQ can be converted to S via a primitive widening conversion\nNone\n\n\nPrimitiveReference\nS is a supertype of the Wrapper(Q)\nCast from Wrapper(Q) to S\n\n\nReferencePrimitive\nfor parameter types: Q is a primitive wrapper and Primitive(Q)\n         can be widened to S\n         for return types: If Q is a primitive wrapper, check that\n         Primitive(Q) can be widened to S\nIf Q is not a primitive wrapper, cast Q to the base Wrapper(S);\n         for example Number for numeric types\n\n\nReferenceReference\nfor parameter types: S is a supertype of Q\n         for return types: none\nCast from Q to S\n\n\n", "codes": ["public final class LambdaMetafactory\nextends Object"], "fields": [{"field_name": "FLAG_SERIALIZABLE", "field_sig": "public static final\u00a0int FLAG_SERIALIZABLE", "description": "Flag for alternate metafactories indicating the lambda object\n must be serializable"}, {"field_name": "FLAG_MARKERS", "field_sig": "public static final\u00a0int FLAG_MARKERS", "description": "Flag for alternate metafactories indicating the lambda object implements\n other marker interfaces\n besides Serializable"}, {"field_name": "FLAG_BRIDGES", "field_sig": "public static final\u00a0int FLAG_BRIDGES", "description": "Flag for alternate metafactories indicating the lambda object requires\n additional bridge methods"}], "methods": [{"method_name": "metafactory", "method_sig": "public static CallSite metafactory (MethodHandles.Lookup caller,\n                                   String invokedName,\n                                   MethodType invokedType,\n                                   MethodType samMethodType,\n                                   MethodHandle implMethod,\n                                   MethodType instantiatedMethodType)\n                            throws LambdaConversionException", "description": "Facilitates the creation of simple \"function objects\" that implement one\n or more interfaces by delegation to a provided MethodHandle,\n after appropriate type adaptation and partial evaluation of arguments.\n Typically used as a bootstrap method for invokedynamic\n call sites, to support the lambda expression and method\n reference expression features of the Java Programming Language.\n\n This is the standard, streamlined metafactory; additional flexibility\n is provided by altMetafactory(MethodHandles.Lookup, String, MethodType, Object...).\n A general description of the behavior of this method is provided\n above.\n\n When the target of the CallSite returned from this method is\n invoked, the resulting function objects are instances of a class which\n implements the interface named by the return type of invokedType,\n declares a method with the name given by invokedName and the\n signature given by samMethodType.  It may also override additional\n methods from Object."}, {"method_name": "altMetafactory", "method_sig": "public static CallSite altMetafactory (MethodHandles.Lookup caller,\n                                      String invokedName,\n                                      MethodType invokedType,\n                                      Object... args)\n                               throws LambdaConversionException", "description": "Facilitates the creation of simple \"function objects\" that implement one\n or more interfaces by delegation to a provided MethodHandle,\n after appropriate type adaptation and partial evaluation of arguments.\n Typically used as a bootstrap method for invokedynamic\n call sites, to support the lambda expression and method\n reference expression features of the Java Programming Language.\n\n This is the general, more flexible metafactory; a streamlined version\n is provided by metafactory(java.lang.invoke.MethodHandles.Lookup,\n String, MethodType, MethodType, MethodHandle, MethodType).\n A general description of the behavior of this method is provided\n above.\n\n The argument list for this method includes three fixed parameters,\n corresponding to the parameters automatically stacked by the VM for the\n bootstrap method in an invokedynamic invocation, and an Object[]\n parameter that contains additional parameters.  The declared argument\n list for this method is:\n\n \n  CallSite altMetafactory(MethodHandles.Lookup caller,\n                          String invokedName,\n                          MethodType invokedType,\n                          Object... args)\n \nbut it behaves as if the argument list is as follows:\n\n \n  CallSite altMetafactory(MethodHandles.Lookup caller,\n                          String invokedName,\n                          MethodType invokedType,\n                          MethodType samMethodType,\n                          MethodHandle implMethod,\n                          MethodType instantiatedMethodType,\n                          int flags,\n                          int markerInterfaceCount,  // IF flags has MARKERS set\n                          Class... markerInterfaces, // IF flags has MARKERS set\n                          int bridgeCount,           // IF flags has BRIDGES set\n                          MethodType... bridges      // IF flags has BRIDGES set\n                          )\n \nArguments that appear in the argument list for\n metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)\n have the same specification as in that method.  The additional arguments\n are interpreted as follows:\n \nflags indicates additional options; this is a bitwise\n     OR of desired flags.  Defined flags are FLAG_BRIDGES,\n     FLAG_MARKERS, and FLAG_SERIALIZABLE.\nmarkerInterfaceCount is the number of additional interfaces\n     the function object should implement, and is present if and only if the\n     FLAG_MARKERS flag is set.\nmarkerInterfaces is a variable-length list of additional\n     interfaces to implement, whose length equals markerInterfaceCount,\n     and is present if and only if the FLAG_MARKERS flag is set.\nbridgeCount is the number of additional method signatures\n     the function object should implement, and is present if and only if\n     the FLAG_BRIDGES flag is set.\nbridges is a variable-length list of additional\n     methods signatures to implement, whose length equals bridgeCount,\n     and is present if and only if the FLAG_BRIDGES flag is set.\n\nEach class named by markerInterfaces is subject to the same\n restrictions as Rd, the return type of invokedType,\n as described above.  Each MethodType\n named by bridges is subject to the same restrictions as\n samMethodType, as described above.\n\n When FLAG_SERIALIZABLE is set in flags, the function objects\n will implement Serializable, and will have a writeReplace\n method that returns an appropriate SerializedLambda.  The\n caller class must have an appropriate $deserializeLambda$\n method, as described in SerializedLambda.\n\n When the target of the CallSite returned from this method is\n invoked, the resulting function objects are instances of a class with\n the following properties:\n \nThe class implements the interface named by the return type\n     of invokedType and any interfaces named by markerInterfaces\nThe class declares methods with the name given by invokedName,\n     and the signature given by samMethodType and additional signatures\n     given by bridges\nThe class may override methods from Object, and may\n     implement methods related to serialization.\n"}]}