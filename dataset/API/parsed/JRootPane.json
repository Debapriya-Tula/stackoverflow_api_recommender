{"name": "Class JRootPane", "module": "java.desktop", "package": "javax.swing", "text": "A lightweight container used behind the scenes by\n JFrame, JDialog, JWindow,\n JApplet, and JInternalFrame.\n For task-oriented information on functionality provided by root panes\n see How to Use Root Panes,\n a section in The Java Tutorial.\n\n \n The following image shows the relationships between\n the classes that use root panes.\n \n The \"heavyweight\" components (those that delegate to a peer, or native\n component on the host system) are shown with a darker, heavier box. The four\n heavyweight JFC/Swing containers (JFrame, JDialog,\n JWindow, and JApplet) are\n shown in relation to the AWT classes they extend.\n These four components are the\n only heavyweight containers in the Swing library. The lightweight container\n JInternalFrame is also shown.\n All five of these JFC/Swing containers implement the\n RootPaneContainer interface,\n and they all delegate their operations to a\n JRootPane (shown with a little \"handle\" on top).\n \nNote: The JComponent method getRootPane\n can be used to obtain the JRootPane that contains\n a given component.\n \n\nExample\n\n\n\n\n\n\n The diagram at right shows the structure of a JRootPane.\n A JRootpane is made up of a glassPane,\n an optional menuBar, and a contentPane.\n (The JLayeredPane manages the menuBar\n and the contentPane.)\n The glassPane sits over the top of everything,\n where it is in a position to intercept mouse movements.\n Since the glassPane (like the contentPane)\n can be an arbitrary component, it is also possible to set up the\n glassPane for drawing. Lines and images on the\n glassPane can then range\n over the frames underneath without being limited by their boundaries.\n \n Although the menuBar component is optional,\n the layeredPane, contentPane,\n and glassPane always exist.\n Attempting to set them to null generates an exception.\n \n To add components to the JRootPane (other than the\n optional menu bar), you add the object to the contentPane\n of the JRootPane, like this:\n \n       rootPane.getContentPane().add(child);\n \n The same principle holds true for setting layout managers, removing\n components, listing children, etc. All these methods are invoked on\n the contentPane instead of on the JRootPane.\n \nNote: The default layout manager for the contentPane is\n  a BorderLayout manager. However, the JRootPane\n  uses a custom LayoutManager.\n  So, when you want to change the layout manager for the components you added\n  to a JRootPane, be sure to use code like this:\n \n    rootPane.getContentPane().setLayout(new BoxLayout());\n \n If a JMenuBar component is set on the JRootPane,\n it is positioned along the upper edge of the frame.\n The contentPane is adjusted in location and size to\n fill the remaining area.\n (The JMenuBar and the contentPane are added to the\n layeredPane component at the\n JLayeredPane.FRAME_CONTENT_LAYER layer.)\n \n The layeredPane is the parent of all children in the\n JRootPane -- both as the direct parent of the menu and\n the grandparent of all components added to the contentPane.\n It is an instance of JLayeredPane,\n which provides the ability to add components at several layers.\n This capability is very useful when working with menu popups,\n dialog boxes, and dragging -- situations in which you need to place\n a component on top of all other components in the pane.\n \n The glassPane sits on top of all other components in the\n JRootPane.\n That provides a convenient place to draw above all other components,\n and makes it possible to intercept mouse events,\n which is useful both for dragging and for drawing.\n Developers can use setVisible on the glassPane\n to control when the glassPane displays over the other children.\n By default the glassPane is not visible.\n \n The custom LayoutManager used by JRootPane\n ensures that:\n \nThe glassPane fills the entire viewable\n     area of the JRootPane (bounds - insets).\n The layeredPane fills the entire viewable area of the\n     JRootPane. (bounds - insets)\n The menuBar is positioned at the upper edge of the\n     layeredPane.\n The contentPane fills the entire viewable area,\n     minus the menuBar, if present.\n \n Any other views in the JRootPane view hierarchy are ignored.\n \n If you replace the LayoutManager of the JRootPane,\n you are responsible for managing all of these views.\n So ordinarily you will want to be sure that you\n change the layout manager for the contentPane rather than\n for the JRootPane itself!\n \n The painting architecture of Swing requires an opaque\n JComponent\n to exist in the containment hierarchy above all other components. This is\n typically provided by way of the content pane. If you replace the content\n pane, it is recommended that you make the content pane opaque\n by way of setOpaque(true). Additionally, if the content pane\n overrides paintComponent, it\n will need to completely fill in the background in an opaque color in\n paintComponent.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans\u2122\n has been added to the java.beans package.\n Please see XMLEncoder.", "codes": ["public class JRootPane\nextends JComponent\nimplements Accessible"], "fields": [{"field_name": "NONE", "field_sig": "public static final\u00a0int NONE", "description": "Constant used for the windowDecorationStyle property. Indicates that\n the JRootPane should not provide any sort of\n Window decorations."}, {"field_name": "FRAME", "field_sig": "public static final\u00a0int FRAME", "description": "Constant used for the windowDecorationStyle property. Indicates that\n the JRootPane should provide decorations appropriate for\n a Frame."}, {"field_name": "PLAIN_DIALOG", "field_sig": "public static final\u00a0int PLAIN_DIALOG", "description": "Constant used for the windowDecorationStyle property. Indicates that\n the JRootPane should provide decorations appropriate for\n a Dialog."}, {"field_name": "INFORMATION_DIALOG", "field_sig": "public static final\u00a0int INFORMATION_DIALOG", "description": "Constant used for the windowDecorationStyle property. Indicates that\n the JRootPane should provide decorations appropriate for\n a Dialog used to display an informational message."}, {"field_name": "ERROR_DIALOG", "field_sig": "public static final\u00a0int ERROR_DIALOG", "description": "Constant used for the windowDecorationStyle property. Indicates that\n the JRootPane should provide decorations appropriate for\n a Dialog used to display an error message."}, {"field_name": "COLOR_CHOOSER_DIALOG", "field_sig": "public static final\u00a0int COLOR_CHOOSER_DIALOG", "description": "Constant used for the windowDecorationStyle property. Indicates that\n the JRootPane should provide decorations appropriate for\n a Dialog used to display a JColorChooser."}, {"field_name": "FILE_CHOOSER_DIALOG", "field_sig": "public static final\u00a0int FILE_CHOOSER_DIALOG", "description": "Constant used for the windowDecorationStyle property. Indicates that\n the JRootPane should provide decorations appropriate for\n a Dialog used to display a JFileChooser."}, {"field_name": "QUESTION_DIALOG", "field_sig": "public static final\u00a0int QUESTION_DIALOG", "description": "Constant used for the windowDecorationStyle property. Indicates that\n the JRootPane should provide decorations appropriate for\n a Dialog used to present a question to the user."}, {"field_name": "WARNING_DIALOG", "field_sig": "public static final\u00a0int WARNING_DIALOG", "description": "Constant used for the windowDecorationStyle property. Indicates that\n the JRootPane should provide decorations appropriate for\n a Dialog used to display a warning message."}, {"field_name": "menuBar", "field_sig": "protected\u00a0JMenuBar menuBar", "description": "The menu bar."}, {"field_name": "contentPane", "field_sig": "protected\u00a0Container contentPane", "description": "The content pane."}, {"field_name": "layeredPane", "field_sig": "protected\u00a0JLayeredPane layeredPane", "description": "The layered pane that manages the menu bar and content pane."}, {"field_name": "glassPane", "field_sig": "protected\u00a0Component glassPane", "description": "The glass pane that overlays the menu bar and content pane,\n  so it can intercept mouse movements and such."}, {"field_name": "defaultButton", "field_sig": "protected\u00a0JButton defaultButton", "description": "The button that gets activated when the pane has the focus and\n a UI-specific action like pressing the Enter key occurs."}], "methods": [{"method_name": "setDoubleBuffered", "method_sig": "public void setDoubleBuffered (boolean aFlag)", "description": "Sets whether this component should use a buffer to paint.\n  If set to true, all the drawing from this component will be done\n  in an offscreen painting buffer. The offscreen painting buffer will\n  the be copied onto the screen.\n  If a Component is buffered and one of its ancestor\n  is also buffered, the ancestor buffer will be used."}, {"method_name": "getWindowDecorationStyle", "method_sig": "public int getWindowDecorationStyle()", "description": "Returns a constant identifying the type of Window decorations the\n JRootPane is providing."}, {"method_name": "setWindowDecorationStyle", "method_sig": "@BeanProperty(expert=true,\n              visualUpdate=true,\n              enumerationValues={\"JRootPane.NONE\",\"JRootPane.FRAME\",\"JRootPane.PLAIN_DIALOG\",\"JRootPane.INFORMATION_DIALOG\",\"JRootPane.ERROR_DIALOG\",\"JRootPane.COLOR_CHOOSER_DIALOG\",\"JRootPane.FILE_CHOOSER_DIALOG\",\"JRootPane.QUESTION_DIALOG\",\"JRootPane.WARNING_DIALOG\"},\n              description=\"Identifies the type of Window decorations to provide\")\npublic void setWindowDecorationStyle (int windowDecorationStyle)", "description": "Sets the type of Window decorations (such as borders, widgets for\n closing a Window, title ...) the JRootPane should\n provide. The default is to provide no Window decorations\n (NONE).\n \n This is only a hint, and some look and feels may not support\n this.\n This is a bound property."}, {"method_name": "getUI", "method_sig": "public RootPaneUI getUI()", "description": "Returns the L&F object that renders this component."}, {"method_name": "setUI", "method_sig": "@BeanProperty(expert=true,\n              hidden=true,\n              visualUpdate=true,\n              description=\"The UI object that implements the Component\\'s LookAndFeel.\")\npublic void setUI (RootPaneUI ui)", "description": "Sets the L&F object that renders this component."}, {"method_name": "updateUI", "method_sig": "public void updateUI()", "description": "Resets the UI property to a value from the current look and feel."}, {"method_name": "getUIClassID", "method_sig": "public String getUIClassID()", "description": "Returns a string that specifies the name of the L&F class\n that renders this component."}, {"method_name": "createLayeredPane", "method_sig": "protected JLayeredPane createLayeredPane()", "description": "Called by the constructor methods to create the default\n layeredPane.\n Bt default it creates a new JLayeredPane."}, {"method_name": "createContentPane", "method_sig": "protected Container createContentPane()", "description": "Called by the constructor methods to create the default\n contentPane.\n By default this method creates a new JComponent add sets a\n BorderLayout as its LayoutManager."}, {"method_name": "createGlassPane", "method_sig": "protected Component createGlassPane()", "description": "Called by the constructor methods to create the default\n glassPane.\n By default this method creates a new JComponent\n with visibility set to false."}, {"method_name": "createRootLayout", "method_sig": "protected LayoutManager createRootLayout()", "description": "Called by the constructor methods to create the default\n layoutManager."}, {"method_name": "setJMenuBar", "method_sig": "public void setJMenuBar (JMenuBar menu)", "description": "Adds or changes the menu bar used in the layered pane."}, {"method_name": "setMenuBar", "method_sig": "@Deprecated\npublic void setMenuBar (JMenuBar menu)", "description": "Specifies the menu bar value."}, {"method_name": "getJMenuBar", "method_sig": "public JMenuBar getJMenuBar()", "description": "Returns the menu bar from the layered pane."}, {"method_name": "getMenuBar", "method_sig": "@Deprecated\npublic JMenuBar getMenuBar()", "description": "Returns the menu bar value."}, {"method_name": "setContentPane", "method_sig": "public void setContentPane (Container content)", "description": "Sets the content pane -- the container that holds the components\n parented by the root pane.\n \n Swing's painting architecture requires an opaque JComponent\n in the containment hierarchy. This is typically provided by the\n content pane. If you replace the content pane it is recommended you\n replace it with an opaque JComponent."}, {"method_name": "getContentPane", "method_sig": "public Container getContentPane()", "description": "Returns the content pane -- the container that holds the components\n parented by the root pane."}, {"method_name": "setLayeredPane", "method_sig": "public void setLayeredPane (JLayeredPane layered)", "description": "Sets the layered pane for the root pane. The layered pane\n typically holds a content pane and an optional JMenuBar."}, {"method_name": "getLayeredPane", "method_sig": "public JLayeredPane getLayeredPane()", "description": "Gets the layered pane used by the root pane. The layered pane\n typically holds a content pane and an optional JMenuBar."}, {"method_name": "setGlassPane", "method_sig": "public void setGlassPane (Component glass)", "description": "Sets a specified Component to be the glass pane for this\n root pane.  The glass pane should normally be a lightweight,\n transparent component, because it will be made visible when\n ever the root pane needs to grab input events.\n \n The new glass pane's visibility is changed to match that of\n the current glass pane.  An implication of this is that care\n must be taken when you want to replace the glass pane and\n make it visible.  Either of the following will work:\n \n   root.setGlassPane(newGlassPane);\n   newGlassPane.setVisible(true);\n \n or:\n \n   root.getGlassPane().setVisible(true);\n   root.setGlassPane(newGlassPane);\n "}, {"method_name": "getGlassPane", "method_sig": "public Component getGlassPane()", "description": "Returns the current glass pane for this JRootPane."}, {"method_name": "isValidateRoot", "method_sig": "public boolean isValidateRoot()", "description": "If a descendant of this JRootPane calls\n revalidate, validate from here on down.\n\n Deferred requests to layout a component and its descendents again.\n For example, calls to revalidate, are pushed upwards to\n either a JRootPane or a JScrollPane\n because both classes override isValidateRoot to return true."}, {"method_name": "isOptimizedDrawingEnabled", "method_sig": "public boolean isOptimizedDrawingEnabled()", "description": "The glassPane and contentPane\n have the same bounds, which means JRootPane\n does not tiles its children and this should return false.\n On the other hand, the glassPane\n is normally not visible, and so this can return true if the\n glassPane isn't visible. Therefore, the\n return value here depends upon the visibility of the\n glassPane."}, {"method_name": "setDefaultButton", "method_sig": "@BeanProperty(description=\"The button activated by default in this root pane\")\npublic void setDefaultButton (JButton defaultButton)", "description": "Sets the defaultButton property,\n which determines the current default button for this JRootPane.\n The default button is the button which will be activated\n when a UI-defined activation event (typically the Enter key)\n occurs in the root pane regardless of whether or not the button\n has keyboard focus (unless there is another component within\n the root pane which consumes the activation event,\n such as a JTextPane).\n For default activation to work, the button must be an enabled\n descendent of the root pane when activation occurs.\n To remove a default button from this root pane, set this\n property to null."}, {"method_name": "getDefaultButton", "method_sig": "public JButton getDefaultButton()", "description": "Returns the value of the defaultButton property."}, {"method_name": "addImpl", "method_sig": "protected void addImpl (Component comp,\n                       Object constraints,\n                       int index)", "description": "Overridden to enforce the position of the glass component as\n the zero child."}, {"method_name": "paramString", "method_sig": "protected String paramString()", "description": "Returns a string representation of this JRootPane.\n This method is intended to be used only for debugging purposes,\n and the content and format of the returned string may vary between\n implementations. The returned string may be empty but may not\n be null."}, {"method_name": "getAccessibleContext", "method_sig": "public AccessibleContext getAccessibleContext()", "description": "Gets the AccessibleContext associated with this\n JRootPane. For root panes, the\n AccessibleContext takes the form of an\n AccessibleJRootPane.\n A new AccessibleJRootPane instance is created if necessary."}]}