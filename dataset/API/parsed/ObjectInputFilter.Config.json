{"name": "Class ObjectInputFilter.Config", "module": "java.base", "package": "java.io", "text": "A utility class to set and get the process-wide filter or create a filter\n from a pattern string. If a process-wide filter is set, it will be\n used for each ObjectInputStream that does not set its own filter.\n \n When setting the filter, it should be stateless and idempotent,\n reporting the same result when passed the same arguments.\n \n The filter is configured during the initialization of the ObjectInputFilter.Config\n class. For example, by calling Config.getSerialFilter.\n If the system property jdk.serialFilter is defined, it is used\n to configure the filter.\n If the system property is not defined, and the Security\n property jdk.serialFilter is defined then it is used to configure the filter.\n Otherwise, the filter is not configured during initialization.\n The syntax for each property is the same as for the\n createFilter method.\n If a filter is not configured, it can be set with\n Config.setSerialFilter.", "codes": ["public static final class ObjectInputFilter.Config\nextends Object"], "fields": [], "methods": [{"method_name": "getSerialFilter", "method_sig": "public static ObjectInputFilter getSerialFilter()", "description": "Returns the process-wide serialization filter or null if not configured."}, {"method_name": "setSerialFilter", "method_sig": "public static void setSerialFilter (ObjectInputFilter filter)", "description": "Set the process-wide filter if it has not already been configured or set."}, {"method_name": "createFilter", "method_sig": "public static ObjectInputFilter createFilter (String pattern)", "description": "Returns an ObjectInputFilter from a string of patterns.\n \n Patterns are separated by \";\" (semicolon). Whitespace is significant and\n is considered part of the pattern.\n If a pattern includes an equals assignment, \"=\" it sets a limit.\n If a limit appears more than once the last value is used.\n \nmaxdepth=value - the maximum depth of a graph\nmaxrefs=value  - the maximum number of internal references\nmaxbytes=value - the maximum number of bytes in the input stream\nmaxarray=value - the maximum array length allowed\n\n\n Other patterns match or reject class or package name\n as returned from Class.getName() and\n if an optional module name is present\n class.getModule().getName().\n Note that for arrays the element type is used in the pattern,\n not the array type.\n \nIf the pattern starts with \"!\", the class is rejected if the remaining pattern is matched;\n     otherwise the class is allowed if the pattern matches.\n If the pattern contains \"/\", the non-empty prefix up to the \"/\" is the module name;\n     if the module name matches the module name of the class then\n     the remaining pattern is matched with the class name.\n     If there is no \"/\", the module name is not compared.\n If the pattern ends with \".**\" it matches any class in the package and all subpackages.\n If the pattern ends with \".*\" it matches any class in the package.\n If the pattern ends with \"*\", it matches any class with the pattern as a prefix.\n If the pattern is equal to the class name, it matches.\n Otherwise, the pattern is not matched.\n \n\n The resulting filter performs the limit checks and then\n tries to match the class, if any. If any of the limits are exceeded,\n the filter returns Status.REJECTED.\n If the class is an array type, the class to be matched is the element type.\n Arrays of any number of dimensions are treated the same as the element type.\n For example, a pattern of \"!example.Foo\",\n rejects creation of any instance or array of example.Foo.\n The first pattern that matches, working from left to right, determines\n the Status.ALLOWED\n or Status.REJECTED result.\n If the limits are not exceeded and no pattern matches the class,\n the result is Status.UNDECIDED."}]}