{"name": "Class ColorModel", "module": "java.desktop", "package": "java.awt.image", "text": "The ColorModel abstract class encapsulates the\n methods for translating a pixel value to color components\n (for example, red, green, and blue) and an alpha component.\n In order to render an image to the screen, a printer, or another\n image, pixel values must be converted to color and alpha components.\n As arguments to or return values from methods of this class,\n pixels are represented as 32-bit ints or as arrays of primitive types.\n The number, order, and interpretation of color components for a\n ColorModel is specified by its ColorSpace.\n A ColorModel used with pixel data that does not include\n alpha information treats all pixels as opaque, which is an alpha\n value of 1.0.\n \n This ColorModel class supports two representations of\n pixel values.  A pixel value can be a single 32-bit int or an\n array of primitive types.  The Java(tm) Platform 1.0 and 1.1 APIs\n represented pixels as single byte or single\n int values.  For purposes of the ColorModel\n class, pixel value arguments were passed as ints.  The Java(tm) 2\n Platform API introduced additional classes for representing images.\n With BufferedImage or RenderedImage\n objects, based on Raster and SampleModel classes, pixel\n values might not be conveniently representable as a single int.\n Consequently, ColorModel now has methods that accept\n pixel values represented as arrays of primitive types.  The primitive\n type used by a particular ColorModel object is called its\n transfer type.\n \nColorModel objects used with images for which pixel values\n are not conveniently representable as a single int throw an\n IllegalArgumentException when methods taking a single int pixel\n argument are called.  Subclasses of ColorModel must\n specify the conditions under which this occurs.  This does not\n occur with DirectColorModel or IndexColorModel objects.\n \n Currently, the transfer types supported by the Java 2D(tm) API are\n DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, DataBuffer.TYPE_INT,\n DataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT, and DataBuffer.TYPE_DOUBLE.\n Most rendering operations will perform much faster when using ColorModels\n and images based on the first three of these types.  In addition, some\n image filtering operations are not supported for ColorModels and\n images based on the latter three types.\n The transfer type for a particular ColorModel object is\n specified when the object is created, either explicitly or by default.\n All subclasses of ColorModel must specify what the\n possible transfer types are and how the number of elements in the\n primitive arrays representing pixels is determined.\n \n For BufferedImages, the transfer type of its\n Raster and of the Raster object's\n SampleModel (available from the\n getTransferType methods of these classes) must match that\n of the ColorModel.  The number of elements in an array\n representing a pixel for the Raster and\n SampleModel (available from the\n getNumDataElements methods of these classes) must match\n that of the ColorModel.\n \n The algorithm used to convert from pixel values to color and alpha\n components varies by subclass.  For example, there is not necessarily\n a one-to-one correspondence between samples obtained from the\n SampleModel of a BufferedImage object's\n Raster and color/alpha components.  Even when\n there is such a correspondence, the number of bits in a sample is not\n necessarily the same as the number of bits in the corresponding color/alpha\n component.  Each subclass must specify how the translation from\n pixel values to color/alpha components is done.\n \n Methods in the ColorModel class use two different\n representations of color and alpha components - a normalized form\n and an unnormalized form.  In the normalized form, each component is a\n float value between some minimum and maximum values.  For\n the alpha component, the minimum is 0.0 and the maximum is 1.0.  For\n color components the minimum and maximum values for each component can\n be obtained from the ColorSpace object.  These values\n will often be 0.0 and 1.0 (e.g. normalized component values for the\n default sRGB color space range from 0.0 to 1.0), but some color spaces\n have component values with different upper and lower limits.  These\n limits can be obtained using the getMinValue and\n getMaxValue methods of the ColorSpace\n class.  Normalized color component values are not premultiplied.\n All ColorModels must support the normalized form.\n \n In the unnormalized\n form, each component is an unsigned integral value between 0 and\n 2n - 1, where n is the number of significant bits for a\n particular component.  If pixel values for a particular\n ColorModel represent color samples premultiplied by\n the alpha sample, unnormalized color component values are\n also premultiplied.  The unnormalized form is used only with instances\n of ColorModel whose ColorSpace has minimum\n component values of 0.0 for all components and maximum values of\n 1.0 for all components.\n The unnormalized form for color and alpha components can be a convenient\n representation for ColorModels whose normalized component\n values all lie\n between 0.0 and 1.0.  In such cases the integral value 0 maps to 0.0 and\n the value 2n - 1 maps to 1.0.  In other cases, such as\n when the normalized component values can be either negative or positive,\n the unnormalized form is not convenient.  Such ColorModel\n objects throw an IllegalArgumentException when methods involving\n an unnormalized argument are called.  Subclasses of ColorModel\n must specify the conditions under which this occurs.", "codes": ["public abstract class ColorModel\nextends Object\nimplements Transparency"], "fields": [{"field_name": "pixel_bits", "field_sig": "protected\u00a0int pixel_bits", "description": "The total number of bits in the pixel."}, {"field_name": "transferType", "field_sig": "protected\u00a0int transferType", "description": "Data type of the array used to represent pixel values."}], "methods": [{"method_name": "getRGBdefault", "method_sig": "public static ColorModel getRGBdefault()", "description": "Returns a DirectColorModel that describes the default\n format for integer RGB values used in many of the methods in the\n AWT image interfaces for the convenience of the programmer.\n The color space is the default ColorSpace, sRGB.\n The format for the RGB values is an integer with 8 bits\n each of alpha, red, green, and blue color components ordered\n correspondingly from the most significant byte to the least\n significant byte, as in:  0xAARRGGBB.  Color components are\n not premultiplied by the alpha component.  This format does not\n necessarily represent the native or the most efficient\n ColorModel for a particular device or for all images.\n It is merely used as a common color model format."}, {"method_name": "hasAlpha", "method_sig": "public final boolean hasAlpha()", "description": "Returns whether or not alpha is supported in this\n ColorModel."}, {"method_name": "isAlphaPremultiplied", "method_sig": "public final boolean isAlphaPremultiplied()", "description": "Returns whether or not the alpha has been premultiplied in the\n pixel values to be translated by this ColorModel.\n If the boolean is true, this ColorModel\n is to be used to interpret pixel values in which color and alpha\n information are represented as separate spatial bands, and color\n samples are assumed to have been multiplied by the\n alpha sample."}, {"method_name": "getTransferType", "method_sig": "public final int getTransferType()", "description": "Returns the transfer type of this ColorModel.\n The transfer type is the type of primitive array used to represent\n pixel values as arrays."}, {"method_name": "getPixelSize", "method_sig": "public int getPixelSize()", "description": "Returns the number of bits per pixel described by this\n ColorModel."}, {"method_name": "getComponentSize", "method_sig": "public int getComponentSize (int componentIdx)", "description": "Returns the number of bits for the specified color/alpha component.\n Color components are indexed in the order specified by the\n ColorSpace.  Typically, this order reflects the name\n of the color space type. For example, for TYPE_RGB, index 0\n corresponds to red, index 1 to green, and index 2\n to blue.  If this ColorModel supports alpha, the alpha\n component corresponds to the index following the last color\n component."}, {"method_name": "getComponentSize", "method_sig": "public int[] getComponentSize()", "description": "Returns an array of the number of bits per color/alpha component.\n The array contains the color components in the order specified by the\n ColorSpace, followed by the alpha component, if\n present."}, {"method_name": "getTransparency", "method_sig": "public int getTransparency()", "description": "Returns the transparency.  Returns either OPAQUE, BITMASK,\n or TRANSLUCENT."}, {"method_name": "getNumComponents", "method_sig": "public int getNumComponents()", "description": "Returns the number of components, including alpha, in this\n ColorModel.  This is equal to the number of color\n components, optionally plus one, if there is an alpha component."}, {"method_name": "getNumColorComponents", "method_sig": "public int getNumColorComponents()", "description": "Returns the number of color components in this\n ColorModel.\n This is the number of components returned by\n ColorSpace.getNumComponents()."}, {"method_name": "getRed", "method_sig": "public abstract int getRed (int pixel)", "description": "Returns the red color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion\n is done if necessary.  The pixel value is specified as an int.\n An IllegalArgumentException is thrown if pixel\n values for this ColorModel are not conveniently\n representable as a single int.  The returned value is not a\n pre-multiplied value.  For example, if the\n alpha is premultiplied, this method divides it out before returning\n the value.  If the alpha value is 0, the red value is 0."}, {"method_name": "getGreen", "method_sig": "public abstract int getGreen (int pixel)", "description": "Returns the green color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion\n is done if necessary.  The pixel value is specified as an int.\n An IllegalArgumentException is thrown if pixel\n values for this ColorModel are not conveniently\n representable as a single int.  The returned value is a non\n pre-multiplied value.  For example, if the alpha is premultiplied,\n this method divides it out before returning\n the value.  If the alpha value is 0, the green value is 0."}, {"method_name": "getBlue", "method_sig": "public abstract int getBlue (int pixel)", "description": "Returns the blue color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion\n is done if necessary.  The pixel value is specified as an int.\n An IllegalArgumentException is thrown if pixel values\n for this ColorModel are not conveniently representable\n as a single int.  The returned value is a non pre-multiplied\n value, for example, if the alpha is premultiplied, this method\n divides it out before returning the value.  If the alpha value is\n 0, the blue value is 0."}, {"method_name": "getAlpha", "method_sig": "public abstract int getAlpha (int pixel)", "description": "Returns the alpha component for the specified pixel, scaled\n from 0 to 255.  The pixel value is specified as an int.\n An IllegalArgumentException is thrown if pixel\n values for this ColorModel are not conveniently\n representable as a single int."}, {"method_name": "getRGB", "method_sig": "public int getRGB (int pixel)", "description": "Returns the color/alpha components of the pixel in the default\n RGB color model format.  A color conversion is done if necessary.\n The pixel value is specified as an int.\n An IllegalArgumentException thrown if pixel values\n for this ColorModel are not conveniently representable\n as a single int.  The returned value is in a non\n pre-multiplied format. For example, if the alpha is premultiplied,\n this method divides it out of the color components.  If the alpha\n value is 0, the color values are 0."}, {"method_name": "getRed", "method_sig": "public int getRed (Object inData)", "description": "Returns the red color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.  A\n color conversion is done if necessary.  The pixel value is\n specified by an array of data elements of type transferType passed\n in as an object reference.  The returned value is a non\n pre-multiplied value.  For example, if alpha is premultiplied,\n this method divides it out before returning\n the value.  If the alpha value is 0, the red value is 0.\n If inData is not a primitive array of type\n transferType, a ClassCastException is thrown.  An\n ArrayIndexOutOfBoundsException is thrown if\n inData is not large enough to hold a pixel value for\n this ColorModel.\n If this transferType is not supported, a\n UnsupportedOperationException will be\n thrown.  Since\n ColorModel is an abstract class, any instance\n must be an instance of a subclass.  Subclasses inherit the\n implementation of this method and if they don't override it, this\n method throws an exception if the subclass uses a\n transferType other than\n DataBuffer.TYPE_BYTE,\n DataBuffer.TYPE_USHORT, or\n DataBuffer.TYPE_INT."}, {"method_name": "getGreen", "method_sig": "public int getGreen (Object inData)", "description": "Returns the green color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.  A\n color conversion is done if necessary.  The pixel value is\n specified by an array of data elements of type transferType passed\n in as an object reference.  The returned value will be a non\n pre-multiplied value.  For example, if the alpha is premultiplied,\n this method divides it out before returning the value.  If the\n alpha value is 0, the green value is 0.  If inData is\n not a primitive array of type transferType, a\n ClassCastException is thrown.  An\n ArrayIndexOutOfBoundsException is thrown if\n inData is not large enough to hold a pixel value for\n this ColorModel.\n If this transferType is not supported, a\n UnsupportedOperationException will be\n thrown.  Since\n ColorModel is an abstract class, any instance\n must be an instance of a subclass.  Subclasses inherit the\n implementation of this method and if they don't override it, this\n method throws an exception if the subclass uses a\n transferType other than\n DataBuffer.TYPE_BYTE,\n DataBuffer.TYPE_USHORT, or\n DataBuffer.TYPE_INT."}, {"method_name": "getBlue", "method_sig": "public int getBlue (Object inData)", "description": "Returns the blue color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.  A\n color conversion is done if necessary.  The pixel value is\n specified by an array of data elements of type transferType passed\n in as an object reference.  The returned value is a non\n pre-multiplied value.  For example, if the alpha is premultiplied,\n this method divides it out before returning the value.  If the\n alpha value is 0, the blue value will be 0.  If\n inData is not a primitive array of type transferType,\n a ClassCastException is thrown.  An\n ArrayIndexOutOfBoundsException is\n thrown if inData is not large enough to hold a pixel\n value for this ColorModel.\n If this transferType is not supported, a\n UnsupportedOperationException will be\n thrown.  Since\n ColorModel is an abstract class, any instance\n must be an instance of a subclass.  Subclasses inherit the\n implementation of this method and if they don't override it, this\n method throws an exception if the subclass uses a\n transferType other than\n DataBuffer.TYPE_BYTE,\n DataBuffer.TYPE_USHORT, or\n DataBuffer.TYPE_INT."}, {"method_name": "getAlpha", "method_sig": "public int getAlpha (Object inData)", "description": "Returns the alpha component for the specified pixel, scaled\n from 0 to 255.  The pixel value is specified by an array of data\n elements of type transferType passed in as an object reference.\n If inData is not a primitive array of type transferType, a\n ClassCastException is thrown.  An\n ArrayIndexOutOfBoundsException is thrown if\n inData is not large enough to hold a pixel value for\n this ColorModel.\n If this transferType is not supported, a\n UnsupportedOperationException will be\n thrown.  Since\n ColorModel is an abstract class, any instance\n must be an instance of a subclass.  Subclasses inherit the\n implementation of this method and if they don't override it, this\n method throws an exception if the subclass uses a\n transferType other than\n DataBuffer.TYPE_BYTE,\n DataBuffer.TYPE_USHORT, or\n DataBuffer.TYPE_INT."}, {"method_name": "getRGB", "method_sig": "public int getRGB (Object inData)", "description": "Returns the color/alpha components for the specified pixel in the\n default RGB color model format.  A color conversion is done if\n necessary.  The pixel value is specified by an array of data\n elements of type transferType passed in as an object reference.\n If inData is not a primitive array of type transferType, a\n ClassCastException is thrown.  An\n ArrayIndexOutOfBoundsException is\n thrown if inData is not large enough to hold a pixel\n value for this ColorModel.\n The returned value will be in a non pre-multiplied format, i.e. if\n the alpha is premultiplied, this method will divide it out of the\n color components (if the alpha value is 0, the color values will be 0)."}, {"method_name": "getDataElements", "method_sig": "public Object getDataElements (int rgb,\n                              Object pixel)", "description": "Returns a data element array representation of a pixel in this\n ColorModel, given an integer pixel representation in\n the default RGB color model.\n This array can then be passed to the\n WritableRaster.setDataElements(int, int, java.lang.Object) method of\n a WritableRaster object.  If the pixel variable is\n null, a new array will be allocated.  If\n pixel is not\n null, it must be a primitive array of type\n transferType; otherwise, a\n ClassCastException is thrown.  An\n ArrayIndexOutOfBoundsException is thrown if\n pixel is\n not large enough to hold a pixel value for this\n ColorModel. The pixel array is returned.\n If this transferType is not supported, a\n UnsupportedOperationException will be\n thrown.  Since ColorModel is an abstract class,\n any instance is an instance of a subclass.  Subclasses must\n override this method since the implementation in this abstract\n class throws an UnsupportedOperationException."}, {"method_name": "getComponents", "method_sig": "public int[] getComponents (int pixel,\n                           int[] components,\n                           int offset)", "description": "Returns an array of unnormalized color/alpha components given a pixel\n in this ColorModel.  The pixel value is specified as\n an int.  An IllegalArgumentException\n will be thrown if pixel values for this ColorModel are\n not conveniently representable as a single int or if\n color component values for this ColorModel are not\n conveniently representable in the unnormalized form.\n For example, this method can be used to retrieve the\n components for a specific pixel value in a\n DirectColorModel.  If the components array is\n null, a new array will be allocated.  The\n components array will be returned.  Color/alpha components are\n stored in the components array starting at offset\n (even if the array is allocated by this method).  An\n ArrayIndexOutOfBoundsException is thrown if  the\n components array is not null and is not large\n enough to hold all the color and alpha components (starting at offset).\n Since ColorModel is an abstract class,\n any instance is an instance of a subclass.  Subclasses must\n override this method since the implementation in this abstract\n class throws an UnsupportedOperationException."}, {"method_name": "getComponents", "method_sig": "public int[] getComponents (Object pixel,\n                           int[] components,\n                           int offset)", "description": "Returns an array of unnormalized color/alpha components given a pixel\n in this ColorModel.  The pixel value is specified by\n an array of data elements of type transferType passed in as an\n object reference.  If pixel is not a primitive array\n of type transferType, a ClassCastException is thrown.\n An IllegalArgumentException will be thrown if color\n component values for this ColorModel are not\n conveniently representable in the unnormalized form.\n An ArrayIndexOutOfBoundsException is\n thrown if pixel is not large enough to hold a pixel\n value for this ColorModel.\n This method can be used to retrieve the components for a specific\n pixel value in any ColorModel.  If the components\n array is null, a new array will be allocated.  The\n components array will be returned.  Color/alpha components are\n stored in the components array starting at\n offset (even if the array is allocated by this\n method).  An ArrayIndexOutOfBoundsException\n is thrown if  the components array is not null and is\n not large enough to hold all the color and alpha components\n (starting at offset).\n Since ColorModel is an abstract class,\n any instance is an instance of a subclass.  Subclasses must\n override this method since the implementation in this abstract\n class throws an UnsupportedOperationException."}, {"method_name": "getUnnormalizedComponents", "method_sig": "public int[] getUnnormalizedComponents (float[] normComponents,\n                                       int normOffset,\n                                       int[] components,\n                                       int offset)", "description": "Returns an array of all of the color/alpha components in unnormalized\n form, given a normalized component array.  Unnormalized components\n are unsigned integral values between 0 and 2n - 1, where\n n is the number of bits for a particular component.  Normalized\n components are float values between a per component minimum and\n maximum specified by the ColorSpace object for this\n ColorModel.  An IllegalArgumentException\n will be thrown if color component values for this\n ColorModel are not conveniently representable in the\n unnormalized form.  If the\n components array is null, a new array\n will be allocated.  The components array will\n be returned.  Color/alpha components are stored in the\n components array starting at offset (even\n if the array is allocated by this method). An\n ArrayIndexOutOfBoundsException is thrown if the\n components array is not null and is not\n large enough to hold all the color and alpha\n components (starting at offset).  An\n IllegalArgumentException is thrown if the\n normComponents array is not large enough to hold\n all the color and alpha components starting at\n normOffset."}, {"method_name": "getNormalizedComponents", "method_sig": "public float[] getNormalizedComponents (int[] components,\n                                       int offset,\n                                       float[] normComponents,\n                                       int normOffset)", "description": "Returns an array of all of the color/alpha components in normalized\n form, given an unnormalized component array.  Unnormalized components\n are unsigned integral values between 0 and 2n - 1, where\n n is the number of bits for a particular component.  Normalized\n components are float values between a per component minimum and\n maximum specified by the ColorSpace object for this\n ColorModel.  An IllegalArgumentException\n will be thrown if color component values for this\n ColorModel are not conveniently representable in the\n unnormalized form.  If the\n normComponents array is null, a new array\n will be allocated.  The normComponents array\n will be returned.  Color/alpha components are stored in the\n normComponents array starting at\n normOffset (even if the array is allocated by this\n method).  An ArrayIndexOutOfBoundsException is thrown\n if the normComponents array is not null\n and is not large enough to hold all the color and alpha components\n (starting at normOffset).  An\n IllegalArgumentException is thrown if the\n components array is not large enough to hold all the\n color and alpha components starting at offset.\n \n Since ColorModel is an abstract class,\n any instance is an instance of a subclass.  The default implementation\n of this method in this abstract class assumes that component values\n for this class are conveniently representable in the unnormalized\n form.  Therefore, subclasses which may\n have instances which do not support the unnormalized form must\n override this method."}, {"method_name": "getDataElement", "method_sig": "public int getDataElement (int[] components,\n                          int offset)", "description": "Returns a pixel value represented as an int in this\n ColorModel, given an array of unnormalized color/alpha\n components.  This method will throw an\n IllegalArgumentException if component values for this\n ColorModel are not conveniently representable as a\n single int or if color component values for this\n ColorModel are not conveniently representable in the\n unnormalized form.  An\n ArrayIndexOutOfBoundsException is thrown if  the\n components array is not large enough to hold all the\n color and alpha components (starting at offset).\n Since ColorModel is an abstract class,\n any instance is an instance of a subclass.  Subclasses must\n override this method since the implementation in this abstract\n class throws an UnsupportedOperationException."}, {"method_name": "getDataElements", "method_sig": "public Object getDataElements (int[] components,\n                              int offset,\n                              Object obj)", "description": "Returns a data element array representation of a pixel in this\n ColorModel, given an array of unnormalized color/alpha\n components.  This array can then be passed to the\n setDataElements method of a WritableRaster\n object.  This method will throw an IllegalArgumentException\n if color component values for this ColorModel are not\n conveniently representable in the unnormalized form.\n An ArrayIndexOutOfBoundsException is thrown\n if the components array is not large enough to hold\n all the color and alpha components (starting at\n offset).  If the obj variable is\n null, a new array will be allocated.  If\n obj is not null, it must be a primitive\n array of type transferType; otherwise, a\n ClassCastException is thrown.  An\n ArrayIndexOutOfBoundsException is thrown if\n obj is not large enough to hold a pixel value for this\n ColorModel.\n Since ColorModel is an abstract class,\n any instance is an instance of a subclass.  Subclasses must\n override this method since the implementation in this abstract\n class throws an UnsupportedOperationException."}, {"method_name": "getDataElement", "method_sig": "public int getDataElement (float[] normComponents,\n                          int normOffset)", "description": "Returns a pixel value represented as an int in this\n ColorModel, given an array of normalized color/alpha\n components.  This method will throw an\n IllegalArgumentException if pixel values for this\n ColorModel are not conveniently representable as a\n single int.  An\n ArrayIndexOutOfBoundsException is thrown if  the\n normComponents array is not large enough to hold all the\n color and alpha components (starting at normOffset).\n Since ColorModel is an abstract class,\n any instance is an instance of a subclass.  The default implementation\n of this method in this abstract class first converts from the\n normalized form to the unnormalized form and then calls\n getDataElement(int[], int).  Subclasses which may\n have instances which do not support the unnormalized form must\n override this method."}, {"method_name": "getDataElements", "method_sig": "public Object getDataElements (float[] normComponents,\n                              int normOffset,\n                              Object obj)", "description": "Returns a data element array representation of a pixel in this\n ColorModel, given an array of normalized color/alpha\n components.  This array can then be passed to the\n setDataElements method of a WritableRaster\n object.  An ArrayIndexOutOfBoundsException is thrown\n if the normComponents array is not large enough to hold\n all the color and alpha components (starting at\n normOffset).  If the obj variable is\n null, a new array will be allocated.  If\n obj is not null, it must be a primitive\n array of type transferType; otherwise, a\n ClassCastException is thrown.  An\n ArrayIndexOutOfBoundsException is thrown if\n obj is not large enough to hold a pixel value for this\n ColorModel.\n Since ColorModel is an abstract class,\n any instance is an instance of a subclass.  The default implementation\n of this method in this abstract class first converts from the\n normalized form to the unnormalized form and then calls\n getDataElement(int[], int, Object).  Subclasses which may\n have instances which do not support the unnormalized form must\n override this method."}, {"method_name": "getNormalizedComponents", "method_sig": "public float[] getNormalizedComponents (Object pixel,\n                                       float[] normComponents,\n                                       int normOffset)", "description": "Returns an array of all of the color/alpha components in normalized\n form, given a pixel in this ColorModel.  The pixel\n value is specified by an array of data elements of type transferType\n passed in as an object reference.  If pixel is not a primitive array\n of type transferType, a ClassCastException is thrown.\n An ArrayIndexOutOfBoundsException is thrown if\n pixel is not large enough to hold a pixel value for this\n ColorModel.\n Normalized components are float values between a per component minimum\n and maximum specified by the ColorSpace object for this\n ColorModel.  If the\n normComponents array is null, a new array\n will be allocated.  The normComponents array\n will be returned.  Color/alpha components are stored in the\n normComponents array starting at\n normOffset (even if the array is allocated by this\n method).  An ArrayIndexOutOfBoundsException is thrown\n if the normComponents array is not null\n and is not large enough to hold all the color and alpha components\n (starting at normOffset).\n Since ColorModel is an abstract class,\n any instance is an instance of a subclass.  The default implementation\n of this method in this abstract class first retrieves color and alpha\n components in the unnormalized form using\n getComponents(Object, int[], int) and then calls\n getNormalizedComponents(int[], int, float[], int).\n Subclasses which may\n have instances which do not support the unnormalized form must\n override this method."}, {"method_name": "equals", "method_sig": "public boolean equals (Object obj)", "description": "This method simply delegates to the default implementation in Object\n which is identical to an == test since this class cannot enforce the\n issues of a proper equality test among multiple independent subclass\n branches.\n Subclasses are encouraged to override this method and provide equality\n testing for their own properties in addition to equality tests for the\n following common base properties of ColorModel:\n \nSupport for alpha component.\nIs alpha premultiplied.\nNumber of bits per pixel.\nType of transparency like Opaque, Bitmask or Translucent.\nNumber of components in a pixel.\nColorSpace type.\nType of the array used to represent pixel values.\nNumber of significant bits per color and alpha component.\n"}, {"method_name": "hashCode", "method_sig": "public int hashCode()", "description": "This method simply delegates to the default implementation in Object\n which returns the system ID for the class.\n Subclasses are encouraged to override this method and provide a hash\n for their own properties in addition to hashing the values of the\n following common base properties of ColorModel:\n \nSupport for alpha component.\nIs alpha premultiplied.\nNumber of bits per pixel.\nType of transparency like Opaque, Bitmask or Translucent.\nNumber of components in a pixel.\nColorSpace type.\nType of the array used to represent pixel values.\nNumber of significant bits per color and alpha component.\n"}, {"method_name": "getColorSpace", "method_sig": "public final ColorSpace getColorSpace()", "description": "Returns the ColorSpace associated with this\n ColorModel."}, {"method_name": "coerceData", "method_sig": "public ColorModel coerceData (WritableRaster raster,\n                             boolean isAlphaPremultiplied)", "description": "Forces the raster data to match the state specified in the\n isAlphaPremultiplied variable, assuming the data is\n currently correctly described by this ColorModel.  It\n may multiply or divide the color raster data by alpha, or do\n nothing if the data is in the correct state.  If the data needs to\n be coerced, this method will also return an instance of this\n ColorModel with the isAlphaPremultiplied\n flag set appropriately.  This method will throw a\n UnsupportedOperationException if it is not supported\n by this ColorModel.\n Since ColorModel is an abstract class,\n any instance is an instance of a subclass.  Subclasses must\n override this method since the implementation in this abstract\n class throws an UnsupportedOperationException."}, {"method_name": "isCompatibleRaster", "method_sig": "public boolean isCompatibleRaster (Raster raster)", "description": "Returns true if raster is compatible\n with this ColorModel and false if it is\n not.\n Since ColorModel is an abstract class,\n any instance is an instance of a subclass.  Subclasses must\n override this method since the implementation in this abstract\n class throws an UnsupportedOperationException."}, {"method_name": "createCompatibleWritableRaster", "method_sig": "public WritableRaster createCompatibleWritableRaster (int w,\n                                                     int h)", "description": "Creates a WritableRaster with the specified width and\n height that has a data layout (SampleModel) compatible\n with this ColorModel.\n Since ColorModel is an abstract class,\n any instance is an instance of a subclass.  Subclasses must\n override this method since the implementation in this abstract\n class throws an UnsupportedOperationException."}, {"method_name": "createCompatibleSampleModel", "method_sig": "public SampleModel createCompatibleSampleModel (int w,\n                                               int h)", "description": "Creates a SampleModel with the specified width and\n height that has a data layout compatible with this\n ColorModel.\n Since ColorModel is an abstract class,\n any instance is an instance of a subclass.  Subclasses must\n override this method since the implementation in this abstract\n class throws an UnsupportedOperationException."}, {"method_name": "isCompatibleSampleModel", "method_sig": "public boolean isCompatibleSampleModel (SampleModel sm)", "description": "Checks if the SampleModel is compatible with this\n ColorModel.\n Since ColorModel is an abstract class,\n any instance is an instance of a subclass.  Subclasses must\n override this method since the implementation in this abstract\n class throws an UnsupportedOperationException."}, {"method_name": "finalize", "method_sig": "@Deprecated(since=\"9\")\npublic void finalize()", "description": "Disposes of system resources associated with this\n ColorModel once this ColorModel is no\n longer referenced."}, {"method_name": "getAlphaRaster", "method_sig": "public WritableRaster getAlphaRaster (WritableRaster raster)", "description": "Returns a Raster representing the alpha channel of an\n image, extracted from the input Raster, provided that\n pixel values of this ColorModel represent color and\n alpha information as separate spatial bands (e.g.\n ComponentColorModel and DirectColorModel).\n This method assumes that Raster objects associated\n with such a ColorModel store the alpha band, if\n present, as the last band of image data.  Returns null\n if there is no separate spatial alpha channel associated with this\n ColorModel.  If this is an\n IndexColorModel which has alpha in the lookup table,\n this method will return null since\n there is no spatially discrete alpha channel.\n This method will create a new Raster (but will share\n the data array).\n Since ColorModel is an abstract class, any instance\n is an instance of a subclass.  Subclasses must override this\n method to get any behavior other than returning null\n because the implementation in this abstract class returns\n null."}, {"method_name": "toString", "method_sig": "public String toString()", "description": "Returns the String representation of the contents of\n this ColorModel object."}]}