{"name": "Class JTree", "module": "java.desktop", "package": "javax.swing", "text": "A control that displays a set of hierarchical data as an outline.\n You can find task-oriented documentation and examples of using trees in\n How to Use Trees,\n a section in The Java Tutorial.\n\n A specific node in a tree can be identified either by a\n TreePath (an object\n that encapsulates a node and all of its ancestors), or by its\n display row, where each row in the display area displays one node.\n An expanded node is a non-leaf node (as identified by\n TreeModel.isLeaf(node) returning false) that will displays\n its children when all its ancestors are expanded.\n A collapsed\n node is one which hides them. A hidden node is one which is\n under a collapsed ancestor. All of a viewable nodes parents\n are expanded, but may or may not be displayed. A displayed node\n is both viewable and in the display area, where it can be seen.\n \n The following JTree methods use \"visible\" to mean \"displayed\":\n \nisRootVisible()\nsetRootVisible()\nscrollPathToVisible()\nscrollRowToVisible()\ngetVisibleRowCount()\nsetVisibleRowCount()\n\n The next group of JTree methods use \"visible\" to mean\n \"viewable\" (under an expanded parent):\n \nisVisible()\nmakeVisible()\n\n If you are interested in knowing when the selection changes implement\n the TreeSelectionListener interface and add the instance\n using the method addTreeSelectionListener.\n valueChanged will be invoked when the\n selection changes, that is if the user clicks twice on the same\n node valueChanged will only be invoked once.\n \n If you are interested in detecting either double-click events or when\n a user clicks on a node, regardless of whether or not it was selected,\n we recommend you do the following:\n \n\n final JTree tree = ...;\n\n MouseListener ml = new MouseAdapter() {\n     public void mousePressed(MouseEvent e) {\n         int selRow = tree.getRowForLocation(e.getX(), e.getY());\n         TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());\n         if(selRow != -1) {\n             if(e.getClickCount() == 1) {\n                 mySingleClick(selRow, selPath);\n             }\n             else if(e.getClickCount() == 2) {\n                 myDoubleClick(selRow, selPath);\n             }\n         }\n     }\n };\n tree.addMouseListener(ml);\n \n NOTE: This example obtains both the path and row, but you only need to\n get the one you're interested in.\n \n To use JTree to display compound nodes\n (for example, nodes containing both\n a graphic icon and text), subclass TreeCellRenderer and use\n setCellRenderer(javax.swing.tree.TreeCellRenderer) to tell the tree to use it. To edit such nodes,\n subclass TreeCellEditor and use setCellEditor(javax.swing.tree.TreeCellEditor).\n \n\n Like all JComponent classes, you can use InputMap and\n ActionMap\n to associate an Action object with a KeyStroke\n and execute the action under specified conditions.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans\u2122\n has been added to the java.beans package.\n Please see XMLEncoder.\n", "codes": ["@JavaBean(defaultProperty=\"UI\",\n          description=\"A component that displays a set of hierarchical data as an outline.\")\npublic class JTree\nextends JComponent\nimplements Scrollable, Accessible"], "fields": [{"field_name": "treeModel", "field_sig": "protected transient\u00a0TreeModel treeModel", "description": "The model that defines the tree displayed by this object."}, {"field_name": "selectionModel", "field_sig": "protected transient\u00a0TreeSelectionModel selectionModel", "description": "Models the set of selected nodes in this tree."}, {"field_name": "rootVisible", "field_sig": "protected\u00a0boolean rootVisible", "description": "True if the root node is displayed, false if its children are\n the highest visible nodes."}, {"field_name": "cellRenderer", "field_sig": "protected transient\u00a0TreeCellRenderer cellRenderer", "description": "The cell used to draw nodes. If null, the UI uses a default\n cellRenderer."}, {"field_name": "rowHeight", "field_sig": "protected\u00a0int rowHeight", "description": "Height to use for each display row. If this is <= 0 the renderer\n determines the height for each row."}, {"field_name": "showsRootHandles", "field_sig": "protected\u00a0boolean showsRootHandles", "description": "True if handles are displayed at the topmost level of the tree.\n \n A handle is a small icon that displays adjacent to the node which\n allows the user to click once to expand or collapse the node. A\n common interface shows a plus sign (+) for a node which can be\n expanded and a minus sign (-) for a node which can be collapsed.\n Handles are always shown for nodes below the topmost level.\n \n If the rootVisible setting specifies that the root\n node is to be displayed, then that is the only node at the topmost\n level. If the root node is not displayed, then all of its\n children are at the topmost level of the tree. Handles are\n always displayed for nodes other than the topmost.\n \n If the root node isn't visible, it is generally a good to make\n this value true. Otherwise, the tree looks exactly like a list,\n and users may not know that the \"list entries\" are actually\n tree nodes."}, {"field_name": "selectionRedirector", "field_sig": "protected transient\u00a0JTree.TreeSelectionRedirector selectionRedirector", "description": "Creates a new event and passed it off the\n selectionListeners."}, {"field_name": "cellEditor", "field_sig": "protected transient\u00a0TreeCellEditor cellEditor", "description": "Editor for the entries.  Default is null\n (tree is not editable)."}, {"field_name": "editable", "field_sig": "protected\u00a0boolean editable", "description": "Is the tree editable? Default is false."}, {"field_name": "largeModel", "field_sig": "protected\u00a0boolean largeModel", "description": "Is this tree a large model? This is a code-optimization setting.\n A large model can be used when the cell height is the same for all\n nodes. The UI will then cache very little information and instead\n continually message the model. Without a large model the UI caches\n most of the information, resulting in fewer method calls to the model.\n \n This value is only a suggestion to the UI. Not all UIs will\n take advantage of it. Default value is false."}, {"field_name": "visibleRowCount", "field_sig": "protected\u00a0int visibleRowCount", "description": "Number of rows to make visible at one time. This value is used for\n the Scrollable interface. It determines the preferred\n size of the display area."}, {"field_name": "invokesStopCellEditing", "field_sig": "protected\u00a0boolean invokesStopCellEditing", "description": "If true, when editing is to be stopped by way of selection changing,\n data in tree changing or other means stopCellEditing\n is invoked, and changes are saved. If false,\n cancelCellEditing is invoked, and changes\n are discarded. Default is false."}, {"field_name": "scrollsOnExpand", "field_sig": "protected\u00a0boolean scrollsOnExpand", "description": "If true, when a node is expanded, as many of the descendants are\n scrolled to be visible."}, {"field_name": "toggleClickCount", "field_sig": "protected\u00a0int toggleClickCount", "description": "Number of mouse clicks before a node is expanded."}, {"field_name": "treeModelListener", "field_sig": "protected transient\u00a0TreeModelListener treeModelListener", "description": "Updates the expandedState."}, {"field_name": "CELL_RENDERER_PROPERTY", "field_sig": "public static final\u00a0String CELL_RENDERER_PROPERTY", "description": "Bound property name for cellRenderer."}, {"field_name": "TREE_MODEL_PROPERTY", "field_sig": "public static final\u00a0String TREE_MODEL_PROPERTY", "description": "Bound property name for treeModel."}, {"field_name": "ROOT_VISIBLE_PROPERTY", "field_sig": "public static final\u00a0String ROOT_VISIBLE_PROPERTY", "description": "Bound property name for rootVisible."}, {"field_name": "SHOWS_ROOT_HANDLES_PROPERTY", "field_sig": "public static final\u00a0String SHOWS_ROOT_HANDLES_PROPERTY", "description": "Bound property name for showsRootHandles."}, {"field_name": "ROW_HEIGHT_PROPERTY", "field_sig": "public static final\u00a0String ROW_HEIGHT_PROPERTY", "description": "Bound property name for rowHeight."}, {"field_name": "CELL_EDITOR_PROPERTY", "field_sig": "public static final\u00a0String CELL_EDITOR_PROPERTY", "description": "Bound property name for cellEditor."}, {"field_name": "EDITABLE_PROPERTY", "field_sig": "public static final\u00a0String EDITABLE_PROPERTY", "description": "Bound property name for editable."}, {"field_name": "LARGE_MODEL_PROPERTY", "field_sig": "public static final\u00a0String LARGE_MODEL_PROPERTY", "description": "Bound property name for largeModel."}, {"field_name": "SELECTION_MODEL_PROPERTY", "field_sig": "public static final\u00a0String SELECTION_MODEL_PROPERTY", "description": "Bound property name for selectionModel."}, {"field_name": "VISIBLE_ROW_COUNT_PROPERTY", "field_sig": "public static final\u00a0String VISIBLE_ROW_COUNT_PROPERTY", "description": "Bound property name for visibleRowCount."}, {"field_name": "INVOKES_STOP_CELL_EDITING_PROPERTY", "field_sig": "public static final\u00a0String INVOKES_STOP_CELL_EDITING_PROPERTY", "description": "Bound property name for messagesStopCellEditing."}, {"field_name": "SCROLLS_ON_EXPAND_PROPERTY", "field_sig": "public static final\u00a0String SCROLLS_ON_EXPAND_PROPERTY", "description": "Bound property name for scrollsOnExpand."}, {"field_name": "TOGGLE_CLICK_COUNT_PROPERTY", "field_sig": "public static final\u00a0String TOGGLE_CLICK_COUNT_PROPERTY", "description": "Bound property name for toggleClickCount."}, {"field_name": "LEAD_SELECTION_PATH_PROPERTY", "field_sig": "public static final\u00a0String LEAD_SELECTION_PATH_PROPERTY", "description": "Bound property name for leadSelectionPath."}, {"field_name": "ANCHOR_SELECTION_PATH_PROPERTY", "field_sig": "public static final\u00a0String ANCHOR_SELECTION_PATH_PROPERTY", "description": "Bound property name for anchor selection path."}, {"field_name": "EXPANDS_SELECTED_PATHS_PROPERTY", "field_sig": "public static final\u00a0String EXPANDS_SELECTED_PATHS_PROPERTY", "description": "Bound property name for expands selected paths property"}], "methods": [{"method_name": "getDefaultTreeModel", "method_sig": "protected static TreeModel getDefaultTreeModel()", "description": "Creates and returns a sample TreeModel.\n Used primarily for beanbuilders to show something interesting."}, {"method_name": "createTreeModel", "method_sig": "protected static TreeModel createTreeModel (Object value)", "description": "Returns a TreeModel wrapping the specified object.\n If the object is:\nan array of Objects,\n a Hashtable, or\n a Vector\nthen a new root node is created with each of the incoming\n objects as children. Otherwise, a new root is created with\n a value of \"root\"."}, {"method_name": "getUI", "method_sig": "public TreeUI getUI()", "description": "Returns the L&F object that renders this component."}, {"method_name": "setUI", "method_sig": "@BeanProperty(hidden=true,\n              visualUpdate=true,\n              description=\"The UI object that implements the Component\\'s LookAndFeel.\")\npublic void setUI (TreeUI ui)", "description": "Sets the L&F object that renders this component.\n \n This is a bound property."}, {"method_name": "updateUI", "method_sig": "public void updateUI()", "description": "Notification from the UIManager that the L&F has changed.\n Replaces the current UI object with the latest version from the\n UIManager."}, {"method_name": "getUIClassID", "method_sig": "@BeanProperty(bound=false)\npublic String getUIClassID()", "description": "Returns the name of the L&F class that renders this component."}, {"method_name": "getCellRenderer", "method_sig": "public TreeCellRenderer getCellRenderer()", "description": "Returns the current TreeCellRenderer\n  that is rendering each cell."}, {"method_name": "setCellRenderer", "method_sig": "@BeanProperty(description=\"The TreeCellRenderer that will be used to draw each cell.\")\npublic void setCellRenderer (TreeCellRenderer x)", "description": "Sets the TreeCellRenderer that will be used to\n draw each cell.\n \n This is a bound property."}, {"method_name": "setEditable", "method_sig": "@BeanProperty(description=\"Whether the tree is editable.\")\npublic void setEditable (boolean flag)", "description": "Determines whether the tree is editable. Fires a property\n change event if the new setting is different from the existing\n setting.\n \n This is a bound property."}, {"method_name": "isEditable", "method_sig": "public boolean isEditable()", "description": "Returns true if the tree is editable."}, {"method_name": "setCellEditor", "method_sig": "@BeanProperty(description=\"The cell editor. A null value implies the tree cannot be edited.\")\npublic void setCellEditor (TreeCellEditor cellEditor)", "description": "Sets the cell editor.  A null value implies that the\n tree cannot be edited.  If this represents a change in the\n cellEditor, the propertyChange\n method is invoked on all listeners.\n \n This is a bound property."}, {"method_name": "getCellEditor", "method_sig": "public TreeCellEditor getCellEditor()", "description": "Returns the editor used to edit entries in the tree."}, {"method_name": "getModel", "method_sig": "public TreeModel getModel()", "description": "Returns the TreeModel that is providing the data."}, {"method_name": "setModel", "method_sig": "@BeanProperty(description=\"The TreeModel that will provide the data.\")\npublic void setModel (TreeModel newModel)", "description": "Sets the TreeModel that will provide the data.\n \n This is a bound property."}, {"method_name": "isRootVisible", "method_sig": "public boolean isRootVisible()", "description": "Returns true if the root node of the tree is displayed."}, {"method_name": "setRootVisible", "method_sig": "@BeanProperty(description=\"Whether or not the root node from the TreeModel is visible.\")\npublic void setRootVisible (boolean rootVisible)", "description": "Determines whether or not the root node from\n the TreeModel is visible.\n \n This is a bound property."}, {"method_name": "setShowsRootHandles", "method_sig": "@BeanProperty(description=\"Whether the node handles are to be displayed.\")\npublic void setShowsRootHandles (boolean newValue)", "description": "Sets the value of the showsRootHandles property,\n which specifies whether the node handles should be displayed.\n The default value of this property depends on the constructor\n used to create the JTree.\n Some look and feels might not support handles;\n they will ignore this property.\n \n This is a bound property."}, {"method_name": "getShowsRootHandles", "method_sig": "public boolean getShowsRootHandles()", "description": "Returns the value of the showsRootHandles property."}, {"method_name": "setRowHeight", "method_sig": "@BeanProperty(description=\"The height of each cell.\")\npublic void setRowHeight (int rowHeight)", "description": "Sets the height of each cell, in pixels.  If the specified value\n is less than or equal to zero the current cell renderer is\n queried for each row's height.\n \n This is a bound property."}, {"method_name": "getRowHeight", "method_sig": "public int getRowHeight()", "description": "Returns the height of each row.  If the returned value is less than\n or equal to 0 the height for each row is determined by the\n renderer."}, {"method_name": "isFixedRowHeight", "method_sig": "@BeanProperty(bound=false)\npublic boolean isFixedRowHeight()", "description": "Returns true if the height of each display row is a fixed size."}, {"method_name": "setLargeModel", "method_sig": "@BeanProperty(description=\"Whether the UI should use a large model.\")\npublic void setLargeModel (boolean newValue)", "description": "Specifies whether the UI should use a large model.\n (Not all UIs will implement this.) Fires a property change\n for the LARGE_MODEL_PROPERTY.\n \n This is a bound property."}, {"method_name": "isLargeModel", "method_sig": "public boolean isLargeModel()", "description": "Returns true if the tree is configured for a large model."}, {"method_name": "setInvokesStopCellEditing", "method_sig": "@BeanProperty(description=\"Determines what happens when editing is interrupted, selecting another node in the tree, a change in the tree\\'s data, or some other means.\")\npublic void setInvokesStopCellEditing (boolean newValue)", "description": "Determines what happens when editing is interrupted by selecting\n another node in the tree, a change in the tree's data, or by some\n other means. Setting this property to true causes the\n changes to be automatically saved when editing is interrupted.\n \n Fires a property change for the INVOKES_STOP_CELL_EDITING_PROPERTY."}, {"method_name": "getInvokesStopCellEditing", "method_sig": "public boolean getInvokesStopCellEditing()", "description": "Returns the indicator that tells what happens when editing is\n interrupted."}, {"method_name": "setScrollsOnExpand", "method_sig": "@BeanProperty(description=\"Indicates if a node descendant should be scrolled when expanded.\")\npublic void setScrollsOnExpand (boolean newValue)", "description": "Sets the scrollsOnExpand property,\n which determines whether the\n tree might scroll to show previously hidden children.\n If this property is true (the default),\n when a node expands\n the tree can use scrolling to make\n the maximum possible number of the node's descendants visible.\n In some look and feels, trees might not need to scroll when expanded;\n those look and feels will ignore this property.\n \n This is a bound property."}, {"method_name": "getScrollsOnExpand", "method_sig": "public boolean getScrollsOnExpand()", "description": "Returns the value of the scrollsOnExpand property."}, {"method_name": "setToggleClickCount", "method_sig": "@BeanProperty(description=\"Number of clicks before a node will expand/collapse.\")\npublic void setToggleClickCount (int clickCount)", "description": "Sets the number of mouse clicks before a node will expand or close.\n The default is two.\n \n This is a bound property."}, {"method_name": "getToggleClickCount", "method_sig": "public int getToggleClickCount()", "description": "Returns the number of mouse clicks needed to expand or close a node."}, {"method_name": "setExpandsSelectedPaths", "method_sig": "@BeanProperty(description=\"Indicates whether changes to the selection should make the parent of the path visible.\")\npublic void setExpandsSelectedPaths (boolean newValue)", "description": "Configures the expandsSelectedPaths property. If\n true, any time the selection is changed, either via the\n TreeSelectionModel, or the cover methods provided by\n JTree, the TreePaths parents will be\n expanded to make them visible (visible meaning the parent path is\n expanded, not necessarily in the visible rectangle of the\n JTree). If false, when the selection\n changes the nodes parent is not made visible (all its parents expanded).\n This is useful if you wish to have your selection model maintain paths\n that are not always visible (all parents expanded).\n \n This is a bound property."}, {"method_name": "getExpandsSelectedPaths", "method_sig": "public boolean getExpandsSelectedPaths()", "description": "Returns the expandsSelectedPaths property."}, {"method_name": "setDragEnabled", "method_sig": "@BeanProperty(bound=false,\n              description=\"determines whether automatic drag handling is enabled\")\npublic void setDragEnabled (boolean b)", "description": "Turns on or off automatic drag handling. In order to enable automatic\n drag handling, this property should be set to true, and the\n tree's TransferHandler needs to be non-null.\n The default value of the dragEnabled property is false.\n \n The job of honoring this property, and recognizing a user drag gesture,\n lies with the look and feel implementation, and in particular, the tree's\n TreeUI. When automatic drag handling is enabled, most look and\n feels (including those that subclass BasicLookAndFeel) begin a\n drag and drop operation whenever the user presses the mouse button over\n an item and then moves the mouse a few pixels. Setting this property to\n true can therefore have a subtle effect on how selections behave.\n \n If a look and feel is used that ignores this property, you can still\n begin a drag and drop operation by calling exportAsDrag on the\n tree's TransferHandler."}, {"method_name": "getDragEnabled", "method_sig": "public boolean getDragEnabled()", "description": "Returns whether or not automatic drag handling is enabled."}, {"method_name": "setDropMode", "method_sig": "public final void setDropMode (DropMode dropMode)", "description": "Sets the drop mode for this component. For backward compatibility,\n the default for this property is DropMode.USE_SELECTION.\n Usage of one of the other modes is recommended, however, for an\n improved user experience. DropMode.ON, for instance,\n offers similar behavior of showing items as selected, but does so without\n affecting the actual selection in the tree.\n \nJTree supports the following drop modes:\n \nDropMode.USE_SELECTION\nDropMode.ON\nDropMode.INSERT\nDropMode.ON_OR_INSERT\n\n\n The drop mode is only meaningful if this component has a\n TransferHandler that accepts drops."}, {"method_name": "getDropMode", "method_sig": "public final DropMode getDropMode()", "description": "Returns the drop mode for this component."}, {"method_name": "getDropLocation", "method_sig": "@BeanProperty(bound=false)\npublic final JTree.DropLocation getDropLocation()", "description": "Returns the location that this component should visually indicate\n as the drop location during a DnD operation over the component,\n or null if no location is to currently be shown.\n \n This method is not meant for querying the drop location\n from a TransferHandler, as the drop location is only\n set after the TransferHandler's canImport\n has returned and has allowed for the location to be shown.\n \n When this property changes, a property change event with\n name \"dropLocation\" is fired by the component."}, {"method_name": "isPathEditable", "method_sig": "public boolean isPathEditable (TreePath path)", "description": "Returns isEditable. This is invoked from the UI before\n editing begins to insure that the given path can be edited. This\n is provided as an entry point for subclassers to add filtered\n editing without having to resort to creating a new editor."}, {"method_name": "getToolTipText", "method_sig": "public String getToolTipText (MouseEvent event)", "description": "Overrides JComponent's getToolTipText\n method in order to allow\n renderer's tips to be used if it has text set.\n \n NOTE: For JTree to properly display tooltips of its\n renderers, JTree must be a registered component with the\n ToolTipManager.  This can be done by invoking\n ToolTipManager.sharedInstance().registerComponent(tree).\n This is not done automatically!"}, {"method_name": "convertValueToText", "method_sig": "public String convertValueToText (Object value,\n                                 boolean selected,\n                                 boolean expanded,\n                                 boolean leaf,\n                                 int row,\n                                 boolean hasFocus)", "description": "Called by the renderers to convert the specified value to\n text. This implementation returns value.toString, ignoring\n all other arguments. To control the conversion, subclass this\n method and use any of the arguments you need."}, {"method_name": "getRowCount", "method_sig": "@BeanProperty(bound=false)\npublic int getRowCount()", "description": "Returns the number of viewable nodes. A node is viewable if all of its\n parents are expanded. The root is only included in this count if\n isRootVisible() is true. This returns 0 if\n the UI has not been set."}, {"method_name": "setSelectionPath", "method_sig": "public void setSelectionPath (TreePath path)", "description": "Selects the node identified by the specified path. If any\n component of the path is hidden (under a collapsed node), and\n getExpandsSelectedPaths is true it is\n exposed (made viewable)."}, {"method_name": "setSelectionPaths", "method_sig": "public void setSelectionPaths (TreePath[] paths)", "description": "Selects the nodes identified by the specified array of paths.\n If any component in any of the paths is hidden (under a collapsed\n node), and getExpandsSelectedPaths is true\n it is exposed (made viewable)."}, {"method_name": "setLeadSelectionPath", "method_sig": "@BeanProperty(description=\"Lead selection path\")\npublic void setLeadSelectionPath (TreePath newPath)", "description": "Sets the path identifies as the lead. The lead may not be selected.\n The lead is not maintained by JTree,\n rather the UI will update it.\n \n This is a bound property."}, {"method_name": "setAnchorSelectionPath", "method_sig": "@BeanProperty(description=\"Anchor selection path\")\npublic void setAnchorSelectionPath (TreePath newPath)", "description": "Sets the path identified as the anchor.\n The anchor is not maintained by JTree, rather the UI will\n update it.\n \n This is a bound property."}, {"method_name": "setSelectionRow", "method_sig": "public void setSelectionRow (int row)", "description": "Selects the node at the specified row in the display."}, {"method_name": "setSelectionRows", "method_sig": "public void setSelectionRows (int[] rows)", "description": "Selects the nodes corresponding to each of the specified rows\n in the display. If a particular element of rows is\n < 0 or >= getRowCount, it will be ignored.\n If none of the elements\n in rows are valid rows, the selection will\n be cleared. That is it will be as if clearSelection\n was invoked."}, {"method_name": "addSelectionPath", "method_sig": "public void addSelectionPath (TreePath path)", "description": "Adds the node identified by the specified TreePath\n to the current selection. If any component of the path isn't\n viewable, and getExpandsSelectedPaths is true it is\n made viewable.\n \n Note that JTree does not allow duplicate nodes to\n exist as children under the same parent -- each sibling must be\n a unique object."}, {"method_name": "addSelectionPaths", "method_sig": "public void addSelectionPaths (TreePath[] paths)", "description": "Adds each path in the array of paths to the current selection. If\n any component of any of the paths isn't viewable and\n getExpandsSelectedPaths is true, it is\n made viewable.\n \n Note that JTree does not allow duplicate nodes to\n exist as children under the same parent -- each sibling must be\n a unique object."}, {"method_name": "addSelectionRow", "method_sig": "public void addSelectionRow (int row)", "description": "Adds the path at the specified row to the current selection."}, {"method_name": "addSelectionRows", "method_sig": "public void addSelectionRows (int[] rows)", "description": "Adds the paths at each of the specified rows to the current selection."}, {"method_name": "getLastSelectedPathComponent", "method_sig": "@BeanProperty(bound=false)\npublic Object getLastSelectedPathComponent()", "description": "Returns the last path component of the selected path. This is\n a convenience method for\n getSelectionModel().getSelectionPath().getLastPathComponent().\n This is typically only useful if the selection has one path."}, {"method_name": "getLeadSelectionPath", "method_sig": "public TreePath getLeadSelectionPath()", "description": "Returns the path identified as the lead."}, {"method_name": "getAnchorSelectionPath", "method_sig": "public TreePath getAnchorSelectionPath()", "description": "Returns the path identified as the anchor."}, {"method_name": "getSelectionPath", "method_sig": "public TreePath getSelectionPath()", "description": "Returns the path to the first selected node."}, {"method_name": "getSelectionPaths", "method_sig": "public TreePath[] getSelectionPaths()", "description": "Returns the paths of all selected values."}, {"method_name": "getSelectionRows", "method_sig": "public int[] getSelectionRows()", "description": "Returns all of the currently selected rows. This method is simply\n forwarded to the TreeSelectionModel.\n If nothing is selected null or an empty array will\n be returned, based on the TreeSelectionModel\n implementation."}, {"method_name": "getSelectionCount", "method_sig": "@BeanProperty(bound=false)\npublic int getSelectionCount()", "description": "Returns the number of nodes selected."}, {"method_name": "getMinSelectionRow", "method_sig": "@BeanProperty(bound=false)\npublic int getMinSelectionRow()", "description": "Returns the smallest selected row. If the selection is empty, or\n none of the selected paths are viewable, -1 is returned."}, {"method_name": "getMaxSelectionRow", "method_sig": "@BeanProperty(bound=false)\npublic int getMaxSelectionRow()", "description": "Returns the largest selected row. If the selection is empty, or\n none of the selected paths are viewable, -1 is returned."}, {"method_name": "getLeadSelectionRow", "method_sig": "@BeanProperty(bound=false)\npublic int getLeadSelectionRow()", "description": "Returns the row index corresponding to the lead path."}, {"method_name": "isPathSelected", "method_sig": "public boolean isPathSelected (TreePath path)", "description": "Returns true if the item identified by the path is currently selected."}, {"method_name": "isRowSelected", "method_sig": "public boolean isRowSelected (int row)", "description": "Returns true if the node identified by row is selected."}, {"method_name": "getExpandedDescendants", "method_sig": "public Enumeration<TreePath> getExpandedDescendants (TreePath parent)", "description": "Returns an Enumeration of the descendants of the\n path parent that\n are currently expanded. If parent is not currently\n expanded, this will return null.\n If you expand/collapse nodes while\n iterating over the returned Enumeration\n this may not return all\n the expanded paths, or may return paths that are no longer expanded."}, {"method_name": "hasBeenExpanded", "method_sig": "public boolean hasBeenExpanded (TreePath path)", "description": "Returns true if the node identified by the path has ever been\n expanded."}, {"method_name": "isExpanded", "method_sig": "public boolean isExpanded (TreePath path)", "description": "Returns true if the node identified by the path is currently expanded,"}, {"method_name": "isExpanded", "method_sig": "public boolean isExpanded (int row)", "description": "Returns true if the node at the specified display row is currently\n expanded."}, {"method_name": "isCollapsed", "method_sig": "public boolean isCollapsed (TreePath path)", "description": "Returns true if the value identified by path is currently collapsed,\n this will return false if any of the values in path are currently\n not being displayed."}, {"method_name": "isCollapsed", "method_sig": "public boolean isCollapsed (int row)", "description": "Returns true if the node at the specified display row is collapsed."}, {"method_name": "makeVisible", "method_sig": "public void makeVisible (TreePath path)", "description": "Ensures that the node identified by path is currently viewable."}, {"method_name": "isVisible", "method_sig": "public boolean isVisible (TreePath path)", "description": "Returns true if the value identified by path is currently viewable,\n which means it is either the root or all of its parents are expanded.\n Otherwise, this method returns false."}, {"method_name": "getPathBounds", "method_sig": "public Rectangle getPathBounds (TreePath path)", "description": "Returns the Rectangle that the specified node will be drawn\n into. Returns null if any component in the path is hidden\n (under a collapsed parent).\n \n Note:\n This method returns a valid rectangle, even if the specified\n node is not currently displayed."}, {"method_name": "getRowBounds", "method_sig": "public Rectangle getRowBounds (int row)", "description": "Returns the Rectangle that the node at the specified row is\n drawn in."}, {"method_name": "scrollPathToVisible", "method_sig": "public void scrollPathToVisible (TreePath path)", "description": "Makes sure all the path components in path are expanded (except\n for the last path component) and scrolls so that the\n node identified by the path is displayed. Only works when this\n JTree is contained in a JScrollPane."}, {"method_name": "scrollRowToVisible", "method_sig": "public void scrollRowToVisible (int row)", "description": "Scrolls the item identified by row until it is displayed. The minimum\n of amount of scrolling necessary to bring the row into view\n is performed. Only works when this JTree is contained in a\n JScrollPane."}, {"method_name": "getPathForRow", "method_sig": "@BeanProperty(bound=false)\npublic TreePath getPathForRow (int row)", "description": "Returns the path for the specified row.  If row is\n not visible, or a TreeUI has not been set, null\n is returned."}, {"method_name": "getRowForPath", "method_sig": "public int getRowForPath (TreePath path)", "description": "Returns the row that displays the node identified by the specified\n path."}, {"method_name": "expandPath", "method_sig": "public void expandPath (TreePath path)", "description": "Ensures that the node identified by the specified path is\n expanded and viewable. If the last item in the path is a\n leaf, this will have no effect."}, {"method_name": "expandRow", "method_sig": "public void expandRow (int row)", "description": "Ensures that the node in the specified row is expanded and\n viewable.\n \n If row is < 0 or >= getRowCount this\n will have no effect."}, {"method_name": "collapsePath", "method_sig": "public void collapsePath (TreePath path)", "description": "Ensures that the node identified by the specified path is\n collapsed and viewable."}, {"method_name": "collapseRow", "method_sig": "public void collapseRow (int row)", "description": "Ensures that the node in the specified row is collapsed.\n \n If row is < 0 or >= getRowCount this\n will have no effect."}, {"method_name": "getPathForLocation", "method_sig": "public TreePath getPathForLocation (int x,\n                                   int y)", "description": "Returns the path for the node at the specified location."}, {"method_name": "getRowForLocation", "method_sig": "public int getRowForLocation (int x,\n                             int y)", "description": "Returns the row for the specified location."}, {"method_name": "getClosestPathForLocation", "method_sig": "public TreePath getClosestPathForLocation (int x,\n                                          int y)", "description": "Returns the path to the node that is closest to x,y.  If\n no nodes are currently viewable, or there is no model, returns\n null, otherwise it always returns a valid path.  To test if\n the node is exactly at x, y, get the node's bounds and\n test x, y against that."}, {"method_name": "getClosestRowForLocation", "method_sig": "public int getClosestRowForLocation (int x,\n                                    int y)", "description": "Returns the row to the node that is closest to x,y.  If no nodes\n are viewable or there is no model, returns -1. Otherwise,\n it always returns a valid row.  To test if the returned object is\n exactly at x, y, get the bounds for the node at the returned\n row and test x, y against that."}, {"method_name": "isEditing", "method_sig": "@BeanProperty(bound=false)\npublic boolean isEditing()", "description": "Returns true if the tree is being edited. The item that is being\n edited can be obtained using getSelectionPath."}, {"method_name": "stopEditing", "method_sig": "public boolean stopEditing()", "description": "Ends the current editing session.\n (The DefaultTreeCellEditor\n object saves any edits that are currently in progress on a cell.\n Other implementations may operate differently.)\n Has no effect if the tree isn't being edited.\n \nNote:\n To make edit-saves automatic whenever the user changes\n their position in the tree, use setInvokesStopCellEditing(boolean).\n "}, {"method_name": "cancelEditing", "method_sig": "public void cancelEditing()", "description": "Cancels the current editing session. Has no effect if the\n tree isn't being edited."}, {"method_name": "startEditingAtPath", "method_sig": "public void startEditingAtPath (TreePath path)", "description": "Selects the node identified by the specified path and initiates\n editing.  The edit-attempt fails if the CellEditor\n does not allow\n editing for the specified item."}, {"method_name": "getEditingPath", "method_sig": "@BeanProperty(bound=false)\npublic TreePath getEditingPath()", "description": "Returns the path to the element that is currently being edited."}, {"method_name": "setSelectionModel", "method_sig": "@BeanProperty(description=\"The tree\\'s selection model.\")\npublic void setSelectionModel (TreeSelectionModel selectionModel)", "description": "Sets the tree's selection model. When a null value is\n specified an empty\n selectionModel is used, which does not allow selections.\n \n This is a bound property."}, {"method_name": "getSelectionModel", "method_sig": "public TreeSelectionModel getSelectionModel()", "description": "Returns the model for selections. This should always return a\n non-null value. If you don't want to allow anything\n to be selected\n set the selection model to null, which forces an empty\n selection model to be used."}, {"method_name": "getPathBetweenRows", "method_sig": "protected TreePath[] getPathBetweenRows (int index0,\n                                        int index1)", "description": "Returns the paths (inclusive) between the specified rows. If\n the specified indices are within the viewable set of rows, or\n bound the viewable set of rows, then the indices are\n constrained by the viewable set of rows. If the specified\n indices are not within the viewable set of rows, or do not\n bound the viewable set of rows, then an empty array is\n returned. For example, if the row count is 10, and this\n method is invoked with -1, 20, then the specified\n indices are constrained to the viewable set of rows, and this is\n treated as if invoked with 0, 9. On the other hand, if\n this were invoked with -10, -1, then the specified\n indices do not bound the viewable set of rows, and an empty\n array is returned.\n \n The parameters are not order dependent. That is, \n getPathBetweenRows(x, y) is equivalent to\n getPathBetweenRows(y, x).\n \n An empty array is returned if the row count is 0, or\n the specified indices do not bound the viewable set of rows."}, {"method_name": "setSelectionInterval", "method_sig": "public void setSelectionInterval (int index0,\n                                 int index1)", "description": "Selects the rows in the specified interval (inclusive). If\n the specified indices are within the viewable set of rows, or bound\n the viewable set of rows, then the specified rows are constrained by\n the viewable set of rows. If the specified indices are not within the\n viewable set of rows, or do not bound the viewable set of rows, then\n the selection is cleared. For example, if the row count is \n 10, and this method is invoked with -1, 20, then the\n specified indices bounds the viewable range, and this is treated as\n if invoked with 0, 9. On the other hand, if this were\n invoked with -10, -1, then the specified indices do not\n bound the viewable set of rows, and the selection is cleared.\n \n The parameters are not order dependent. That is, \n setSelectionInterval(x, y) is equivalent to\n setSelectionInterval(y, x)."}, {"method_name": "addSelectionInterval", "method_sig": "public void addSelectionInterval (int index0,\n                                 int index1)", "description": "Adds the specified rows (inclusive) to the selection. If the\n specified indices are within the viewable set of rows, or bound\n the viewable set of rows, then the specified indices are\n constrained by the viewable set of rows. If the indices are not\n within the viewable set of rows, or do not bound the viewable\n set of rows, then the selection is unchanged. For example, if\n the row count is 10, and this method is invoked with\n -1, 20, then the specified indices bounds the viewable\n range, and this is treated as if invoked with 0, 9. On\n the other hand, if this were invoked with -10, -1, then\n the specified indices do not bound the viewable set of rows,\n and the selection is unchanged.\n \n The parameters are not order dependent. That is, \n addSelectionInterval(x, y) is equivalent to\n addSelectionInterval(y, x)."}, {"method_name": "removeSelectionInterval", "method_sig": "public void removeSelectionInterval (int index0,\n                                    int index1)", "description": "Removes the specified rows (inclusive) from the selection. If\n the specified indices are within the viewable set of rows, or bound\n the viewable set of rows, then the specified indices are constrained by\n the viewable set of rows. If the specified indices are not within the\n viewable set of rows, or do not bound the viewable set of rows, then\n the selection is unchanged. For example, if the row count is \n 10, and this method is invoked with -1, 20, then the\n specified range bounds the viewable range, and this is treated as\n if invoked with 0, 9. On the other hand, if this were\n invoked with -10, -1, then the specified range does not\n bound the viewable set of rows, and the selection is unchanged.\n \n The parameters are not order dependent. That is, \n removeSelectionInterval(x, y) is equivalent to\n removeSelectionInterval(y, x)."}, {"method_name": "removeSelectionPath", "method_sig": "public void removeSelectionPath (TreePath path)", "description": "Removes the node identified by the specified path from the current\n selection."}, {"method_name": "removeSelectionPaths", "method_sig": "public void removeSelectionPaths (TreePath[] paths)", "description": "Removes the nodes identified by the specified paths from the\n current selection."}, {"method_name": "removeSelectionRow", "method_sig": "public void removeSelectionRow (int row)", "description": "Removes the row at the index row from the current\n selection."}, {"method_name": "removeSelectionRows", "method_sig": "public void removeSelectionRows (int[] rows)", "description": "Removes the rows that are selected at each of the specified\n rows."}, {"method_name": "clearSelection", "method_sig": "public void clearSelection()", "description": "Clears the selection."}, {"method_name": "isSelectionEmpty", "method_sig": "@BeanProperty(bound=false)\npublic boolean isSelectionEmpty()", "description": "Returns true if the selection is currently empty."}, {"method_name": "addTreeExpansionListener", "method_sig": "public void addTreeExpansionListener (TreeExpansionListener tel)", "description": "Adds a listener for TreeExpansion events."}, {"method_name": "removeTreeExpansionListener", "method_sig": "public void removeTreeExpansionListener (TreeExpansionListener tel)", "description": "Removes a listener for TreeExpansion events."}, {"method_name": "getTreeExpansionListeners", "method_sig": "@BeanProperty(bound=false)\npublic TreeExpansionListener[] getTreeExpansionListeners()", "description": "Returns an array of all the TreeExpansionListeners added\n to this JTree with addTreeExpansionListener()."}, {"method_name": "addTreeWillExpandListener", "method_sig": "public void addTreeWillExpandListener (TreeWillExpandListener tel)", "description": "Adds a listener for TreeWillExpand events."}, {"method_name": "removeTreeWillExpandListener", "method_sig": "public void removeTreeWillExpandListener (TreeWillExpandListener tel)", "description": "Removes a listener for TreeWillExpand events."}, {"method_name": "getTreeWillExpandListeners", "method_sig": "@BeanProperty(bound=false)\npublic TreeWillExpandListener[] getTreeWillExpandListeners()", "description": "Returns an array of all the TreeWillExpandListeners added\n to this JTree with addTreeWillExpandListener()."}, {"method_name": "fireTreeExpanded", "method_sig": "public void fireTreeExpanded (TreePath path)", "description": "Notifies all listeners that have registered interest for\n notification on this event type.  The event instance\n is lazily created using the path parameter."}, {"method_name": "fireTreeCollapsed", "method_sig": "public void fireTreeCollapsed (TreePath path)", "description": "Notifies all listeners that have registered interest for\n notification on this event type.  The event instance\n is lazily created using the path parameter."}, {"method_name": "fireTreeWillExpand", "method_sig": "public void fireTreeWillExpand (TreePath path)\n                        throws ExpandVetoException", "description": "Notifies all listeners that have registered interest for\n notification on this event type.  The event instance\n is lazily created using the path parameter."}, {"method_name": "fireTreeWillCollapse", "method_sig": "public void fireTreeWillCollapse (TreePath path)\n                          throws ExpandVetoException", "description": "Notifies all listeners that have registered interest for\n notification on this event type.  The event instance\n is lazily created using the path parameter."}, {"method_name": "addTreeSelectionListener", "method_sig": "public void addTreeSelectionListener (TreeSelectionListener tsl)", "description": "Adds a listener for TreeSelection events."}, {"method_name": "removeTreeSelectionListener", "method_sig": "public void removeTreeSelectionListener (TreeSelectionListener tsl)", "description": "Removes a TreeSelection listener."}, {"method_name": "getTreeSelectionListeners", "method_sig": "@BeanProperty(bound=false)\npublic TreeSelectionListener[] getTreeSelectionListeners()", "description": "Returns an array of all the TreeSelectionListeners added\n to this JTree with addTreeSelectionListener()."}, {"method_name": "fireValueChanged", "method_sig": "protected void fireValueChanged (TreeSelectionEvent e)", "description": "Notifies all listeners that have registered interest for\n notification on this event type."}, {"method_name": "treeDidChange", "method_sig": "public void treeDidChange()", "description": "Sent when the tree has changed enough that we need to resize\n the bounds, but not enough that we need to remove the\n expanded node set (e.g nodes were expanded or collapsed, or\n nodes were inserted into the tree). You should never have to\n invoke this, the UI will invoke this as it needs to."}, {"method_name": "setVisibleRowCount", "method_sig": "@BeanProperty(description=\"The number of rows that are to be displayed.\")\npublic void setVisibleRowCount (int newCount)", "description": "Sets the number of rows that are to be displayed.\n This will only work if the tree is contained in a\n JScrollPane,\n and will adjust the preferred size and size of that scrollpane.\n \n This is a bound property."}, {"method_name": "getVisibleRowCount", "method_sig": "public int getVisibleRowCount()", "description": "Returns the number of rows that are displayed in the display area."}, {"method_name": "getNextMatch", "method_sig": "public TreePath getNextMatch (String prefix,\n                             int startingRow,\n                             Position.Bias bias)", "description": "Returns the TreePath to the next tree element that\n begins with a prefix. To handle the conversion of a\n TreePath into a String, convertValueToText\n is used."}, {"method_name": "getPreferredScrollableViewportSize", "method_sig": "@BeanProperty(bound=false)\npublic Dimension getPreferredScrollableViewportSize()", "description": "Returns the preferred display size of a JTree. The height is\n determined from getVisibleRowCount and the width\n is the current preferred width."}, {"method_name": "getScrollableUnitIncrement", "method_sig": "public int getScrollableUnitIncrement (Rectangle visibleRect,\n                                      int orientation,\n                                      int direction)", "description": "Returns the amount to increment when scrolling. The amount is\n the height of the first displayed row that isn't completely in view\n or, if it is totally displayed, the height of the next row in the\n scrolling direction."}, {"method_name": "getScrollableBlockIncrement", "method_sig": "public int getScrollableBlockIncrement (Rectangle visibleRect,\n                                       int orientation,\n                                       int direction)", "description": "Returns the amount for a block increment, which is the height or\n width of visibleRect, based on orientation."}, {"method_name": "getScrollableTracksViewportWidth", "method_sig": "@BeanProperty(bound=false)\npublic boolean getScrollableTracksViewportWidth()", "description": "Returns false to indicate that the width of the viewport does not\n determine the width of the table, unless the preferred width of\n the tree is smaller than the viewports width.  In other words:\n ensure that the tree is never smaller than its viewport."}, {"method_name": "getScrollableTracksViewportHeight", "method_sig": "@BeanProperty(bound=false)\npublic boolean getScrollableTracksViewportHeight()", "description": "Returns false to indicate that the height of the viewport does not\n determine the height of the table, unless the preferred height\n of the tree is smaller than the viewports height.  In other words:\n ensure that the tree is never smaller than its viewport."}, {"method_name": "setExpandedState", "method_sig": "protected void setExpandedState (TreePath path,\n                                boolean state)", "description": "Sets the expanded state of this JTree.\n If state is\n true, all parents of path and path are marked as\n expanded. If state is false, all parents of\n path are marked EXPANDED, but path itself\n is marked collapsed.\n This will fail if a TreeWillExpandListener vetos it."}, {"method_name": "getDescendantToggledPaths", "method_sig": "protected Enumeration<TreePath> getDescendantToggledPaths (TreePath parent)", "description": "Returns an Enumeration of TreePaths\n that have been expanded that\n are descendants of parent."}, {"method_name": "removeDescendantToggledPaths", "method_sig": "protected void removeDescendantToggledPaths (Enumeration<TreePath> toRemove)", "description": "Removes any descendants of the TreePaths in\n toRemove\n that have been expanded."}, {"method_name": "clearToggledPaths", "method_sig": "protected void clearToggledPaths()", "description": "Clears the cache of toggled tree paths. This does NOT send out\n any TreeExpansionListener events."}, {"method_name": "createTreeModelListener", "method_sig": "protected TreeModelListener createTreeModelListener()", "description": "Creates and returns an instance of TreeModelHandler.\n The returned\n object is responsible for updating the expanded state when the\n TreeModel changes.\n \n For more information on what expanded state means, see the\n JTree description above."}, {"method_name": "removeDescendantSelectedPaths", "method_sig": "protected boolean removeDescendantSelectedPaths (TreePath path,\n                                                boolean includePath)", "description": "Removes any paths in the selection that are descendants of\n path. If includePath is true and\n path is selected, it will be removed from the selection."}, {"method_name": "paramString", "method_sig": "protected String paramString()", "description": "Returns a string representation of this JTree.\n This method\n is intended to be used only for debugging purposes, and the\n content and format of the returned string may vary between\n implementations. The returned string may be empty but may not\n be null."}, {"method_name": "getAccessibleContext", "method_sig": "@BeanProperty(bound=false)\npublic AccessibleContext getAccessibleContext()", "description": "Gets the AccessibleContext associated with this JTree.\n For JTrees, the AccessibleContext takes the form of an\n AccessibleJTree.\n A new AccessibleJTree instance is created if necessary."}]}