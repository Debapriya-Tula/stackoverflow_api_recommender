{"name": "Class SyncFactory", "module": "java.sql.rowset", "package": "javax.sql.rowset.spi", "text": "The Service Provider Interface (SPI) mechanism that generates SyncProvider\n instances to be used by disconnected RowSet objects.\n The SyncProvider instances in turn provide the\n javax.sql.RowSetReader object the RowSet object\n needs to populate itself with data and the\n javax.sql.RowSetWriter object it needs to\n propagate changes to its\n data back to the underlying data source.\n \n Because the methods in the SyncFactory class are all static,\n there is only one SyncFactory object\n per Java VM at any one time. This ensures that there is a single source from which a\n RowSet implementation can obtain its SyncProvider\n implementation.\n\n 1.0 Overview\n The SyncFactory class provides an internal registry of available\n synchronization provider implementations (SyncProvider objects).\n This registry may be queried to determine which\n synchronization providers are available.\n The following line of code gets an enumeration of the providers currently registered.\n \n     java.util.Enumeration e = SyncFactory.getRegisteredProviders();\n \n All standard RowSet implementations must provide at least two providers:\n \nan optimistic provider for use with a CachedRowSet implementation\n     or an implementation derived from it\n  an XML provider, which is used for reading and writing XML, such as with\n       WebRowSet objects\n \n Note that the JDBC RowSet Implementations include the SyncProvider\n implementations RIOptimisticProvider and RIXmlProvider,\n which satisfy this requirement.\n \n The SyncFactory class provides accessor methods to assist\n applications in determining which synchronization providers are currently\n registered with the SyncFactory.\n \n Other methods let RowSet persistence providers be\n registered or de-registered with the factory mechanism. This\n allows additional synchronization provider implementations to be made\n available to RowSet objects at run time.\n \n Applications can apply a degree of filtering to determine the level of\n synchronization that a SyncProvider implementation offers.\n The following criteria determine whether a provider is\n made available to a RowSet object:\n \nIf a particular provider is specified by a RowSet object, and\n the SyncFactory does not contain a reference to this provider,\n a SyncFactoryException is thrown stating that the synchronization\n provider could not be found.\n\n If a RowSet implementation is instantiated with a specified\n provider and the specified provider has been properly registered, the\n requested provider is supplied. Otherwise a SyncFactoryException\n is thrown.\n\n If a RowSet object does not specify a\n SyncProvider implementation and no additional\n SyncProvider implementations are available, the reference\n implementation providers are supplied.\n \n2.0 Registering SyncProvider Implementations\n\n Both vendors and developers can register SyncProvider\n implementations using one of the following mechanisms.\n \nUsing the command line\n The name of the provider is supplied on the command line, which will add\n the provider to the system properties.\n For example:\n \n    -Drowset.provider.classname=com.fred.providers.HighAvailabilityProvider\n \nUsing the Standard Properties File\n The reference implementation is targeted\n to ship with J2SE 1.5, which will include an additional resource file\n that may be edited by hand. Here is an example of the properties file\n included in the reference implementation:\n \n   #Default JDBC RowSet sync providers listing\n   #\n\n   # Optimistic synchronization provider\n   rowset.provider.classname.0=com.sun.rowset.providers.RIOptimisticProvider\n   rowset.provider.vendor.0=Oracle Corporation\n   rowset.provider.version.0=1.0\n\n   # XML Provider using standard XML schema\n   rowset.provider.classname.1=com.sun.rowset.providers.RIXMLProvider\n   rowset.provider.vendor.1=Oracle Corporation\n   rowset.provider.version.1=1.0\n \n The SyncFactory checks this file and registers the\n SyncProvider implementations that it contains. A\n developer or vendor can add other implementations to this file.\n For example, here is a possible addition:\n \n     rowset.provider.classname.2=com.fred.providers.HighAvailabilityProvider\n     rowset.provider.vendor.2=Fred, Inc.\n     rowset.provider.version.2=1.0\n \nUsing a JNDI Context\n Available providers can be registered on a JNDI\n context, and the SyncFactory will attempt to load\n SyncProvider implementations from that JNDI context.\n For example, the following code fragment registers a provider implementation\n on a JNDI context.  This is something a deployer would normally do. In this\n example, MyProvider is being registered on a CosNaming\n namespace, which is the namespace used by J2EE resources.\n \n    import javax.naming.*;\n\n    Hashtable svrEnv = new  Hashtable();\n    srvEnv.put(Context.INITIAL_CONTEXT_FACTORY, \"CosNaming\");\n\n    Context ctx = new InitialContext(svrEnv);\n    com.fred.providers.MyProvider = new MyProvider();\n    ctx.rebind(\"providers/MyProvider\", syncProvider);\n \n\n Next, an application will register the JNDI context with the\n SyncFactory instance.  This allows the SyncFactory\n to browse within the JNDI context looking for SyncProvider\n implementations.\n \n    Hashtable appEnv = new Hashtable();\n    appEnv.put(Context.INITIAL_CONTEXT_FACTORY, \"CosNaming\");\n    appEnv.put(Context.PROVIDER_URL, \"iiop://hostname/providers\");\n    Context ctx = new InitialContext(appEnv);\n\n    SyncFactory.registerJNDIContext(ctx);\n \n If a RowSet object attempts to obtain a MyProvider\n object, the SyncFactory will try to locate it. First it searches\n for it in the system properties, then it looks in the resource files, and\n finally it checks the JNDI context that has been set. The SyncFactory\n instance verifies that the requested provider is a valid extension of the\n SyncProvider abstract class and then gives it to the\n RowSet object. In the following code fragment, a new\n CachedRowSet object is created and initialized with\n env, which contains the binding to MyProvider.\n \n    Hashtable env = new Hashtable();\n    env.put(SyncFactory.ROWSET_SYNC_PROVIDER, \"com.fred.providers.MyProvider\");\n    CachedRowSet crs = new com.sun.rowset.CachedRowSetImpl(env);\n \n Further details on these mechanisms are available in the\n javax.sql.rowset.spi package specification.", "codes": ["public class SyncFactory\nextends Object"], "fields": [{"field_name": "ROWSET_SYNC_PROVIDER", "field_sig": "public static final\u00a0String ROWSET_SYNC_PROVIDER", "description": "The standard property-id for a synchronization provider implementation\n name."}, {"field_name": "ROWSET_SYNC_VENDOR", "field_sig": "public static final\u00a0String ROWSET_SYNC_VENDOR", "description": "The standard property-id for a synchronization provider implementation\n vendor name."}, {"field_name": "ROWSET_SYNC_PROVIDER_VERSION", "field_sig": "public static final\u00a0String ROWSET_SYNC_PROVIDER_VERSION", "description": "The standard property-id for a synchronization provider implementation\n version tag."}], "methods": [{"method_name": "registerProvider", "method_sig": "public static void registerProvider (String providerID)\n                             throws SyncFactoryException", "description": "Adds the given synchronization provider to the factory register. Guidelines\n are provided in the SyncProvider specification for the\n required naming conventions for SyncProvider\n implementations.\n \n Synchronization providers bound to a JNDI context can be\n registered by binding a SyncProvider instance to a JNDI namespace.\n\n \n \n SyncProvider p = new MySyncProvider();\n InitialContext ic = new InitialContext();\n ic.bind (\"jdbc/rowset/MySyncProvider\", p);\n  \n\n Furthermore, an initial JNDI context should be set with the\n SyncFactory using the setJNDIContext method.\n The SyncFactory leverages this context to search for\n available SyncProvider objects bound to the JNDI\n context and its child nodes."}, {"method_name": "getSyncFactory", "method_sig": "public static SyncFactory getSyncFactory()", "description": "Returns the SyncFactory singleton."}, {"method_name": "unregisterProvider", "method_sig": "public static void unregisterProvider (String providerID)\n                               throws SyncFactoryException", "description": "Removes the designated currently registered synchronization provider from the\n Factory SPI register."}, {"method_name": "getInstance", "method_sig": "public static SyncProvider getInstance (String providerID)\n                                throws SyncFactoryException", "description": "Returns the SyncProvider instance identified by providerID."}, {"method_name": "getRegisteredProviders", "method_sig": "public static Enumeration<SyncProvider> getRegisteredProviders()\n                                                        throws SyncFactoryException", "description": "Returns an Enumeration of currently registered synchronization\n providers.  A RowSet implementation may use any provider in\n the enumeration as its SyncProvider object.\n \n At a minimum, the reference synchronization provider allowing\n RowSet content data to be stored using a JDBC driver should be\n possible."}, {"method_name": "setLogger", "method_sig": "public static void setLogger (Logger logger)", "description": "Sets the logging object to be used by the SyncProvider\n implementation provided by the SyncFactory. All\n SyncProvider implementations can log their events to\n this object and the application can retrieve a handle to this\n object using the getLogger method.\n \n This method checks to see that there is an SQLPermission\n object  which grants the permission setSyncFactory\n before allowing the method to succeed.  If a\n SecurityManager exists and its\n checkPermission method denies calling setLogger,\n this method throws a\n java.lang.SecurityException."}, {"method_name": "setLogger", "method_sig": "public static void setLogger (Logger logger,\n                             Level level)", "description": "Sets the logging object that is used by SyncProvider\n implementations provided by the SyncFactory SPI. All\n SyncProvider implementations can log their events\n to this object and the application can retrieve a handle to this\n object using the getLogger method.\n \n This method checks to see that there is an SQLPermission\n object  which grants the permission setSyncFactory\n before allowing the method to succeed.  If a\n SecurityManager exists and its\n checkPermission method denies calling setLogger,\n this method throws a\n java.lang.SecurityException."}, {"method_name": "getLogger", "method_sig": "public static Logger getLogger()\n                        throws SyncFactoryException", "description": "Returns the logging object for applications to retrieve\n synchronization events posted by SyncProvider implementations."}, {"method_name": "setJNDIContext", "method_sig": "public static void setJNDIContext (Context ctx)\n                           throws SyncFactoryException", "description": "Sets the initial JNDI context from which SyncProvider implementations\n can be retrieved from a JNDI namespace\n \n  This method checks to see that there is an SQLPermission\n object  which grants the permission setSyncFactory\n before allowing the method to succeed.  If a\n SecurityManager exists and its\n checkPermission method denies calling setJNDIContext,\n this method throws a\n java.lang.SecurityException."}]}