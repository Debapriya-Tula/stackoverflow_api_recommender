{"name": "Class Configuration", "module": "java.base", "package": "javax.security.auth.login", "text": "A Configuration object is responsible for specifying which LoginModules\n should be used for a particular application, and in what order the\n LoginModules should be invoked.\n\n  A login configuration contains the following information.\n Note that this example only represents the default syntax for the\n Configuration.  Subclass implementations of this class\n may implement alternative syntaxes and may retrieve the\n Configuration from any source such as files, databases,\n or servers.\n\n \n      Name {\n            ModuleClass  Flag    ModuleOptions;\n            ModuleClass  Flag    ModuleOptions;\n            ModuleClass  Flag    ModuleOptions;\n      };\n      Name {\n            ModuleClass  Flag    ModuleOptions;\n            ModuleClass  Flag    ModuleOptions;\n      };\n      other {\n            ModuleClass  Flag    ModuleOptions;\n            ModuleClass  Flag    ModuleOptions;\n      };\n \n Each entry in the Configuration is indexed via an\n application name, Name, and contains a list of\n LoginModules configured for that application.  Each LoginModule\n is specified via its fully qualified class name.\n Authentication proceeds down the module list in the exact order specified.\n If an application does not have a specific entry,\n it defaults to the specific entry for \"other\".\n\n  The Flag value controls the overall behavior as authentication\n proceeds down the stack.  The following represents a description of the\n valid values for Flag and their respective semantics:\n\n \n      1) Required     - The LoginModule is required to succeed.\n                      If it succeeds or fails, authentication still continues\n                      to proceed down the LoginModule list.\n\n      2) Requisite    - The LoginModule is required to succeed.\n                      If it succeeds, authentication continues down the\n                      LoginModule list.  If it fails,\n                      control immediately returns to the application\n                      (authentication does not proceed down the\n                      LoginModule list).\n\n      3) Sufficient   - The LoginModule is not required to\n                      succeed.  If it does succeed, control immediately\n                      returns to the application (authentication does not\n                      proceed down the LoginModule list).\n                      If it fails, authentication continues down the\n                      LoginModule list.\n\n      4) Optional     - The LoginModule is not required to\n                      succeed.  If it succeeds or fails,\n                      authentication still continues to proceed down the\n                      LoginModule list.\n \n The overall authentication succeeds only if all Required and\n Requisite LoginModules succeed.  If a Sufficient\nLoginModule is configured and succeeds,\n then only the Required and Requisite LoginModules prior to\n that Sufficient LoginModule need to have succeeded for\n the overall authentication to succeed. If no Required or\n Requisite LoginModules are configured for an application,\n then at least one Sufficient or Optional\nLoginModule must succeed.\n\n  ModuleOptions is a space separated list of\n LoginModule-specific values which are passed directly to\n the underlying LoginModules.  Options are defined by the\n LoginModule itself, and control the behavior within it.\n For example, a LoginModule may define options to support\n debugging/testing capabilities.  The correct way to specify options in the\n Configuration is by using the following key-value pairing:\n debug=\"true\".  The key and value should be separated by an\n 'equals' symbol, and the value should be surrounded by double quotes.\n If a String in the form, ${system.property}, occurs in the value,\n it will be expanded to the value of the system property.\n Note that there is no limit to the number of\n options a LoginModule may define.\n\n  The following represents an example Configuration entry\n based on the syntax above:\n\n \n Login {\n   com.sun.security.auth.module.UnixLoginModule required;\n   com.sun.security.auth.module.Krb5LoginModule optional\n                   useTicketCache=\"true\"\n                   ticketCache=\"${user.home}${/}tickets\";\n };\n \n This Configuration specifies that an application named,\n \"Login\", requires users to first authenticate to the\n com.sun.security.auth.module.UnixLoginModule, which is\n required to succeed.  Even if the UnixLoginModule\n authentication fails, the\n com.sun.security.auth.module.Krb5LoginModule\n still gets invoked.  This helps hide the source of failure.\n Since the Krb5LoginModule is Optional, the overall\n authentication succeeds only if the UnixLoginModule\n (Required) succeeds.\n\n  Also note that the LoginModule-specific options,\n useTicketCache=\"true\" and\n ticketCache=${user.home}${/}tickets\",\n are passed to the Krb5LoginModule.\n These options instruct the Krb5LoginModule to\n use the ticket cache at the specified location.\n The system properties, user.home and /\n (file.separator), are expanded to their respective values.\n\n  There is only one Configuration object installed in the runtime at any\n given time.  A Configuration object can be installed by calling the\n setConfiguration method.  The installed Configuration object\n can be obtained by calling the getConfiguration method.\n\n  If no Configuration object has been installed in the runtime, a call to\n getConfiguration installs an instance of the default\n Configuration implementation (a default subclass implementation of this\n abstract class).\n The default Configuration implementation can be changed by setting the value\n of the login.configuration.provider security property to the fully\n qualified name of the desired Configuration subclass implementation.\n\n  Application code can directly subclass Configuration to provide a custom\n implementation.  In addition, an instance of a Configuration object can be\n constructed by invoking one of the getInstance factory methods\n with a standard type.  The default policy type is \"JavaLoginConfig\".\n See the Configuration section in the \n Java Security Standard Algorithm Names Specification\n for a list of standard Configuration types.", "codes": ["public abstract class Configuration\nextends Object"], "fields": [], "methods": [{"method_name": "getConfiguration", "method_sig": "public static Configuration getConfiguration()", "description": "Get the installed login Configuration."}, {"method_name": "setConfiguration", "method_sig": "public static void setConfiguration (Configuration configuration)", "description": "Set the login Configuration."}, {"method_name": "getInstance", "method_sig": "public static Configuration getInstance (String type,\n                                        Configuration.Parameters params)\n                                 throws NoSuchAlgorithmException", "description": "Returns a Configuration object of the specified type.\n\n  This method traverses the list of registered security providers,\n starting with the most preferred Provider.\n A new Configuration object encapsulating the\n ConfigurationSpi implementation from the first\n Provider that supports the specified type is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."}, {"method_name": "getInstance", "method_sig": "public static Configuration getInstance (String type,\n                                        Configuration.Parameters params,\n                                        String provider)\n                                 throws NoSuchProviderException,\n                                        NoSuchAlgorithmException", "description": "Returns a Configuration object of the specified type.\n\n  A new Configuration object encapsulating the\n ConfigurationSpi implementation from the specified provider\n is returned.   The specified provider must be registered\n in the provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."}, {"method_name": "getInstance", "method_sig": "public static Configuration getInstance (String type,\n                                        Configuration.Parameters params,\n                                        Provider provider)\n                                 throws NoSuchAlgorithmException", "description": "Returns a Configuration object of the specified type.\n\n  A new Configuration object encapsulating the\n ConfigurationSpi implementation from the specified Provider\n object is returned.  Note that the specified Provider object\n does not have to be registered in the provider list."}, {"method_name": "getProvider", "method_sig": "public Provider getProvider()", "description": "Return the Provider of this Configuration.\n\n  This Configuration instance will only have a Provider if it\n was obtained via a call to Configuration.getInstance.\n Otherwise this method returns null."}, {"method_name": "getType", "method_sig": "public String getType()", "description": "Return the type of this Configuration.\n\n  This Configuration instance will only have a type if it\n was obtained via a call to Configuration.getInstance.\n Otherwise this method returns null."}, {"method_name": "getParameters", "method_sig": "public Configuration.Parameters getParameters()", "description": "Return Configuration parameters.\n\n  This Configuration instance will only have parameters if it\n was obtained via a call to Configuration.getInstance.\n Otherwise this method returns null."}, {"method_name": "getAppConfigurationEntry", "method_sig": "public abstract AppConfigurationEntry[] getAppConfigurationEntry (String name)", "description": "Retrieve the AppConfigurationEntries for the specified name\n from this Configuration."}, {"method_name": "refresh", "method_sig": "public void refresh()", "description": "Refresh and reload the Configuration.\n\n  This method causes this Configuration object to refresh/reload its\n contents in an implementation-dependent manner.\n For example, if this Configuration object stores its entries in a file,\n calling refresh may cause the file to be re-read.\n\n  The default implementation of this method does nothing.\n This method should be overridden if a refresh operation is supported\n by the implementation."}]}