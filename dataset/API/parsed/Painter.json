{"name": "Interface Painter<T>", "module": "java.desktop", "package": "javax.swing", "text": "A painting delegate. The Painter interface defines exactly one method,\n paint. It is used in situations where the developer can change\n the painting routine of a component without having to resort to subclassing\n the component. It is also generically useful when doing any form of painting\n delegation.\nPainters are simply encapsulations of Java2D code and make\n it fairly trivial to reuse existing Painters or to combine\n them together. Implementations of this interface are also trivial to write,\n such that if you can't find a Painter that does what you need,\n you can write one with minimal effort. Writing a Painter requires\n knowledge of Java2D.\nA Painter may be created with a type parameter. This type will be\n expected in the paint method. For example, you may wish to write a\n Painter that only works with subclasses of Component.\n In that case, when the Painter is declared, you may declare that\n it requires a Component, allowing the paint method to be type safe. Ex:\n \n \n Painter<Component> p = new Painter<Component>() {\n     public void paint(Graphics2D g, Component c, int width, int height) {\n         g.setColor(c.getBackground());\n         //and so forth\n     }\n }\n \n \nThis interface makes no guarantees of threadsafety.", "codes": ["public interface Painter<T>"], "fields": [], "methods": [{"method_name": "paint", "method_sig": "void paint (Graphics2D g,\n           T object,\n           int width,\n           int height)", "description": "Renders to the given Graphics2D object. Implementations\n of this method may modify state on the Graphics2D, and are not\n required to restore that state upon completion. In most cases, it is recommended\n that the caller pass in a scratch graphics object. The Graphics2D\n must never be null.\nState on the graphics object may be honored by the paint method,\n but may not be. For instance, setting the antialiasing rendering hint on the\n graphics may or may not be respected by the Painter implementation.\nThe supplied object parameter acts as an optional configuration argument.\n For example, it could be of type Component. A Painter\n that expected it could then read state from that Component and\n use the state for painting. For example, an implementation may read the\n backgroundColor and use that.\nGenerally, to enhance reusability, most standard Painters ignore\n this parameter. They can thus be reused in any context. The object\n may be null. Implementations must not throw a NullPointerException if the object\n parameter is null.\nFinally, the width and height arguments specify the\n width and height that the Painter should paint into. More\n specifically, the specified width and height instruct the painter that it should\n paint fully within this width and height. Any specified clip on the\n g param will further constrain the region.\nFor example, suppose I have a Painter implementation that draws\n a gradient. The gradient goes from white to black. It \"stretches\" to fill the\n painted region. Thus, if I use this Painter to paint a 500 x 500\n region, the far left would be black, the far right would be white, and a smooth\n gradient would be painted between. I could then, without modification, reuse the\n Painter to paint a region that is 20x20 in size. This region would\n also be black on the left, white on the right, and a smooth gradient painted\n between."}]}