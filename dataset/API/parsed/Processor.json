{"name": "Interface Processor", "module": "java.compiler", "package": "javax.annotation.processing", "text": "The interface for an annotation processor.\n\n Annotation processing happens in a sequence of rounds.  On each\n round, a processor may be asked to process a\n subset of the annotations found on the source and class files\n produced by a prior round.  The inputs to the first round of\n processing are the initial inputs to a run of the tool; these\n initial inputs can be regarded as the output of a virtual zeroth\n round of processing.  If a processor was asked to process on a\n given round, it will be asked to process on subsequent rounds,\n including the last round, even if there are no annotations for it\n to process.  The tool infrastructure may also ask a processor to\n process files generated implicitly by the tool's operation.\n\n  Each implementation of a Processor must provide a\n public no-argument constructor to be used by tools to instantiate\n the processor.  The tool infrastructure will interact with classes\n implementing this interface as follows:\n\n \nIf an existing Processor object is not being used, to\n create an instance of a processor the tool calls the no-arg\n constructor of the processor class.\n\n Next, the tool calls the init method with\n an appropriate ProcessingEnvironment.\n\n Afterwards, the tool calls getSupportedAnnotationTypes, getSupportedOptions, and getSupportedSourceVersion.  These methods are only called once per\n run, not on each round.\n\n As appropriate, the tool calls the process\n method on the Processor object; a new Processor\n object is not created for each round.\n\n \n\n If a processor object is created and used without the above\n protocol being followed, then the processor's behavior is not\n defined by this interface specification.\n\n  The tool uses a discovery process to find annotation\n processors and decide whether or not they should be run.  By\n configuring the tool, the set of potential processors can be\n controlled.  For example, for a JavaCompiler the list of candidate processors to run can be\n set directly or controlled by a search path\n used for a service-style\n lookup.  Other tool implementations may have different\n configuration mechanisms, such as command line options; for\n details, refer to the particular tool's documentation.  Which\n processors the tool asks to run is a function\n of the types of the annotations present\n on the root elements, what annotation types a processor\n supports, and whether or not a processor claims the annotation types it processes.  A processor will be asked to\n process a subset of the annotation types it supports, possibly an\n empty set.\n\n For a given round, the tool computes the set of annotation types\n that are present on the elements enclosed within the root elements.\n If there is at least one annotation type present, then as\n processors claim annotation types, they are removed from the set of\n unmatched annotation types.  When the set is empty or no more\n processors are available, the round has run to completion.  If\n there are no annotation types present, annotation processing still\n occurs but only universal processors which support\n processing all annotation types, \"*\", can claim the (empty)\n set of annotation types.\n\n An annotation type is considered present if there is at least\n one annotation of that type present on an element enclosed within\n the root elements of a round. For this purpose, a type parameter is\n considered to be enclosed by its generic\n element.\n\n For this purpose, a package element is not considered to\n enclose the top-level types within that package. (A root element\n representing a package is created when a package-info file\n is processed.) Likewise, for this purpose, a module element is\n not considered to enclose the packages within that\n module. (A root element representing a module is created when a\n module-info file is processed.)\n\n Annotations on type uses, as opposed to\n annotations on elements, are ignored when computing whether or not\n an annotation type is present.\n\n An annotation is present if it meets the definition of being\n present given in AnnotatedConstruct. In brief, an\n annotation is considered present for the purposes of discovery if\n it is directly present or present via inheritance. An annotation is\n not considered present by virtue of being wrapped by a\n container annotation. Operationally, this is equivalent to an\n annotation being present on an element if and only if it would be\n included in the results of Elements.getAllAnnotationMirrors(Element) called on that element. Since\n annotations inside container annotations are not considered\n present, to properly process repeatable annotation types,\n processors are advised to include both the repeatable annotation\n type and its containing annotation type in the set of supported annotation types of a\n processor.\n\n Note that if a processor supports \"*\" and returns \n true, all annotations are claimed.  Therefore, a universal\n processor being used to, for example, implement additional validity\n checks should return false so as to not prevent other such\n checkers from being able to run.\n\n If a processor throws an uncaught exception, the tool may cease\n other active annotation processors.  If a processor raises an\n error, the current round will run to completion and the subsequent\n round will indicate an error was raised.  Since annotation processors are run in a\n cooperative environment, a processor should throw an uncaught\n exception only in situations where no error recovery or reporting\n is feasible.\n\n The tool environment is not required to support annotation\n processors that access environmental resources, either per round or cross-round, in a multi-threaded fashion.\n\n If the methods that return configuration information about the\n annotation processor return null, return other invalid\n input, or throw an exception, the tool infrastructure must treat\n this as an error condition.\n\n To be robust when running in different tool implementations, an\n annotation processor should have the following properties:\n\n \nThe result of processing a given input is not a function of the presence or absence\n of other inputs (orthogonality).\n\n Processing the same input produces the same output (consistency).\n\n Processing input A followed by processing input B\n is equivalent to processing B then A\n (commutativity)\n\n Processing an input does not rely on the presence of the output\n of other annotation processors (independence)\n\n \nThe Filer interface discusses restrictions on how\n processors can operate on files.", "codes": ["public interface Processor"], "fields": [], "methods": [{"method_name": "getSupportedOptions", "method_sig": "Set<String> getSupportedOptions()", "description": "Returns the options recognized by this processor.  An\n implementation of the processing tool must provide a way to\n pass processor-specific options distinctly from options passed\n to the tool itself, see getOptions.\n\n Each string returned in the set must be a period separated\n sequence of identifiers:\n\n \n\nSupportedOptionString:\nIdentifiers\nIdentifiers:\n Identifier\n Identifier . Identifiers\nIdentifier:\nSyntactic identifier, including keywords and literals\n \n\n A tool might use this information to determine if any\n options provided by a user are unrecognized by any processor,\n in which case it may wish to report a warning."}, {"method_name": "getSupportedAnnotationTypes", "method_sig": "Set<String> getSupportedAnnotationTypes()", "description": "Returns the names of the annotation types supported by this\n processor.  An element of the result may be the canonical\n (fully qualified) name of a supported annotation type.\n Alternately it may be of the form \"name.*\"\n representing the set of all annotation types with canonical\n names beginning with \"name.\".\n\n In either of those cases, the name of the annotation type can\n be optionally preceded by a module name followed by a \n \"/\" character. For example, if a processor supports \n \"a.B\", this can include multiple annotation types named \n a.B which reside in different modules. To only support \n a.B in the Foo module, instead use \"Foo/a.B\".\n\n If a module name is included, only an annotation in that module\n is matched. In particular, if a module name is given in an\n environment where modules are not supported, such as an\n annotation processing environment configured for a source version without modules, then the annotation types with\n a module name do not match.\n\n Finally, \"*\" by itself represents the set of all\n annotation types, including the empty set.  Note that a\n processor should not claim \"*\" unless it is actually\n processing all files; claiming unnecessary annotations may\n cause a performance slowdown in some environments.\n\n Each string returned in the set must be accepted by the\n following grammar:\n\n \n\nSupportedAnnotationTypeString:\nModulePrefixopt TypeName DotStaropt\n*\nModulePrefix:\nModuleName /\nDotStar:\n. *\n\n\n\n where TypeName and ModuleName are as defined in\n The Java\u2122 Language Specification."}, {"method_name": "getSupportedSourceVersion", "method_sig": "SourceVersion getSupportedSourceVersion()", "description": "Returns the latest source version supported by this annotation\n processor."}, {"method_name": "init", "method_sig": "void init (ProcessingEnvironment processingEnv)", "description": "Initializes the processor with the processing environment."}, {"method_name": "process", "method_sig": "boolean process (Set<? extends TypeElement> annotations,\n                RoundEnvironment roundEnv)", "description": "Processes a set of annotation types on type elements\n originating from the prior round and returns whether or not\n these annotation types are claimed by this processor.  If \n true is returned, the annotation types are claimed and subsequent\n processors will not be asked to process them; if false\n is returned, the annotation types are unclaimed and subsequent\n processors may be asked to process them.  A processor may\n always return the same boolean value or may vary the result\n based on its own chosen criteria.\n\n The input set will be empty if the processor supports \n \"*\" and the root elements have no annotations.  A \n Processor must gracefully handle an empty set of annotations."}, {"method_name": "getCompletions", "method_sig": "Iterable<? extends Completion> getCompletions (Element element,\n                                              AnnotationMirror annotation,\n                                              ExecutableElement member,\n                                              String userText)", "description": "Returns to the tool infrastructure an iterable of suggested\n completions to an annotation.  Since completions are being asked\n for, the information provided about the annotation may be\n incomplete, as if for a source code fragment. A processor may\n return an empty iterable.  Annotation processors should focus\n their efforts on providing completions for annotation members\n with additional validity constraints known to the processor, for\n example an int member whose value should lie between 1\n and 10 or a string member that should be recognized by a known\n grammar, such as a regular expression or a URL.\n\n Since incomplete programs are being modeled, some of the\n parameters may only have partial information or may be \n null.  At least one of element and userText\n must be non-null.  If element is non-null,\n annotation and member may be \n null.  Processors may not throw a NullPointerException\n if some parameters are null; if a processor has no\n completions to offer based on the provided information, an\n empty iterable can be returned.  The processor may also return\n a single completion with an empty value string and a message\n describing why there are no completions.\n\n Completions are informative and may reflect additional\n validity checks performed by annotation processors.  For\n example, consider the simple annotation:\n\n \n\n @MersennePrime {\n    int value();\n }\n \n\n\n (A Mersenne prime is prime number of the form\n 2n - 1.) Given an AnnotationMirror\n for this annotation type, a list of all such primes in the\n int range could be returned without examining any other\n arguments to getCompletions:\n\n \n\n import static javax.annotation.processing.Completions.*;\n ...\n return Arrays.asList(of(\"3\"),\n                      of(\"7\"),\n                      of(\"31\"),\n                      of(\"127\"),\n                      of(\"8191\"),\n                      of(\"131071\"),\n                      of(\"524287\"),\n                      of(\"2147483647\"));\n \n\n\n A more informative set of completions would include the number\n of each prime:\n\n \n\n return Arrays.asList(of(\"3\",          \"M2\"),\n                      of(\"7\",          \"M3\"),\n                      of(\"31\",         \"M5\"),\n                      of(\"127\",        \"M7\"),\n                      of(\"8191\",       \"M13\"),\n                      of(\"131071\",     \"M17\"),\n                      of(\"524287\",     \"M19\"),\n                      of(\"2147483647\", \"M31\"));\n \n\n\n However, if the userText is available, it can be checked\n to see if only a subset of the Mersenne primes are valid.  For\n example, if the user has typed\n\n \n\n @MersennePrime(1\n \n\n\n the value of userText will be \"1\"; and only\n two of the primes are possible completions:\n\n \n\n return Arrays.asList(of(\"127\",        \"M7\"),\n                      of(\"131071\",     \"M17\"));\n \n\n\n Sometimes no valid completion is possible.  For example, there\n is no in-range Mersenne prime starting with 9:\n\n \n\n @MersennePrime(9\n \n\n\n An appropriate response in this case is to either return an\n empty list of completions,\n\n \n\n return Collections.emptyList();\n \n\n\n or a single empty completion with a helpful message\n\n \n\n return Arrays.asList(of(\"\", \"No in-range Mersenne primes start with 9\"));\n \n"}]}