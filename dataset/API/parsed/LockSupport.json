{"name": "Class LockSupport", "module": "java.base", "package": "java.util.concurrent.locks", "text": "Basic thread blocking primitives for creating locks and other\n synchronization classes.\n\n This class associates, with each thread that uses it, a permit\n (in the sense of the Semaphore class). A call to park will return immediately\n if the permit is available, consuming it in the process; otherwise\n it may block.  A call to unpark makes the permit\n available, if it was not already available. (Unlike with Semaphores\n though, permits do not accumulate. There is at most one.)\n Reliable usage requires the use of volatile (or atomic) variables\n to control when to park or unpark.  Orderings of calls to these\n methods are maintained with respect to volatile variable accesses,\n but not necessarily non-volatile variable accesses.\n\n Methods park and unpark provide efficient\n means of blocking and unblocking threads that do not encounter the\n problems that cause the deprecated methods Thread.suspend\n and Thread.resume to be unusable for such purposes: Races\n between one thread invoking park and another thread trying\n to unpark it will preserve liveness, due to the\n permit. Additionally, park will return if the caller's\n thread was interrupted, and timeout versions are supported. The\n park method may also return at any other time, for \"no\n reason\", so in general must be invoked within a loop that rechecks\n conditions upon return. In this sense park serves as an\n optimization of a \"busy wait\" that does not waste as much time\n spinning, but must be paired with an unpark to be\n effective.\n\n The three forms of park each also support a\n blocker object parameter. This object is recorded while\n the thread is blocked to permit monitoring and diagnostic tools to\n identify the reasons that threads are blocked. (Such tools may\n access blockers using method getBlocker(Thread).)\n The use of these forms rather than the original forms without this\n parameter is strongly encouraged. The normal argument to supply as\n a blocker within a lock implementation is this.\n\n These methods are designed to be used as tools for creating\n higher-level synchronization utilities, and are not in themselves\n useful for most concurrency control applications.  The park\n method is designed for use only in constructions of the form:\n\n  \n while (!canProceed()) {\n   // ensure request to unpark is visible to other threads\n   ...\n   LockSupport.park(this);\n }\n\n where no actions by the thread publishing a request to unpark,\n prior to the call to park, entail locking or blocking.\n Because only one permit is associated with each thread, any\n intermediary uses of park, including implicitly via class\n loading, could lead to an unresponsive thread (a \"lost unpark\").\n\n Sample Usage. Here is a sketch of a first-in-first-out\n non-reentrant lock class:\n  \n class FIFOMutex {\n   private final AtomicBoolean locked = new AtomicBoolean(false);\n   private final Queue<Thread> waiters\n     = new ConcurrentLinkedQueue<>();\n\n   public void lock() {\n     boolean wasInterrupted = false;\n     // publish current thread for unparkers\n     waiters.add(Thread.currentThread());\n\n     // Block while not first in queue or cannot acquire lock\n     while (waiters.peek() != Thread.currentThread() ||\n            !locked.compareAndSet(false, true)) {\n       LockSupport.park(this);\n       // ignore interrupts while waiting\n       if (Thread.interrupted())\n         wasInterrupted = true;\n     }\n\n     waiters.remove();\n     // ensure correct interrupt status on return\n     if (wasInterrupted)\n       Thread.currentThread().interrupt();\n   }\n\n   public void unlock() {\n     locked.set(false);\n     LockSupport.unpark(waiters.peek());\n   }\n\n   static {\n     // Reduce the risk of \"lost unpark\" due to classloading\n     Class<?> ensureLoaded = LockSupport.class;\n   }\n }", "codes": ["public class LockSupport\nextends Object"], "fields": [], "methods": [{"method_name": "unpark", "method_sig": "public static void unpark (Thread thread)", "description": "Makes available the permit for the given thread, if it\n was not already available.  If the thread was blocked on\n park then it will unblock.  Otherwise, its next call\n to park is guaranteed not to block. This operation\n is not guaranteed to have any effect at all if the given\n thread has not been started."}, {"method_name": "park", "method_sig": "public static void park (Object blocker)", "description": "Disables the current thread for thread scheduling purposes unless the\n permit is available.\n\n If the permit is available then it is consumed and the call returns\n immediately; otherwise\n the current thread becomes disabled for thread scheduling\n purposes and lies dormant until one of three things happens:\n\n \nSome other thread invokes unpark with the\n current thread as the target; or\n\n Some other thread interrupts\n the current thread; or\n\n The call spuriously (that is, for no reason) returns.\n \nThis method does not report which of these caused the\n method to return. Callers should re-check the conditions which caused\n the thread to park in the first place. Callers may also determine,\n for example, the interrupt status of the thread upon return."}, {"method_name": "parkNanos", "method_sig": "public static void parkNanos (Object blocker,\n                             long nanos)", "description": "Disables the current thread for thread scheduling purposes, for up to\n the specified waiting time, unless the permit is available.\n\n If the permit is available then it is consumed and the call\n returns immediately; otherwise the current thread becomes disabled\n for thread scheduling purposes and lies dormant until one of four\n things happens:\n\n \nSome other thread invokes unpark with the\n current thread as the target; or\n\n Some other thread interrupts\n the current thread; or\n\n The specified waiting time elapses; or\n\n The call spuriously (that is, for no reason) returns.\n \nThis method does not report which of these caused the\n method to return. Callers should re-check the conditions which caused\n the thread to park in the first place. Callers may also determine,\n for example, the interrupt status of the thread, or the elapsed time\n upon return."}, {"method_name": "parkUntil", "method_sig": "public static void parkUntil (Object blocker,\n                             long deadline)", "description": "Disables the current thread for thread scheduling purposes, until\n the specified deadline, unless the permit is available.\n\n If the permit is available then it is consumed and the call\n returns immediately; otherwise the current thread becomes disabled\n for thread scheduling purposes and lies dormant until one of four\n things happens:\n\n \nSome other thread invokes unpark with the\n current thread as the target; or\n\n Some other thread interrupts the\n current thread; or\n\n The specified deadline passes; or\n\n The call spuriously (that is, for no reason) returns.\n \nThis method does not report which of these caused the\n method to return. Callers should re-check the conditions which caused\n the thread to park in the first place. Callers may also determine,\n for example, the interrupt status of the thread, or the current time\n upon return."}, {"method_name": "getBlocker", "method_sig": "public static Object getBlocker (Thread t)", "description": "Returns the blocker object supplied to the most recent\n invocation of a park method that has not yet unblocked, or null\n if not blocked.  The value returned is just a momentary\n snapshot -- the thread may have since unblocked or blocked on a\n different blocker object."}, {"method_name": "park", "method_sig": "public static void park()", "description": "Disables the current thread for thread scheduling purposes unless the\n permit is available.\n\n If the permit is available then it is consumed and the call\n returns immediately; otherwise the current thread becomes disabled\n for thread scheduling purposes and lies dormant until one of three\n things happens:\n\n \nSome other thread invokes unpark with the\n current thread as the target; or\n\n Some other thread interrupts\n the current thread; or\n\n The call spuriously (that is, for no reason) returns.\n \nThis method does not report which of these caused the\n method to return. Callers should re-check the conditions which caused\n the thread to park in the first place. Callers may also determine,\n for example, the interrupt status of the thread upon return."}, {"method_name": "parkNanos", "method_sig": "public static void parkNanos (long nanos)", "description": "Disables the current thread for thread scheduling purposes, for up to\n the specified waiting time, unless the permit is available.\n\n If the permit is available then it is consumed and the call\n returns immediately; otherwise the current thread becomes disabled\n for thread scheduling purposes and lies dormant until one of four\n things happens:\n\n \nSome other thread invokes unpark with the\n current thread as the target; or\n\n Some other thread interrupts\n the current thread; or\n\n The specified waiting time elapses; or\n\n The call spuriously (that is, for no reason) returns.\n \nThis method does not report which of these caused the\n method to return. Callers should re-check the conditions which caused\n the thread to park in the first place. Callers may also determine,\n for example, the interrupt status of the thread, or the elapsed time\n upon return."}, {"method_name": "parkUntil", "method_sig": "public static void parkUntil (long deadline)", "description": "Disables the current thread for thread scheduling purposes, until\n the specified deadline, unless the permit is available.\n\n If the permit is available then it is consumed and the call\n returns immediately; otherwise the current thread becomes disabled\n for thread scheduling purposes and lies dormant until one of four\n things happens:\n\n \nSome other thread invokes unpark with the\n current thread as the target; or\n\n Some other thread interrupts\n the current thread; or\n\n The specified deadline passes; or\n\n The call spuriously (that is, for no reason) returns.\n \nThis method does not report which of these caused the\n method to return. Callers should re-check the conditions which caused\n the thread to park in the first place. Callers may also determine,\n for example, the interrupt status of the thread, or the current time\n upon return."}]}