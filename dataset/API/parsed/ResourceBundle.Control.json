{"name": "Class ResourceBundle.Control", "module": "java.base", "package": "java.util", "text": "ResourceBundle.Control defines a set of callback methods\n that are invoked by the ResourceBundle.getBundle factory\n methods during the bundle loading process. In other words, a\n ResourceBundle.Control collaborates with the factory\n methods for loading resource bundles. The default implementation of\n the callback methods provides the information necessary for the\n factory methods to perform the default behavior.\n\n  ResourceBundle.Control is designed for an application deployed\n in an unnamed module, for example to support resource bundles in\n non-standard formats or package localized resources in a non-traditional\n convention. ResourceBundleProvider is the replacement for\n ResourceBundle.Control when migrating to modules.\n UnsupportedOperationException will be thrown when a factory\n method that takes the ResourceBundle.Control parameter is called.\n\n In addition to the callback methods, the toBundleName and toResourceName methods are defined\n primarily for convenience in implementing the callback\n methods. However, the toBundleName method could be\n overridden to provide different conventions in the organization and\n packaging of localized resources.  The toResourceName\n method is final to avoid use of wrong resource and class\n name separators.\n\n Two factory methods, getControl(List) and getNoFallbackControl(List), provide\n ResourceBundle.Control instances that implement common\n variations of the default bundle loading process.\n\n The formats returned by the getFormats method and candidate locales returned by the getCandidateLocales method must be consistent in all\n ResourceBundle.getBundle invocations for the same base\n bundle. Otherwise, the ResourceBundle.getBundle methods\n may return unintended bundles. For example, if only\n \"java.class\" is returned by the getFormats\n method for the first call to ResourceBundle.getBundle\n and only \"java.properties\" for the second call, then the\n second call will return the class-based one that has been cached\n during the first call.\n\n A ResourceBundle.Control instance must be thread-safe\n if it's simultaneously used by multiple threads.\n ResourceBundle.getBundle does not synchronize to call\n the ResourceBundle.Control methods. The default\n implementations of the methods are thread-safe.\n\n Applications can specify ResourceBundle.Control\n instances returned by the getControl factory methods or\n created from a subclass of ResourceBundle.Control to\n customize the bundle loading process. The following are examples of\n changing the default bundle loading process.\n\n Example 1\nThe following code lets ResourceBundle.getBundle look\n up only properties-based resources.\n\n \n import java.util.*;\n import static java.util.ResourceBundle.Control.*;\n ...\n ResourceBundle bundle =\n   ResourceBundle.getBundle(\"MyResources\", new Locale(\"fr\", \"CH\"),\n                            ResourceBundle.Control.getControl(FORMAT_PROPERTIES));\n \n\n Given the resource bundles in the example in\n the ResourceBundle.getBundle description, this\n ResourceBundle.getBundle call loads\n MyResources_fr_CH.properties whose parent is\n MyResources_fr.properties whose parent is\n MyResources.properties. (MyResources_fr_CH.properties\n is not hidden, but MyResources_fr_CH.class is.)\n\n Example 2\nThe following is an example of loading XML-based bundles\n using Properties.loadFromXML.\n\n \n ResourceBundle rb = ResourceBundle.getBundle(\"Messages\",\n     new ResourceBundle.Control() {\n         public List<String> getFormats(String baseName) {\n             if (baseName == null)\n                 throw new NullPointerException();\n             return Arrays.asList(\"xml\");\n         }\n         public ResourceBundle newBundle(String baseName,\n                                         Locale locale,\n                                         String format,\n                                         ClassLoader loader,\n                                         boolean reload)\n                          throws IllegalAccessException,\n                                 InstantiationException,\n                                 IOException {\n             if (baseName == null || locale == null\n                   || format == null || loader == null)\n                 throw new NullPointerException();\n             ResourceBundle bundle = null;\n             if (format.equals(\"xml\")) {\n                 String bundleName = toBundleName(baseName, locale);\n                 String resourceName = toResourceName(bundleName, format);\n                 InputStream stream = null;\n                 if (reload) {\n                     URL url = loader.getResource(resourceName);\n                     if (url != null) {\n                         URLConnection connection = url.openConnection();\n                         if (connection != null) {\n                             // Disable caches to get fresh data for\n                             // reloading.\n                             connection.setUseCaches(false);\n                             stream = connection.getInputStream();\n                         }\n                     }\n                 } else {\n                     stream = loader.getResourceAsStream(resourceName);\n                 }\n                 if (stream != null) {\n                     BufferedInputStream bis = new BufferedInputStream(stream);\n                     bundle = new XMLResourceBundle(bis);\n                     bis.close();\n                 }\n             }\n             return bundle;\n         }\n     });\n\n ...\n\n private static class XMLResourceBundle extends ResourceBundle {\n     private Properties props;\n     XMLResourceBundle(InputStream stream) throws IOException {\n         props = new Properties();\n         props.loadFromXML(stream);\n     }\n     protected Object handleGetObject(String key) {\n         return props.getProperty(key);\n     }\n     public Enumeration<String> getKeys() {\n         ...\n     }\n }\n ", "codes": ["public static class ResourceBundle.Control\nextends Object"], "fields": [{"field_name": "FORMAT_DEFAULT", "field_sig": "public static final\u00a0List<String> FORMAT_DEFAULT", "description": "The default format List, which contains the strings\n \"java.class\" and \"java.properties\", in\n this order. This List is unmodifiable."}, {"field_name": "FORMAT_CLASS", "field_sig": "public static final\u00a0List<String> FORMAT_CLASS", "description": "The class-only format List containing\n \"java.class\". This List is unmodifiable."}, {"field_name": "FORMAT_PROPERTIES", "field_sig": "public static final\u00a0List<String> FORMAT_PROPERTIES", "description": "The properties-only format List containing\n \"java.properties\". This List is unmodifiable."}, {"field_name": "TTL_DONT_CACHE", "field_sig": "public static final\u00a0long TTL_DONT_CACHE", "description": "The time-to-live constant for not caching loaded resource bundle\n instances."}, {"field_name": "TTL_NO_EXPIRATION_CONTROL", "field_sig": "public static final\u00a0long TTL_NO_EXPIRATION_CONTROL", "description": "The time-to-live constant for disabling the expiration control\n for loaded resource bundle instances in the cache."}], "methods": [{"method_name": "getControl", "method_sig": "public static final ResourceBundle.Control getControl (List<String> formats)", "description": "Returns a ResourceBundle.Control in which the getFormats method returns the specified\n formats. The formats must be equal to\n one of FORMAT_PROPERTIES, FORMAT_CLASS or FORMAT_DEFAULT. ResourceBundle.Control\n instances returned by this method are singletons and thread-safe.\n\n Specifying FORMAT_DEFAULT is equivalent to\n instantiating the ResourceBundle.Control class,\n except that this method returns a singleton."}, {"method_name": "getNoFallbackControl", "method_sig": "public static final ResourceBundle.Control getNoFallbackControl (List<String> formats)", "description": "Returns a ResourceBundle.Control in which the getFormats method returns the specified\n formats and the getFallbackLocale\n method returns null. The formats must\n be equal to one of FORMAT_PROPERTIES, FORMAT_CLASS or FORMAT_DEFAULT.\n ResourceBundle.Control instances returned by this\n method are singletons and thread-safe."}, {"method_name": "getFormats", "method_sig": "public List<String> getFormats (String baseName)", "description": "Returns a List of Strings containing\n formats to be used to load resource bundles for the given\n baseName. The ResourceBundle.getBundle\n factory method tries to load resource bundles with formats in the\n order specified by the list. The list returned by this method\n must have at least one String. The predefined\n formats are \"java.class\" for class-based resource\n bundles and \"java.properties\" for properties-based ones. Strings starting\n with \"java.\" are reserved for future extensions and\n must not be used by application-defined formats.\n\n It is not a requirement to return an immutable (unmodifiable)\n List.  However, the returned List must\n not be mutated after it has been returned by\n getFormats.\n\n The default implementation returns FORMAT_DEFAULT so\n that the ResourceBundle.getBundle factory method\n looks up first class-based resource bundles, then\n properties-based ones."}, {"method_name": "getCandidateLocales", "method_sig": "public List<Locale> getCandidateLocales (String baseName,\n                                        Locale locale)", "description": "Returns a List of Locales as candidate\n locales for baseName and locale. This\n method is called by the ResourceBundle.getBundle\n factory method each time the factory method tries finding a\n resource bundle for a target Locale.\n\n The sequence of the candidate locales also corresponds to the\n runtime resource lookup path (also known as the parent\n chain), if the corresponding resource bundles for the\n candidate locales exist and their parents are not defined by\n loaded resource bundles themselves.  The last element of the list\n must be a root locale if it is desired to\n have the base bundle as the terminal of the parent chain.\n\n If the given locale is equal to Locale.ROOT (the\n root locale), a List containing only the root\n Locale must be returned. In this case, the\n ResourceBundle.getBundle factory method loads only\n the base bundle as the resulting resource bundle.\n\n It is not a requirement to return an immutable (unmodifiable)\n List. However, the returned List must not\n be mutated after it has been returned by\n getCandidateLocales.\n\n The default implementation returns a List containing\n Locales using the rules described below.  In the\n description below, L, S, C and V\n respectively represent non-empty language, script, country, and\n variant.  For example, [L, C] represents a\n Locale that has non-empty values only for language and\n country.  The form L(\"xx\") represents the (non-empty)\n language value is \"xx\".  For all cases, Locales whose\n final component values are empty strings are omitted.\n\n For an input Locale with an empty script value,\n append candidate Locales by omitting the final component\n one by one as below:\n\n \n [L, C, V] \n [L, C] \n [L] \n Locale.ROOT \n\nFor an input Locale with a non-empty script value,\n append candidate Locales by omitting the final component\n up to language, then append candidates generated from the\n Locale with country and variant restored:\n\n \n [L, S, C, V]\n [L, S, C]\n [L, S]\n [L, C, V]\n [L, C]\n [L]\n Locale.ROOT\n\nFor an input Locale with a variant value consisting\n of multiple subtags separated by underscore, generate candidate\n Locales by omitting the variant subtags one by one, then\n insert them after every occurrence of  Locales with the\n full variant value in the original list.  For example, if\n the variant consists of two subtags V1 and V2:\n\n \n [L, S, C, V1, V2]\n [L, S, C, V1]\n [L, S, C]\n [L, S]\n [L, C, V1, V2]\n [L, C, V1]\n [L, C]\n [L]\n Locale.ROOT\n\nSpecial cases for Chinese.  When an input Locale has the\n language \"zh\" (Chinese) and an empty script value, either \"Hans\" (Simplified) or\n \"Hant\" (Traditional) might be supplied, depending on the country.\n When the country is \"CN\" (China) or \"SG\" (Singapore), \"Hans\" is supplied.\n When the country is \"HK\" (Hong Kong SAR China), \"MO\" (Macau SAR China),\n or \"TW\" (Taiwan), \"Hant\" is supplied.  For all other countries or when the country\n is empty, no script is supplied.  For example, for Locale(\"zh\", \"CN\")\n , the candidate list will be:\n \n [L(\"zh\"), S(\"Hans\"), C(\"CN\")]\n [L(\"zh\"), S(\"Hans\")]\n [L(\"zh\"), C(\"CN\")]\n [L(\"zh\")]\n Locale.ROOT\n\n\n For Locale(\"zh\", \"TW\"), the candidate list will be:\n \n [L(\"zh\"), S(\"Hant\"), C(\"TW\")]\n [L(\"zh\"), S(\"Hant\")]\n [L(\"zh\"), C(\"TW\")]\n [L(\"zh\")]\n Locale.ROOT\n\nSpecial cases for Norwegian.  Both Locale(\"no\", \"NO\",\n \"NY\") and Locale(\"nn\", \"NO\") represent Norwegian\n Nynorsk.  When a locale's language is \"nn\", the standard candidate\n list is generated up to [L(\"nn\")], and then the following\n candidates are added:\n\n  [L(\"no\"), C(\"NO\"), V(\"NY\")]\n [L(\"no\"), C(\"NO\")]\n [L(\"no\")]\n Locale.ROOT\n\n\n If the locale is exactly Locale(\"no\", \"NO\", \"NY\"), it is first\n converted to Locale(\"nn\", \"NO\") and then the above procedure is\n followed.\n\n Also, Java treats the language \"no\" as a synonym of Norwegian\n Bokm\u00e5l \"nb\".  Except for the single case Locale(\"no\",\n \"NO\", \"NY\") (handled above), when an input Locale\n has language \"no\" or \"nb\", candidate Locales with\n language code \"no\" and \"nb\" are interleaved, first using the\n requested language, then using its synonym. For example,\n Locale(\"nb\", \"NO\", \"POSIX\") generates the following\n candidate list:\n\n \n [L(\"nb\"), C(\"NO\"), V(\"POSIX\")]\n [L(\"no\"), C(\"NO\"), V(\"POSIX\")]\n [L(\"nb\"), C(\"NO\")]\n [L(\"no\"), C(\"NO\")]\n [L(\"nb\")]\n [L(\"no\")]\n Locale.ROOT\n\nLocale(\"no\", \"NO\", \"POSIX\") would generate the same list\n except that locales with \"no\" would appear before the corresponding\n locales with \"nb\".\n\nThe default implementation uses an ArrayList that\n overriding implementations may modify before returning it to the\n caller. However, a subclass must not modify it after it has\n been returned by getCandidateLocales.\n\n For example, if the given baseName is \"Messages\"\n and the given locale is\n Locale(\"ja\",\u00a0\"\",\u00a0\"XX\"), then a\n List of Locales:\n \n     Locale(\"ja\", \"\", \"XX\")\n     Locale(\"ja\")\n     Locale.ROOT\n \n is returned. And if the resource bundles for the \"ja\" and\n \"\" Locales are found, then the runtime resource\n lookup path (parent chain) is:\n \n     Messages_ja -> Messages\n "}, {"method_name": "getFallbackLocale", "method_sig": "public Locale getFallbackLocale (String baseName,\n                                Locale locale)", "description": "Returns a Locale to be used as a fallback locale for\n further resource bundle searches by the\n ResourceBundle.getBundle factory method. This method\n is called from the factory method every time when no resulting\n resource bundle has been found for baseName and\n locale, where locale is either the parameter for\n ResourceBundle.getBundle or the previous fallback\n locale returned by this method.\n\n The method returns null if no further fallback\n search is desired.\n\n The default implementation returns the default Locale if the given\n locale isn't the default one.  Otherwise,\n null is returned."}, {"method_name": "newBundle", "method_sig": "public ResourceBundle newBundle (String baseName,\n                                Locale locale,\n                                String format,\n                                ClassLoader loader,\n                                boolean reload)\n                         throws IllegalAccessException,\n                                InstantiationException,\n                                IOException", "description": "Instantiates a resource bundle for the given bundle name of the\n given format and locale, using the given class loader if\n necessary. This method returns null if there is no\n resource bundle available for the given parameters. If a resource\n bundle can't be instantiated due to an unexpected error, the\n error must be reported by throwing an Error or\n Exception rather than simply returning\n null.\n\n If the reload flag is true, it\n indicates that this method is being called because the previously\n loaded resource bundle has expired."}, {"method_name": "getTimeToLive", "method_sig": "public long getTimeToLive (String baseName,\n                          Locale locale)", "description": "Returns the time-to-live (TTL) value for resource bundles that\n are loaded under this\n ResourceBundle.Control. Positive time-to-live values\n specify the number of milliseconds a bundle can remain in the\n cache without being validated against the source data from which\n it was constructed. The value 0 indicates that a bundle must be\n validated each time it is retrieved from the cache. TTL_DONT_CACHE specifies that loaded resource bundles are not\n put in the cache. TTL_NO_EXPIRATION_CONTROL specifies\n that loaded resource bundles are put in the cache with no\n expiration control.\n\n The expiration affects only the bundle loading process by the\n ResourceBundle.getBundle factory method.  That is,\n if the factory method finds a resource bundle in the cache that\n has expired, the factory method calls the needsReload method to determine whether the resource\n bundle needs to be reloaded. If needsReload returns\n true, the cached resource bundle instance is removed\n from the cache. Otherwise, the instance stays in the cache,\n updated with the new TTL value returned by this method.\n\n All cached resource bundles are subject to removal from the\n cache due to memory constraints of the runtime environment.\n Returning a large positive value doesn't mean to lock loaded\n resource bundles in the cache.\n\n The default implementation returns TTL_NO_EXPIRATION_CONTROL."}, {"method_name": "needsReload", "method_sig": "public boolean needsReload (String baseName,\n                           Locale locale,\n                           String format,\n                           ClassLoader loader,\n                           ResourceBundle bundle,\n                           long loadTime)", "description": "Determines if the expired bundle in the cache needs\n to be reloaded based on the loading time given by\n loadTime or some other criteria. The method returns\n true if reloading is required; false\n otherwise. loadTime is a millisecond offset since\n the  Calendar\n Epoch.\n\n \n The calling ResourceBundle.getBundle factory method\n calls this method on the ResourceBundle.Control\n instance used for its current invocation, not on the instance\n used in the invocation that originally loaded the resource\n bundle.\n\n The default implementation compares loadTime and\n the last modified time of the source data of the resource\n bundle. If it's determined that the source data has been modified\n since loadTime, true is\n returned. Otherwise, false is returned. This\n implementation assumes that the given format is the\n same string as its file suffix if it's not one of the default\n formats, \"java.class\" or\n \"java.properties\"."}, {"method_name": "toBundleName", "method_sig": "public String toBundleName (String baseName,\n                           Locale locale)", "description": "Converts the given baseName and locale\n to the bundle name. This method is called from the default\n implementation of the newBundle and needsReload\n methods.\n\n This implementation returns the following value:\n \n     baseName + \"_\" + language + \"_\" + script + \"_\" + country + \"_\" + variant\n \n where language, script, country,\n and variant are the language, script, country, and variant\n values of locale, respectively. Final component values that\n are empty Strings are omitted along with the preceding '_'.  When the\n script is empty, the script value is omitted along with the preceding '_'.\n If all of the values are empty strings, then baseName\n is returned.\n\n For example, if baseName is\n \"baseName\" and locale is\n Locale(\"ja\",\u00a0\"\",\u00a0\"XX\"), then\n \"baseName_ja_\u2009_XX\" is returned. If the given\n locale is Locale(\"en\"), then\n \"baseName_en\" is returned.\n\n Overriding this method allows applications to use different\n conventions in the organization and packaging of localized\n resources."}, {"method_name": "toResourceName", "method_sig": "public final String toResourceName (String bundleName,\n                                   String suffix)", "description": "Converts the given bundleName to the form required\n by the ClassLoader.getResource\n method by replacing all occurrences of '.' in\n bundleName with '/' and appending a\n '.' and the given file suffix. For\n example, if bundleName is\n \"foo.bar.MyResources_ja_JP\" and suffix\n is \"properties\", then\n \"foo/bar/MyResources_ja_JP.properties\" is returned."}]}