{"name": "Class LineBreakMeasurer", "module": "java.desktop", "package": "java.awt.font", "text": "The LineBreakMeasurer class allows styled text to be\n broken into lines (or segments) that fit within a particular visual\n advance.  This is useful for clients who wish to display a paragraph of\n text that fits within a specific width, called the wrapping\n width.\n \nLineBreakMeasurer is constructed with an iterator over\n styled text.  The iterator's range should be a single paragraph in the\n text.\n LineBreakMeasurer maintains a position in the text for the\n start of the next text segment.  Initially, this position is the\n start of text.  Paragraphs are assigned an overall direction (either\n left-to-right or right-to-left) according to the bidirectional\n formatting rules.  All segments obtained from a paragraph have the\n same direction as the paragraph.\n \n Segments of text are obtained by calling the method\n nextLayout, which returns a TextLayout\n representing the text that fits within the wrapping width.\n The nextLayout method moves the current position\n to the end of the layout returned from nextLayout.\n \nLineBreakMeasurer implements the most commonly used\n line-breaking policy: Every word that fits within the wrapping\n width is placed on the line. If the first word does not fit, then all\n of the characters that fit within the wrapping width are placed on the\n line.  At least one character is placed on each line.\n \n The TextLayout instances returned by\n LineBreakMeasurer treat tabs like 0-width spaces.  Clients\n who wish to obtain tab-delimited segments for positioning should use\n the overload of nextLayout which takes a limiting offset\n in the text.\n The limiting offset should be the first character after the tab.\n The TextLayout objects returned from this method end\n at the limit provided (or before, if the text between the current\n position and the limit won't fit entirely within the  wrapping\n width).\n \n Clients who are laying out tab-delimited text need a slightly\n different line-breaking policy after the first segment has been\n placed on a line.  Instead of fitting partial words in the\n remaining space, they should place words which don't fit in the\n remaining space entirely on the next line.  This change of policy\n can be requested in the overload of nextLayout which\n takes a boolean parameter.  If this parameter is\n true, nextLayout returns\n null if the first word won't fit in\n the given space.  See the tab sample below.\n \n In general, if the text used to construct the\n LineBreakMeasurer changes, a new\n LineBreakMeasurer must be constructed to reflect\n the change.  (The old LineBreakMeasurer continues to\n function properly, but it won't be aware of the text change.)\n Nevertheless, if the text change is the insertion or deletion of a\n single character, an existing LineBreakMeasurer can be\n 'updated' by calling insertChar or\n deleteChar. Updating an existing\n LineBreakMeasurer is much faster than creating a new one.\n Clients who modify text based on user typing should take advantage\n of these methods.\n \nExamples:\n Rendering a paragraph in a component\n \n\n public void paint(Graphics graphics) {\n\n     float dx = 0f, dy = 5f;\n     Graphics2D g2d = (Graphics2D)graphics;\n     FontRenderContext frc = g2d.getFontRenderContext();\n\n     AttributedString text = new AttributedString(\".....\");\n     AttributedCharacterIterator paragraph = text.getIterator();\n\n     LineBreakMeasurer measurer = new LineBreakMeasurer(paragraph, frc);\n     measurer.setPosition(paragraph.getBeginIndex());\n     float wrappingWidth = (float)getSize().width;\n\n     while (measurer.getPosition() < paragraph.getEndIndex()) {\n\n         TextLayout layout = measurer.nextLayout(wrappingWidth);\n\n         dy += (layout.getAscent());\n         float dx = layout.isLeftToRight() ?\n             0 : (wrappingWidth - layout.getAdvance());\n\n         layout.draw(graphics, dx, dy);\n         dy += layout.getDescent() + layout.getLeading();\n     }\n }\n \n\n\n Rendering text with tabs.  For simplicity, the overall text\n direction is assumed to be left-to-right\n \n\n public void paint(Graphics graphics) {\n\n     float leftMargin = 10, rightMargin = 310;\n     float[] tabStops = { 100, 250 };\n\n     // assume styledText is an AttributedCharacterIterator, and the number\n     // of tabs in styledText is tabCount\n\n     int[] tabLocations = new int[tabCount+1];\n\n     int i = 0;\n     for (char c = styledText.first(); c != styledText.DONE; c = styledText.next()) {\n         if (c == '\\t') {\n             tabLocations[i++] = styledText.getIndex();\n         }\n     }\n     tabLocations[tabCount] = styledText.getEndIndex() - 1;\n\n     // Now tabLocations has an entry for every tab's offset in\n     // the text.  For convenience, the last entry is tabLocations\n     // is the offset of the last character in the text.\n\n     LineBreakMeasurer measurer = new LineBreakMeasurer(styledText);\n     int currentTab = 0;\n     float verticalPos = 20;\n\n     while (measurer.getPosition() < styledText.getEndIndex()) {\n\n         // Lay out and draw each line.  All segments on a line\n         // must be computed before any drawing can occur, since\n         // we must know the largest ascent on the line.\n         // TextLayouts are computed and stored in a Vector;\n         // their horizontal positions are stored in a parallel\n         // Vector.\n\n         // lineContainsText is true after first segment is drawn\n         boolean lineContainsText = false;\n         boolean lineComplete = false;\n         float maxAscent = 0, maxDescent = 0;\n         float horizontalPos = leftMargin;\n         Vector layouts = new Vector(1);\n         Vector penPositions = new Vector(1);\n\n         while (!lineComplete) {\n             float wrappingWidth = rightMargin - horizontalPos;\n             TextLayout layout =\n                     measurer.nextLayout(wrappingWidth,\n                                         tabLocations[currentTab]+1,\n                                         lineContainsText);\n\n             // layout can be null if lineContainsText is true\n             if (layout != null) {\n                 layouts.addElement(layout);\n                 penPositions.addElement(new Float(horizontalPos));\n                 horizontalPos += layout.getAdvance();\n                 maxAscent = Math.max(maxAscent, layout.getAscent());\n                 maxDescent = Math.max(maxDescent,\n                     layout.getDescent() + layout.getLeading());\n             } else {\n                 lineComplete = true;\n             }\n\n             lineContainsText = true;\n\n             if (measurer.getPosition() == tabLocations[currentTab]+1) {\n                 currentTab++;\n             }\n\n             if (measurer.getPosition() == styledText.getEndIndex())\n                 lineComplete = true;\n             else if (horizontalPos >= tabStops[tabStops.length-1])\n                 lineComplete = true;\n\n             if (!lineComplete) {\n                 // move to next tab stop\n                 int j;\n                 for (j=0; horizontalPos >= tabStops[j]; j++) {}\n                 horizontalPos = tabStops[j];\n             }\n         }\n\n         verticalPos += maxAscent;\n\n         Enumeration layoutEnum = layouts.elements();\n         Enumeration positionEnum = penPositions.elements();\n\n         // now iterate through layouts and draw them\n         while (layoutEnum.hasMoreElements()) {\n             TextLayout nextLayout = (TextLayout) layoutEnum.nextElement();\n             Float nextPosition = (Float) positionEnum.nextElement();\n             nextLayout.draw(graphics, nextPosition.floatValue(), verticalPos);\n         }\n\n         verticalPos += maxDescent;\n     }\n }\n \n", "codes": ["public final class LineBreakMeasurer\nextends Object"], "fields": [], "methods": [{"method_name": "nextOffset", "method_sig": "public int nextOffset (float wrappingWidth)", "description": "Returns the position at the end of the next layout.  Does NOT\n update the current position of this LineBreakMeasurer."}, {"method_name": "nextOffset", "method_sig": "public int nextOffset (float wrappingWidth,\n                      int offsetLimit,\n                      boolean requireNextWord)", "description": "Returns the position at the end of the next layout.  Does NOT\n update the current position of this LineBreakMeasurer."}, {"method_name": "nextLayout", "method_sig": "public TextLayout nextLayout (float wrappingWidth)", "description": "Returns the next layout, and updates the current position."}, {"method_name": "nextLayout", "method_sig": "public TextLayout nextLayout (float wrappingWidth,\n                             int offsetLimit,\n                             boolean requireNextWord)", "description": "Returns the next layout, and updates the current position."}, {"method_name": "getPosition", "method_sig": "public int getPosition()", "description": "Returns the current position of this LineBreakMeasurer."}, {"method_name": "setPosition", "method_sig": "public void setPosition (int newPosition)", "description": "Sets the current position of this LineBreakMeasurer."}, {"method_name": "insertChar", "method_sig": "public void insertChar (AttributedCharacterIterator newParagraph,\n                       int insertPos)", "description": "Updates this LineBreakMeasurer after a single\n character is inserted into the text, and sets the current\n position to the beginning of the paragraph."}, {"method_name": "deleteChar", "method_sig": "public void deleteChar (AttributedCharacterIterator newParagraph,\n                       int deletePos)", "description": "Updates this LineBreakMeasurer after a single\n character is deleted from the text, and sets the current\n position to the beginning of the paragraph."}]}