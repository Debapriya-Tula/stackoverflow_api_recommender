{"name": "Class Arrays", "module": "java.base", "package": "java.util", "text": "This class contains various methods for manipulating arrays (such as\n sorting and searching). This class also contains a static factory\n that allows arrays to be viewed as lists.\n\n The methods in this class all throw a NullPointerException,\n if the specified array reference is null, except where noted.\n\n The documentation for the methods contained in this class includes\n brief descriptions of the implementations. Such descriptions should\n be regarded as implementation notes, rather than parts of the\n specification. Implementors should feel free to substitute other\n algorithms, so long as the specification itself is adhered to. (For\n example, the algorithm used by sort(Object[]) does not have to be\n a MergeSort, but it does have to be stable.)\n\n This class is a member of the\n \n Java Collections Framework.", "codes": ["public class Arrays\nextends Object"], "fields": [], "methods": [{"method_name": "sort", "method_sig": "public static void sort (int[] a)", "description": "Sorts the specified array into ascending numerical order.\n\n Implementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations."}, {"method_name": "sort", "method_sig": "public static void sort (int[] a,\n                        int fromIndex,\n                        int toIndex)", "description": "Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index fromIndex, inclusive, to\n the index toIndex, exclusive. If fromIndex == toIndex,\n the range to be sorted is empty.\n\n Implementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations."}, {"method_name": "sort", "method_sig": "public static void sort (long[] a)", "description": "Sorts the specified array into ascending numerical order.\n\n Implementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations."}, {"method_name": "sort", "method_sig": "public static void sort (long[] a,\n                        int fromIndex,\n                        int toIndex)", "description": "Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index fromIndex, inclusive, to\n the index toIndex, exclusive. If fromIndex == toIndex,\n the range to be sorted is empty.\n\n Implementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations."}, {"method_name": "sort", "method_sig": "public static void sort (short[] a)", "description": "Sorts the specified array into ascending numerical order.\n\n Implementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations."}, {"method_name": "sort", "method_sig": "public static void sort (short[] a,\n                        int fromIndex,\n                        int toIndex)", "description": "Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index fromIndex, inclusive, to\n the index toIndex, exclusive. If fromIndex == toIndex,\n the range to be sorted is empty.\n\n Implementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations."}, {"method_name": "sort", "method_sig": "public static void sort (char[] a)", "description": "Sorts the specified array into ascending numerical order.\n\n Implementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations."}, {"method_name": "sort", "method_sig": "public static void sort (char[] a,\n                        int fromIndex,\n                        int toIndex)", "description": "Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index fromIndex, inclusive, to\n the index toIndex, exclusive. If fromIndex == toIndex,\n the range to be sorted is empty.\n\n Implementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations."}, {"method_name": "sort", "method_sig": "public static void sort (byte[] a)", "description": "Sorts the specified array into ascending numerical order.\n\n Implementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations."}, {"method_name": "sort", "method_sig": "public static void sort (byte[] a,\n                        int fromIndex,\n                        int toIndex)", "description": "Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index fromIndex, inclusive, to\n the index toIndex, exclusive. If fromIndex == toIndex,\n the range to be sorted is empty.\n\n Implementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations."}, {"method_name": "sort", "method_sig": "public static void sort (float[] a)", "description": "Sorts the specified array into ascending numerical order.\n\n The < relation does not provide a total order on all float\n values: -0.0f == 0.0f is true and a Float.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Float.compareTo(java.lang.Float): -0.0f is treated as less than value\n 0.0f and Float.NaN is considered greater than any\n other value and all Float.NaN values are considered equal.\n\n Implementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations."}, {"method_name": "sort", "method_sig": "public static void sort (float[] a,\n                        int fromIndex,\n                        int toIndex)", "description": "Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index fromIndex, inclusive, to\n the index toIndex, exclusive. If fromIndex == toIndex,\n the range to be sorted is empty.\n\n The < relation does not provide a total order on all float\n values: -0.0f == 0.0f is true and a Float.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Float.compareTo(java.lang.Float): -0.0f is treated as less than value\n 0.0f and Float.NaN is considered greater than any\n other value and all Float.NaN values are considered equal.\n\n Implementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations."}, {"method_name": "sort", "method_sig": "public static void sort (double[] a)", "description": "Sorts the specified array into ascending numerical order.\n\n The < relation does not provide a total order on all double\n values: -0.0d == 0.0d is true and a Double.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Double.compareTo(java.lang.Double): -0.0d is treated as less than value\n 0.0d and Double.NaN is considered greater than any\n other value and all Double.NaN values are considered equal.\n\n Implementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations."}, {"method_name": "sort", "method_sig": "public static void sort (double[] a,\n                        int fromIndex,\n                        int toIndex)", "description": "Sorts the specified range of the array into ascending order. The range\n to be sorted extends from the index fromIndex, inclusive, to\n the index toIndex, exclusive. If fromIndex == toIndex,\n the range to be sorted is empty.\n\n The < relation does not provide a total order on all double\n values: -0.0d == 0.0d is true and a Double.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Double.compareTo(java.lang.Double): -0.0d is treated as less than value\n 0.0d and Double.NaN is considered greater than any\n other value and all Double.NaN values are considered equal.\n\n Implementation note: The sorting algorithm is a Dual-Pivot Quicksort\n by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n offers O(n log(n)) performance on many data sets that cause other\n quicksorts to degrade to quadratic performance, and is typically\n faster than traditional (one-pivot) Quicksort implementations."}, {"method_name": "parallelSort", "method_sig": "public static void parallelSort (byte[] a)", "description": "Sorts the specified array into ascending numerical order."}, {"method_name": "parallelSort", "method_sig": "public static void parallelSort (byte[] a,\n                                int fromIndex,\n                                int toIndex)", "description": "Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index fromIndex,\n inclusive, to the index toIndex, exclusive. If\n fromIndex == toIndex, the range to be sorted is empty."}, {"method_name": "parallelSort", "method_sig": "public static void parallelSort (char[] a)", "description": "Sorts the specified array into ascending numerical order."}, {"method_name": "parallelSort", "method_sig": "public static void parallelSort (char[] a,\n                                int fromIndex,\n                                int toIndex)", "description": "Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index fromIndex,\n inclusive, to the index toIndex, exclusive. If\n fromIndex == toIndex, the range to be sorted is empty."}, {"method_name": "parallelSort", "method_sig": "public static void parallelSort (short[] a)", "description": "Sorts the specified array into ascending numerical order."}, {"method_name": "parallelSort", "method_sig": "public static void parallelSort (short[] a,\n                                int fromIndex,\n                                int toIndex)", "description": "Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index fromIndex,\n inclusive, to the index toIndex, exclusive. If\n fromIndex == toIndex, the range to be sorted is empty."}, {"method_name": "parallelSort", "method_sig": "public static void parallelSort (int[] a)", "description": "Sorts the specified array into ascending numerical order."}, {"method_name": "parallelSort", "method_sig": "public static void parallelSort (int[] a,\n                                int fromIndex,\n                                int toIndex)", "description": "Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index fromIndex,\n inclusive, to the index toIndex, exclusive. If\n fromIndex == toIndex, the range to be sorted is empty."}, {"method_name": "parallelSort", "method_sig": "public static void parallelSort (long[] a)", "description": "Sorts the specified array into ascending numerical order."}, {"method_name": "parallelSort", "method_sig": "public static void parallelSort (long[] a,\n                                int fromIndex,\n                                int toIndex)", "description": "Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index fromIndex,\n inclusive, to the index toIndex, exclusive. If\n fromIndex == toIndex, the range to be sorted is empty."}, {"method_name": "parallelSort", "method_sig": "public static void parallelSort (float[] a)", "description": "Sorts the specified array into ascending numerical order.\n\n The < relation does not provide a total order on all float\n values: -0.0f == 0.0f is true and a Float.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Float.compareTo(java.lang.Float): -0.0f is treated as less than value\n 0.0f and Float.NaN is considered greater than any\n other value and all Float.NaN values are considered equal."}, {"method_name": "parallelSort", "method_sig": "public static void parallelSort (float[] a,\n                                int fromIndex,\n                                int toIndex)", "description": "Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index fromIndex,\n inclusive, to the index toIndex, exclusive. If\n fromIndex == toIndex, the range to be sorted is empty.\n\n The < relation does not provide a total order on all float\n values: -0.0f == 0.0f is true and a Float.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Float.compareTo(java.lang.Float): -0.0f is treated as less than value\n 0.0f and Float.NaN is considered greater than any\n other value and all Float.NaN values are considered equal."}, {"method_name": "parallelSort", "method_sig": "public static void parallelSort (double[] a)", "description": "Sorts the specified array into ascending numerical order.\n\n The < relation does not provide a total order on all double\n values: -0.0d == 0.0d is true and a Double.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Double.compareTo(java.lang.Double): -0.0d is treated as less than value\n 0.0d and Double.NaN is considered greater than any\n other value and all Double.NaN values are considered equal."}, {"method_name": "parallelSort", "method_sig": "public static void parallelSort (double[] a,\n                                int fromIndex,\n                                int toIndex)", "description": "Sorts the specified range of the array into ascending numerical order.\n The range to be sorted extends from the index fromIndex,\n inclusive, to the index toIndex, exclusive. If\n fromIndex == toIndex, the range to be sorted is empty.\n\n The < relation does not provide a total order on all double\n values: -0.0d == 0.0d is true and a Double.NaN\n value compares neither less than, greater than, nor equal to any value,\n even itself. This method uses the total order imposed by the method\n Double.compareTo(java.lang.Double): -0.0d is treated as less than value\n 0.0d and Double.NaN is considered greater than any\n other value and all Double.NaN values are considered equal."}, {"method_name": "parallelSort", "method_sig": "public static <T extends Comparable<? super T>> void parallelSort (T[] a)", "description": "Sorts the specified array of objects into ascending order, according\n to the natural ordering of its elements.\n All elements in the array must implement the Comparable\n interface.  Furthermore, all elements in the array must be\n mutually comparable (that is, e1.compareTo(e2) must\n not throw a ClassCastException for any elements e1\n and e2 in the array).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort."}, {"method_name": "parallelSort", "method_sig": "public static <T extends Comparable<? super T>> void parallelSort (T[] a,\n                                                                  int fromIndex,\n                                                                  int toIndex)", "description": "Sorts the specified range of the specified array of objects into\n ascending order, according to the\n natural ordering of its\n elements.  The range to be sorted extends from index\n fromIndex, inclusive, to index toIndex, exclusive.\n (If fromIndex==toIndex, the range to be sorted is empty.)  All\n elements in this range must implement the Comparable\n interface.  Furthermore, all elements in this range must be mutually\n comparable (that is, e1.compareTo(e2) must not throw a\n ClassCastException for any elements e1 and\n e2 in the array).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort."}, {"method_name": "parallelSort", "method_sig": "public static <T> void parallelSort (T[] a,\n                                    Comparator<? super T> cmp)", "description": "Sorts the specified array of objects according to the order induced by\n the specified comparator.  All elements in the array must be\n mutually comparable by the specified comparator (that is,\n c.compare(e1, e2) must not throw a ClassCastException\n for any elements e1 and e2 in the array).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort."}, {"method_name": "parallelSort", "method_sig": "public static <T> void parallelSort (T[] a,\n                                    int fromIndex,\n                                    int toIndex,\n                                    Comparator<? super T> cmp)", "description": "Sorts the specified range of the specified array of objects according\n to the order induced by the specified comparator.  The range to be\n sorted extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be sorted is empty.)  All elements in the range must be\n mutually comparable by the specified comparator (that is,\n c.compare(e1, e2) must not throw a ClassCastException\n for any elements e1 and e2 in the range).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort."}, {"method_name": "sort", "method_sig": "public static void sort (Object[] a)", "description": "Sorts the specified array of objects into ascending order, according\n to the natural ordering of its elements.\n All elements in the array must implement the Comparable\n interface.  Furthermore, all elements in the array must be\n mutually comparable (that is, e1.compareTo(e2) must\n not throw a ClassCastException for any elements e1\n and e2 in the array).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort.\n\n Implementation note: This implementation is a stable, adaptive,\n iterative mergesort that requires far fewer than n lg(n) comparisons\n when the input array is partially sorted, while offering the\n performance of a traditional mergesort when the input array is\n randomly ordered.  If the input array is nearly sorted, the\n implementation requires approximately n comparisons.  Temporary\n storage requirements vary from a small constant for nearly sorted\n input arrays to n/2 object references for randomly ordered input\n arrays.\n\n The implementation takes equal advantage of ascending and\n descending order in its input array, and can take advantage of\n ascending and descending order in different parts of the same\n input array.  It is well-suited to merging two or more sorted arrays:\n simply concatenate the arrays and sort the resulting array.\n\n The implementation was adapted from Tim Peters's list sort for Python\n (\n TimSort).  It uses techniques from Peter McIlroy's \"Optimistic\n Sorting and Information Theoretic Complexity\", in Proceedings of the\n Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n January 1993."}, {"method_name": "sort", "method_sig": "public static void sort (Object[] a,\n                        int fromIndex,\n                        int toIndex)", "description": "Sorts the specified range of the specified array of objects into\n ascending order, according to the\n natural ordering of its\n elements.  The range to be sorted extends from index\n fromIndex, inclusive, to index toIndex, exclusive.\n (If fromIndex==toIndex, the range to be sorted is empty.)  All\n elements in this range must implement the Comparable\n interface.  Furthermore, all elements in this range must be mutually\n comparable (that is, e1.compareTo(e2) must not throw a\n ClassCastException for any elements e1 and\n e2 in the array).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort.\n\n Implementation note: This implementation is a stable, adaptive,\n iterative mergesort that requires far fewer than n lg(n) comparisons\n when the input array is partially sorted, while offering the\n performance of a traditional mergesort when the input array is\n randomly ordered.  If the input array is nearly sorted, the\n implementation requires approximately n comparisons.  Temporary\n storage requirements vary from a small constant for nearly sorted\n input arrays to n/2 object references for randomly ordered input\n arrays.\n\n The implementation takes equal advantage of ascending and\n descending order in its input array, and can take advantage of\n ascending and descending order in different parts of the same\n input array.  It is well-suited to merging two or more sorted arrays:\n simply concatenate the arrays and sort the resulting array.\n\n The implementation was adapted from Tim Peters's list sort for Python\n (\n TimSort).  It uses techniques from Peter McIlroy's \"Optimistic\n Sorting and Information Theoretic Complexity\", in Proceedings of the\n Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n January 1993."}, {"method_name": "sort", "method_sig": "public static <T> void sort (T[] a,\n                            Comparator<? super T> c)", "description": "Sorts the specified array of objects according to the order induced by\n the specified comparator.  All elements in the array must be\n mutually comparable by the specified comparator (that is,\n c.compare(e1, e2) must not throw a ClassCastException\n for any elements e1 and e2 in the array).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort.\n\n Implementation note: This implementation is a stable, adaptive,\n iterative mergesort that requires far fewer than n lg(n) comparisons\n when the input array is partially sorted, while offering the\n performance of a traditional mergesort when the input array is\n randomly ordered.  If the input array is nearly sorted, the\n implementation requires approximately n comparisons.  Temporary\n storage requirements vary from a small constant for nearly sorted\n input arrays to n/2 object references for randomly ordered input\n arrays.\n\n The implementation takes equal advantage of ascending and\n descending order in its input array, and can take advantage of\n ascending and descending order in different parts of the same\n input array.  It is well-suited to merging two or more sorted arrays:\n simply concatenate the arrays and sort the resulting array.\n\n The implementation was adapted from Tim Peters's list sort for Python\n (\n TimSort).  It uses techniques from Peter McIlroy's \"Optimistic\n Sorting and Information Theoretic Complexity\", in Proceedings of the\n Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n January 1993."}, {"method_name": "sort", "method_sig": "public static <T> void sort (T[] a,\n                            int fromIndex,\n                            int toIndex,\n                            Comparator<? super T> c)", "description": "Sorts the specified range of the specified array of objects according\n to the order induced by the specified comparator.  The range to be\n sorted extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be sorted is empty.)  All elements in the range must be\n mutually comparable by the specified comparator (that is,\n c.compare(e1, e2) must not throw a ClassCastException\n for any elements e1 and e2 in the range).\n\n This sort is guaranteed to be stable:  equal elements will\n not be reordered as a result of the sort.\n\n Implementation note: This implementation is a stable, adaptive,\n iterative mergesort that requires far fewer than n lg(n) comparisons\n when the input array is partially sorted, while offering the\n performance of a traditional mergesort when the input array is\n randomly ordered.  If the input array is nearly sorted, the\n implementation requires approximately n comparisons.  Temporary\n storage requirements vary from a small constant for nearly sorted\n input arrays to n/2 object references for randomly ordered input\n arrays.\n\n The implementation takes equal advantage of ascending and\n descending order in its input array, and can take advantage of\n ascending and descending order in different parts of the same\n input array.  It is well-suited to merging two or more sorted arrays:\n simply concatenate the arrays and sort the resulting array.\n\n The implementation was adapted from Tim Peters's list sort for Python\n (\n TimSort).  It uses techniques from Peter McIlroy's \"Optimistic\n Sorting and Information Theoretic Complexity\", in Proceedings of the\n Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n January 1993."}, {"method_name": "parallelPrefix", "method_sig": "public static <T> void parallelPrefix (T[] array,\n                                      BinaryOperator<T> op)", "description": "Cumulates, in parallel, each element of the given array in place,\n using the supplied function. For example if the array initially\n holds [2, 1, 0, 3] and the operation performs addition,\n then upon return the array holds [2, 3, 3, 6].\n Parallel prefix computation is usually more efficient than\n sequential loops for large arrays."}, {"method_name": "parallelPrefix", "method_sig": "public static <T> void parallelPrefix (T[] array,\n                                      int fromIndex,\n                                      int toIndex,\n                                      BinaryOperator<T> op)", "description": "Performs parallelPrefix(Object[], BinaryOperator)\n for the given subrange of the array."}, {"method_name": "parallelPrefix", "method_sig": "public static void parallelPrefix (long[] array,\n                                  LongBinaryOperator op)", "description": "Cumulates, in parallel, each element of the given array in place,\n using the supplied function. For example if the array initially\n holds [2, 1, 0, 3] and the operation performs addition,\n then upon return the array holds [2, 3, 3, 6].\n Parallel prefix computation is usually more efficient than\n sequential loops for large arrays."}, {"method_name": "parallelPrefix", "method_sig": "public static void parallelPrefix (long[] array,\n                                  int fromIndex,\n                                  int toIndex,\n                                  LongBinaryOperator op)", "description": "Performs parallelPrefix(long[], LongBinaryOperator)\n for the given subrange of the array."}, {"method_name": "parallelPrefix", "method_sig": "public static void parallelPrefix (double[] array,\n                                  DoubleBinaryOperator op)", "description": "Cumulates, in parallel, each element of the given array in place,\n using the supplied function. For example if the array initially\n holds [2.0, 1.0, 0.0, 3.0] and the operation performs addition,\n then upon return the array holds [2.0, 3.0, 3.0, 6.0].\n Parallel prefix computation is usually more efficient than\n sequential loops for large arrays.\n\n  Because floating-point operations may not be strictly associative,\n the returned result may not be identical to the value that would be\n obtained if the operation was performed sequentially."}, {"method_name": "parallelPrefix", "method_sig": "public static void parallelPrefix (double[] array,\n                                  int fromIndex,\n                                  int toIndex,\n                                  DoubleBinaryOperator op)", "description": "Performs parallelPrefix(double[], DoubleBinaryOperator)\n for the given subrange of the array."}, {"method_name": "parallelPrefix", "method_sig": "public static void parallelPrefix (int[] array,\n                                  IntBinaryOperator op)", "description": "Cumulates, in parallel, each element of the given array in place,\n using the supplied function. For example if the array initially\n holds [2, 1, 0, 3] and the operation performs addition,\n then upon return the array holds [2, 3, 3, 6].\n Parallel prefix computation is usually more efficient than\n sequential loops for large arrays."}, {"method_name": "parallelPrefix", "method_sig": "public static void parallelPrefix (int[] array,\n                                  int fromIndex,\n                                  int toIndex,\n                                  IntBinaryOperator op)", "description": "Performs parallelPrefix(int[], IntBinaryOperator)\n for the given subrange of the array."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (long[] a,\n                               long key)", "description": "Searches the specified array of longs for the specified value using the\n binary search algorithm.  The array must be sorted (as\n by the sort(long[]) method) prior to making this call.  If it\n is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (long[] a,\n                               int fromIndex,\n                               int toIndex,\n                               long key)", "description": "Searches a range of\n the specified array of longs for the specified value using the\n binary search algorithm.\n The range must be sorted (as\n by the sort(long[], int, int) method)\n prior to making this call.  If it\n is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (int[] a,\n                               int key)", "description": "Searches the specified array of ints for the specified value using the\n binary search algorithm.  The array must be sorted (as\n by the sort(int[]) method) prior to making this call.  If it\n is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (int[] a,\n                               int fromIndex,\n                               int toIndex,\n                               int key)", "description": "Searches a range of\n the specified array of ints for the specified value using the\n binary search algorithm.\n The range must be sorted (as\n by the sort(int[], int, int) method)\n prior to making this call.  If it\n is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (short[] a,\n                               short key)", "description": "Searches the specified array of shorts for the specified value using\n the binary search algorithm.  The array must be sorted\n (as by the sort(short[]) method) prior to making this call.  If\n it is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (short[] a,\n                               int fromIndex,\n                               int toIndex,\n                               short key)", "description": "Searches a range of\n the specified array of shorts for the specified value using\n the binary search algorithm.\n The range must be sorted\n (as by the sort(short[], int, int) method)\n prior to making this call.  If\n it is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (char[] a,\n                               char key)", "description": "Searches the specified array of chars for the specified value using the\n binary search algorithm.  The array must be sorted (as\n by the sort(char[]) method) prior to making this call.  If it\n is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (char[] a,\n                               int fromIndex,\n                               int toIndex,\n                               char key)", "description": "Searches a range of\n the specified array of chars for the specified value using the\n binary search algorithm.\n The range must be sorted (as\n by the sort(char[], int, int) method)\n prior to making this call.  If it\n is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (byte[] a,\n                               byte key)", "description": "Searches the specified array of bytes for the specified value using the\n binary search algorithm.  The array must be sorted (as\n by the sort(byte[]) method) prior to making this call.  If it\n is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (byte[] a,\n                               int fromIndex,\n                               int toIndex,\n                               byte key)", "description": "Searches a range of\n the specified array of bytes for the specified value using the\n binary search algorithm.\n The range must be sorted (as\n by the sort(byte[], int, int) method)\n prior to making this call.  If it\n is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (double[] a,\n                               double key)", "description": "Searches the specified array of doubles for the specified value using\n the binary search algorithm.  The array must be sorted\n (as by the sort(double[]) method) prior to making this call.\n If it is not sorted, the results are undefined.  If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.  This method considers all NaN values to be\n equivalent and equal."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (double[] a,\n                               int fromIndex,\n                               int toIndex,\n                               double key)", "description": "Searches a range of\n the specified array of doubles for the specified value using\n the binary search algorithm.\n The range must be sorted\n (as by the sort(double[], int, int) method)\n prior to making this call.\n If it is not sorted, the results are undefined.  If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found.  This method considers all NaN values to be\n equivalent and equal."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (float[] a,\n                               float key)", "description": "Searches the specified array of floats for the specified value using\n the binary search algorithm. The array must be sorted\n (as by the sort(float[]) method) prior to making this call. If\n it is not sorted, the results are undefined. If the array contains\n multiple elements with the specified value, there is no guarantee which\n one will be found. This method considers all NaN values to be\n equivalent and equal."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (float[] a,\n                               int fromIndex,\n                               int toIndex,\n                               float key)", "description": "Searches a range of\n the specified array of floats for the specified value using\n the binary search algorithm.\n The range must be sorted\n (as by the sort(float[], int, int) method)\n prior to making this call. If\n it is not sorted, the results are undefined. If the range contains\n multiple elements with the specified value, there is no guarantee which\n one will be found. This method considers all NaN values to be\n equivalent and equal."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (Object[] a,\n                               Object key)", "description": "Searches the specified array for the specified object using the binary\n search algorithm. The array must be sorted into ascending order\n according to the\n natural ordering\n of its elements (as by the\n sort(Object[]) method) prior to making this call.\n If it is not sorted, the results are undefined.\n (If the array contains elements that are not mutually comparable (for\n example, strings and integers), it cannot be sorted according\n to the natural ordering of its elements, hence results are undefined.)\n If the array contains multiple\n elements equal to the specified object, there is no guarantee which\n one will be found."}, {"method_name": "binarySearch", "method_sig": "public static int binarySearch (Object[] a,\n                               int fromIndex,\n                               int toIndex,\n                               Object key)", "description": "Searches a range of\n the specified array for the specified object using the binary\n search algorithm.\n The range must be sorted into ascending order\n according to the\n natural ordering\n of its elements (as by the\n sort(Object[], int, int) method) prior to making this\n call.  If it is not sorted, the results are undefined.\n (If the range contains elements that are not mutually comparable (for\n example, strings and integers), it cannot be sorted according\n to the natural ordering of its elements, hence results are undefined.)\n If the range contains multiple\n elements equal to the specified object, there is no guarantee which\n one will be found."}, {"method_name": "binarySearch", "method_sig": "public static <T> int binarySearch (T[] a,\n                                   T key,\n                                   Comparator<? super T> c)", "description": "Searches the specified array for the specified object using the binary\n search algorithm.  The array must be sorted into ascending order\n according to the specified comparator (as by the\n sort(T[], Comparator)\n method) prior to making this call.  If it is\n not sorted, the results are undefined.\n If the array contains multiple\n elements equal to the specified object, there is no guarantee which one\n will be found."}, {"method_name": "binarySearch", "method_sig": "public static <T> int binarySearch (T[] a,\n                                   int fromIndex,\n                                   int toIndex,\n                                   T key,\n                                   Comparator<? super T> c)", "description": "Searches a range of\n the specified array for the specified object using the binary\n search algorithm.\n The range must be sorted into ascending order\n according to the specified comparator (as by the\n sort(T[], int, int, Comparator)\n method) prior to making this call.\n If it is not sorted, the results are undefined.\n If the range contains multiple elements equal to the specified object,\n there is no guarantee which one will be found."}, {"method_name": "equals", "method_sig": "public static boolean equals (long[] a,\n                             long[] a2)", "description": "Returns true if the two specified arrays of longs are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null."}, {"method_name": "equals", "method_sig": "public static boolean equals (long[] a,\n                             int aFromIndex,\n                             int aToIndex,\n                             long[] b,\n                             int bFromIndex,\n                             int bToIndex)", "description": "Returns true if the two specified arrays of longs, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order."}, {"method_name": "equals", "method_sig": "public static boolean equals (int[] a,\n                             int[] a2)", "description": "Returns true if the two specified arrays of ints are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null."}, {"method_name": "equals", "method_sig": "public static boolean equals (int[] a,\n                             int aFromIndex,\n                             int aToIndex,\n                             int[] b,\n                             int bFromIndex,\n                             int bToIndex)", "description": "Returns true if the two specified arrays of ints, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order."}, {"method_name": "equals", "method_sig": "public static boolean equals (short[] a,\n                             short[] a2)", "description": "Returns true if the two specified arrays of shorts are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null."}, {"method_name": "equals", "method_sig": "public static boolean equals (short[] a,\n                             int aFromIndex,\n                             int aToIndex,\n                             short[] b,\n                             int bFromIndex,\n                             int bToIndex)", "description": "Returns true if the two specified arrays of shorts, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order."}, {"method_name": "equals", "method_sig": "public static boolean equals (char[] a,\n                             char[] a2)", "description": "Returns true if the two specified arrays of chars are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null."}, {"method_name": "equals", "method_sig": "public static boolean equals (char[] a,\n                             int aFromIndex,\n                             int aToIndex,\n                             char[] b,\n                             int bFromIndex,\n                             int bToIndex)", "description": "Returns true if the two specified arrays of chars, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order."}, {"method_name": "equals", "method_sig": "public static boolean equals (byte[] a,\n                             byte[] a2)", "description": "Returns true if the two specified arrays of bytes are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null."}, {"method_name": "equals", "method_sig": "public static boolean equals (byte[] a,\n                             int aFromIndex,\n                             int aToIndex,\n                             byte[] b,\n                             int bFromIndex,\n                             int bToIndex)", "description": "Returns true if the two specified arrays of bytes, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order."}, {"method_name": "equals", "method_sig": "public static boolean equals (boolean[] a,\n                             boolean[] a2)", "description": "Returns true if the two specified arrays of booleans are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null."}, {"method_name": "equals", "method_sig": "public static boolean equals (boolean[] a,\n                             int aFromIndex,\n                             int aToIndex,\n                             boolean[] b,\n                             int bFromIndex,\n                             int bToIndex)", "description": "Returns true if the two specified arrays of booleans, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order."}, {"method_name": "equals", "method_sig": "public static boolean equals (double[] a,\n                             double[] a2)", "description": "Returns true if the two specified arrays of doubles are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null.\n\n Two doubles d1 and d2 are considered equal if:\n     new Double(d1).equals(new Double(d2))\n (Unlike the == operator, this method considers\n NaN equals to itself, and 0.0d unequal to -0.0d.)"}, {"method_name": "equals", "method_sig": "public static boolean equals (double[] a,\n                             int aFromIndex,\n                             int aToIndex,\n                             double[] b,\n                             int bFromIndex,\n                             int bToIndex)", "description": "Returns true if the two specified arrays of doubles, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order.\n\n Two doubles d1 and d2 are considered equal if:\n     new Double(d1).equals(new Double(d2))\n (Unlike the == operator, this method considers\n NaN equals to itself, and 0.0d unequal to -0.0d.)"}, {"method_name": "equals", "method_sig": "public static boolean equals (float[] a,\n                             float[] a2)", "description": "Returns true if the two specified arrays of floats are\n equal to one another.  Two arrays are considered equal if both\n arrays contain the same number of elements, and all corresponding pairs\n of elements in the two arrays are equal.  In other words, two arrays\n are equal if they contain the same elements in the same order.  Also,\n two array references are considered equal if both are null.\n\n Two floats f1 and f2 are considered equal if:\n     new Float(f1).equals(new Float(f2))\n (Unlike the == operator, this method considers\n NaN equals to itself, and 0.0f unequal to -0.0f.)"}, {"method_name": "equals", "method_sig": "public static boolean equals (float[] a,\n                             int aFromIndex,\n                             int aToIndex,\n                             float[] b,\n                             int bFromIndex,\n                             int bToIndex)", "description": "Returns true if the two specified arrays of floats, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order.\n\n Two floats f1 and f2 are considered equal if:\n     new Float(f1).equals(new Float(f2))\n (Unlike the == operator, this method considers\n NaN equals to itself, and 0.0f unequal to -0.0f.)"}, {"method_name": "equals", "method_sig": "public static boolean equals (Object[] a,\n                             Object[] a2)", "description": "Returns true if the two specified arrays of Objects are\n equal to one another.  The two arrays are considered equal if\n both arrays contain the same number of elements, and all corresponding\n pairs of elements in the two arrays are equal.  Two objects e1\n and e2 are considered equal if\n Objects.equals(e1, e2).\n In other words, the two arrays are equal if\n they contain the same elements in the same order.  Also, two array\n references are considered equal if both are null."}, {"method_name": "equals", "method_sig": "public static boolean equals (Object[] a,\n                             int aFromIndex,\n                             int aToIndex,\n                             Object[] b,\n                             int bFromIndex,\n                             int bToIndex)", "description": "Returns true if the two specified arrays of Objects, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order.\n\n Two objects e1 and e2 are considered equal if\n Objects.equals(e1, e2)."}, {"method_name": "equals", "method_sig": "public static <T> boolean equals (T[] a,\n                                 T[] a2,\n                                 Comparator<? super T> cmp)", "description": "Returns true if the two specified arrays of Objects are\n equal to one another.\n\n Two arrays are considered equal if both arrays contain the same number\n of elements, and all corresponding pairs of elements in the two arrays\n are equal.  In other words, the two arrays are equal if they contain the\n same elements in the same order.  Also, two array references are\n considered equal if both are null.\n\n Two objects e1 and e2 are considered equal if,\n given the specified comparator, cmp.compare(e1, e2) == 0."}, {"method_name": "equals", "method_sig": "public static <T> boolean equals (T[] a,\n                                 int aFromIndex,\n                                 int aToIndex,\n                                 T[] b,\n                                 int bFromIndex,\n                                 int bToIndex,\n                                 Comparator<? super T> cmp)", "description": "Returns true if the two specified arrays of Objects, over the specified\n ranges, are equal to one another.\n\n Two arrays are considered equal if the number of elements covered by\n each range is the same, and all corresponding pairs of elements over the\n specified ranges in the two arrays are equal.  In other words, two arrays\n are equal if they contain, over the specified ranges, the same elements\n in the same order.\n\n Two objects e1 and e2 are considered equal if,\n given the specified comparator, cmp.compare(e1, e2) == 0."}, {"method_name": "fill", "method_sig": "public static void fill (long[] a,\n                        long val)", "description": "Assigns the specified long value to each element of the specified array\n of longs."}, {"method_name": "fill", "method_sig": "public static void fill (long[] a,\n                        int fromIndex,\n                        int toIndex,\n                        long val)", "description": "Assigns the specified long value to each element of the specified\n range of the specified array of longs.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"}, {"method_name": "fill", "method_sig": "public static void fill (int[] a,\n                        int val)", "description": "Assigns the specified int value to each element of the specified array\n of ints."}, {"method_name": "fill", "method_sig": "public static void fill (int[] a,\n                        int fromIndex,\n                        int toIndex,\n                        int val)", "description": "Assigns the specified int value to each element of the specified\n range of the specified array of ints.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"}, {"method_name": "fill", "method_sig": "public static void fill (short[] a,\n                        short val)", "description": "Assigns the specified short value to each element of the specified array\n of shorts."}, {"method_name": "fill", "method_sig": "public static void fill (short[] a,\n                        int fromIndex,\n                        int toIndex,\n                        short val)", "description": "Assigns the specified short value to each element of the specified\n range of the specified array of shorts.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"}, {"method_name": "fill", "method_sig": "public static void fill (char[] a,\n                        char val)", "description": "Assigns the specified char value to each element of the specified array\n of chars."}, {"method_name": "fill", "method_sig": "public static void fill (char[] a,\n                        int fromIndex,\n                        int toIndex,\n                        char val)", "description": "Assigns the specified char value to each element of the specified\n range of the specified array of chars.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"}, {"method_name": "fill", "method_sig": "public static void fill (byte[] a,\n                        byte val)", "description": "Assigns the specified byte value to each element of the specified array\n of bytes."}, {"method_name": "fill", "method_sig": "public static void fill (byte[] a,\n                        int fromIndex,\n                        int toIndex,\n                        byte val)", "description": "Assigns the specified byte value to each element of the specified\n range of the specified array of bytes.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"}, {"method_name": "fill", "method_sig": "public static void fill (boolean[] a,\n                        boolean val)", "description": "Assigns the specified boolean value to each element of the specified\n array of booleans."}, {"method_name": "fill", "method_sig": "public static void fill (boolean[] a,\n                        int fromIndex,\n                        int toIndex,\n                        boolean val)", "description": "Assigns the specified boolean value to each element of the specified\n range of the specified array of booleans.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"}, {"method_name": "fill", "method_sig": "public static void fill (double[] a,\n                        double val)", "description": "Assigns the specified double value to each element of the specified\n array of doubles."}, {"method_name": "fill", "method_sig": "public static void fill (double[] a,\n                        int fromIndex,\n                        int toIndex,\n                        double val)", "description": "Assigns the specified double value to each element of the specified\n range of the specified array of doubles.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"}, {"method_name": "fill", "method_sig": "public static void fill (float[] a,\n                        float val)", "description": "Assigns the specified float value to each element of the specified array\n of floats."}, {"method_name": "fill", "method_sig": "public static void fill (float[] a,\n                        int fromIndex,\n                        int toIndex,\n                        float val)", "description": "Assigns the specified float value to each element of the specified\n range of the specified array of floats.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"}, {"method_name": "fill", "method_sig": "public static void fill (Object[] a,\n                        Object val)", "description": "Assigns the specified Object reference to each element of the specified\n array of Objects."}, {"method_name": "fill", "method_sig": "public static void fill (Object[] a,\n                        int fromIndex,\n                        int toIndex,\n                        Object val)", "description": "Assigns the specified Object reference to each element of the specified\n range of the specified array of Objects.  The range to be filled\n extends from index fromIndex, inclusive, to index\n toIndex, exclusive.  (If fromIndex==toIndex, the\n range to be filled is empty.)"}, {"method_name": "copyOf", "method_sig": "public static <T> T[] copyOf (T[] original,\n                             int newLength)", "description": "Copies the specified array, truncating or padding with nulls (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain null.\n Such indices will exist if and only if the specified length\n is greater than that of the original array.\n The resulting array is of exactly the same class as the original array."}, {"method_name": "copyOf", "method_sig": "public static <T, U> T[] copyOf (U[] original,\n                                     int newLength,\n                                     Class<? extends T[]> newType)", "description": "Copies the specified array, truncating or padding with nulls (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain null.\n Such indices will exist if and only if the specified length\n is greater than that of the original array.\n The resulting array is of the class newType."}, {"method_name": "copyOf", "method_sig": "public static byte[] copyOf (byte[] original,\n                            int newLength)", "description": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain (byte)0.\n Such indices will exist if and only if the specified length\n is greater than that of the original array."}, {"method_name": "copyOf", "method_sig": "public static short[] copyOf (short[] original,\n                             int newLength)", "description": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain (short)0.\n Such indices will exist if and only if the specified length\n is greater than that of the original array."}, {"method_name": "copyOf", "method_sig": "public static int[] copyOf (int[] original,\n                           int newLength)", "description": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain 0.\n Such indices will exist if and only if the specified length\n is greater than that of the original array."}, {"method_name": "copyOf", "method_sig": "public static long[] copyOf (long[] original,\n                            int newLength)", "description": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain 0L.\n Such indices will exist if and only if the specified length\n is greater than that of the original array."}, {"method_name": "copyOf", "method_sig": "public static char[] copyOf (char[] original,\n                            int newLength)", "description": "Copies the specified array, truncating or padding with null characters (if necessary)\n so the copy has the specified length.  For all indices that are valid\n in both the original array and the copy, the two arrays will contain\n identical values.  For any indices that are valid in the copy but not\n the original, the copy will contain '\\\\u000'.  Such indices\n will exist if and only if the specified length is greater than that of\n the original array."}, {"method_name": "copyOf", "method_sig": "public static float[] copyOf (float[] original,\n                             int newLength)", "description": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain 0f.\n Such indices will exist if and only if the specified length\n is greater than that of the original array."}, {"method_name": "copyOf", "method_sig": "public static double[] copyOf (double[] original,\n                              int newLength)", "description": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain 0d.\n Such indices will exist if and only if the specified length\n is greater than that of the original array."}, {"method_name": "copyOf", "method_sig": "public static boolean[] copyOf (boolean[] original,\n                               int newLength)", "description": "Copies the specified array, truncating or padding with false (if necessary)\n so the copy has the specified length.  For all indices that are\n valid in both the original array and the copy, the two arrays will\n contain identical values.  For any indices that are valid in the\n copy but not the original, the copy will contain false.\n Such indices will exist if and only if the specified length\n is greater than that of the original array."}, {"method_name": "copyOfRange", "method_sig": "public static <T> T[] copyOfRange (T[] original,\n                                  int from,\n                                  int to)", "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n null is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from.\n \n The resulting array is of exactly the same class as the original array."}, {"method_name": "copyOfRange", "method_sig": "public static <T, U> T[] copyOfRange (U[] original,\n                                          int from,\n                                          int to,\n                                          Class<? extends T[]> newType)", "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n null is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from.\n The resulting array is of the class newType."}, {"method_name": "copyOfRange", "method_sig": "public static byte[] copyOfRange (byte[] original,\n                                 int from,\n                                 int to)", "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n (byte)0 is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."}, {"method_name": "copyOfRange", "method_sig": "public static short[] copyOfRange (short[] original,\n                                  int from,\n                                  int to)", "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n (short)0 is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."}, {"method_name": "copyOfRange", "method_sig": "public static int[] copyOfRange (int[] original,\n                                int from,\n                                int to)", "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n 0 is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."}, {"method_name": "copyOfRange", "method_sig": "public static long[] copyOfRange (long[] original,\n                                 int from,\n                                 int to)", "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n 0L is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."}, {"method_name": "copyOfRange", "method_sig": "public static char[] copyOfRange (char[] original,\n                                 int from,\n                                 int to)", "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n '\\\\u000' is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."}, {"method_name": "copyOfRange", "method_sig": "public static float[] copyOfRange (float[] original,\n                                  int from,\n                                  int to)", "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n 0f is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."}, {"method_name": "copyOfRange", "method_sig": "public static double[] copyOfRange (double[] original,\n                                   int from,\n                                   int to)", "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n 0d is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."}, {"method_name": "copyOfRange", "method_sig": "public static boolean[] copyOfRange (boolean[] original,\n                                    int from,\n                                    int to)", "description": "Copies the specified range of the specified array into a new array.\n The initial index of the range (from) must lie between zero\n and original.length, inclusive.  The value at\n original[from] is placed into the initial element of the copy\n (unless from == original.length or from == to).\n Values from subsequent elements in the original array are placed into\n subsequent elements in the copy.  The final index of the range\n (to), which must be greater than or equal to from,\n may be greater than original.length, in which case\n false is placed in all elements of the copy whose index is\n greater than or equal to original.length - from.  The length\n of the returned array will be to - from."}, {"method_name": "asList", "method_sig": "@SafeVarargs\npublic static <T> List<T> asList (T... a)", "description": "Returns a fixed-size list backed by the specified array.  (Changes to\n the returned list \"write through\" to the array.)  This method acts\n as bridge between array-based and collection-based APIs, in\n combination with Collection.toArray().  The returned list is\n serializable and implements RandomAccess.\n\n This method also provides a convenient way to create a fixed-size\n list initialized to contain several elements:\n \n     List<String> stooges = Arrays.asList(\"Larry\", \"Moe\", \"Curly\");\n "}, {"method_name": "hashCode", "method_sig": "public static int hashCode (long[] a)", "description": "Returns a hash code based on the contents of the specified array.\n For any two long arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Long\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."}, {"method_name": "hashCode", "method_sig": "public static int hashCode (int[] a)", "description": "Returns a hash code based on the contents of the specified array.\n For any two non-null int arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Integer\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."}, {"method_name": "hashCode", "method_sig": "public static int hashCode (short[] a)", "description": "Returns a hash code based on the contents of the specified array.\n For any two short arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Short\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."}, {"method_name": "hashCode", "method_sig": "public static int hashCode (char[] a)", "description": "Returns a hash code based on the contents of the specified array.\n For any two char arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Character\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."}, {"method_name": "hashCode", "method_sig": "public static int hashCode (byte[] a)", "description": "Returns a hash code based on the contents of the specified array.\n For any two byte arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Byte\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."}, {"method_name": "hashCode", "method_sig": "public static int hashCode (boolean[] a)", "description": "Returns a hash code based on the contents of the specified array.\n For any two boolean arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Boolean\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."}, {"method_name": "hashCode", "method_sig": "public static int hashCode (float[] a)", "description": "Returns a hash code based on the contents of the specified array.\n For any two float arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Float\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."}, {"method_name": "hashCode", "method_sig": "public static int hashCode (double[] a)", "description": "Returns a hash code based on the contents of the specified array.\n For any two double arrays a and b\n such that Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is the same value that would be\n obtained by invoking the hashCode\n method on a List containing a sequence of Double\n instances representing the elements of a in the same order.\n If a is null, this method returns 0."}, {"method_name": "hashCode", "method_sig": "public static int hashCode (Object[] a)", "description": "Returns a hash code based on the contents of the specified array.  If\n the array contains other arrays as elements, the hash code is based on\n their identities rather than their contents.  It is therefore\n acceptable to invoke this method on an array that contains itself as an\n element,  either directly or indirectly through one or more levels of\n arrays.\n\n For any two arrays a and b such that\n Arrays.equals(a, b), it is also the case that\n Arrays.hashCode(a) == Arrays.hashCode(b).\n\n The value returned by this method is equal to the value that would\n be returned by Arrays.asList(a).hashCode(), unless a\n is null, in which case 0 is returned."}, {"method_name": "deepHashCode", "method_sig": "public static int deepHashCode (Object[] a)", "description": "Returns a hash code based on the \"deep contents\" of the specified\n array.  If the array contains other arrays as elements, the\n hash code is based on their contents and so on, ad infinitum.\n It is therefore unacceptable to invoke this method on an array that\n contains itself as an element, either directly or indirectly through\n one or more levels of arrays.  The behavior of such an invocation is\n undefined.\n\n For any two arrays a and b such that\n Arrays.deepEquals(a, b), it is also the case that\n Arrays.deepHashCode(a) == Arrays.deepHashCode(b).\n\n The computation of the value returned by this method is similar to\n that of the value returned by List.hashCode() on a list\n containing the same elements as a in the same order, with one\n difference: If an element e of a is itself an array,\n its hash code is computed not by calling e.hashCode(), but as\n by calling the appropriate overloading of Arrays.hashCode(e)\n if e is an array of a primitive type, or as by calling\n Arrays.deepHashCode(e) recursively if e is an array\n of a reference type.  If a is null, this method\n returns 0."}, {"method_name": "deepEquals", "method_sig": "public static boolean deepEquals (Object[] a1,\n                                 Object[] a2)", "description": "Returns true if the two specified arrays are deeply\n equal to one another.  Unlike the equals(Object[],Object[])\n method, this method is appropriate for use with nested arrays of\n arbitrary depth.\n\n Two array references are considered deeply equal if both\n are null, or if they refer to arrays that contain the same\n number of elements and all corresponding pairs of elements in the two\n arrays are deeply equal.\n\n Two possibly null elements e1 and e2 are\n deeply equal if any of the following conditions hold:\n \n e1 and e2 are both arrays of object reference\n         types, and Arrays.deepEquals(e1, e2) would return true\n e1 and e2 are arrays of the same primitive\n         type, and the appropriate overloading of\n         Arrays.equals(e1, e2) would return true.\n     e1 == e2\n e1.equals(e2) would return true.\n \n Note that this definition permits null elements at any depth.\n\n If either of the specified arrays contain themselves as elements\n either directly or indirectly through one or more levels of arrays,\n the behavior of this method is undefined."}, {"method_name": "toString", "method_sig": "public static String toString (long[] a)", "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements are\n separated by the characters \", \" (a comma followed by a\n space).  Elements are converted to strings as by\n String.valueOf(long).  Returns \"null\" if a\n is null."}, {"method_name": "toString", "method_sig": "public static String toString (int[] a)", "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements are\n separated by the characters \", \" (a comma followed by a\n space).  Elements are converted to strings as by\n String.valueOf(int).  Returns \"null\" if a is\n null."}, {"method_name": "toString", "method_sig": "public static String toString (short[] a)", "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements are\n separated by the characters \", \" (a comma followed by a\n space).  Elements are converted to strings as by\n String.valueOf(short).  Returns \"null\" if a\n is null."}, {"method_name": "toString", "method_sig": "public static String toString (char[] a)", "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements are\n separated by the characters \", \" (a comma followed by a\n space).  Elements are converted to strings as by\n String.valueOf(char).  Returns \"null\" if a\n is null."}, {"method_name": "toString", "method_sig": "public static String toString (byte[] a)", "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements\n are separated by the characters \", \" (a comma followed\n by a space).  Elements are converted to strings as by\n String.valueOf(byte).  Returns \"null\" if\n a is null."}, {"method_name": "toString", "method_sig": "public static String toString (boolean[] a)", "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements are\n separated by the characters \", \" (a comma followed by a\n space).  Elements are converted to strings as by\n String.valueOf(boolean).  Returns \"null\" if\n a is null."}, {"method_name": "toString", "method_sig": "public static String toString (float[] a)", "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements are\n separated by the characters \", \" (a comma followed by a\n space).  Elements are converted to strings as by\n String.valueOf(float).  Returns \"null\" if a\n is null."}, {"method_name": "toString", "method_sig": "public static String toString (double[] a)", "description": "Returns a string representation of the contents of the specified array.\n The string representation consists of a list of the array's elements,\n enclosed in square brackets (\"[]\").  Adjacent elements are\n separated by the characters \", \" (a comma followed by a\n space).  Elements are converted to strings as by\n String.valueOf(double).  Returns \"null\" if a\n is null."}, {"method_name": "toString", "method_sig": "public static String toString (Object[] a)", "description": "Returns a string representation of the contents of the specified array.\n If the array contains other arrays as elements, they are converted to\n strings by the Object.toString() method inherited from\n Object, which describes their identities rather than\n their contents.\n\n The value returned by this method is equal to the value that would\n be returned by Arrays.asList(a).toString(), unless a\n is null, in which case \"null\" is returned."}, {"method_name": "deepToString", "method_sig": "public static String deepToString (Object[] a)", "description": "Returns a string representation of the \"deep contents\" of the specified\n array.  If the array contains other arrays as elements, the string\n representation contains their contents and so on.  This method is\n designed for converting multidimensional arrays to strings.\n\n The string representation consists of a list of the array's\n elements, enclosed in square brackets (\"[]\").  Adjacent\n elements are separated by the characters \", \" (a comma\n followed by a space).  Elements are converted to strings as by\n String.valueOf(Object), unless they are themselves\n arrays.\n\n If an element e is an array of a primitive type, it is\n converted to a string as by invoking the appropriate overloading of\n Arrays.toString(e).  If an element e is an array of a\n reference type, it is converted to a string as by invoking\n this method recursively.\n\n To avoid infinite recursion, if the specified array contains itself\n as an element, or contains an indirect reference to itself through one\n or more levels of arrays, the self-reference is converted to the string\n \"[...]\".  For example, an array containing only a reference\n to itself would be rendered as \"[[...]]\".\n\n This method returns \"null\" if the specified array\n is null."}, {"method_name": "setAll", "method_sig": "public static <T> void setAll (T[] array,\n                              IntFunction<? extends T> generator)", "description": "Set all elements of the specified array, using the provided\n generator function to compute each element.\n\n If the generator function throws an exception, it is relayed to\n the caller and the array is left in an indeterminate state."}, {"method_name": "parallelSetAll", "method_sig": "public static <T> void parallelSetAll (T[] array,\n                                      IntFunction<? extends T> generator)", "description": "Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.\n\n If the generator function throws an exception, an unchecked exception\n is thrown from parallelSetAll and the array is left in an\n indeterminate state."}, {"method_name": "setAll", "method_sig": "public static void setAll (int[] array,\n                          IntUnaryOperator generator)", "description": "Set all elements of the specified array, using the provided\n generator function to compute each element.\n\n If the generator function throws an exception, it is relayed to\n the caller and the array is left in an indeterminate state."}, {"method_name": "parallelSetAll", "method_sig": "public static void parallelSetAll (int[] array,\n                                  IntUnaryOperator generator)", "description": "Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.\n\n If the generator function throws an exception, an unchecked exception\n is thrown from parallelSetAll and the array is left in an\n indeterminate state."}, {"method_name": "setAll", "method_sig": "public static void setAll (long[] array,\n                          IntToLongFunction generator)", "description": "Set all elements of the specified array, using the provided\n generator function to compute each element.\n\n If the generator function throws an exception, it is relayed to\n the caller and the array is left in an indeterminate state."}, {"method_name": "parallelSetAll", "method_sig": "public static void parallelSetAll (long[] array,\n                                  IntToLongFunction generator)", "description": "Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.\n\n If the generator function throws an exception, an unchecked exception\n is thrown from parallelSetAll and the array is left in an\n indeterminate state."}, {"method_name": "setAll", "method_sig": "public static void setAll (double[] array,\n                          IntToDoubleFunction generator)", "description": "Set all elements of the specified array, using the provided\n generator function to compute each element.\n\n If the generator function throws an exception, it is relayed to\n the caller and the array is left in an indeterminate state."}, {"method_name": "parallelSetAll", "method_sig": "public static void parallelSetAll (double[] array,\n                                  IntToDoubleFunction generator)", "description": "Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.\n\n If the generator function throws an exception, an unchecked exception\n is thrown from parallelSetAll and the array is left in an\n indeterminate state."}, {"method_name": "spliterator", "method_sig": "public static <T> Spliterator<T> spliterator (T[] array)", "description": "Returns a Spliterator covering all of the specified array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."}, {"method_name": "spliterator", "method_sig": "public static <T> Spliterator<T> spliterator (T[] array,\n                                             int startInclusive,\n                                             int endExclusive)", "description": "Returns a Spliterator covering the specified range of the\n specified array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."}, {"method_name": "spliterator", "method_sig": "public static Spliterator.OfInt spliterator (int[] array)", "description": "Returns a Spliterator.OfInt covering all of the specified array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."}, {"method_name": "spliterator", "method_sig": "public static Spliterator.OfInt spliterator (int[] array,\n                                            int startInclusive,\n                                            int endExclusive)", "description": "Returns a Spliterator.OfInt covering the specified range of the\n specified array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."}, {"method_name": "spliterator", "method_sig": "public static Spliterator.OfLong spliterator (long[] array)", "description": "Returns a Spliterator.OfLong covering all of the specified array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."}, {"method_name": "spliterator", "method_sig": "public static Spliterator.OfLong spliterator (long[] array,\n                                             int startInclusive,\n                                             int endExclusive)", "description": "Returns a Spliterator.OfLong covering the specified range of the\n specified array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."}, {"method_name": "spliterator", "method_sig": "public static Spliterator.OfDouble spliterator (double[] array)", "description": "Returns a Spliterator.OfDouble covering all of the specified\n array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."}, {"method_name": "spliterator", "method_sig": "public static Spliterator.OfDouble spliterator (double[] array,\n                                               int startInclusive,\n                                               int endExclusive)", "description": "Returns a Spliterator.OfDouble covering the specified range of\n the specified array.\n\n The spliterator reports Spliterator.SIZED,\n Spliterator.SUBSIZED, Spliterator.ORDERED, and\n Spliterator.IMMUTABLE."}, {"method_name": "stream", "method_sig": "public static <T> Stream<T> stream (T[] array)", "description": "Returns a sequential Stream with the specified array as its\n source."}, {"method_name": "stream", "method_sig": "public static <T> Stream<T> stream (T[] array,\n                                   int startInclusive,\n                                   int endExclusive)", "description": "Returns a sequential Stream with the specified range of the\n specified array as its source."}, {"method_name": "stream", "method_sig": "public static IntStream stream (int[] array)", "description": "Returns a sequential IntStream with the specified array as its\n source."}, {"method_name": "stream", "method_sig": "public static IntStream stream (int[] array,\n                               int startInclusive,\n                               int endExclusive)", "description": "Returns a sequential IntStream with the specified range of the\n specified array as its source."}, {"method_name": "stream", "method_sig": "public static LongStream stream (long[] array)", "description": "Returns a sequential LongStream with the specified array as its\n source."}, {"method_name": "stream", "method_sig": "public static LongStream stream (long[] array,\n                                int startInclusive,\n                                int endExclusive)", "description": "Returns a sequential LongStream with the specified range of the\n specified array as its source."}, {"method_name": "stream", "method_sig": "public static DoubleStream stream (double[] array)", "description": "Returns a sequential DoubleStream with the specified array as its\n source."}, {"method_name": "stream", "method_sig": "public static DoubleStream stream (double[] array,\n                                  int startInclusive,\n                                  int endExclusive)", "description": "Returns a sequential DoubleStream with the specified range of the\n specified array as its source."}, {"method_name": "compare", "method_sig": "public static int compare (boolean[] a,\n                          boolean[] b)", "description": "Compares two boolean arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Boolean.compare(boolean, boolean), at an index within the\n respective arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(boolean[], boolean[]) for the definition of a\n common and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n "}, {"method_name": "compare", "method_sig": "public static int compare (boolean[] a,\n                          int aFromIndex,\n                          int aToIndex,\n                          boolean[] b,\n                          int bFromIndex,\n                          int bToIndex)", "description": "Compares two boolean arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Boolean.compare(boolean, boolean), at a\n relative index within the respective arrays that is the length of the\n prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(boolean[], int, int, boolean[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n "}, {"method_name": "compare", "method_sig": "public static int compare (byte[] a,\n                          byte[] b)", "description": "Compares two byte arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Byte.compare(byte, byte), at an index within the respective\n arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(byte[], byte[]) for the definition of a common and\n proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n "}, {"method_name": "compare", "method_sig": "public static int compare (byte[] a,\n                          int aFromIndex,\n                          int aToIndex,\n                          byte[] b,\n                          int bFromIndex,\n                          int bToIndex)", "description": "Compares two byte arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Byte.compare(byte, byte), at a relative index\n within the respective arrays that is the length of the prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(byte[], int, int, byte[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n "}, {"method_name": "compareUnsigned", "method_sig": "public static int compareUnsigned (byte[] a,\n                                  byte[] b)", "description": "Compares two byte arrays lexicographically, numerically treating\n elements as unsigned.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Byte.compareUnsigned(byte, byte), at an index within the\n respective arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(byte[], byte[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal."}, {"method_name": "compareUnsigned", "method_sig": "public static int compareUnsigned (byte[] a,\n                                  int aFromIndex,\n                                  int aToIndex,\n                                  byte[] b,\n                                  int bFromIndex,\n                                  int bToIndex)", "description": "Compares two byte arrays lexicographically over the specified\n ranges, numerically treating elements as unsigned.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Byte.compareUnsigned(byte, byte), at a\n relative index within the respective arrays that is the length of the\n prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(byte[], int, int, byte[], int, int) for the\n definition of a common and proper prefix.)"}, {"method_name": "compare", "method_sig": "public static int compare (short[] a,\n                          short[] b)", "description": "Compares two short arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Short.compare(short, short), at an index within the respective\n arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(short[], short[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n "}, {"method_name": "compare", "method_sig": "public static int compare (short[] a,\n                          int aFromIndex,\n                          int aToIndex,\n                          short[] b,\n                          int bFromIndex,\n                          int bToIndex)", "description": "Compares two short arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Short.compare(short, short), at a relative\n index within the respective arrays that is the length of the prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(short[], int, int, short[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n "}, {"method_name": "compareUnsigned", "method_sig": "public static int compareUnsigned (short[] a,\n                                  short[] b)", "description": "Compares two short arrays lexicographically, numerically treating\n elements as unsigned.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Short.compareUnsigned(short, short), at an index within the\n respective arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(short[], short[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal."}, {"method_name": "compareUnsigned", "method_sig": "public static int compareUnsigned (short[] a,\n                                  int aFromIndex,\n                                  int aToIndex,\n                                  short[] b,\n                                  int bFromIndex,\n                                  int bToIndex)", "description": "Compares two short arrays lexicographically over the specified\n ranges, numerically treating elements as unsigned.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Short.compareUnsigned(short, short), at a\n relative index within the respective arrays that is the length of the\n prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(short[], int, int, short[], int, int) for the\n definition of a common and proper prefix.)"}, {"method_name": "compare", "method_sig": "public static int compare (char[] a,\n                          char[] b)", "description": "Compares two char arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Character.compare(char, char), at an index within the respective\n arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(char[], char[]) for the definition of a common and\n proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n "}, {"method_name": "compare", "method_sig": "public static int compare (char[] a,\n                          int aFromIndex,\n                          int aToIndex,\n                          char[] b,\n                          int bFromIndex,\n                          int bToIndex)", "description": "Compares two char arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Character.compare(char, char), at a relative\n index within the respective arrays that is the length of the prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(char[], int, int, char[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n "}, {"method_name": "compare", "method_sig": "public static int compare (int[] a,\n                          int[] b)", "description": "Compares two int arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Integer.compare(int, int), at an index within the respective\n arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(int[], int[]) for the definition of a common and\n proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n "}, {"method_name": "compare", "method_sig": "public static int compare (int[] a,\n                          int aFromIndex,\n                          int aToIndex,\n                          int[] b,\n                          int bFromIndex,\n                          int bToIndex)", "description": "Compares two int arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Integer.compare(int, int), at a relative index\n within the respective arrays that is the length of the prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(int[], int, int, int[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n "}, {"method_name": "compareUnsigned", "method_sig": "public static int compareUnsigned (int[] a,\n                                  int[] b)", "description": "Compares two int arrays lexicographically, numerically treating\n elements as unsigned.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Integer.compareUnsigned(int, int), at an index within the\n respective arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(int[], int[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal."}, {"method_name": "compareUnsigned", "method_sig": "public static int compareUnsigned (int[] a,\n                                  int aFromIndex,\n                                  int aToIndex,\n                                  int[] b,\n                                  int bFromIndex,\n                                  int bToIndex)", "description": "Compares two int arrays lexicographically over the specified\n ranges, numerically treating elements as unsigned.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Integer.compareUnsigned(int, int), at a\n relative index within the respective arrays that is the length of the\n prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(int[], int, int, int[], int, int) for the\n definition of a common and proper prefix.)"}, {"method_name": "compare", "method_sig": "public static int compare (long[] a,\n                          long[] b)", "description": "Compares two long arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Long.compare(long, long), at an index within the respective\n arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(long[], long[]) for the definition of a common and\n proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n "}, {"method_name": "compare", "method_sig": "public static int compare (long[] a,\n                          int aFromIndex,\n                          int aToIndex,\n                          long[] b,\n                          int bFromIndex,\n                          int bToIndex)", "description": "Compares two long arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Long.compare(long, long), at a relative index\n within the respective arrays that is the length of the prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(long[], int, int, long[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n "}, {"method_name": "compareUnsigned", "method_sig": "public static int compareUnsigned (long[] a,\n                                  long[] b)", "description": "Compares two long arrays lexicographically, numerically treating\n elements as unsigned.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Long.compareUnsigned(long, long), at an index within the\n respective arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(long[], long[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal."}, {"method_name": "compareUnsigned", "method_sig": "public static int compareUnsigned (long[] a,\n                                  int aFromIndex,\n                                  int aToIndex,\n                                  long[] b,\n                                  int bFromIndex,\n                                  int bToIndex)", "description": "Compares two long arrays lexicographically over the specified\n ranges, numerically treating elements as unsigned.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Long.compareUnsigned(long, long), at a\n relative index within the respective arrays that is the length of the\n prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(long[], int, int, long[], int, int) for the\n definition of a common and proper prefix.)"}, {"method_name": "compare", "method_sig": "public static int compare (float[] a,\n                          float[] b)", "description": "Compares two float arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Float.compare(float, float), at an index within the respective\n arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(float[], float[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n "}, {"method_name": "compare", "method_sig": "public static int compare (float[] a,\n                          int aFromIndex,\n                          int aToIndex,\n                          float[] b,\n                          int bFromIndex,\n                          int bToIndex)", "description": "Compares two float arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Float.compare(float, float), at a relative\n index within the respective arrays that is the length of the prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(float[], int, int, float[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n "}, {"method_name": "compare", "method_sig": "public static int compare (double[] a,\n                          double[] b)", "description": "Compares two double arrays lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements, as if by\n Double.compare(double, double), at an index within the respective\n arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(double[], double[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n "}, {"method_name": "compare", "method_sig": "public static int compare (double[] a,\n                          int aFromIndex,\n                          int aToIndex,\n                          double[] b,\n                          int bFromIndex,\n                          int bToIndex)", "description": "Compares two double arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements, as if by Double.compare(double, double), at a relative\n index within the respective arrays that is the length of the prefix.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(double[], int, int, double[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n "}, {"method_name": "compare", "method_sig": "public static <T extends Comparable<? super T>> int compare (T[] a,\n                                                            T[] b)", "description": "Compares two Object arrays, within comparable elements,\n lexicographically.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing two elements of type T at\n an index i within the respective arrays that is the prefix\n length, as if by:\n \n     Comparator.nullsFirst(Comparator.<T>naturalOrder()).\n         compare(a[i], b[i])\n \n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(Object[], Object[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal.\n A null array element is considered lexicographically than a\n non-null array element.  Two null array elements are\n considered equal.\n\n The comparison is consistent with equals,\n more specifically the following holds for arrays a and b:\n \n     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n "}, {"method_name": "compare", "method_sig": "public static <T extends Comparable<? super T>> int compare (T[] a,\n                                                            int aFromIndex,\n                                                            int aToIndex,\n                                                            T[] b,\n                                                            int bFromIndex,\n                                                            int bToIndex)", "description": "Compares two Object arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing two\n elements of type T at a relative index i within the\n respective arrays that is the prefix length, as if by:\n \n     Comparator.nullsFirst(Comparator.<T>naturalOrder()).\n         compare(a[aFromIndex + i, b[bFromIndex + i])\n \n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(Object[], int, int, Object[], int, int) for the\n definition of a common and proper prefix.)\n\n The comparison is consistent with\n equals, more\n specifically the following holds for arrays a and b with\n specified ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively:\n \n     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n "}, {"method_name": "compare", "method_sig": "public static <T> int compare (T[] a,\n                              T[] b,\n                              Comparator<? super T> cmp)", "description": "Compares two Object arrays lexicographically using a specified\n comparator.\n\n If the two arrays share a common prefix then the lexicographic\n comparison is the result of comparing with the specified comparator two\n elements at an index within the respective arrays that is the prefix\n length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two array lengths.\n (See mismatch(Object[], Object[]) for the definition of a common\n and proper prefix.)\n\n A null array reference is considered lexicographically less\n than a non-null array reference.  Two null array\n references are considered equal."}, {"method_name": "compare", "method_sig": "public static <T> int compare (T[] a,\n                              int aFromIndex,\n                              int aToIndex,\n                              T[] b,\n                              int bFromIndex,\n                              int bToIndex,\n                              Comparator<? super T> cmp)", "description": "Compares two Object arrays lexicographically over the specified\n ranges.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the lexicographic comparison is the result of comparing with the\n specified comparator two elements at a relative index within the\n respective arrays that is the prefix length.\n Otherwise, one array is a proper prefix of the other and, lexicographic\n comparison is the result of comparing the two range lengths.\n (See mismatch(Object[], int, int, Object[], int, int) for the\n definition of a common and proper prefix.)"}, {"method_name": "mismatch", "method_sig": "public static int mismatch (boolean[] a,\n                           boolean[] b)", "description": "Finds and returns the index of the first mismatch between two\n boolean arrays, otherwise return -1 if no mismatch is found.  The\n index will be in the range of 0 (inclusive) up to the length (inclusive)\n of the smaller array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     a[pl] != b[pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (boolean[] a,\n                           int aFromIndex,\n                           int aToIndex,\n                           boolean[] b,\n                           int bFromIndex,\n                           int bToIndex)", "description": "Finds and returns the relative index of the first mismatch between two\n boolean arrays over the specified ranges, otherwise return -1 if\n no mismatch is found.  The index will be in the range of 0 (inclusive) up\n to the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     a[aFromIndex + pl] != b[bFromIndex + pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (byte[] a,\n                           byte[] b)", "description": "Finds and returns the index of the first mismatch between two byte\n arrays, otherwise return -1 if no mismatch is found.  The index will be\n in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     a[pl] != b[pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (byte[] a,\n                           int aFromIndex,\n                           int aToIndex,\n                           byte[] b,\n                           int bFromIndex,\n                           int bToIndex)", "description": "Finds and returns the relative index of the first mismatch between two\n byte arrays over the specified ranges, otherwise return -1 if no\n mismatch is found.  The index will be in the range of 0 (inclusive) up to\n the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     a[aFromIndex + pl] != b[bFromIndex + pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (char[] a,\n                           char[] b)", "description": "Finds and returns the index of the first mismatch between two char\n arrays, otherwise return -1 if no mismatch is found.  The index will be\n in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     a[pl] != b[pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (char[] a,\n                           int aFromIndex,\n                           int aToIndex,\n                           char[] b,\n                           int bFromIndex,\n                           int bToIndex)", "description": "Finds and returns the relative index of the first mismatch between two\n char arrays over the specified ranges, otherwise return -1 if no\n mismatch is found.  The index will be in the range of 0 (inclusive) up to\n the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     a[aFromIndex + pl] != b[bFromIndex + pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (short[] a,\n                           short[] b)", "description": "Finds and returns the index of the first mismatch between two short\n arrays, otherwise return -1 if no mismatch is found.  The index will be\n in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     a[pl] != b[pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (short[] a,\n                           int aFromIndex,\n                           int aToIndex,\n                           short[] b,\n                           int bFromIndex,\n                           int bToIndex)", "description": "Finds and returns the relative index of the first mismatch between two\n short arrays over the specified ranges, otherwise return -1 if no\n mismatch is found.  The index will be in the range of 0 (inclusive) up to\n the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     a[aFromIndex + pl] != b[bFromIndex + pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (int[] a,\n                           int[] b)", "description": "Finds and returns the index of the first mismatch between two int\n arrays, otherwise return -1 if no mismatch is found.  The index will be\n in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     a[pl] != b[pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (int[] a,\n                           int aFromIndex,\n                           int aToIndex,\n                           int[] b,\n                           int bFromIndex,\n                           int bToIndex)", "description": "Finds and returns the relative index of the first mismatch between two\n int arrays over the specified ranges, otherwise return -1 if no\n mismatch is found.  The index will be in the range of 0 (inclusive) up to\n the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     a[aFromIndex + pl] != b[bFromIndex + pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (long[] a,\n                           long[] b)", "description": "Finds and returns the index of the first mismatch between two long\n arrays, otherwise return -1 if no mismatch is found.  The index will be\n in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     a[pl] != b[pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (long[] a,\n                           int aFromIndex,\n                           int aToIndex,\n                           long[] b,\n                           int bFromIndex,\n                           int bToIndex)", "description": "Finds and returns the relative index of the first mismatch between two\n long arrays over the specified ranges, otherwise return -1 if no\n mismatch is found.  The index will be in the range of 0 (inclusive) up to\n the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     a[aFromIndex + pl] != b[bFromIndex + pl]\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (float[] a,\n                           float[] b)", "description": "Finds and returns the index of the first mismatch between two float\n arrays, otherwise return -1 if no mismatch is found.  The index will be\n in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     Float.compare(a[pl], b[pl]) != 0\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (float[] a,\n                           int aFromIndex,\n                           int aToIndex,\n                           float[] b,\n                           int bFromIndex,\n                           int bToIndex)", "description": "Finds and returns the relative index of the first mismatch between two\n float arrays over the specified ranges, otherwise return -1 if no\n mismatch is found.  The index will be in the range of 0 (inclusive) up to\n the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     Float.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (double[] a,\n                           double[] b)", "description": "Finds and returns the index of the first mismatch between two\n double arrays, otherwise return -1 if no mismatch is found.  The\n index will be in the range of 0 (inclusive) up to the length (inclusive)\n of the smaller array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     Double.compare(a[pl], b[pl]) != 0\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (double[] a,\n                           int aFromIndex,\n                           int aToIndex,\n                           double[] b,\n                           int bFromIndex,\n                           int bToIndex)", "description": "Finds and returns the relative index of the first mismatch between two\n double arrays over the specified ranges, otherwise return -1 if\n no mismatch is found.  The index will be in the range of 0 (inclusive) up\n to the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     Double.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (Object[] a,\n                           Object[] b)", "description": "Finds and returns the index of the first mismatch between two\n Object arrays, otherwise return -1 if no mismatch is found.  The\n index will be in the range of 0 (inclusive) up to the length (inclusive)\n of the smaller array.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     !Objects.equals(a[pl], b[pl])\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length))\n "}, {"method_name": "mismatch", "method_sig": "public static int mismatch (Object[] a,\n                           int aFromIndex,\n                           int aToIndex,\n                           Object[] b,\n                           int bFromIndex,\n                           int bToIndex)", "description": "Finds and returns the relative index of the first mismatch between two\n Object arrays over the specified ranges, otherwise return -1 if\n no mismatch is found.  The index will be in the range of 0 (inclusive) up\n to the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     !Objects.equals(a[aFromIndex + pl], b[bFromIndex + pl])\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n "}, {"method_name": "mismatch", "method_sig": "public static <T> int mismatch (T[] a,\n                               T[] b,\n                               Comparator<? super T> cmp)", "description": "Finds and returns the index of the first mismatch between two\n Object arrays, otherwise return -1 if no mismatch is found.\n The index will be in the range of 0 (inclusive) up to the length\n (inclusive) of the smaller array.\n\n The specified comparator is used to determine if two array elements\n from the each array are not equal.\n\n If the two arrays share a common prefix then the returned index is the\n length of the common prefix and it follows that there is a mismatch\n between the two elements at that index within the respective arrays.\n If one array is a proper prefix of the other then the returned index is\n the length of the smaller array and it follows that the index is only\n valid for the larger array.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(a.length, b.length) &&\n     Arrays.equals(a, 0, pl, b, 0, pl, cmp)\n     cmp.compare(a[pl], b[pl]) != 0\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b, share a proper\n prefix if the following expression is true:\n \n     a.length != b.length &&\n     Arrays.equals(a, 0, Math.min(a.length, b.length),\n                   b, 0, Math.min(a.length, b.length),\n                   cmp)\n "}, {"method_name": "mismatch", "method_sig": "public static <T> int mismatch (T[] a,\n                               int aFromIndex,\n                               int aToIndex,\n                               T[] b,\n                               int bFromIndex,\n                               int bToIndex,\n                               Comparator<? super T> cmp)", "description": "Finds and returns the relative index of the first mismatch between two\n Object arrays over the specified ranges, otherwise return -1 if\n no mismatch is found.  The index will be in the range of 0 (inclusive) up\n to the length (inclusive) of the smaller range.\n\n If the two arrays, over the specified ranges, share a common prefix\n then the returned relative index is the length of the common prefix and\n it follows that there is a mismatch between the two elements at that\n relative index within the respective arrays.\n If one array is a proper prefix of the other, over the specified ranges,\n then the returned relative index is the length of the smaller range and\n it follows that the relative index is only valid for the array with the\n larger range.\n Otherwise, there is no mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a common\n prefix of length pl if the following expression is true:\n \n     pl >= 0 &&\n     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl, cmp) &&\n     cmp.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0\n \n Note that a common prefix length of 0 indicates that the first\n elements from each array mismatch.\n\n Two non-null arrays, a and b with specified\n ranges [aFromIndex, atoIndex) and\n [bFromIndex, btoIndex) respectively, share a proper\n if the following expression is true:\n \n     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n                   cmp)\n "}]}