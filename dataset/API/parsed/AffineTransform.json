{"name": "Class AffineTransform", "module": "java.desktop", "package": "java.awt.geom", "text": "The AffineTransform class represents a 2D affine transform\n that performs a linear mapping from 2D coordinates to other 2D\n coordinates that preserves the \"straightness\" and\n \"parallelness\" of lines.  Affine transformations can be constructed\n using sequences of translations, scales, flips, rotations, and shears.\n \n Such a coordinate transformation can be represented by a 3 row by\n 3 column matrix with an implied last row of [ 0 0 1 ].  This matrix\n transforms source coordinates (x,y) into\n destination coordinates (x',y') by considering\n them to be a column vector and multiplying the coordinate vector\n by the matrix according to the following process:\n \n      [ x']   [  m00  m01  m02  ] [ x ]   [ m00x + m01y + m02 ]\n      [ y'] = [  m10  m11  m12  ] [ y ] = [ m10x + m11y + m12 ]\n      [ 1 ]   [   0    0    1   ] [ 1 ]   [         1         ]\n \nHandling 90-Degree Rotations\n\n In some variations of the rotate methods in the\n AffineTransform class, a double-precision argument\n specifies the angle of rotation in radians.\n These methods have special handling for rotations of approximately\n 90 degrees (including multiples such as 180, 270, and 360 degrees),\n so that the common case of quadrant rotation is handled more\n efficiently.\n This special handling can cause angles very close to multiples of\n 90 degrees to be treated as if they were exact multiples of\n 90 degrees.\n For small multiples of 90 degrees the range of angles treated\n as a quadrant rotation is approximately 0.00000121 degrees wide.\n This section explains why such special care is needed and how\n it is implemented.\n \n Since 90 degrees is represented as PI/2 in radians,\n and since PI is a transcendental (and therefore irrational) number,\n it is not possible to exactly represent a multiple of 90 degrees as\n an exact double precision value measured in radians.\n As a result it is theoretically impossible to describe quadrant\n rotations (90, 180, 270 or 360 degrees) using these values.\n Double precision floating point values can get very close to\n non-zero multiples of PI/2 but never close enough\n for the sine or cosine to be exactly 0.0, 1.0 or -1.0.\n The implementations of Math.sin() and\n Math.cos() correspondingly never return 0.0\n for any case other than Math.sin(0.0).\n These same implementations do, however, return exactly 1.0 and\n -1.0 for some range of numbers around each multiple of 90\n degrees since the correct answer is so close to 1.0 or -1.0 that\n the double precision significand cannot represent the difference\n as accurately as it can for numbers that are near 0.0.\n \n The net result of these issues is that if the\n Math.sin() and Math.cos() methods\n are used to directly generate the values for the matrix modifications\n during these radian-based rotation operations then the resulting\n transform is never strictly classifiable as a quadrant rotation\n even for a simple case like rotate(Math.PI/2.0),\n due to minor variations in the matrix caused by the non-0.0 values\n obtained for the sine and cosine.\n If these transforms are not classified as quadrant rotations then\n subsequent code which attempts to optimize further operations based\n upon the type of the transform will be relegated to its most general\n implementation.\n \n Because quadrant rotations are fairly common,\n this class should handle these cases reasonably quickly, both in\n applying the rotations to the transform and in applying the resulting\n transform to the coordinates.\n To facilitate this optimal handling, the methods which take an angle\n of rotation measured in radians attempt to detect angles that are\n intended to be quadrant rotations and treat them as such.\n These methods therefore treat an angle theta as a quadrant\n rotation if either Math.sin(theta) or\n Math.cos(theta) returns exactly 1.0 or -1.0.\n As a rule of thumb, this property holds true for a range of\n approximately 0.0000000211 radians (or 0.00000121 degrees) around\n small multiples of Math.PI/2.0.", "codes": ["public class AffineTransform\nextends Object\nimplements Cloneable, Serializable"], "fields": [{"field_name": "TYPE_IDENTITY", "field_sig": "public static final\u00a0int TYPE_IDENTITY", "description": "This constant indicates that the transform defined by this object\n is an identity transform.\n An identity transform is one in which the output coordinates are\n always the same as the input coordinates.\n If this transform is anything other than the identity transform,\n the type will either be the constant GENERAL_TRANSFORM or a\n combination of the appropriate flag bits for the various coordinate\n conversions that this transform performs."}, {"field_name": "TYPE_TRANSLATION", "field_sig": "public static final\u00a0int TYPE_TRANSLATION", "description": "This flag bit indicates that the transform defined by this object\n performs a translation in addition to the conversions indicated\n by other flag bits.\n A translation moves the coordinates by a constant amount in x\n and y without changing the length or angle of vectors."}, {"field_name": "TYPE_UNIFORM_SCALE", "field_sig": "public static final\u00a0int TYPE_UNIFORM_SCALE", "description": "This flag bit indicates that the transform defined by this object\n performs a uniform scale in addition to the conversions indicated\n by other flag bits.\n A uniform scale multiplies the length of vectors by the same amount\n in both the x and y directions without changing the angle between\n vectors.\n This flag bit is mutually exclusive with the TYPE_GENERAL_SCALE flag."}, {"field_name": "TYPE_GENERAL_SCALE", "field_sig": "public static final\u00a0int TYPE_GENERAL_SCALE", "description": "This flag bit indicates that the transform defined by this object\n performs a general scale in addition to the conversions indicated\n by other flag bits.\n A general scale multiplies the length of vectors by different\n amounts in the x and y directions without changing the angle\n between perpendicular vectors.\n This flag bit is mutually exclusive with the TYPE_UNIFORM_SCALE flag."}, {"field_name": "TYPE_MASK_SCALE", "field_sig": "public static final\u00a0int TYPE_MASK_SCALE", "description": "This constant is a bit mask for any of the scale flag bits."}, {"field_name": "TYPE_FLIP", "field_sig": "public static final\u00a0int TYPE_FLIP", "description": "This flag bit indicates that the transform defined by this object\n performs a mirror image flip about some axis which changes the\n normally right handed coordinate system into a left handed\n system in addition to the conversions indicated by other flag bits.\n A right handed coordinate system is one where the positive X\n axis rotates counterclockwise to overlay the positive Y axis\n similar to the direction that the fingers on your right hand\n curl when you stare end on at your thumb.\n A left handed coordinate system is one where the positive X\n axis rotates clockwise to overlay the positive Y axis similar\n to the direction that the fingers on your left hand curl.\n There is no mathematical way to determine the angle of the\n original flipping or mirroring transformation since all angles\n of flip are identical given an appropriate adjusting rotation."}, {"field_name": "TYPE_QUADRANT_ROTATION", "field_sig": "public static final\u00a0int TYPE_QUADRANT_ROTATION", "description": "This flag bit indicates that the transform defined by this object\n performs a quadrant rotation by some multiple of 90 degrees in\n addition to the conversions indicated by other flag bits.\n A rotation changes the angles of vectors by the same amount\n regardless of the original direction of the vector and without\n changing the length of the vector.\n This flag bit is mutually exclusive with the TYPE_GENERAL_ROTATION flag."}, {"field_name": "TYPE_GENERAL_ROTATION", "field_sig": "public static final\u00a0int TYPE_GENERAL_ROTATION", "description": "This flag bit indicates that the transform defined by this object\n performs a rotation by an arbitrary angle in addition to the\n conversions indicated by other flag bits.\n A rotation changes the angles of vectors by the same amount\n regardless of the original direction of the vector and without\n changing the length of the vector.\n This flag bit is mutually exclusive with the\n TYPE_QUADRANT_ROTATION flag."}, {"field_name": "TYPE_MASK_ROTATION", "field_sig": "public static final\u00a0int TYPE_MASK_ROTATION", "description": "This constant is a bit mask for any of the rotation flag bits."}, {"field_name": "TYPE_GENERAL_TRANSFORM", "field_sig": "public static final\u00a0int TYPE_GENERAL_TRANSFORM", "description": "This constant indicates that the transform defined by this object\n performs an arbitrary conversion of the input coordinates.\n If this transform can be classified by any of the above constants,\n the type will either be the constant TYPE_IDENTITY or a\n combination of the appropriate flag bits for the various coordinate\n conversions that this transform performs."}], "methods": [{"method_name": "getTranslateInstance", "method_sig": "public static AffineTransform getTranslateInstance (double tx,\n                                                   double ty)", "description": "Returns a transform representing a translation transformation.\n The matrix representing the returned transform is:\n \n          [   1    0    tx  ]\n          [   0    1    ty  ]\n          [   0    0    1   ]\n "}, {"method_name": "getRotateInstance", "method_sig": "public static AffineTransform getRotateInstance (double theta)", "description": "Returns a transform representing a rotation transformation.\n The matrix representing the returned transform is:\n \n          [   cos(theta)    -sin(theta)    0   ]\n          [   sin(theta)     cos(theta)    0   ]\n          [       0              0         1   ]\n \n Rotating by a positive angle theta rotates points on the positive\n X axis toward the positive Y axis.\n Note also the discussion of\n Handling 90-Degree Rotations\n above."}, {"method_name": "getRotateInstance", "method_sig": "public static AffineTransform getRotateInstance (double theta,\n                                                double anchorx,\n                                                double anchory)", "description": "Returns a transform that rotates coordinates around an anchor point.\n This operation is equivalent to translating the coordinates so\n that the anchor point is at the origin (S1), then rotating them\n about the new origin (S2), and finally translating so that the\n intermediate origin is restored to the coordinates of the original\n anchor point (S3).\n \n This operation is equivalent to the following sequence of calls:\n \n     AffineTransform Tx = new AffineTransform();\n     Tx.translate(anchorx, anchory);    // S3: final translation\n     Tx.rotate(theta);                  // S2: rotate around anchor\n     Tx.translate(-anchorx, -anchory);  // S1: translate anchor to origin\n \n The matrix representing the returned transform is:\n \n          [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]\n          [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]\n          [       0              0               1        ]\n \n Rotating by a positive angle theta rotates points on the positive\n X axis toward the positive Y axis.\n Note also the discussion of\n Handling 90-Degree Rotations\n above."}, {"method_name": "getRotateInstance", "method_sig": "public static AffineTransform getRotateInstance (double vecx,\n                                                double vecy)", "description": "Returns a transform that rotates coordinates according to\n a rotation vector.\n All coordinates rotate about the origin by the same amount.\n The amount of rotation is such that coordinates along the former\n positive X axis will subsequently align with the vector pointing\n from the origin to the specified vector coordinates.\n If both vecx and vecy are 0.0,\n an identity transform is returned.\n This operation is equivalent to calling:\n \n     AffineTransform.getRotateInstance(Math.atan2(vecy, vecx));\n "}, {"method_name": "getRotateInstance", "method_sig": "public static AffineTransform getRotateInstance (double vecx,\n                                                double vecy,\n                                                double anchorx,\n                                                double anchory)", "description": "Returns a transform that rotates coordinates around an anchor\n point according to a rotation vector.\n All coordinates rotate about the specified anchor coordinates\n by the same amount.\n The amount of rotation is such that coordinates along the former\n positive X axis will subsequently align with the vector pointing\n from the origin to the specified vector coordinates.\n If both vecx and vecy are 0.0,\n an identity transform is returned.\n This operation is equivalent to calling:\n \n     AffineTransform.getRotateInstance(Math.atan2(vecy, vecx),\n                                       anchorx, anchory);\n "}, {"method_name": "getQuadrantRotateInstance", "method_sig": "public static AffineTransform getQuadrantRotateInstance (int numquadrants)", "description": "Returns a transform that rotates coordinates by the specified\n number of quadrants.\n This operation is equivalent to calling:\n \n     AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0);\n \n Rotating by a positive number of quadrants rotates points on\n the positive X axis toward the positive Y axis."}, {"method_name": "getQuadrantRotateInstance", "method_sig": "public static AffineTransform getQuadrantRotateInstance (int numquadrants,\n                                                        double anchorx,\n                                                        double anchory)", "description": "Returns a transform that rotates coordinates by the specified\n number of quadrants around the specified anchor point.\n This operation is equivalent to calling:\n \n     AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0,\n                                       anchorx, anchory);\n \n Rotating by a positive number of quadrants rotates points on\n the positive X axis toward the positive Y axis."}, {"method_name": "getScaleInstance", "method_sig": "public static AffineTransform getScaleInstance (double sx,\n                                               double sy)", "description": "Returns a transform representing a scaling transformation.\n The matrix representing the returned transform is:\n \n          [   sx   0    0   ]\n          [   0    sy   0   ]\n          [   0    0    1   ]\n "}, {"method_name": "getShearInstance", "method_sig": "public static AffineTransform getShearInstance (double shx,\n                                               double shy)", "description": "Returns a transform representing a shearing transformation.\n The matrix representing the returned transform is:\n \n          [   1   shx   0   ]\n          [  shy   1    0   ]\n          [   0    0    1   ]\n "}, {"method_name": "getType", "method_sig": "public int getType()", "description": "Retrieves the flag bits describing the conversion properties of\n this transform.\n The return value is either one of the constants TYPE_IDENTITY\n or TYPE_GENERAL_TRANSFORM, or a combination of the\n appropriate flag bits.\n A valid combination of flag bits is an exclusive OR operation\n that can combine\n the TYPE_TRANSLATION flag bit\n in addition to either of the\n TYPE_UNIFORM_SCALE or TYPE_GENERAL_SCALE flag bits\n as well as either of the\n TYPE_QUADRANT_ROTATION or TYPE_GENERAL_ROTATION flag bits."}, {"method_name": "getDeterminant", "method_sig": "public double getDeterminant()", "description": "Returns the determinant of the matrix representation of the transform.\n The determinant is useful both to determine if the transform can\n be inverted and to get a single value representing the\n combined X and Y scaling of the transform.\n \n If the determinant is non-zero, then this transform is\n invertible and the various methods that depend on the inverse\n transform do not need to throw a\n NoninvertibleTransformException.\n If the determinant is zero then this transform can not be\n inverted since the transform maps all input coordinates onto\n a line or a point.\n If the determinant is near enough to zero then inverse transform\n operations might not carry enough precision to produce meaningful\n results.\n \n If this transform represents a uniform scale, as indicated by\n the getType method then the determinant also\n represents the square of the uniform scale factor by which all of\n the points are expanded from or contracted towards the origin.\n If this transform represents a non-uniform scale or more general\n transform then the determinant is not likely to represent a\n value useful for any purpose other than determining if inverse\n transforms are possible.\n \n Mathematically, the determinant is calculated using the formula:\n \n          |  m00  m01  m02  |\n          |  m10  m11  m12  |  =  m00 * m11 - m01 * m10\n          |   0    0    1   |\n "}, {"method_name": "getMatrix", "method_sig": "public void getMatrix (double[] flatmatrix)", "description": "Retrieves the 6 specifiable values in the 3x3 affine transformation\n matrix and places them into an array of double precisions values.\n The values are stored in the array as\n {\u00a0m00\u00a0m10\u00a0m01\u00a0m11\u00a0m02\u00a0m12\u00a0}.\n An array of 4 doubles can also be specified, in which case only the\n first four elements representing the non-transform\n parts of the array are retrieved and the values are stored into\n the array as {\u00a0m00\u00a0m10\u00a0m01\u00a0m11\u00a0}"}, {"method_name": "getScaleX", "method_sig": "public double getScaleX()", "description": "Returns the m00 element of the 3x3 affine transformation matrix.\n This matrix factor determines how input X coordinates will affect output\n X coordinates and is one element of the scale of the transform.\n To measure the full amount by which X coordinates are stretched or\n contracted by this transform, use the following code:\n \n     Point2D p = new Point2D.Double(1, 0);\n     p = tx.deltaTransform(p, p);\n     double scaleX = p.distance(0, 0);\n "}, {"method_name": "getScaleY", "method_sig": "public double getScaleY()", "description": "Returns the m11 element of the 3x3 affine transformation matrix.\n This matrix factor determines how input Y coordinates will affect output\n Y coordinates and is one element of the scale of the transform.\n To measure the full amount by which Y coordinates are stretched or\n contracted by this transform, use the following code:\n \n     Point2D p = new Point2D.Double(0, 1);\n     p = tx.deltaTransform(p, p);\n     double scaleY = p.distance(0, 0);\n "}, {"method_name": "getShearX", "method_sig": "public double getShearX()", "description": "Returns the X coordinate shearing element (m01) of the 3x3\n affine transformation matrix."}, {"method_name": "getShearY", "method_sig": "public double getShearY()", "description": "Returns the Y coordinate shearing element (m10) of the 3x3\n affine transformation matrix."}, {"method_name": "getTranslateX", "method_sig": "public double getTranslateX()", "description": "Returns the X coordinate of the translation element (m02) of the\n 3x3 affine transformation matrix."}, {"method_name": "getTranslateY", "method_sig": "public double getTranslateY()", "description": "Returns the Y coordinate of the translation element (m12) of the\n 3x3 affine transformation matrix."}, {"method_name": "translate", "method_sig": "public void translate (double tx,\n                      double ty)", "description": "Concatenates this transform with a translation transformation.\n This is equivalent to calling concatenate(T), where T is an\n AffineTransform represented by the following matrix:\n \n          [   1    0    tx  ]\n          [   0    1    ty  ]\n          [   0    0    1   ]\n "}, {"method_name": "rotate", "method_sig": "public void rotate (double theta)", "description": "Concatenates this transform with a rotation transformation.\n This is equivalent to calling concatenate(R), where R is an\n AffineTransform represented by the following matrix:\n \n          [   cos(theta)    -sin(theta)    0   ]\n          [   sin(theta)     cos(theta)    0   ]\n          [       0              0         1   ]\n \n Rotating by a positive angle theta rotates points on the positive\n X axis toward the positive Y axis.\n Note also the discussion of\n Handling 90-Degree Rotations\n above."}, {"method_name": "rotate", "method_sig": "public void rotate (double theta,\n                   double anchorx,\n                   double anchory)", "description": "Concatenates this transform with a transform that rotates\n coordinates around an anchor point.\n This operation is equivalent to translating the coordinates so\n that the anchor point is at the origin (S1), then rotating them\n about the new origin (S2), and finally translating so that the\n intermediate origin is restored to the coordinates of the original\n anchor point (S3).\n \n This operation is equivalent to the following sequence of calls:\n \n     translate(anchorx, anchory);      // S3: final translation\n     rotate(theta);                    // S2: rotate around anchor\n     translate(-anchorx, -anchory);    // S1: translate anchor to origin\n \n Rotating by a positive angle theta rotates points on the positive\n X axis toward the positive Y axis.\n Note also the discussion of\n Handling 90-Degree Rotations\n above."}, {"method_name": "rotate", "method_sig": "public void rotate (double vecx,\n                   double vecy)", "description": "Concatenates this transform with a transform that rotates\n coordinates according to a rotation vector.\n All coordinates rotate about the origin by the same amount.\n The amount of rotation is such that coordinates along the former\n positive X axis will subsequently align with the vector pointing\n from the origin to the specified vector coordinates.\n If both vecx and vecy are 0.0,\n no additional rotation is added to this transform.\n This operation is equivalent to calling:\n \n          rotate(Math.atan2(vecy, vecx));\n "}, {"method_name": "rotate", "method_sig": "public void rotate (double vecx,\n                   double vecy,\n                   double anchorx,\n                   double anchory)", "description": "Concatenates this transform with a transform that rotates\n coordinates around an anchor point according to a rotation\n vector.\n All coordinates rotate about the specified anchor coordinates\n by the same amount.\n The amount of rotation is such that coordinates along the former\n positive X axis will subsequently align with the vector pointing\n from the origin to the specified vector coordinates.\n If both vecx and vecy are 0.0,\n the transform is not modified in any way.\n This method is equivalent to calling:\n \n     rotate(Math.atan2(vecy, vecx), anchorx, anchory);\n "}, {"method_name": "quadrantRotate", "method_sig": "public void quadrantRotate (int numquadrants)", "description": "Concatenates this transform with a transform that rotates\n coordinates by the specified number of quadrants.\n This is equivalent to calling:\n \n     rotate(numquadrants * Math.PI / 2.0);\n \n Rotating by a positive number of quadrants rotates points on\n the positive X axis toward the positive Y axis."}, {"method_name": "quadrantRotate", "method_sig": "public void quadrantRotate (int numquadrants,\n                           double anchorx,\n                           double anchory)", "description": "Concatenates this transform with a transform that rotates\n coordinates by the specified number of quadrants around\n the specified anchor point.\n This method is equivalent to calling:\n \n     rotate(numquadrants * Math.PI / 2.0, anchorx, anchory);\n \n Rotating by a positive number of quadrants rotates points on\n the positive X axis toward the positive Y axis."}, {"method_name": "scale", "method_sig": "public void scale (double sx,\n                  double sy)", "description": "Concatenates this transform with a scaling transformation.\n This is equivalent to calling concatenate(S), where S is an\n AffineTransform represented by the following matrix:\n \n          [   sx   0    0   ]\n          [   0    sy   0   ]\n          [   0    0    1   ]\n "}, {"method_name": "shear", "method_sig": "public void shear (double shx,\n                  double shy)", "description": "Concatenates this transform with a shearing transformation.\n This is equivalent to calling concatenate(SH), where SH is an\n AffineTransform represented by the following matrix:\n \n          [   1   shx   0   ]\n          [  shy   1    0   ]\n          [   0    0    1   ]\n "}, {"method_name": "setToIdentity", "method_sig": "public void setToIdentity()", "description": "Resets this transform to the Identity transform."}, {"method_name": "setToTranslation", "method_sig": "public void setToTranslation (double tx,\n                             double ty)", "description": "Sets this transform to a translation transformation.\n The matrix representing this transform becomes:\n \n          [   1    0    tx  ]\n          [   0    1    ty  ]\n          [   0    0    1   ]\n "}, {"method_name": "setToRotation", "method_sig": "public void setToRotation (double theta)", "description": "Sets this transform to a rotation transformation.\n The matrix representing this transform becomes:\n \n          [   cos(theta)    -sin(theta)    0   ]\n          [   sin(theta)     cos(theta)    0   ]\n          [       0              0         1   ]\n \n Rotating by a positive angle theta rotates points on the positive\n X axis toward the positive Y axis.\n Note also the discussion of\n Handling 90-Degree Rotations\n above."}, {"method_name": "setToRotation", "method_sig": "public void setToRotation (double theta,\n                          double anchorx,\n                          double anchory)", "description": "Sets this transform to a translated rotation transformation.\n This operation is equivalent to translating the coordinates so\n that the anchor point is at the origin (S1), then rotating them\n about the new origin (S2), and finally translating so that the\n intermediate origin is restored to the coordinates of the original\n anchor point (S3).\n \n This operation is equivalent to the following sequence of calls:\n \n     setToTranslation(anchorx, anchory); // S3: final translation\n     rotate(theta);                      // S2: rotate around anchor\n     translate(-anchorx, -anchory);      // S1: translate anchor to origin\n \n The matrix representing this transform becomes:\n \n          [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]\n          [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]\n          [       0              0               1        ]\n \n Rotating by a positive angle theta rotates points on the positive\n X axis toward the positive Y axis.\n Note also the discussion of\n Handling 90-Degree Rotations\n above."}, {"method_name": "setToRotation", "method_sig": "public void setToRotation (double vecx,\n                          double vecy)", "description": "Sets this transform to a rotation transformation that rotates\n coordinates according to a rotation vector.\n All coordinates rotate about the origin by the same amount.\n The amount of rotation is such that coordinates along the former\n positive X axis will subsequently align with the vector pointing\n from the origin to the specified vector coordinates.\n If both vecx and vecy are 0.0,\n the transform is set to an identity transform.\n This operation is equivalent to calling:\n \n     setToRotation(Math.atan2(vecy, vecx));\n "}, {"method_name": "setToRotation", "method_sig": "public void setToRotation (double vecx,\n                          double vecy,\n                          double anchorx,\n                          double anchory)", "description": "Sets this transform to a rotation transformation that rotates\n coordinates around an anchor point according to a rotation\n vector.\n All coordinates rotate about the specified anchor coordinates\n by the same amount.\n The amount of rotation is such that coordinates along the former\n positive X axis will subsequently align with the vector pointing\n from the origin to the specified vector coordinates.\n If both vecx and vecy are 0.0,\n the transform is set to an identity transform.\n This operation is equivalent to calling:\n \n     setToTranslation(Math.atan2(vecy, vecx), anchorx, anchory);\n "}, {"method_name": "setToQuadrantRotation", "method_sig": "public void setToQuadrantRotation (int numquadrants)", "description": "Sets this transform to a rotation transformation that rotates\n coordinates by the specified number of quadrants.\n This operation is equivalent to calling:\n \n     setToRotation(numquadrants * Math.PI / 2.0);\n \n Rotating by a positive number of quadrants rotates points on\n the positive X axis toward the positive Y axis."}, {"method_name": "setToQuadrantRotation", "method_sig": "public void setToQuadrantRotation (int numquadrants,\n                                  double anchorx,\n                                  double anchory)", "description": "Sets this transform to a translated rotation transformation\n that rotates coordinates by the specified number of quadrants\n around the specified anchor point.\n This operation is equivalent to calling:\n \n     setToRotation(numquadrants * Math.PI / 2.0, anchorx, anchory);\n \n Rotating by a positive number of quadrants rotates points on\n the positive X axis toward the positive Y axis."}, {"method_name": "setToScale", "method_sig": "public void setToScale (double sx,\n                       double sy)", "description": "Sets this transform to a scaling transformation.\n The matrix representing this transform becomes:\n \n          [   sx   0    0   ]\n          [   0    sy   0   ]\n          [   0    0    1   ]\n "}, {"method_name": "setToShear", "method_sig": "public void setToShear (double shx,\n                       double shy)", "description": "Sets this transform to a shearing transformation.\n The matrix representing this transform becomes:\n \n          [   1   shx   0   ]\n          [  shy   1    0   ]\n          [   0    0    1   ]\n "}, {"method_name": "setTransform", "method_sig": "public void setTransform (AffineTransform Tx)", "description": "Sets this transform to a copy of the transform in the specified\n AffineTransform object."}, {"method_name": "setTransform", "method_sig": "public void setTransform (double m00,\n                         double m10,\n                         double m01,\n                         double m11,\n                         double m02,\n                         double m12)", "description": "Sets this transform to the matrix specified by the 6\n double precision values."}, {"method_name": "concatenate", "method_sig": "public void concatenate (AffineTransform Tx)", "description": "Concatenates an AffineTransform Tx to\n this AffineTransform Cx in the most commonly useful\n way to provide a new user space\n that is mapped to the former user space by Tx.\n Cx is updated to perform the combined transformation.\n Transforming a point p by the updated transform Cx' is\n equivalent to first transforming p by Tx and then\n transforming the result by the original transform Cx like this:\n Cx'(p) = Cx(Tx(p))\n In matrix notation, if this transform Cx is\n represented by the matrix [this] and Tx is represented\n by the matrix [Tx] then this method does the following:\n \n          [this] = [this] x [Tx]\n "}, {"method_name": "preConcatenate", "method_sig": "public void preConcatenate (AffineTransform Tx)", "description": "Concatenates an AffineTransform Tx to\n this AffineTransform Cx\n in a less commonly used way such that Tx modifies the\n coordinate transformation relative to the absolute pixel\n space rather than relative to the existing user space.\n Cx is updated to perform the combined transformation.\n Transforming a point p by the updated transform Cx' is\n equivalent to first transforming p by the original transform\n Cx and then transforming the result by\n Tx like this:\n Cx'(p) = Tx(Cx(p))\n In matrix notation, if this transform Cx\n is represented by the matrix [this] and Tx is\n represented by the matrix [Tx] then this method does the\n following:\n \n          [this] = [Tx] x [this]\n "}, {"method_name": "createInverse", "method_sig": "public AffineTransform createInverse()\n                              throws NoninvertibleTransformException", "description": "Returns an AffineTransform object representing the\n inverse transformation.\n The inverse transform Tx' of this transform Tx\n maps coordinates transformed by Tx back\n to their original coordinates.\n In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).\n \n If this transform maps all coordinates onto a point or a line\n then it will not have an inverse, since coordinates that do\n not lie on the destination point or line will not have an inverse\n mapping.\n The getDeterminant method can be used to determine if this\n transform has no inverse, in which case an exception will be\n thrown if the createInverse method is called."}, {"method_name": "invert", "method_sig": "public void invert()\n            throws NoninvertibleTransformException", "description": "Sets this transform to the inverse of itself.\n The inverse transform Tx' of this transform Tx\n maps coordinates transformed by Tx back\n to their original coordinates.\n In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).\n \n If this transform maps all coordinates onto a point or a line\n then it will not have an inverse, since coordinates that do\n not lie on the destination point or line will not have an inverse\n mapping.\n The getDeterminant method can be used to determine if this\n transform has no inverse, in which case an exception will be\n thrown if the invert method is called."}, {"method_name": "transform", "method_sig": "public Point2D transform (Point2D ptSrc,\n                         Point2D ptDst)", "description": "Transforms the specified ptSrc and stores the result\n in ptDst.\n If ptDst is null, a new Point2D\n object is allocated and then the result of the transformation is\n stored in this object.\n In either case, ptDst, which contains the\n transformed point, is returned for convenience.\n If ptSrc and ptDst are the same\n object, the input point is correctly overwritten with\n the transformed point."}, {"method_name": "transform", "method_sig": "public void transform (Point2D[] ptSrc,\n                      int srcOff,\n                      Point2D[] ptDst,\n                      int dstOff,\n                      int numPts)", "description": "Transforms an array of point objects by this transform.\n If any element of the ptDst array is\n null, a new Point2D object is allocated\n and stored into that element before storing the results of the\n transformation.\n \n Note that this method does not take any precautions to\n avoid problems caused by storing results into Point2D\n objects that will be used as the source for calculations\n further down the source array.\n This method does guarantee that if a specified Point2D\n object is both the source and destination for the same single point\n transform operation then the results will not be stored until\n the calculations are complete to avoid storing the results on\n top of the operands.\n If, however, the destination Point2D object for one\n operation is the same object as the source Point2D\n object for another operation further down the source array then\n the original coordinates in that point are overwritten before\n they can be converted."}, {"method_name": "transform", "method_sig": "public void transform (float[] srcPts,\n                      int srcOff,\n                      float[] dstPts,\n                      int dstOff,\n                      int numPts)", "description": "Transforms an array of floating point coordinates by this transform.\n The two coordinate array sections can be exactly the same or\n can be overlapping sections of the same array without affecting the\n validity of the results.\n This method ensures that no source coordinates are overwritten by a\n previous operation before they can be transformed.\n The coordinates are stored in the arrays starting at the specified\n offset in the order [x0, y0, x1, y1, ..., xn, yn]."}, {"method_name": "transform", "method_sig": "public void transform (double[] srcPts,\n                      int srcOff,\n                      double[] dstPts,\n                      int dstOff,\n                      int numPts)", "description": "Transforms an array of double precision coordinates by this transform.\n The two coordinate array sections can be exactly the same or\n can be overlapping sections of the same array without affecting the\n validity of the results.\n This method ensures that no source coordinates are\n overwritten by a previous operation before they can be transformed.\n The coordinates are stored in the arrays starting at the indicated\n offset in the order [x0, y0, x1, y1, ..., xn, yn]."}, {"method_name": "transform", "method_sig": "public void transform (float[] srcPts,\n                      int srcOff,\n                      double[] dstPts,\n                      int dstOff,\n                      int numPts)", "description": "Transforms an array of floating point coordinates by this transform\n and stores the results into an array of doubles.\n The coordinates are stored in the arrays starting at the specified\n offset in the order [x0, y0, x1, y1, ..., xn, yn]."}, {"method_name": "transform", "method_sig": "public void transform (double[] srcPts,\n                      int srcOff,\n                      float[] dstPts,\n                      int dstOff,\n                      int numPts)", "description": "Transforms an array of double precision coordinates by this transform\n and stores the results into an array of floats.\n The coordinates are stored in the arrays starting at the specified\n offset in the order [x0, y0, x1, y1, ..., xn, yn]."}, {"method_name": "inverseTransform", "method_sig": "public Point2D inverseTransform (Point2D ptSrc,\n                                Point2D ptDst)\n                         throws NoninvertibleTransformException", "description": "Inverse transforms the specified ptSrc and stores the\n result in ptDst.\n If ptDst is null, a new\n Point2D object is allocated and then the result of the\n transform is stored in this object.\n In either case, ptDst, which contains the transformed\n point, is returned for convenience.\n If ptSrc and ptDst are the same\n object, the input point is correctly overwritten with the\n transformed point."}, {"method_name": "inverseTransform", "method_sig": "public void inverseTransform (double[] srcPts,\n                             int srcOff,\n                             double[] dstPts,\n                             int dstOff,\n                             int numPts)\n                      throws NoninvertibleTransformException", "description": "Inverse transforms an array of double precision coordinates by\n this transform.\n The two coordinate array sections can be exactly the same or\n can be overlapping sections of the same array without affecting the\n validity of the results.\n This method ensures that no source coordinates are\n overwritten by a previous operation before they can be transformed.\n The coordinates are stored in the arrays starting at the specified\n offset in the order [x0, y0, x1, y1, ..., xn, yn]."}, {"method_name": "deltaTransform", "method_sig": "public Point2D deltaTransform (Point2D ptSrc,\n                              Point2D ptDst)", "description": "Transforms the relative distance vector specified by\n ptSrc and stores the result in ptDst.\n A relative distance vector is transformed without applying the\n translation components of the affine transformation matrix\n using the following equations:\n \n  [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]\n  [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]\n  [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]\n \n If ptDst is null, a new\n Point2D object is allocated and then the result of the\n transform is stored in this object.\n In either case, ptDst, which contains the\n transformed point, is returned for convenience.\n If ptSrc and ptDst are the same object,\n the input point is correctly overwritten with the transformed\n point."}, {"method_name": "deltaTransform", "method_sig": "public void deltaTransform (double[] srcPts,\n                           int srcOff,\n                           double[] dstPts,\n                           int dstOff,\n                           int numPts)", "description": "Transforms an array of relative distance vectors by this\n transform.\n A relative distance vector is transformed without applying the\n translation components of the affine transformation matrix\n using the following equations:\n \n  [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]\n  [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]\n  [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]\n \n The two coordinate array sections can be exactly the same or\n can be overlapping sections of the same array without affecting the\n validity of the results.\n This method ensures that no source coordinates are\n overwritten by a previous operation before they can be transformed.\n The coordinates are stored in the arrays starting at the indicated\n offset in the order [x0, y0, x1, y1, ..., xn, yn]."}, {"method_name": "createTransformedShape", "method_sig": "public Shape createTransformedShape (Shape pSrc)", "description": "Returns a new Shape object defined by the geometry of the\n specified Shape after it has been transformed by\n this transform."}, {"method_name": "toString", "method_sig": "public String toString()", "description": "Returns a String that represents the value of this\n Object."}, {"method_name": "isIdentity", "method_sig": "public boolean isIdentity()", "description": "Returns true if this AffineTransform is\n an identity transform."}, {"method_name": "clone", "method_sig": "public Object clone()", "description": "Returns a copy of this AffineTransform object."}, {"method_name": "hashCode", "method_sig": "public int hashCode()", "description": "Returns the hashcode for this transform."}, {"method_name": "equals", "method_sig": "public boolean equals (Object obj)", "description": "Returns true if this AffineTransform\n represents the same affine coordinate transform as the specified\n argument."}]}