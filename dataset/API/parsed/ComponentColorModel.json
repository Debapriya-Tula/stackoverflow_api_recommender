{"name": "Class ComponentColorModel", "module": "java.desktop", "package": "java.awt.image", "text": "A ColorModel class that works with pixel values that\n represent color and alpha information as separate samples and that\n store each sample in a separate data element.  This class can be\n used with an arbitrary ColorSpace.  The number of\n color samples in the pixel values must be same as the number of\n color components in the ColorSpace. There may be a\n single alpha sample.\n \n For those methods that use\n a primitive array pixel representation of type transferType,\n the array length is the same as the number of color and alpha samples.\n Color samples are stored first in the array followed by the alpha\n sample, if present.  The order of the color samples is specified\n by the ColorSpace.  Typically, this order reflects the\n name of the color space type. For example, for TYPE_RGB,\n index 0 corresponds to red, index 1 to green, and index 2 to blue.\n \n The translation from pixel sample values to color/alpha components for\n display or processing purposes is based on a one-to-one correspondence of\n samples to components.\n Depending on the transfer type used to create an instance of\n ComponentColorModel, the pixel sample values\n represented by that instance may be signed or unsigned and may\n be of integral type or float or double (see below for details).\n The translation from sample values to normalized color/alpha components\n must follow certain rules.  For float and double samples, the translation\n is an identity, i.e. normalized component values are equal to the\n corresponding sample values.  For integral samples, the translation\n should be only a simple scale and offset, where the scale and offset\n constants may be different for each component.  The result of\n applying the scale and offset constants is a set of color/alpha\n component values, which are guaranteed to fall within a certain\n range.  Typically, the range for a color component will be the range\n defined by the getMinValue and getMaxValue\n methods of the ColorSpace class.  The range for an\n alpha component should be 0.0 to 1.0.\n \n Instances of ComponentColorModel created with transfer types\n DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,\n and DataBuffer.TYPE_INT have pixel sample values which\n are treated as unsigned integral values.\n The number of bits in a color or alpha sample of a pixel value might not\n be the same as the number of bits for the corresponding color or alpha\n sample passed to the\n ComponentColorModel(ColorSpace, int[], boolean, boolean, int, int)\n constructor.  In\n that case, this class assumes that the least significant n bits of a sample\n value hold the component value, where n is the number of significant bits\n for the component passed to the constructor.  It also assumes that\n any higher-order bits in a sample value are zero.  Thus, sample values\n range from 0 to 2n - 1.  This class maps these sample values\n to normalized color component values such that 0 maps to the value\n obtained from the ColorSpace's getMinValue\n method for each component and 2n - 1 maps to the value\n obtained from getMaxValue.  To create a\n ComponentColorModel with a different color sample mapping\n requires subclassing this class and overriding the\n getNormalizedComponents(Object, float[], int) method.\n The mapping for an alpha sample always maps 0 to 0.0 and\n 2n - 1 to 1.0.\n \n For instances with unsigned sample values,\n the unnormalized color/alpha component representation is only\n supported if two conditions hold.  First, sample value 0 must\n map to normalized component value 0.0 and sample value 2n - 1\n to 1.0.  Second the min/max range of all color components of the\n ColorSpace must be 0.0 to 1.0.  In this case, the\n component representation is the n least\n significant bits of the corresponding sample.  Thus each component is\n an unsigned integral value between 0 and 2n - 1, where\n n is the number of significant bits for a particular component.\n If these conditions are not met, any method taking an unnormalized\n component argument will throw an IllegalArgumentException.\n \n Instances of ComponentColorModel created with transfer types\n DataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT, and\n DataBuffer.TYPE_DOUBLE have pixel sample values which\n are treated as signed short, float, or double values.\n Such instances do not support the unnormalized color/alpha component\n representation, so any methods taking such a representation as an argument\n will throw an IllegalArgumentException when called on one\n of these instances.  The normalized component values of instances\n of this class have a range which depends on the transfer\n type as follows: for float samples, the full range of the float data\n type; for double samples, the full range of the float data type\n (resulting from casting double to float); for short samples,\n from approximately -maxVal to +maxVal, where maxVal is the per\n component maximum value for the ColorSpace\n (-32767 maps to -maxVal, 0 maps to 0.0, and 32767 maps\n to +maxVal).  A subclass may override the scaling for short sample\n values to normalized component values by overriding the\n getNormalizedComponents(Object, float[], int) method.\n For float and double samples, the normalized component values are\n taken to be equal to the corresponding sample values, and subclasses\n should not attempt to add any non-identity scaling for these transfer\n types.\n \n Instances of ComponentColorModel created with transfer types\n DataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT, and\n DataBuffer.TYPE_DOUBLE\n use all the bits of all sample values.  Thus all color/alpha components\n have 16 bits when using DataBuffer.TYPE_SHORT, 32 bits when\n using DataBuffer.TYPE_FLOAT, and 64 bits when using\n DataBuffer.TYPE_DOUBLE.  When the\n ComponentColorModel(ColorSpace, int[], boolean, boolean, int, int)\n form of constructor is used with one of these transfer types, the\n bits array argument is ignored.\n \n It is possible to have color/alpha sample values\n which cannot be reasonably interpreted as component values for rendering.\n This can happen when ComponentColorModel is subclassed to\n override the mapping of unsigned sample values to normalized color\n component values or when signed sample values outside a certain range\n are used.  (As an example, specifying an alpha component as a signed\n short value outside the range 0 to 32767, normalized range 0.0 to 1.0, can\n lead to unexpected results.) It is the\n responsibility of applications to appropriately scale pixel data before\n rendering such that color components fall within the normalized range\n of the ColorSpace (obtained using the getMinValue\n and getMaxValue methods of the ColorSpace class)\n and the alpha component is between 0.0 and 1.0.  If color or alpha\n component values fall outside these ranges, rendering results are\n indeterminate.\n \n Methods that use a single int pixel representation throw\n an IllegalArgumentException, unless the number of components\n for the ComponentColorModel is one and the component\n value is unsigned -- in other words,  a single color component using\n a transfer type of DataBuffer.TYPE_BYTE,\n DataBuffer.TYPE_USHORT, or DataBuffer.TYPE_INT\n and no alpha.\n \n A ComponentColorModel can be used in conjunction with a\n ComponentSampleModel, a BandedSampleModel,\n or a PixelInterleavedSampleModel to construct a\n BufferedImage.", "codes": ["public class ComponentColorModel\nextends ColorModel"], "fields": [], "methods": [{"method_name": "getRed", "method_sig": "public int getRed (int pixel)", "description": "Returns the red color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion\n is done if necessary.  The pixel value is specified as an int.\n The returned value will be a non pre-multiplied value.\n If the alpha is premultiplied, this method divides\n it out before returning the value (if the alpha value is 0,\n the red value will be 0)."}, {"method_name": "getGreen", "method_sig": "public int getGreen (int pixel)", "description": "Returns the green color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion\n is done if necessary.  The pixel value is specified as an int.\n The returned value will be a non\n pre-multiplied value. If the alpha is premultiplied, this method\n divides it out before returning the value (if the alpha value is 0,\n the green value will be 0)."}, {"method_name": "getBlue", "method_sig": "public int getBlue (int pixel)", "description": "Returns the blue color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion\n is done if necessary.  The pixel value is specified as an int.\n The returned value will be a non\n pre-multiplied value. If the alpha is premultiplied, this method\n divides it out before returning the value (if the alpha value is 0,\n the blue value will be 0)."}, {"method_name": "getAlpha", "method_sig": "public int getAlpha (int pixel)", "description": "Returns the alpha component for the specified pixel, scaled\n from 0 to 255.   The pixel value is specified as an int."}, {"method_name": "getRGB", "method_sig": "public int getRGB (int pixel)", "description": "Returns the color/alpha components of the pixel in the default\n RGB color model format.  A color conversion is done if necessary.\n The returned value will be in a non pre-multiplied format. If\n the alpha is premultiplied, this method divides it out of the\n color components (if the alpha value is 0, the color values will be 0)."}, {"method_name": "getRed", "method_sig": "public int getRed (Object inData)", "description": "Returns the red color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion\n is done if necessary.  The pixel value is specified by an array\n of data elements of type transferType passed in as an object\n reference. The returned value will be a non pre-multiplied value. If the\n alpha is premultiplied, this method divides it out before returning\n the value (if the alpha value is 0, the red value will be 0). Since\n ComponentColorModel can be subclassed, subclasses\n inherit the implementation of this method and if they don't override\n it then they throw an exception if they use an unsupported\n transferType."}, {"method_name": "getGreen", "method_sig": "public int getGreen (Object inData)", "description": "Returns the green color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.\n A color conversion is done if necessary.  The pixel value\n is specified by an array of data elements of type transferType\n passed in as an object reference. The returned value is a non pre-multiplied\n value. If the alpha is premultiplied, this method divides it out before\n returning the value (if the alpha value is 0, the green value will be 0).\n Since ComponentColorModel can be subclassed,\n subclasses inherit the implementation of this method and if they\n don't override it then they throw an exception if they use an\n unsupported transferType."}, {"method_name": "getBlue", "method_sig": "public int getBlue (Object inData)", "description": "Returns the blue color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.\n A color conversion is done if necessary.  The pixel value is\n specified by an array of data elements of type transferType\n passed in as an object reference. The returned value is a non pre-multiplied\n value. If the alpha is premultiplied, this method divides it out before\n returning the value (if the alpha value is 0, the blue value will be 0).\n Since ComponentColorModel can be subclassed,\n subclasses inherit the implementation of this method and if they\n don't override it then they throw an exception if they use an\n unsupported transferType."}, {"method_name": "getAlpha", "method_sig": "public int getAlpha (Object inData)", "description": "Returns the alpha component for the specified pixel, scaled from\n 0 to 255.  The pixel value is specified by an array of data\n elements of type transferType passed in as an\n object reference.  Since ComponentColorModel can be\n subclassed, subclasses inherit the\n implementation of this method and if they don't override it then\n they throw an exception if they use an unsupported\n transferType."}, {"method_name": "getRGB", "method_sig": "public int getRGB (Object inData)", "description": "Returns the color/alpha components for the specified pixel in the\n default RGB color model format.  A color conversion is done if\n necessary.  The pixel value is specified by an\n array of data elements of type transferType passed\n in as an object reference.\n The returned value is in a non pre-multiplied format. If\n the alpha is premultiplied, this method divides it out of the\n color components (if the alpha value is 0, the color values will be 0).\n Since ComponentColorModel can be subclassed,\n subclasses inherit the implementation of this method and if they\n don't override it then they throw an exception if they use an\n unsupported transferType."}, {"method_name": "getDataElements", "method_sig": "public Object getDataElements (int rgb,\n                              Object pixel)", "description": "Returns a data element array representation of a pixel in this\n ColorModel, given an integer pixel representation\n in the default RGB color model.\n This array can then be passed to the setDataElements\n method of a WritableRaster object.  If the\n pixel\n parameter is null, a new array is allocated.  Since\n ComponentColorModel can be subclassed, subclasses\n inherit the implementation of this method and if they don't\n override it then\n they throw an exception if they use an unsupported\n transferType."}, {"method_name": "getComponents", "method_sig": "public int[] getComponents (int pixel,\n                           int[] components,\n                           int offset)", "description": "Returns an array of unnormalized color/alpha components given a pixel\n in this ColorModel.\n An IllegalArgumentException is thrown if the component value for this\n ColorModel is not conveniently representable in the\n unnormalized form.  Color/alpha components are stored\n in the components array starting at offset\n (even if the array is allocated by this method)."}, {"method_name": "getComponents", "method_sig": "public int[] getComponents (Object pixel,\n                           int[] components,\n                           int offset)", "description": "Returns an array of unnormalized color/alpha components given a pixel\n in this ColorModel.  The pixel value is specified by an\n array of data elements of type transferType passed in as\n an object reference.\n An IllegalArgumentException is thrown if the component values for this\n ColorModel are not conveniently representable in the\n unnormalized form.\n Color/alpha components are stored in the components array\n starting at  offset (even if the array is allocated by\n this method).  Since ComponentColorModel can be\n subclassed, subclasses inherit the\n implementation of this method and if they don't override it then\n this method might throw an exception if they use an unsupported\n transferType."}, {"method_name": "getUnnormalizedComponents", "method_sig": "public int[] getUnnormalizedComponents (float[] normComponents,\n                                       int normOffset,\n                                       int[] components,\n                                       int offset)", "description": "Returns an array of all of the color/alpha components in unnormalized\n form, given a normalized component array.  Unnormalized components\n are unsigned integral values between 0 and 2n - 1, where\n n is the number of bits for a particular component.  Normalized\n components are float values between a per component minimum and\n maximum specified by the ColorSpace object for this\n ColorModel.  An IllegalArgumentException\n will be thrown if color component values for this\n ColorModel are not conveniently representable in the\n unnormalized form.  If the\n components array is null, a new array\n will be allocated.  The components array will\n be returned.  Color/alpha components are stored in the\n components array starting at offset (even\n if the array is allocated by this method). An\n ArrayIndexOutOfBoundsException is thrown if the\n components array is not null and is not\n large enough to hold all the color and alpha\n components (starting at offset).  An\n IllegalArgumentException is thrown if the\n normComponents array is not large enough to hold\n all the color and alpha components starting at\n normOffset."}, {"method_name": "getNormalizedComponents", "method_sig": "public float[] getNormalizedComponents (int[] components,\n                                       int offset,\n                                       float[] normComponents,\n                                       int normOffset)", "description": "Returns an array of all of the color/alpha components in normalized\n form, given an unnormalized component array.  Unnormalized components\n are unsigned integral values between 0 and 2n - 1, where\n n is the number of bits for a particular component.  Normalized\n components are float values between a per component minimum and\n maximum specified by the ColorSpace object for this\n ColorModel.  An IllegalArgumentException\n will be thrown if color component values for this\n ColorModel are not conveniently representable in the\n unnormalized form.  If the\n normComponents array is null, a new array\n will be allocated.  The normComponents array\n will be returned.  Color/alpha components are stored in the\n normComponents array starting at\n normOffset (even if the array is allocated by this\n method).  An ArrayIndexOutOfBoundsException is thrown\n if the normComponents array is not null\n and is not large enough to hold all the color and alpha components\n (starting at normOffset).  An\n IllegalArgumentException is thrown if the\n components array is not large enough to hold all the\n color and alpha components starting at offset."}, {"method_name": "getDataElement", "method_sig": "public int getDataElement (int[] components,\n                          int offset)", "description": "Returns a pixel value represented as an int in this ColorModel,\n given an array of unnormalized color/alpha components."}, {"method_name": "getDataElements", "method_sig": "public Object getDataElements (int[] components,\n                              int offset,\n                              Object obj)", "description": "Returns a data element array representation of a pixel in this\n ColorModel, given an array of unnormalized color/alpha\n components. This array can then be passed to the setDataElements\n method of a WritableRaster object."}, {"method_name": "getDataElement", "method_sig": "public int getDataElement (float[] normComponents,\n                          int normOffset)", "description": "Returns a pixel value represented as an int in this\n ColorModel, given an array of normalized color/alpha\n components.  This method will throw an\n IllegalArgumentException if pixel values for this\n ColorModel are not conveniently representable as a\n single int.  An\n ArrayIndexOutOfBoundsException is thrown if  the\n normComponents array is not large enough to hold all the\n color and alpha components (starting at normOffset)."}, {"method_name": "getDataElements", "method_sig": "public Object getDataElements (float[] normComponents,\n                              int normOffset,\n                              Object obj)", "description": "Returns a data element array representation of a pixel in this\n ColorModel, given an array of normalized color/alpha\n components.  This array can then be passed to the\n setDataElements method of a WritableRaster\n object.  An ArrayIndexOutOfBoundsException is thrown\n if the normComponents array is not large enough to hold\n all the color and alpha components (starting at\n normOffset).  If the obj variable is\n null, a new array will be allocated.  If\n obj is not null, it must be a primitive\n array of type transferType; otherwise, a\n ClassCastException is thrown.  An\n ArrayIndexOutOfBoundsException is thrown if\n obj is not large enough to hold a pixel value for this\n ColorModel."}, {"method_name": "getNormalizedComponents", "method_sig": "public float[] getNormalizedComponents (Object pixel,\n                                       float[] normComponents,\n                                       int normOffset)", "description": "Returns an array of all of the color/alpha components in normalized\n form, given a pixel in this ColorModel.  The pixel\n value is specified by an array of data elements of type transferType\n passed in as an object reference.  If pixel is not a primitive array\n of type transferType, a ClassCastException is thrown.\n An ArrayIndexOutOfBoundsException is thrown if\n pixel is not large enough to hold a pixel value for this\n ColorModel.\n Normalized components are float values between a per component minimum\n and maximum specified by the ColorSpace object for this\n ColorModel.  If the\n normComponents array is null, a new array\n will be allocated.  The normComponents array\n will be returned.  Color/alpha components are stored in the\n normComponents array starting at\n normOffset (even if the array is allocated by this\n method).  An ArrayIndexOutOfBoundsException is thrown\n if the normComponents array is not null\n and is not large enough to hold all the color and alpha components\n (starting at normOffset).\n \n This method must be overridden by a subclass if that subclass\n is designed to translate pixel sample values to color component values\n in a non-default way.  The default translations implemented by this\n class is described in the class comments.  Any subclass implementing\n a non-default translation must follow the constraints on allowable\n translations defined there."}, {"method_name": "coerceData", "method_sig": "public ColorModel coerceData (WritableRaster raster,\n                             boolean isAlphaPremultiplied)", "description": "Forces the raster data to match the state specified in the\n isAlphaPremultiplied variable, assuming the data\n is currently correctly described by this ColorModel.\n It may multiply or divide the color raster data by alpha, or\n do nothing if the data is in the correct state.  If the data needs\n to be coerced, this method also returns an instance of\n this ColorModel with\n the isAlphaPremultiplied flag set appropriately.\n Since ColorModel can be subclassed, subclasses inherit\n the implementation of this method and if they don't override it\n then they throw an exception if they use an unsupported\n transferType."}, {"method_name": "isCompatibleRaster", "method_sig": "public boolean isCompatibleRaster (Raster raster)", "description": "Returns true if raster is compatible with this\n ColorModel; false if it is not."}, {"method_name": "createCompatibleWritableRaster", "method_sig": "public WritableRaster createCompatibleWritableRaster (int w,\n                                                     int h)", "description": "Creates a WritableRaster with the specified width and height,\n that  has a data layout (SampleModel) compatible with\n this ColorModel."}, {"method_name": "createCompatibleSampleModel", "method_sig": "public SampleModel createCompatibleSampleModel (int w,\n                                               int h)", "description": "Creates a SampleModel with the specified width and height,\n that  has a data layout compatible with this ColorModel."}, {"method_name": "isCompatibleSampleModel", "method_sig": "public boolean isCompatibleSampleModel (SampleModel sm)", "description": "Checks whether or not the specified SampleModel\n is compatible with this ColorModel."}, {"method_name": "getAlphaRaster", "method_sig": "public WritableRaster getAlphaRaster (WritableRaster raster)", "description": "Returns a Raster representing the alpha channel of an image,\n extracted from the input Raster.\n This method assumes that Raster objects associated with\n this ColorModel store the alpha band, if present, as\n the last band of image data. Returns null if there is no separate spatial\n alpha channel associated with this ColorModel.\n This method creates a new Raster, but will share the data\n array."}, {"method_name": "equals", "method_sig": "public boolean equals (Object obj)", "description": "Tests if the specified Object is an instance\n of ComponentColorModel and equals this\n ComponentColorModel."}, {"method_name": "hashCode", "method_sig": "public int hashCode()", "description": "Returns the hash code for this ComponentColorModel."}]}