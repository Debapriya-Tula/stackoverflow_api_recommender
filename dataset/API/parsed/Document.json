{"name": "Interface Document", "module": "java.desktop", "package": "javax.swing.text", "text": "\n The Document is a container for text that serves\n as the model for swing text components.  The goal for this\n interface is to scale from very simple needs (a plain text textfield)\n to complex needs (an HTML or XML document, for example).\n\n Content\n\n At the simplest level, text can be\n modeled as a linear sequence of characters. To support\n internationalization, the Swing text model uses\n unicode characters.\n The sequence of characters displayed in a text component is\n generally referred to as the component's content.\n \n To refer to locations within the sequence, the coordinates\n used are the location between two characters.  As the diagram\n below shows, a location in a text document can be referred to\n as a position, or an offset. This position is zero-based.\n \n\n In the example, if the content of a document is the\n sequence \"The quick brown fox,\" as shown in the preceding diagram,\n the location just before the word \"The\" is 0, and the location after\n the word \"The\" and before the whitespace that follows it is 3.\n The entire sequence of characters in the sequence \"The\" is called a\n range.\n The following methods give access to the character data\n that makes up the content.\n \ngetLength()\ngetText(int, int)\ngetText(int, int, javax.swing.text.Segment)\n\nStructure\n\n Text is rarely represented simply as featureless content. Rather,\n text typically has some sort of structure associated with it.\n Exactly what structure is modeled is up to a particular Document\n implementation.  It might be as simple as no structure (i.e. a\n simple text field), or it might be something like diagram below.\n \n\n The unit of structure (i.e. a node of the tree) is referred to\n by the Element interface.  Each Element\n can be tagged with a set of attributes.  These attributes\n (name/value pairs) are defined by the\n AttributeSet interface.\n The following methods give access to the document structure.\n \ngetDefaultRootElement()\ngetRootElements()\n\nMutations\n\n All documents need to be able to add and remove simple text.\n Typically, text is inserted and removed via gestures from\n a keyboard or a mouse.  What effect the insertion or removal\n has upon the document structure is entirely up to the\n implementation of the document.\n The following methods are related to mutation of the\n document content:\n \ninsertString(int, java.lang.String, javax.swing.text.AttributeSet)\nremove(int, int)\ncreatePosition(int)\n\nNotification\n\n Mutations to the Document must be communicated to\n interested observers.  The notification of change follows the event model\n guidelines that are specified for JavaBeans.  In the JavaBeans\n event model, once an event notification is dispatched, all listeners\n must be notified before any further mutations occur to the source\n of the event.  Further, order of delivery is not guaranteed.\n \n Notification is provided as two separate events,\n DocumentEvent, and\n UndoableEditEvent.\n If a mutation is made to a Document through its api,\n a DocumentEvent will be sent to all of the registered\n DocumentListeners.  If the Document\n implementation supports undo/redo capabilities, an\n UndoableEditEvent will be sent\n to all of the registered UndoableEditListeners.\n If an undoable edit is undone, a DocumentEvent should be\n fired from the Document to indicate it has changed again.\n In this case however, there should be no UndoableEditEvent\n generated since that edit is actually the source of the change\n rather than a mutation to the Document made through its\n api.\n \n\n Referring to the above diagram, suppose that the component shown\n on the left mutates the document object represented by the blue\n rectangle. The document responds by dispatching a DocumentEvent to\n both component views and sends an UndoableEditEvent to the listening\n logic, which maintains a history buffer.\n \n Now suppose that the component shown on the right mutates the same\n document.  Again, the document dispatches a DocumentEvent to both\n component views and sends an UndoableEditEvent to the listening logic\n that is maintaining the history buffer.\n \n If the history buffer is then rolled back (i.e. the last UndoableEdit\n undone), a DocumentEvent is sent to both views, causing both of them to\n reflect the undone mutation to the document (that is, the\n removal of the right component's mutation). If the history buffer again\n rolls back another change, another DocumentEvent is sent to both views,\n causing them to reflect the undone mutation to the document -- that is,\n the removal of the left component's mutation.\n \n The methods related to observing mutations to the document are:\n \naddDocumentListener(DocumentListener)\nremoveDocumentListener(DocumentListener)\naddUndoableEditListener(UndoableEditListener)\nremoveUndoableEditListener(UndoableEditListener)\n\nProperties\n\n Document implementations will generally have some set of properties\n associated with them at runtime.  Two well known properties are the\n StreamDescriptionProperty,\n which can be used to describe where the Document came from,\n and the TitleProperty, which can be used to\n name the Document.  The methods related to the properties are:\n \ngetProperty(java.lang.Object)\nputProperty(java.lang.Object, java.lang.Object)\n\nFor more information on the Document class, see\n The Swing Connection\n and most particularly the article,\n \n The Element Interface.", "codes": ["public interface Document"], "fields": [{"field_name": "StreamDescriptionProperty", "field_sig": "static final\u00a0String StreamDescriptionProperty", "description": "The property name for the description of the stream\n used to initialize the document.  This should be used\n if the document was initialized from a stream and\n anything is known about the stream."}, {"field_name": "TitleProperty", "field_sig": "static final\u00a0String TitleProperty", "description": "The property name for the title of the document, if\n there is one."}], "methods": [{"method_name": "getLength", "method_sig": "int getLength()", "description": "Returns number of characters of content currently\n in the document."}, {"method_name": "addDocumentListener", "method_sig": "void addDocumentListener (DocumentListener listener)", "description": "Registers the given observer to begin receiving notifications\n when changes are made to the document."}, {"method_name": "removeDocumentListener", "method_sig": "void removeDocumentListener (DocumentListener listener)", "description": "Unregisters the given observer from the notification list\n so it will no longer receive change updates."}, {"method_name": "addUndoableEditListener", "method_sig": "void addUndoableEditListener (UndoableEditListener listener)", "description": "Registers the given observer to begin receiving notifications\n when undoable edits are made to the document."}, {"method_name": "removeUndoableEditListener", "method_sig": "void removeUndoableEditListener (UndoableEditListener listener)", "description": "Unregisters the given observer from the notification list\n so it will no longer receive updates."}, {"method_name": "getProperty", "method_sig": "Object getProperty (Object key)", "description": "Gets the properties associated with the document."}, {"method_name": "putProperty", "method_sig": "void putProperty (Object key,\n                 Object value)", "description": "Associates a property with the document.  Two standard\n property keys provided are: \nStreamDescriptionProperty and\n TitleProperty.\n Other properties, such as author, may also be defined."}, {"method_name": "remove", "method_sig": "void remove (int offs,\n            int len)\n     throws BadLocationException", "description": "Removes a portion of the content of the document.\n This will cause a DocumentEvent of type\n DocumentEvent.EventType.REMOVE to be sent to the\n registered DocumentListeners, unless an exception\n is thrown.  The notification will be sent to the\n listeners by calling the removeUpdate method on the\n DocumentListeners.\n \n To ensure reasonable behavior in the face\n of concurrency, the event is dispatched after the\n mutation has occurred. This means that by the time a\n notification of removal is dispatched, the document\n has already been updated and any marks created by\n createPosition have already changed.\n For a removal, the end of the removal range is collapsed\n down to the start of the range, and any marks in the removal\n range are collapsed down to the start of the range.\n \n\n If the Document structure changed as result of the removal,\n the details of what Elements were inserted and removed in\n response to the change will also be contained in the generated\n DocumentEvent. It is up to the implementation of a Document\n to decide how the structure should change in response to a\n remove.\n \n If the Document supports undo/redo, an UndoableEditEvent will\n also be generated."}, {"method_name": "insertString", "method_sig": "void insertString (int offset,\n                  String str,\n                  AttributeSet a)\n           throws BadLocationException", "description": "Inserts a string of content.  This will cause a DocumentEvent\n of type DocumentEvent.EventType.INSERT to be sent to the\n registered DocumentListers, unless an exception is thrown.\n The DocumentEvent will be delivered by calling the\n insertUpdate method on the DocumentListener.\n The offset and length of the generated DocumentEvent\n will indicate what change was actually made to the Document.\n \n\n If the Document structure changed as result of the insertion,\n the details of what Elements were inserted and removed in\n response to the change will also be contained in the generated\n DocumentEvent.  It is up to the implementation of a Document\n to decide how the structure should change in response to an\n insertion.\n \n If the Document supports undo/redo, an UndoableEditEvent will\n also be generated."}, {"method_name": "getText", "method_sig": "String getText (int offset,\n               int length)\n        throws BadLocationException", "description": "Fetches the text contained within the given portion\n of the document."}, {"method_name": "getText", "method_sig": "void getText (int offset,\n             int length,\n             Segment txt)\n      throws BadLocationException", "description": "Fetches the text contained within the given portion\n of the document.\n \n If the partialReturn property on the txt parameter is false, the\n data returned in the Segment will be the entire length requested and\n may or may not be a copy depending upon how the data was stored.\n If the partialReturn property is true, only the amount of text that\n can be returned without creating a copy is returned.  Using partial\n returns will give better performance for situations where large\n parts of the document are being scanned.  The following is an example\n of using the partial return to access the entire document:\n\n \n\n \u00a0 int nleft = doc.getDocumentLength();\n \u00a0 Segment text = new Segment();\n \u00a0 int offs = 0;\n \u00a0 text.setPartialReturn(true);\n \u00a0 while (nleft > 0) {\n \u00a0     doc.getText(offs, nleft, text);\n \u00a0     // do someting with text\n \u00a0     nleft -= text.count;\n \u00a0     offs += text.count;\n \u00a0 }\n\n "}, {"method_name": "getStartPosition", "method_sig": "Position getStartPosition()", "description": "Returns a position that represents the start of the document.  The\n position returned can be counted on to track change and stay\n located at the beginning of the document."}, {"method_name": "getEndPosition", "method_sig": "Position getEndPosition()", "description": "Returns a position that represents the end of the document.  The\n position returned can be counted on to track change and stay\n located at the end of the document."}, {"method_name": "createPosition", "method_sig": "Position createPosition (int offs)\n                 throws BadLocationException", "description": "This method allows an application to mark a place in\n a sequence of character content. This mark can then be\n used to tracks change as insertions and removals are made\n in the content. The policy is that insertions always\n occur prior to the current position (the most common case)\n unless the insertion location is zero, in which case the\n insertion is forced to a position that follows the\n original position."}, {"method_name": "getRootElements", "method_sig": "Element[] getRootElements()", "description": "Returns all of the root elements that are defined.\n \n Typically there will be only one document structure, but the interface\n supports building an arbitrary number of structural projections over the\n text data. The document can have multiple root elements to support\n multiple document structures.  Some examples might be:\n \n\nText direction.\n Lexical token streams.\n Parse trees.\n Conversions to formats other than the native format.\n Modification specifications.\n Annotations.\n "}, {"method_name": "getDefaultRootElement", "method_sig": "Element getDefaultRootElement()", "description": "Returns the root element that views should be based upon,\n unless some other mechanism for assigning views to element\n structures is provided."}, {"method_name": "render", "method_sig": "void render (Runnable r)", "description": "Allows the model to be safely rendered in the presence\n of concurrency, if the model supports being updated asynchronously.\n The given runnable will be executed in a way that allows it\n to safely read the model with no changes while the runnable\n is being executed.  The runnable itself may not\n make any mutations."}]}