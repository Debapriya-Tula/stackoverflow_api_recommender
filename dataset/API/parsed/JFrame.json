{"name": "Class JFrame", "module": "java.desktop", "package": "javax.swing", "text": "An extended version of java.awt.Frame that adds support for\n the JFC/Swing component architecture.\n You can find task-oriented documentation about using JFrame\n in The Java Tutorial, in the section\n How to Make Frames.\n\n \n The JFrame class is slightly incompatible with Frame.\n Like all other JFC/Swing top-level containers,\n a JFrame contains a JRootPane as its only child.\n The content pane provided by the root pane should,\n as a rule, contain\n all the non-menu components displayed by the JFrame.\n This is different from the AWT Frame case.\n As a convenience, the add, remove, and setLayout\n methods of this class are overridden, so that they delegate calls\n to the corresponding methods of the ContentPane.\n For example, you can add a child component to a frame as follows:\n \n       frame.add(child);\n \n And the child will be added to the contentPane.\n The content pane will\n always be non-null. Attempting to set it to null will cause the JFrame\n to throw an exception. The default content pane will have a BorderLayout\n manager set on it.\n Refer to RootPaneContainer\n for details on adding, removing and setting the LayoutManager\n of a JFrame.\n \n Unlike a Frame, a JFrame has some notion of how to\n respond when the user attempts to close the window. The default behavior\n is to simply hide the JFrame when the user closes the window. To change the\n default behavior, you invoke the method\n setDefaultCloseOperation(int).\n To make the JFrame behave the same as a Frame\n instance, use\n setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE).\n \n For more information on content panes\n and other features that root panes provide,\n see Using Top-Level Containers in The Java Tutorial.\n \n In a multi-screen environment, you can create a JFrame\n on a different screen device.  See Frame for more\n information.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans\u2122\n has been added to the java.beans package.\n Please see XMLEncoder.", "codes": ["@JavaBean(defaultProperty=\"JMenuBar\",\n          description=\"A toplevel window which can be minimized to an icon.\")\npublic class JFrame\nextends Frame\nimplements WindowConstants, Accessible, RootPaneContainer"], "fields": [{"field_name": "rootPane", "field_sig": "protected\u00a0JRootPane rootPane", "description": "The JRootPane instance that manages the\n contentPane\n and optional menuBar for this frame, as well as the\n glassPane."}, {"field_name": "rootPaneCheckingEnabled", "field_sig": "protected\u00a0boolean rootPaneCheckingEnabled", "description": "If true then calls to add and setLayout\n will be forwarded to the contentPane. This is initially\n false, but is set to true when the JFrame is constructed."}, {"field_name": "accessibleContext", "field_sig": "protected\u00a0AccessibleContext accessibleContext", "description": "The accessible context property."}], "methods": [{"method_name": "frameInit", "method_sig": "protected void frameInit()", "description": "Called by the constructors to init the JFrame properly."}, {"method_name": "createRootPane", "method_sig": "protected JRootPane createRootPane()", "description": "Called by the constructor methods to create the default\n rootPane."}, {"method_name": "processWindowEvent", "method_sig": "protected void processWindowEvent (WindowEvent e)", "description": "Processes window events occurring on this component.\n Hides the window or disposes of it, as specified by the setting\n of the defaultCloseOperation property."}, {"method_name": "setDefaultCloseOperation", "method_sig": "@BeanProperty(preferred=true,\n              enumerationValues={\"WindowConstants.DO_NOTHING_ON_CLOSE\",\"WindowConstants.HIDE_ON_CLOSE\",\"WindowConstants.DISPOSE_ON_CLOSE\",\"WindowConstants.EXIT_ON_CLOSE\"},\n              description=\"The frame\\'s default close operation.\")\npublic void setDefaultCloseOperation (int operation)", "description": "Sets the operation that will happen by default when\n the user initiates a \"close\" on this frame.\n You must specify one of the following choices:\n \n\nDO_NOTHING_ON_CLOSE\n (defined in WindowConstants):\n Don't do anything; require the\n program to handle the operation in the windowClosing\n method of a registered WindowListener object.\n\n HIDE_ON_CLOSE\n (defined in WindowConstants):\n Automatically hide the frame after\n invoking any registered WindowListener\n objects.\n\n DISPOSE_ON_CLOSE\n (defined in WindowConstants):\n Automatically hide and dispose the\n frame after invoking any registered WindowListener\n objects.\n\n EXIT_ON_CLOSE\n (defined in WindowConstants):\n Exit the application using the System\nexit method.  Use this only in applications.\n \n\n The value is set to HIDE_ON_CLOSE by default. Changes\n to the value of this property cause the firing of a property\n change event, with property name \"defaultCloseOperation\".\n \nNote: When the last displayable window within the\n Java virtual machine (VM) is disposed of, the VM may\n terminate.  See \n AWT Threading Issues for more information."}, {"method_name": "getDefaultCloseOperation", "method_sig": "public int getDefaultCloseOperation()", "description": "Returns the operation that occurs when the user\n initiates a \"close\" on this frame."}, {"method_name": "setTransferHandler", "method_sig": "@BeanProperty(hidden=true,\n              description=\"Mechanism for transfer of data into the component\")\npublic void setTransferHandler (TransferHandler newHandler)", "description": "Sets the transferHandler property, which is a mechanism to\n support transfer of data into this component. Use null\n if the component does not support data transfer operations.\n \n If the system property suppressSwingDropSupport is false\n (the default) and the current drop target on this component is either\n null or not a user-set drop target, this method will change the\n drop target as follows: If newHandler is null it will\n clear the drop target. If not null it will install a new\n DropTarget.\n \n Note: When used with JFrame, TransferHandler only\n provides data import capability, as the data export related methods\n are currently typed to JComponent.\n \n Please see\n \n How to Use Drag and Drop and Data Transfer, a section in\n The Java Tutorial, for more information."}, {"method_name": "getTransferHandler", "method_sig": "public TransferHandler getTransferHandler()", "description": "Gets the transferHandler property."}, {"method_name": "update", "method_sig": "public void update (Graphics g)", "description": "Just calls paint(g).  This method was overridden to\n prevent an unnecessary call to clear the background."}, {"method_name": "setJMenuBar", "method_sig": "@BeanProperty(bound=false,\n              hidden=true,\n              description=\"The menubar for accessing pulldown menus from this frame.\")\npublic void setJMenuBar (JMenuBar menubar)", "description": "Sets the menubar for this frame."}, {"method_name": "getJMenuBar", "method_sig": "public JMenuBar getJMenuBar()", "description": "Returns the menubar set on this frame."}, {"method_name": "isRootPaneCheckingEnabled", "method_sig": "protected boolean isRootPaneCheckingEnabled()", "description": "Returns whether calls to add and\n setLayout are forwarded to the contentPane."}, {"method_name": "setRootPaneCheckingEnabled", "method_sig": "@BeanProperty(hidden=true,\n              description=\"Whether the add and setLayout methods are forwarded\")\nprotected void setRootPaneCheckingEnabled (boolean enabled)", "description": "Sets whether calls to add and\n setLayout are forwarded to the contentPane."}, {"method_name": "addImpl", "method_sig": "protected void addImpl (Component comp,\n                       Object constraints,\n                       int index)", "description": "Adds the specified child Component.\n This method is overridden to conditionally forward calls to the\n contentPane.\n By default, children are added to the contentPane instead\n of the frame, refer to RootPaneContainer for\n details."}, {"method_name": "remove", "method_sig": "public void remove (Component comp)", "description": "Removes the specified component from the container. If\n comp is not the rootPane, this will forward\n the call to the contentPane. This will do nothing if\n comp is not a child of the JFrame or\n contentPane."}, {"method_name": "setLayout", "method_sig": "public void setLayout (LayoutManager manager)", "description": "Sets the LayoutManager.\n Overridden to conditionally forward the call to the\n contentPane.\n Refer to RootPaneContainer for\n more information."}, {"method_name": "getRootPane", "method_sig": "@BeanProperty(bound=false,\n              hidden=true,\n              description=\"the RootPane object for this frame.\")\npublic JRootPane getRootPane()", "description": "Returns the rootPane object for this frame."}, {"method_name": "setRootPane", "method_sig": "protected void setRootPane (JRootPane root)", "description": "Sets the rootPane property.\n This method is called by the constructor."}, {"method_name": "getContentPane", "method_sig": "public Container getContentPane()", "description": "Returns the contentPane object for this frame."}, {"method_name": "setContentPane", "method_sig": "@BeanProperty(bound=false,\n              hidden=true,\n              description=\"The client area of the frame where child components are normally inserted.\")\npublic void setContentPane (Container contentPane)", "description": "Sets the contentPane property.\n This method is called by the constructor.\n \n Swing's painting architecture requires an opaque JComponent\n in the containment hierarchy. This is typically provided by the\n content pane. If you replace the content pane it is recommended you\n replace it with an opaque JComponent."}, {"method_name": "getLayeredPane", "method_sig": "public JLayeredPane getLayeredPane()", "description": "Returns the layeredPane object for this frame."}, {"method_name": "setLayeredPane", "method_sig": "@BeanProperty(bound=false,\n              hidden=true,\n              description=\"The pane that holds the various frame layers.\")\npublic void setLayeredPane (JLayeredPane layeredPane)", "description": "Sets the layeredPane property.\n This method is called by the constructor."}, {"method_name": "getGlassPane", "method_sig": "public Component getGlassPane()", "description": "Returns the glassPane object for this frame."}, {"method_name": "setGlassPane", "method_sig": "@BeanProperty(bound=false,\n              hidden=true,\n              description=\"A transparent pane used for menu rendering.\")\npublic void setGlassPane (Component glassPane)", "description": "Sets the glassPane property.\n This method is called by the constructor."}, {"method_name": "getGraphics", "method_sig": "@BeanProperty(bound=false)\npublic Graphics getGraphics()", "description": "Creates a graphics context for this component. This method will\n return null if this component is currently not\n displayable."}, {"method_name": "repaint", "method_sig": "public void repaint (long time,\n                    int x,\n                    int y,\n                    int width,\n                    int height)", "description": "Repaints the specified rectangle of this component within\n time milliseconds.  Refer to RepaintManager\n for details on how the repaint is handled."}, {"method_name": "setDefaultLookAndFeelDecorated", "method_sig": "public static void setDefaultLookAndFeelDecorated (boolean defaultLookAndFeelDecorated)", "description": "Provides a hint as to whether or not newly created JFrames\n should have their Window decorations (such as borders, widgets to\n close the window, title...) provided by the current look\n and feel. If defaultLookAndFeelDecorated is true,\n the current LookAndFeel supports providing window\n decorations, and the current window manager supports undecorated\n windows, then newly created JFrames will have their\n Window decorations provided by the current LookAndFeel.\n Otherwise, newly created JFrames will have their\n Window decorations provided by the current window manager.\n \n You can get the same effect on a single JFrame by doing the following:\n \n    JFrame frame = new JFrame();\n    frame.setUndecorated(true);\n    frame.getRootPane().setWindowDecorationStyle(JRootPane.FRAME);\n "}, {"method_name": "isDefaultLookAndFeelDecorated", "method_sig": "public static boolean isDefaultLookAndFeelDecorated()", "description": "Returns true if newly created JFrames should have their\n Window decorations provided by the current look and feel. This is only\n a hint, as certain look and feels may not support this feature."}, {"method_name": "paramString", "method_sig": "protected String paramString()", "description": "Returns a string representation of this JFrame.\n This method\n is intended to be used only for debugging purposes, and the\n content and format of the returned string may vary between\n implementations. The returned string may be empty but may not\n be null."}, {"method_name": "getAccessibleContext", "method_sig": "public AccessibleContext getAccessibleContext()", "description": "Gets the AccessibleContext associated with this JFrame.\n For JFrames, the AccessibleContext takes the form of an\n AccessibleJFrame.\n A new AccessibleJFrame instance is created if necessary."}]}