{"name": "Class Module", "module": "java.base", "package": "java.lang", "text": "Represents a run-time module, either named or unnamed.\n\n  Named modules have a name and are constructed by the\n Java Virtual Machine when a graph of modules is defined to the Java virtual\n machine to create a module layer. \n An unnamed module does not have a name. There is an unnamed module for\n each ClassLoader, obtained by invoking its getUnnamedModule method. All types that are\n not in a named module are members of their defining class loader's unnamed\n module. \n The package names that are parameters or returned by methods defined in\n this class are the fully-qualified names of the packages as defined in\n section 6.5.3 of The Java\u2122 Language Specification, for\n example, \"java.lang\". \n Unless otherwise specified, passing a null argument to a method\n in this class causes a NullPointerException to\n be thrown. ", "codes": ["public final class Module\nextends Object\nimplements AnnotatedElement"], "fields": [], "methods": [{"method_name": "isNamed", "method_sig": "public boolean isNamed()", "description": "Returns true if this module is a named module."}, {"method_name": "getName", "method_sig": "public String getName()", "description": "Returns the module name or null if this module is an unnamed\n module."}, {"method_name": "getClassLoader", "method_sig": "public ClassLoader getClassLoader()", "description": "Returns the ClassLoader for this module.\n\n  If there is a security manager then its checkPermission\n method if first called with a RuntimePermission(\"getClassLoader\")\n permission to check that the caller is allowed to get access to the\n class loader. "}, {"method_name": "getDescriptor", "method_sig": "public ModuleDescriptor getDescriptor()", "description": "Returns the module descriptor for this module or null if this\n module is an unnamed module."}, {"method_name": "getLayer", "method_sig": "public ModuleLayer getLayer()", "description": "Returns the module layer that contains this module or null if\n this module is not in a module layer.\n\n A module layer contains named modules and therefore this method always\n returns null when invoked on an unnamed module.\n\n  Dynamic modules are\n named modules that are generated at runtime. A dynamic module may or may\n not be in a module layer. "}, {"method_name": "canRead", "method_sig": "public boolean canRead (Module other)", "description": "Indicates if this module reads the given module. This method returns\n true if invoked to test if this module reads itself. It also\n returns true if invoked on an unnamed module (as unnamed\n modules read all modules)."}, {"method_name": "addReads", "method_sig": "public Module addReads (Module other)", "description": "If the caller's module is this module then update this module to read\n the given module.\n\n This method is a no-op if other is this module (all modules read\n themselves), this module is an unnamed module (as unnamed modules read\n all modules), or this module already reads other."}, {"method_name": "isExported", "method_sig": "public boolean isExported (String pn,\n                          Module other)", "description": "Returns true if this module exports the given package to at\n least the given module.\n\n  This method returns true if invoked to test if a package in\n this module is exported to itself. It always returns true when\n invoked on an unnamed module. A package that is open to\n the given module is considered exported to that module at run-time and\n so this method returns true if the package is open to the given\n module. \n This method does not check if the given module reads this module. "}, {"method_name": "isOpen", "method_sig": "public boolean isOpen (String pn,\n                      Module other)", "description": "Returns true if this module has opened a package to at\n least the given module.\n\n  This method returns true if invoked to test if a package in\n this module is open to itself. It returns true when invoked on an\n open module with a package in the module.\n It always returns true when invoked on an unnamed module. \n This method does not check if the given module reads this module. "}, {"method_name": "isExported", "method_sig": "public boolean isExported (String pn)", "description": "Returns true if this module exports the given package\n unconditionally.\n\n  This method always returns true when invoked on an unnamed\n module. A package that is opened unconditionally\n is considered exported unconditionally at run-time and so this method\n returns true if the package is opened unconditionally. \n This method does not check if the given module reads this module. "}, {"method_name": "isOpen", "method_sig": "public boolean isOpen (String pn)", "description": "Returns true if this module has opened a package\n unconditionally.\n\n  This method always returns true when invoked on an unnamed\n module. Additionally, it always returns true when invoked on an\n open module with a package in the\n module. \n This method does not check if the given module reads this module. "}, {"method_name": "addExports", "method_sig": "public Module addExports (String pn,\n                         Module other)", "description": "If the caller's module is this module then update this module to export\n the given package to the given module.\n\n  This method has no effect if the package is already exported (or\n open) to the given module. "}, {"method_name": "addOpens", "method_sig": "public Module addOpens (String pn,\n                       Module other)", "description": "If this module has opened a package to at least the caller\n module then update this module to open the package to the given module.\n Opening a package with this method allows all types in the package,\n and all their members, not just public types and their public members,\n to be reflected on by the given module when using APIs that support\n private access or a way to bypass or suppress default Java language\n access control checks.\n\n  This method has no effect if the package is already open\n to the given module. "}, {"method_name": "addUses", "method_sig": "public Module addUses (Class<?> service)", "description": "If the caller's module is this module then update this module to add a\n service dependence on the given service type. This method is intended\n for use by frameworks that invoke ServiceLoader on behalf of other modules or where the framework is\n passed a reference to the service type by other code. This method is\n a no-op when invoked on an unnamed module or an automatic module.\n\n  This method does not cause resolveAndBind to be re-run. "}, {"method_name": "canUse", "method_sig": "public boolean canUse (Class<?> service)", "description": "Indicates if this module has a service dependence on the given service\n type. This method always returns true when invoked on an unnamed\n module or an automatic module."}, {"method_name": "getPackages", "method_sig": "public Set<String> getPackages()", "description": "Returns the set of package names for the packages in this module.\n\n  For named modules, the returned set contains an element for each\n package in the module. \n For unnamed modules, this method is the equivalent to invoking the\n getDefinedPackages method of\n this module's class loader and returning the set of package names. "}, {"method_name": "getAnnotation", "method_sig": "public <T extends Annotation> T getAnnotation (Class<T> annotationClass)", "description": "Returns this element's annotation for the specified type if\n such an annotation is present, else null.\n This method returns null when invoked on an unnamed module."}, {"method_name": "getAnnotations", "method_sig": "public Annotation[] getAnnotations()", "description": "Returns annotations that are present on this element.\n\n If there are no annotations present on this element, the return\n value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n This method returns an empty array when invoked on an unnamed module."}, {"method_name": "getDeclaredAnnotations", "method_sig": "public Annotation[] getDeclaredAnnotations()", "description": "Returns annotations that are directly present on this element.\n This method ignores inherited annotations.\n\n If there are no annotations directly present on this element,\n the return value is an array of length 0.\n\n The caller of this method is free to modify the returned array; it will\n have no effect on the arrays returned to other callers.\n This method returns an empty array when invoked on an unnamed module."}, {"method_name": "getResourceAsStream", "method_sig": "public InputStream getResourceAsStream (String name)\n                                throws IOException", "description": "Returns an input stream for reading a resource in this module.\n The name parameter is a '/'-separated path name that\n identifies the resource. As with Class.getResourceAsStream, this method delegates to the module's class\n loader findResource(String,String) method, invoking it with the module name\n (or null when the module is unnamed) and the name of the\n resource. If the resource name has a leading slash then it is dropped\n before delegation.\n\n  A resource in a named module may be encapsulated so that\n it cannot be located by code in other modules. Whether a resource can be\n located or not is determined as follows: \n\n If the resource name ends with  \".class\" then it is not\n     encapsulated. \n A package name is derived from the resource name. If\n     the package name is a package in the\n     module then the resource can only be located by the caller of this\n     method when the package is open\n     to at least the caller's module. If the resource is not in a\n     package in the module then the resource is not encapsulated. \n\n In the above, the package name for a resource is derived\n from the subsequence of characters that precedes the last '/' in\n the name and then replacing each '/' character in the subsequence\n with '.'. A leading slash is ignored when deriving the package\n name. As an example, the package name derived for a resource named\n \"a/b/c/foo.properties\" is \"a.b.c\". A resource name\n with the name \"META-INF/MANIFEST.MF\" is never encapsulated\n because \"META-INF\" is not a legal package name. \n This method returns null if the resource is not in this\n module, the resource is encapsulated and cannot be located by the caller,\n or access to the resource is denied by the security manager. "}, {"method_name": "toString", "method_sig": "public String toString()", "description": "Returns the string representation of this module. For a named module,\n the representation is the string \"module\", followed by a space,\n and then the module name. For an unnamed module, the representation is\n the string \"unnamed module\", followed by a space, and then an\n implementation specific string that identifies the unnamed module."}]}