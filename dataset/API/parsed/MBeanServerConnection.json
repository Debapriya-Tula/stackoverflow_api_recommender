{"name": "Interface MBeanServerConnection", "module": "java.management", "package": "javax.management", "text": "This interface represents a way to talk to an MBean server, whether\n local or remote.  The MBeanServer interface, representing a\n local MBean server, extends this interface.", "codes": ["public interface MBeanServerConnection"], "fields": [], "methods": [{"method_name": "createMBean", "method_sig": "ObjectInstance createMBean (String className,\n                           ObjectName name)\n                    throws ReflectionException,\n                           InstanceAlreadyExistsException,\n                           MBeanRegistrationException,\n                           MBeanException,\n                           NotCompliantMBeanException,\n                           IOException", "description": "Instantiates and registers an MBean in the MBean server.  The\n MBean server will use its Default Loader\n Repository to load the class of the MBean.  An object name is\n associated with the MBean.  If the object name given is null, the\n MBean must provide its own name by implementing the MBeanRegistration interface\n and returning the name from the preRegister method.\nThis method is equivalent to createMBean(className, name, (Object[]) null, (String[])\n null)."}, {"method_name": "createMBean", "method_sig": "ObjectInstance createMBean (String className,\n                           ObjectName name,\n                           ObjectName loaderName)\n                    throws ReflectionException,\n                           InstanceAlreadyExistsException,\n                           MBeanRegistrationException,\n                           MBeanException,\n                           NotCompliantMBeanException,\n                           InstanceNotFoundException,\n                           IOException", "description": "Instantiates and registers an MBean in the MBean server.  The\n class loader to be used is identified by its object name. An\n object name is associated with the MBean. If the object name of\n the loader is null, the ClassLoader that loaded the MBean\n server will be used.  If the MBean's object name given is null,\n the MBean must provide its own name by implementing the MBeanRegistration interface\n and returning the name from the preRegister method.\nThis method is equivalent to createMBean(className, name, loaderName, (Object[]) null,\n (String[]) null)."}, {"method_name": "createMBean", "method_sig": "ObjectInstance createMBean (String className,\n                           ObjectName name,\n                           Object[] params,\n                           String[] signature)\n                    throws ReflectionException,\n                           InstanceAlreadyExistsException,\n                           MBeanRegistrationException,\n                           MBeanException,\n                           NotCompliantMBeanException,\n                           IOException", "description": "Instantiates and registers an MBean in the MBean server.  The\n MBean server will use its Default Loader\n Repository to load the class of the MBean.  An object name is\n associated with the MBean.  If the object name given is null, the\n MBean must provide its own name by implementing the MBeanRegistration interface\n and returning the name from the preRegister method."}, {"method_name": "createMBean", "method_sig": "ObjectInstance createMBean (String className,\n                           ObjectName name,\n                           ObjectName loaderName,\n                           Object[] params,\n                           String[] signature)\n                    throws ReflectionException,\n                           InstanceAlreadyExistsException,\n                           MBeanRegistrationException,\n                           MBeanException,\n                           NotCompliantMBeanException,\n                           InstanceNotFoundException,\n                           IOException", "description": "Instantiates and registers an MBean in the MBean server.  The\n class loader to be used is identified by its object name. An\n object name is associated with the MBean. If the object name of\n the loader is not specified, the ClassLoader that loaded the\n MBean server will be used.  If the MBean object name given is\n null, the MBean must provide its own name by implementing the\n MBeanRegistration\n interface and returning the name from the preRegister method."}, {"method_name": "unregisterMBean", "method_sig": "void unregisterMBean (ObjectName name)\n              throws InstanceNotFoundException,\n                     MBeanRegistrationException,\n                     IOException", "description": "Unregisters an MBean from the MBean server. The MBean is\n identified by its object name. Once the method has been\n invoked, the MBean may no longer be accessed by its object\n name."}, {"method_name": "getObjectInstance", "method_sig": "ObjectInstance getObjectInstance (ObjectName name)\n                          throws InstanceNotFoundException,\n                                 IOException", "description": "Gets the ObjectInstance for a given MBean\n registered with the MBean server."}, {"method_name": "queryMBeans", "method_sig": "Set<ObjectInstance> queryMBeans (ObjectName name,\n                                QueryExp query)\n                         throws IOException", "description": "Gets MBeans controlled by the MBean server. This method allows\n any of the following to be obtained: All MBeans, a set of\n MBeans specified by pattern matching on the\n ObjectName and/or a Query expression, a specific\n MBean. When the object name is null or no domain and key\n properties are specified, all objects are to be selected (and\n filtered if a query is specified). It returns the set of\n ObjectInstance objects (containing the\n ObjectName and the Java Class name) for the\n selected MBeans."}, {"method_name": "queryNames", "method_sig": "Set<ObjectName> queryNames (ObjectName name,\n                           QueryExp query)\n                    throws IOException", "description": "Gets the names of MBeans controlled by the MBean server. This\n method enables any of the following to be obtained: The names\n of all MBeans, the names of a set of MBeans specified by\n pattern matching on the ObjectName and/or a Query\n expression, a specific MBean name (equivalent to testing\n whether an MBean is registered). When the object name is null\n or no domain and key properties are specified, all objects are\n selected (and filtered if a query is specified). It returns the\n set of ObjectNames for the MBeans selected."}, {"method_name": "isRegistered", "method_sig": "boolean isRegistered (ObjectName name)\n              throws IOException", "description": "Checks whether an MBean, identified by its object name, is\n already registered with the MBean server."}, {"method_name": "getMBeanCount", "method_sig": "Integer getMBeanCount()\n               throws IOException", "description": "Returns the number of MBeans registered in the MBean server."}, {"method_name": "getAttribute", "method_sig": "Object getAttribute (ObjectName name,\n                    String attribute)\n             throws MBeanException,\n                    AttributeNotFoundException,\n                    InstanceNotFoundException,\n                    ReflectionException,\n                    IOException", "description": "Gets the value of a specific attribute of a named MBean. The MBean\n is identified by its object name."}, {"method_name": "getAttributes", "method_sig": "AttributeList getAttributes (ObjectName name,\n                            String[] attributes)\n                     throws InstanceNotFoundException,\n                            ReflectionException,\n                            IOException", "description": "Retrieves the values of several attributes of a named MBean. The MBean\n is identified by its object name.\nIf one or more attributes cannot be retrieved for some reason, they\n will be omitted from the returned AttributeList.  The caller\n should check that the list is the same size as the attributes\n array.  To discover what problem prevented a given attribute from being\n retrieved, call getAttribute for that attribute.\nHere is an example of calling this method and checking that it\n succeeded in retrieving all the requested attributes:\n\n String[] attrNames = ...;\n AttributeList list = mbeanServerConnection.getAttributes(objectName, attrNames);\n if (list.size() == attrNames.length)\n     System.out.println(\"All attributes were retrieved successfully\");\n else {\n     List<String> missing = new ArrayList<String>(Arrays.asList(attrNames));\n     for (Attribute a : list.asList())\n         missing.remove(a.getName());\n     System.out.println(\"Did not retrieve: \" + missing);\n }\n "}, {"method_name": "setAttribute", "method_sig": "void setAttribute (ObjectName name,\n                  Attribute attribute)\n           throws InstanceNotFoundException,\n                  AttributeNotFoundException,\n                  InvalidAttributeValueException,\n                  MBeanException,\n                  ReflectionException,\n                  IOException", "description": "Sets the value of a specific attribute of a named MBean. The MBean\n is identified by its object name."}, {"method_name": "setAttributes", "method_sig": "AttributeList setAttributes (ObjectName name,\n                            AttributeList attributes)\n                     throws InstanceNotFoundException,\n                            ReflectionException,\n                            IOException", "description": "Sets the values of several attributes of a named MBean. The MBean is\n identified by its object name.\nIf one or more attributes cannot be set for some reason, they will be\n omitted from the returned AttributeList.  The caller should check\n that the input AttributeList is the same size as the output one.\n To discover what problem prevented a given attribute from being retrieved,\n it will usually be possible to call setAttribute\n for that attribute, although this is not guaranteed to work.  (For\n example, the values of two attributes may have been rejected because\n they were inconsistent with each other.  Setting one of them alone might\n be allowed.)\n\n Here is an example of calling this method and checking that it\n succeeded in setting all the requested attributes:\n\n AttributeList inputAttrs = ...;\n AttributeList outputAttrs = mbeanServerConnection.setAttributes(objectName, inputAttrs);\n if (inputAttrs.size() == outputAttrs.size())\n     System.out.println(\"All attributes were set successfully\");\n else {\n     List<String> missing = new ArrayList<String>();\n     for (Attribute a : inputAttrs.asList())\n         missing.add(a.getName());\n     for (Attribute a : outputAttrs.asList())\n         missing.remove(a.getName());\n     System.out.println(\"Did not set: \" + missing);\n }\n "}, {"method_name": "invoke", "method_sig": "Object invoke (ObjectName name,\n              String operationName,\n              Object[] params,\n              String[] signature)\n       throws InstanceNotFoundException,\n              MBeanException,\n              ReflectionException,\n              IOException", "description": "Invokes an operation on an MBean.\nBecause of the need for a signature to differentiate\n possibly-overloaded operations, it is much simpler to invoke operations\n through an MBean proxy where possible.  For example, suppose you have a\n Standard MBean interface like this:\n\n public interface FooMBean {\n     public int countMatches(String[] patterns, boolean ignoreCase);\n }\n \nThe countMatches operation can be invoked as follows:\n\n String[] myPatterns = ...;\n int count = (Integer) mbeanServerConnection.invoke(\n         objectName,\n         \"countMatches\",\n         new Object[] {myPatterns, true},\n         new String[] {String[].class.getName(), boolean.class.getName()});\n \nAlternatively, it can be invoked through a proxy as follows:\n\n String[] myPatterns = ...;\n FooMBean fooProxy = JMX.newMBeanProxy(\n         mbeanServerConnection, objectName, FooMBean.class);\n int count = fooProxy.countMatches(myPatterns, true);\n "}, {"method_name": "getDefaultDomain", "method_sig": "String getDefaultDomain()\n                 throws IOException", "description": "Returns the default domain used for naming the MBean.\n The default domain name is used as the domain part in the ObjectName\n of MBeans if no domain is specified by the user."}, {"method_name": "getDomains", "method_sig": "String[] getDomains()\n             throws IOException", "description": "Returns the list of domains in which any MBean is currently\n registered.  A string is in the returned array if and only if\n there is at least one MBean registered with an ObjectName whose\n getDomain() is equal to that\n string.  The order of strings within the returned array is\n not defined."}, {"method_name": "addNotificationListener", "method_sig": "void addNotificationListener (ObjectName name,\n                             NotificationListener listener,\n                             NotificationFilter filter,\n                             Object handback)\n                      throws InstanceNotFoundException,\n                             IOException", "description": "Adds a listener to a registered MBean.\n Notifications emitted by the MBean will be forwarded to the listener."}, {"method_name": "addNotificationListener", "method_sig": "void addNotificationListener (ObjectName name,\n                             ObjectName listener,\n                             NotificationFilter filter,\n                             Object handback)\n                      throws InstanceNotFoundException,\n                             IOException", "description": "Adds a listener to a registered MBean.\nA notification emitted by an MBean will be forwarded by the\n MBeanServer to the listener.  If the source of the notification\n is a reference to an MBean object, the MBean server will\n replace it by that MBean's ObjectName.  Otherwise the source is\n unchanged.\nThe listener object that receives notifications is the one\n that is registered with the given name at the time this method\n is called.  Even if it is subsequently unregistered, it will\n continue to receive notifications."}, {"method_name": "removeNotificationListener", "method_sig": "void removeNotificationListener (ObjectName name,\n                                ObjectName listener)\n                         throws InstanceNotFoundException,\n                                ListenerNotFoundException,\n                                IOException", "description": "Removes a listener from a registered MBean.\n\n  If the listener is registered more than once, perhaps with\n different filters or callbacks, this method will remove all\n those registrations."}, {"method_name": "removeNotificationListener", "method_sig": "void removeNotificationListener (ObjectName name,\n                                ObjectName listener,\n                                NotificationFilter filter,\n                                Object handback)\n                         throws InstanceNotFoundException,\n                                ListenerNotFoundException,\n                                IOException", "description": "Removes a listener from a registered MBean.\nThe MBean must have a listener that exactly matches the\n given listener, filter, and\n handback parameters.  If there is more than one\n such listener, only one is removed.\nThe filter and handback parameters\n may be null if and only if they are null in a listener to be\n removed."}, {"method_name": "removeNotificationListener", "method_sig": "void removeNotificationListener (ObjectName name,\n                                NotificationListener listener)\n                         throws InstanceNotFoundException,\n                                ListenerNotFoundException,\n                                IOException", "description": "Removes a listener from a registered MBean.\n If the listener is registered more than once, perhaps with\n different filters or callbacks, this method will remove all\n those registrations."}, {"method_name": "removeNotificationListener", "method_sig": "void removeNotificationListener (ObjectName name,\n                                NotificationListener listener,\n                                NotificationFilter filter,\n                                Object handback)\n                         throws InstanceNotFoundException,\n                                ListenerNotFoundException,\n                                IOException", "description": "Removes a listener from a registered MBean.\nThe MBean must have a listener that exactly matches the\n given listener, filter, and\n handback parameters.  If there is more than one\n such listener, only one is removed.\nThe filter and handback parameters\n may be null if and only if they are null in a listener to be\n removed."}, {"method_name": "getMBeanInfo", "method_sig": "MBeanInfo getMBeanInfo (ObjectName name)\n                throws InstanceNotFoundException,\n                       IntrospectionException,\n                       ReflectionException,\n                       IOException", "description": "This method discovers the attributes and operations that an\n MBean exposes for management."}, {"method_name": "isInstanceOf", "method_sig": "boolean isInstanceOf (ObjectName name,\n                     String className)\n              throws InstanceNotFoundException,\n                     IOException", "description": "Returns true if the MBean specified is an instance of the\n specified class, false otherwise.\nIf name does not name an MBean, this method\n throws InstanceNotFoundException.\nOtherwise, let\n X be the MBean named by name,\n L be the ClassLoader of X,\n N be the class name in X's MBeanInfo.\nIf N equals className, the result is true.\nOtherwise, if L successfully loads className\n and X is an instance of this class, the result is true.\n\n Otherwise, if L successfully loads both N and\n className, and the second class is assignable from\n the first, the result is true.\nOtherwise, the result is false."}]}