{"name": "Class ScheduledThreadPoolExecutor", "module": "java.base", "package": "java.util.concurrent", "text": "A ThreadPoolExecutor that can additionally schedule\n commands to run after a given delay, or to execute periodically.\n This class is preferable to Timer when multiple\n worker threads are needed, or when the additional flexibility or\n capabilities of ThreadPoolExecutor (which this class\n extends) are required.\n\n Delayed tasks execute no sooner than they are enabled, but\n without any real-time guarantees about when, after they are\n enabled, they will commence. Tasks scheduled for exactly the same\n execution time are enabled in first-in-first-out (FIFO) order of\n submission.\n\n When a submitted task is cancelled before it is run, execution\n is suppressed.  By default, such a cancelled task is not\n automatically removed from the work queue until its delay elapses.\n While this enables further inspection and monitoring, it may also\n cause unbounded retention of cancelled tasks.  To avoid this, use\n setRemoveOnCancelPolicy(boolean) to cause tasks to be immediately\n removed from the work queue at time of cancellation.\n\n Successive executions of a periodic task scheduled via\n scheduleAtFixedRate or\n scheduleWithFixedDelay\n do not overlap. While different executions may be performed by\n different threads, the effects of prior executions\n happen-before\n those of subsequent ones.\n\n While this class inherits from ThreadPoolExecutor, a few\n of the inherited tuning methods are not useful for it. In\n particular, because it acts as a fixed-sized pool using\n corePoolSize threads and an unbounded queue, adjustments\n to maximumPoolSize have no useful effect. Additionally, it\n is almost never a good idea to set corePoolSize to zero or\n use allowCoreThreadTimeOut because this may leave the pool\n without threads to handle tasks once they become eligible to run.\n\n As with ThreadPoolExecutor, if not otherwise specified,\n this class uses Executors.defaultThreadFactory() as the\n default thread factory, and ThreadPoolExecutor.AbortPolicy\n as the default rejected execution handler.\n\n Extension notes: This class overrides the\n execute and\n submit\n methods to generate internal ScheduledFuture objects to\n control per-task delays and scheduling.  To preserve\n functionality, any further overrides of these methods in\n subclasses must invoke superclass versions, which effectively\n disables additional task customization.  However, this class\n provides alternative protected extension method\n decorateTask (one version each for Runnable and\n Callable) that can be used to customize the concrete task\n types used to execute commands entered via execute,\n submit, schedule, scheduleAtFixedRate,\n and scheduleWithFixedDelay.  By default, a\n ScheduledThreadPoolExecutor uses a task type extending\n FutureTask. However, this may be modified or replaced using\n subclasses of the form:\n\n  \n public class CustomScheduledExecutor extends ScheduledThreadPoolExecutor {\n\n   static class CustomTask<V> implements RunnableScheduledFuture<V> { ... }\n\n   protected <V> RunnableScheduledFuture<V> decorateTask(\n                Runnable r, RunnableScheduledFuture<V> task) {\n       return new CustomTask<V>(r, task);\n   }\n\n   protected <V> RunnableScheduledFuture<V> decorateTask(\n                Callable<V> c, RunnableScheduledFuture<V> task) {\n       return new CustomTask<V>(c, task);\n   }\n   // ... add constructors, etc.\n }", "codes": ["public class ScheduledThreadPoolExecutor\nextends ThreadPoolExecutor\nimplements ScheduledExecutorService"], "fields": [], "methods": [{"method_name": "decorateTask", "method_sig": "protected <V> RunnableScheduledFuture<V> decorateTask (Runnable runnable,\n                                                      RunnableScheduledFuture<V> task)", "description": "Modifies or replaces the task used to execute a runnable.\n This method can be used to override the concrete\n class used for managing internal tasks.\n The default implementation simply returns the given task."}, {"method_name": "decorateTask", "method_sig": "protected <V> RunnableScheduledFuture<V> decorateTask (Callable<V> callable,\n                                                      RunnableScheduledFuture<V> task)", "description": "Modifies or replaces the task used to execute a callable.\n This method can be used to override the concrete\n class used for managing internal tasks.\n The default implementation simply returns the given task."}, {"method_name": "schedule", "method_sig": "public ScheduledFuture<?> schedule (Runnable command,\n                                   long delay,\n                                   TimeUnit unit)", "description": "Description copied from interface:\u00a0ScheduledExecutorService"}, {"method_name": "schedule", "method_sig": "public <V> ScheduledFuture<V> schedule (Callable<V> callable,\n                                       long delay,\n                                       TimeUnit unit)", "description": "Description copied from interface:\u00a0ScheduledExecutorService"}, {"method_name": "scheduleAtFixedRate", "method_sig": "public ScheduledFuture<?> scheduleAtFixedRate (Runnable command,\n                                              long initialDelay,\n                                              long period,\n                                              TimeUnit unit)", "description": "Submits a periodic action that becomes enabled first after the\n given initial delay, and subsequently with the given period;\n that is, executions will commence after\n initialDelay, then initialDelay + period, then\n initialDelay + 2 * period, and so on.\n\n The sequence of task executions continues indefinitely until\n one of the following exceptional completions occur:\n \nThe task is explicitly cancelled\n via the returned future.\n Method shutdown() is called and the policy on\n whether to continue after shutdown is not set true, or method\n shutdownNow() is called; also resulting in task\n cancellation.\n An execution of the task throws an exception.  In this case\n calling get on the returned future will throw\n ExecutionException, holding the exception as its cause.\n \n Subsequent executions are suppressed.  Subsequent calls to\n isDone() on the returned future will\n return true.\n\n If any execution of this task takes longer than its period, then\n subsequent executions may start late, but will not concurrently\n execute."}, {"method_name": "scheduleWithFixedDelay", "method_sig": "public ScheduledFuture<?> scheduleWithFixedDelay (Runnable command,\n                                                 long initialDelay,\n                                                 long delay,\n                                                 TimeUnit unit)", "description": "Submits a periodic action that becomes enabled first after the\n given initial delay, and subsequently with the given delay\n between the termination of one execution and the commencement of\n the next.\n\n The sequence of task executions continues indefinitely until\n one of the following exceptional completions occur:\n \nThe task is explicitly cancelled\n via the returned future.\n Method shutdown() is called and the policy on\n whether to continue after shutdown is not set true, or method\n shutdownNow() is called; also resulting in task\n cancellation.\n An execution of the task throws an exception.  In this case\n calling get on the returned future will throw\n ExecutionException, holding the exception as its cause.\n \n Subsequent executions are suppressed.  Subsequent calls to\n isDone() on the returned future will\n return true."}, {"method_name": "execute", "method_sig": "public void execute (Runnable command)", "description": "Executes command with zero required delay.\n This has effect equivalent to\n schedule(command, 0, anyUnit).\n Note that inspections of the queue and of the list returned by\n shutdownNow will access the zero-delayed\n ScheduledFuture, not the command itself.\n\n A consequence of the use of ScheduledFuture objects is\n that afterExecute is always\n called with a null second Throwable argument, even if the\n command terminated abruptly.  Instead, the Throwable\n thrown by such a task can be obtained via Future.get()."}, {"method_name": "submit", "method_sig": "public Future<?> submit (Runnable task)", "description": "Description copied from interface:\u00a0ExecutorService"}, {"method_name": "submit", "method_sig": "public <T> Future<T> submit (Runnable task,\n                            T result)", "description": "Description copied from interface:\u00a0ExecutorService"}, {"method_name": "submit", "method_sig": "public <T> Future<T> submit (Callable<T> task)", "description": "Description copied from interface:\u00a0ExecutorService"}, {"method_name": "setContinueExistingPeriodicTasksAfterShutdownPolicy", "method_sig": "public void setContinueExistingPeriodicTasksAfterShutdownPolicy (boolean value)", "description": "Sets the policy on whether to continue executing existing\n periodic tasks even when this executor has been shutdown.\n In this case, executions will continue until shutdownNow\n or the policy is set to false when already shutdown.\n This value is by default false."}, {"method_name": "getContinueExistingPeriodicTasksAfterShutdownPolicy", "method_sig": "public boolean getContinueExistingPeriodicTasksAfterShutdownPolicy()", "description": "Gets the policy on whether to continue executing existing\n periodic tasks even when this executor has been shutdown.\n In this case, executions will continue until shutdownNow\n or the policy is set to false when already shutdown.\n This value is by default false."}, {"method_name": "setExecuteExistingDelayedTasksAfterShutdownPolicy", "method_sig": "public void setExecuteExistingDelayedTasksAfterShutdownPolicy (boolean value)", "description": "Sets the policy on whether to execute existing delayed\n tasks even when this executor has been shutdown.\n In this case, these tasks will only terminate upon\n shutdownNow, or after setting the policy to\n false when already shutdown.\n This value is by default true."}, {"method_name": "getExecuteExistingDelayedTasksAfterShutdownPolicy", "method_sig": "public boolean getExecuteExistingDelayedTasksAfterShutdownPolicy()", "description": "Gets the policy on whether to execute existing delayed\n tasks even when this executor has been shutdown.\n In this case, these tasks will only terminate upon\n shutdownNow, or after setting the policy to\n false when already shutdown.\n This value is by default true."}, {"method_name": "setRemoveOnCancelPolicy", "method_sig": "public void setRemoveOnCancelPolicy (boolean value)", "description": "Sets the policy on whether cancelled tasks should be immediately\n removed from the work queue at time of cancellation.  This value is\n by default false."}, {"method_name": "getRemoveOnCancelPolicy", "method_sig": "public boolean getRemoveOnCancelPolicy()", "description": "Gets the policy on whether cancelled tasks should be immediately\n removed from the work queue at time of cancellation.  This value is\n by default false."}, {"method_name": "shutdown", "method_sig": "public void shutdown()", "description": "Initiates an orderly shutdown in which previously submitted\n tasks are executed, but no new tasks will be accepted.\n Invocation has no additional effect if already shut down.\n\n This method does not wait for previously submitted tasks to\n complete execution.  Use awaitTermination\n to do that.\n\n If the ExecuteExistingDelayedTasksAfterShutdownPolicy\n has been set false, existing delayed tasks whose delays\n have not yet elapsed are cancelled.  And unless the \n ContinueExistingPeriodicTasksAfterShutdownPolicy has been set\n true, future executions of existing periodic tasks will\n be cancelled."}, {"method_name": "shutdownNow", "method_sig": "public List<Runnable> shutdownNow()", "description": "Attempts to stop all actively executing tasks, halts the\n processing of waiting tasks, and returns a list of the tasks\n that were awaiting execution. These tasks are drained (removed)\n from the task queue upon return from this method.\n\n This method does not wait for actively executing tasks to\n terminate.  Use awaitTermination to\n do that.\n\n There are no guarantees beyond best-effort attempts to stop\n processing actively executing tasks.  This implementation\n interrupts tasks via Thread.interrupt(); any task that\n fails to respond to interrupts may never terminate."}, {"method_name": "getQueue", "method_sig": "public BlockingQueue<Runnable> getQueue()", "description": "Returns the task queue used by this executor.  Access to the\n task queue is intended primarily for debugging and monitoring.\n This queue may be in active use.  Retrieving the task queue\n does not prevent queued tasks from executing.\n\n Each element of this queue is a ScheduledFuture.\n For tasks submitted via one of the schedule methods, the\n element will be identical to the returned ScheduledFuture.\n For tasks submitted using execute, the element\n will be a zero-delay ScheduledFuture.\n\n Iteration over this queue is not guaranteed to traverse\n tasks in the order in which they will execute."}]}