{"name": "Class StartTlsResponse", "module": "java.naming", "package": "javax.naming.ldap", "text": "This class implements the LDAPv3 Extended Response for StartTLS as\n defined in\n Lightweight Directory\n Access Protocol (v3): Extension for Transport Layer Security\n\n The object identifier for StartTLS is 1.3.6.1.4.1.1466.20037\n and no extended response value is defined.\n\n\n The Start TLS extended request and response are used to establish\n a TLS connection over the existing LDAP connection associated with\n the JNDI context on which extendedOperation() is invoked.\n Typically, a JNDI program uses the StartTLS extended request and response\n classes as follows.\n \n import javax.naming.ldap.*;\n\n // Open an LDAP association\n LdapContext ctx = new InitialLdapContext();\n\n // Perform a StartTLS extended operation\n StartTlsResponse tls =\n     (StartTlsResponse) ctx.extendedOperation(new StartTlsRequest());\n\n // Open a TLS connection (over the existing LDAP association) and get details\n // of the negotiated TLS session: cipher suite, peer certificate, ...\n SSLSession session = tls.negotiate();\n\n // ... use ctx to perform protected LDAP operations\n\n // Close the TLS connection (revert back to the underlying LDAP association)\n tls.close();\n\n // ... use ctx to perform unprotected LDAP operations\n\n // Close the LDAP association\n ctx.close;\n ", "codes": ["public abstract class StartTlsResponse\nextends Object\nimplements ExtendedResponse"], "fields": [{"field_name": "OID", "field_sig": "public static final\u00a0String OID", "description": "The StartTLS extended response's assigned object identifier\n is 1.3.6.1.4.1.1466.20037."}], "methods": [{"method_name": "getID", "method_sig": "public String getID()", "description": "Retrieves the StartTLS response's object identifier string."}, {"method_name": "getEncodedValue", "method_sig": "public byte[] getEncodedValue()", "description": "Retrieves the StartTLS response's ASN.1 BER encoded value.\n Since the response has no defined value, null is always\n returned."}, {"method_name": "setEnabledCipherSuites", "method_sig": "public abstract void setEnabledCipherSuites (String[] suites)", "description": "Overrides the default list of cipher suites enabled for use on the\n TLS connection. The cipher suites must have already been listed by\n SSLSocketFactory.getSupportedCipherSuites() as being supported.\n Even if a suite has been enabled, it still might not be used because\n the peer does not support it, or because the requisite certificates\n (and private keys) are not available."}, {"method_name": "setHostnameVerifier", "method_sig": "public abstract void setHostnameVerifier (HostnameVerifier verifier)", "description": "Sets the hostname verifier used by negotiate()\n after the TLS handshake has completed and the default hostname\n verification has failed.\n setHostnameVerifier() must be called before\n negotiate() is invoked for it to have effect.\n If called after\n negotiate(), this method does not do anything."}, {"method_name": "negotiate", "method_sig": "public abstract SSLSession negotiate()\n                              throws IOException", "description": "Negotiates a TLS session using the default SSL socket factory.\n \n This method is equivalent to negotiate(null)."}, {"method_name": "negotiate", "method_sig": "public abstract SSLSession negotiate (SSLSocketFactory factory)\n                              throws IOException", "description": "Negotiates a TLS session using an SSL socket factory.\n \n Creates an SSL socket using the supplied SSL socket factory and\n attaches it to the existing connection. Performs the TLS handshake\n and returns the negotiated session information.\n \n If cipher suites have been set via setEnabledCipherSuites\n then they are enabled before the TLS handshake begins.\n \n Hostname verification is performed after the TLS handshake completes.\n The default hostname verification performs a match of the server's\n hostname against the hostname information found in the server's certificate.\n If this verification fails and no callback has been set via\n setHostnameVerifier then the negotiation fails.\n If this verification fails and a callback has been set via\n setHostnameVerifier, then the callback is used to determine whether\n the negotiation succeeds.\n \n If an error occurs then the SSL socket is closed and an IOException\n is thrown. The underlying connection remains intact."}, {"method_name": "close", "method_sig": "public abstract void close()\n                    throws IOException", "description": "Closes the TLS connection gracefully and reverts back to the underlying\n connection."}]}