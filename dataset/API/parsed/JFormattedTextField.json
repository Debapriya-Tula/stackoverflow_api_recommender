{"name": "Class JFormattedTextField", "module": "java.desktop", "package": "javax.swing", "text": "JFormattedTextField extends JTextField adding\n support for formatting arbitrary values, as well as retrieving a particular\n object once the user has edited the text. The following illustrates\n configuring a JFormattedTextField to edit dates:\n \n   JFormattedTextField ftf = new JFormattedTextField();\n   ftf.setValue(new Date());\n \n\n Once a JFormattedTextField has been created, you can\n listen for editing changes by way of adding\n a PropertyChangeListener and listening for\n PropertyChangeEvents with the property name value.\n \nJFormattedTextField allows\n configuring what action should be taken when focus is lost. The possible\n configurations are:\n\n \nPossible JFormattedTextField configurations and their descriptions\n \n\n\nValue\n     Description\n \n\n\nJFormattedTextField.REVERT\n     Revert the display to match that of getValue, possibly losing\n     the current edit.\n   \nJFormattedTextField.COMMIT\n     Commits the current value. If the value being edited isn't considered\n     a legal value by the AbstractFormatter that is, a\n     ParseException is thrown, then the value will not change, and\n     then edited value will persist.\n   \nJFormattedTextField.COMMIT_OR_REVERT\n     Similar to COMMIT, but if the value isn't legal, behave like\n     REVERT.\n   \nJFormattedTextField.PERSIST\n     Do nothing, don't obtain a new AbstractFormatter, and don't\n     update the value.\n \n\n\n The default is JFormattedTextField.COMMIT_OR_REVERT,\n refer to setFocusLostBehavior(int) for more information on this.\n \nJFormattedTextField allows the focus to leave, even if\n the currently edited value is invalid. To lock the focus down while the\n JFormattedTextField is an invalid edit state\n you can attach an InputVerifier. The following code snippet\n shows a potential implementation of such an InputVerifier:\n \n public class FormattedTextFieldVerifier extends InputVerifier {\n     public boolean verify(JComponent input) {\n         if (input instanceof JFormattedTextField) {\n             JFormattedTextField ftf = (JFormattedTextField)input;\n             AbstractFormatter formatter = ftf.getFormatter();\n             if (formatter != null) {\n                 String text = ftf.getText();\n                 try {\n                      formatter.stringToValue(text);\n                      return true;\n                  } catch (ParseException pe) {\n                      return false;\n                  }\n              }\n          }\n          return true;\n      }\n      public boolean shouldYieldFocus(JComponent input) {\n          return verify(input);\n      }\n  }\n \n\n Alternatively, you could invoke commitEdit, which would also\n commit the value.\n \nJFormattedTextField does not do the formatting it self,\n rather formatting is done through an instance of\n JFormattedTextField.AbstractFormatter which is obtained from\n an instance of JFormattedTextField.AbstractFormatterFactory.\n Instances of JFormattedTextField.AbstractFormatter are\n notified when they become active by way of the\n install method, at which point the\n JFormattedTextField.AbstractFormatter can install whatever\n it needs to, typically a DocumentFilter. Similarly when\n JFormattedTextField no longer\n needs the AbstractFormatter, it will invoke\n uninstall.\n \nJFormattedTextField typically\n queries the AbstractFormatterFactory for an\n AbstractFormat when it gains or loses focus. Although this\n can change based on the focus lost policy. If the focus lost\n policy is JFormattedTextField.PERSIST\n and the JFormattedTextField has been edited, the\n AbstractFormatterFactory will not be queried until the\n value has been committed. Similarly if the focus lost policy is\n JFormattedTextField.COMMIT and an exception\n is thrown from stringToValue, the\n AbstractFormatterFactory will not be queried when focus is\n lost or gained.\n \nJFormattedTextField.AbstractFormatter\n is also responsible for determining when values are committed to\n the JFormattedTextField. Some\n JFormattedTextField.AbstractFormatters will make new values\n available on every edit, and others will never commit the value. You can\n force the current value to be obtained\n from the current JFormattedTextField.AbstractFormatter\n by way of invoking commitEdit. commitEdit will\n be invoked whenever return is pressed in the\n JFormattedTextField.\n \n If an AbstractFormatterFactory has not been explicitly\n set, one will be set based on the Class of the value type after\n setValue has been invoked (assuming value is non-null).\n For example, in the following code an appropriate\n AbstractFormatterFactory and AbstractFormatter\n will be created to handle formatting of numbers:\n \n   JFormattedTextField tf = new JFormattedTextField();\n   tf.setValue(100);\n \n\nWarning: As the AbstractFormatter will\n typically install a DocumentFilter on the\n Document, and a NavigationFilter on the\n JFormattedTextField you should not install your own. If you do,\n you are likely to see odd behavior in that the editing policy of the\n AbstractFormatter will not be enforced.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans\u2122\n has been added to the java.beans package.\n Please see XMLEncoder.", "codes": ["@JavaBean\npublic class JFormattedTextField\nextends JTextField"], "fields": [{"field_name": "COMMIT", "field_sig": "public static final\u00a0int COMMIT", "description": "Constant identifying that when focus is lost,\n commitEdit should be invoked. If in committing the\n new value a ParseException is thrown, the invalid\n value will remain."}, {"field_name": "COMMIT_OR_REVERT", "field_sig": "public static final\u00a0int COMMIT_OR_REVERT", "description": "Constant identifying that when focus is lost,\n commitEdit should be invoked. If in committing the new\n value a ParseException is thrown, the value will be\n reverted."}, {"field_name": "REVERT", "field_sig": "public static final\u00a0int REVERT", "description": "Constant identifying that when focus is lost, editing value should\n be reverted to current value set on the\n JFormattedTextField."}, {"field_name": "PERSIST", "field_sig": "public static final\u00a0int PERSIST", "description": "Constant identifying that when focus is lost, the edited value\n should be left."}], "methods": [{"method_name": "setFocusLostBehavior", "method_sig": "@BeanProperty(bound=false,\n              enumerationValues={\"JFormattedTextField.COMMIT\",\"JFormattedTextField.COMMIT_OR_REVERT\",\"JFormattedTextField.REVERT\",\"JFormattedTextField.PERSIST\"},\n              description=\"Behavior when component loses focus\")\npublic void setFocusLostBehavior (int behavior)", "description": "Sets the behavior when focus is lost. This will be one of\n JFormattedTextField.COMMIT_OR_REVERT,\n JFormattedTextField.REVERT,\n JFormattedTextField.COMMIT or\n JFormattedTextField.PERSIST\n Note that some AbstractFormatters may push changes as\n they occur, so that the value of this will have no effect.\n \n This will throw an IllegalArgumentException if the object\n passed in is not one of the afore mentioned values.\n \n The default value of this property is\n JFormattedTextField.COMMIT_OR_REVERT."}, {"method_name": "getFocusLostBehavior", "method_sig": "public int getFocusLostBehavior()", "description": "Returns the behavior when focus is lost. This will be one of\n COMMIT_OR_REVERT,\n COMMIT,\n REVERT or\n PERSIST\n Note that some AbstractFormatters may push changes as\n they occur, so that the value of this will have no effect."}, {"method_name": "setFormatterFactory", "method_sig": "@BeanProperty(visualUpdate=true,\n              description=\"AbstractFormatterFactory, responsible for returning an AbstractFormatter that can format the current value.\")\npublic void setFormatterFactory (JFormattedTextField.AbstractFormatterFactory tf)", "description": "Sets the AbstractFormatterFactory.\n AbstractFormatterFactory is\n able to return an instance of AbstractFormatter that is\n used to format a value for display, as well an enforcing an editing\n policy.\n \n If you have not explicitly set an AbstractFormatterFactory\n by way of this method (or a constructor) an\n AbstractFormatterFactory and consequently an\n AbstractFormatter will be used based on the\n Class of the value. NumberFormatter will\n be used for Numbers, DateFormatter will\n be used for Dates, otherwise DefaultFormatter\n will be used.\n \n This is a JavaBeans bound property."}, {"method_name": "getFormatterFactory", "method_sig": "public JFormattedTextField.AbstractFormatterFactory getFormatterFactory()", "description": "Returns the current AbstractFormatterFactory."}, {"method_name": "setFormatter", "method_sig": "protected void setFormatter (JFormattedTextField.AbstractFormatter format)", "description": "Sets the current AbstractFormatter.\n \n You should not normally invoke this, instead set the\n AbstractFormatterFactory or set the value.\n JFormattedTextField will\n invoke this as the state of the JFormattedTextField\n changes and requires the value to be reset.\n JFormattedTextField passes in the\n AbstractFormatter obtained from the\n AbstractFormatterFactory.\n \n This is a JavaBeans bound property."}, {"method_name": "getFormatter", "method_sig": "@BeanProperty(visualUpdate=true,\n              description=\"TextFormatter, responsible for formatting the current value\")\npublic JFormattedTextField.AbstractFormatter getFormatter()", "description": "Returns the AbstractFormatter that is used to format and\n parse the current value."}, {"method_name": "setValue", "method_sig": "@BeanProperty(visualUpdate=true,\n              description=\"The value to be formatted.\")\npublic void setValue (Object value)", "description": "Sets the value that will be formatted by an\n AbstractFormatter obtained from the current\n AbstractFormatterFactory. If no\n AbstractFormatterFactory has been specified, this will\n attempt to create one based on the type of value.\n \n The default value of this property is null.\n \n This is a JavaBeans bound property."}, {"method_name": "getValue", "method_sig": "public Object getValue()", "description": "Returns the last valid value. Based on the editing policy of\n the AbstractFormatter this may not return the current\n value. The currently edited value can be obtained by invoking\n commitEdit followed by getValue."}, {"method_name": "commitEdit", "method_sig": "public void commitEdit()\n                throws ParseException", "description": "Forces the current value to be taken from the\n AbstractFormatter and set as the current value.\n This has no effect if there is no current\n AbstractFormatter installed."}, {"method_name": "isEditValid", "method_sig": "@BeanProperty(bound=false)\npublic boolean isEditValid()", "description": "Returns true if the current value being edited is valid. The value of\n this is managed by the current AbstractFormatter, as such\n there is no public setter for it."}, {"method_name": "invalidEdit", "method_sig": "protected void invalidEdit()", "description": "Invoked when the user inputs an invalid value. This gives the\n component a chance to provide feedback. The default\n implementation beeps."}, {"method_name": "processInputMethodEvent", "method_sig": "protected void processInputMethodEvent (InputMethodEvent e)", "description": "Processes any input method events, such as\n InputMethodEvent.INPUT_METHOD_TEXT_CHANGED or\n InputMethodEvent.CARET_POSITION_CHANGED."}, {"method_name": "processFocusEvent", "method_sig": "protected void processFocusEvent (FocusEvent e)", "description": "Processes any focus events, such as\n FocusEvent.FOCUS_GAINED or\n FocusEvent.FOCUS_LOST."}, {"method_name": "getActions", "method_sig": "@BeanProperty(bound=false)\npublic Action[] getActions()", "description": "Fetches the command list for the editor.  This is\n the list of commands supported by the plugged-in UI\n augmented by the collection of commands that the\n editor itself supports.  These are useful for binding\n to events, such as in a keymap."}, {"method_name": "getUIClassID", "method_sig": "@BeanProperty(bound=false)\npublic String getUIClassID()", "description": "Gets the class ID for a UI."}, {"method_name": "setDocument", "method_sig": "@BeanProperty(expert=true,\n              description=\"the text document model\")\npublic void setDocument (Document doc)", "description": "Associates the editor with a text document.\n The currently registered factory is used to build a view for\n the document, which gets displayed by the editor after revalidation.\n A PropertyChange event (\"document\") is propagated to each listener."}]}