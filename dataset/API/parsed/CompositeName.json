{"name": "Class CompositeName", "module": "java.naming", "package": "javax.naming", "text": "This class represents a composite name -- a sequence of\n component names spanning multiple namespaces.\n Each component is a string name from the namespace of a\n naming system. If the component comes from a hierarchical\n namespace, that component can be further parsed into\n its atomic parts by using the CompoundName class.\n\n The components of a composite name are numbered.  The indexes of a\n composite name with N components range from 0 up to, but not including, N.\n This range may be written as [0,N).\n The most significant component is at index 0.\n An empty composite name has no components.\n\n JNDI Composite Name Syntax\n JNDI defines a standard string representation for composite names. This\n representation is the concatenation of the components of a composite name\n from left to right using the component separator (a forward\n slash character (/)) to separate each component.\n The JNDI syntax defines the following meta characters:\n \nescape (backward slash \\),\n quote characters  (single (') and double quotes (\")), and\n component separator (forward slash character (/)).\n \n Any occurrence of a leading quote, an escape preceding any meta character,\n an escape at the end of a component, or a component separator character\n in an unquoted component must be preceded by an escape character when\n that component is being composed into a composite name string.\n Alternatively, to avoid adding escape characters as described,\n the entire component can be quoted using matching single quotes\n or matching double quotes. A single quote occurring within a double-quoted\n component is not considered a meta character (and need not be escaped),\n and vice versa.\n\n When two composite names are compared, the case of the characters\n is significant.\n\n A leading component separator (the composite name string begins with\n a separator) denotes a leading empty component (a component consisting\n of an empty string).\n A trailing component separator (the composite name string ends with\n a separator) denotes a trailing empty component.\n Adjacent component separators denote an empty component.\n\nComposite Name Examples\nThis table shows examples of some composite names. Each row shows\nthe string form of a composite name and its corresponding structural form\n(CompositeName).\n\nexamples showing string\n form of composite name and its corresponding structural form (CompositeName)\n\n\nString Name\nCompositeName\n\n\n\n\n\n\"\"\n\n{} (the empty name == new CompositeName(\"\") == new CompositeName())\n\n\n\n\n\"x\"\n\n{\"x\"}\n\n\n\n\n\"x/y\"\n\n{\"x\", \"y\"}\n\n\n\"x/\"\n{\"x\", \"\"}\n\n\n\"/x\"\n{\"\", \"x\"}\n\n\n\"/\"\n{\"\"}\n\n\n\"//\"\n{\"\", \"\"}\n\n\"/x/\"\n{\"\", \"x\", \"\"}\n\n\"x//y\"\n{\"x\", \"\", \"y\"}\n\n\n\nComposition Examples\n Here are some composition examples.  The right column shows composing\n string composite names while the left column shows composing the\n corresponding CompositeNames.  Notice that composing the\n string forms of two composite names simply involves concatenating\n their string forms together.\n\ncomposition examples\n showing string names and composite names\n\n\nString Names\nCompositeNames\n\n\n\n\n\n\"x/y\"           + \"/\"   = x/y/\n\n\n{\"x\", \"y\"}      + {\"\"}  = {\"x\", \"y\", \"\"}\n\n\n\n\n\"\"              + \"x\"   = \"x\"\n\n\n{}              + {\"x\"} = {\"x\"}\n\n\n\n\n\"/\"             + \"x\"   = \"/x\"\n\n\n{\"\"}            + {\"x\"} = {\"\", \"x\"}\n\n\n\n\n\"x\"   + \"\"      + \"\"    = \"x\"\n\n\n{\"x\"} + {}      + {}    = {\"x\"}\n\n\n\n\nMultithreaded Access\n A CompositeName instance is not synchronized against concurrent\n multithreaded access. Multiple threads trying to access and modify a\n CompositeName should lock the object.", "codes": ["public class CompositeName\nextends Object\nimplements Name"], "fields": [], "methods": [{"method_name": "toString", "method_sig": "public String toString()", "description": "Generates the string representation of this composite name.\n The string representation consists of enumerating in order\n each component of the composite name and separating\n each component by a forward slash character. Quoting and\n escape characters are applied where necessary according to\n the JNDI syntax, which is described in the class description.\n An empty component is represented by an empty string.\n\n The string representation thus generated can be passed to\n the CompositeName constructor to create a new equivalent\n composite name."}, {"method_name": "equals", "method_sig": "public boolean equals (Object obj)", "description": "Determines whether two composite names are equal.\n If obj is null or not a composite name, false is returned.\n Two composite names are equal if each component in one is equal\n to the corresponding component in the other. This implies\n both have the same number of components, and each component's\n equals() test against the corresponding component in the other name\n returns true."}, {"method_name": "hashCode", "method_sig": "public int hashCode()", "description": "Computes the hash code of this composite name.\n The hash code is the sum of the hash codes of individual components\n of this composite name."}, {"method_name": "compareTo", "method_sig": "public int compareTo (Object obj)", "description": "Compares this CompositeName with the specified Object for order.\n Returns a\n negative integer, zero, or a positive integer as this Name is less\n than, equal to, or greater than the given Object.\n \n If obj is null or not an instance of CompositeName, ClassCastException\n is thrown.\n \n See equals() for what it means for two composite names to be equal.\n If two composite names are equal, 0 is returned.\n \n Ordering of composite names follows the lexicographical rules for\n string comparison, with the extension that this applies to all\n the components in the composite name. The effect is as if all the\n components were lined up in their specified ordered and the\n lexicographical rules applied over the two line-ups.\n If this composite name is \"lexicographically\" lesser than obj,\n a negative number is returned.\n If this composite name is \"lexicographically\" greater than obj,\n a positive number is returned."}, {"method_name": "clone", "method_sig": "public Object clone()", "description": "Generates a copy of this composite name.\n Changes to the components of this composite name won't\n affect the new copy and vice versa."}, {"method_name": "size", "method_sig": "public int size()", "description": "Retrieves the number of components in this composite name."}, {"method_name": "isEmpty", "method_sig": "public boolean isEmpty()", "description": "Determines whether this composite name is empty. A composite name\n is empty if it has zero components."}, {"method_name": "getAll", "method_sig": "public Enumeration<String> getAll()", "description": "Retrieves the components of this composite name as an enumeration\n of strings.\n The effects of updates to this composite name on this enumeration\n is undefined."}, {"method_name": "get", "method_sig": "public String get (int posn)", "description": "Retrieves a component of this composite name."}, {"method_name": "getPrefix", "method_sig": "public Name getPrefix (int posn)", "description": "Creates a composite name whose components consist of a prefix of the\n components in this composite name. Subsequent changes to\n this composite name does not affect the name that is returned."}, {"method_name": "getSuffix", "method_sig": "public Name getSuffix (int posn)", "description": "Creates a composite name whose components consist of a suffix of the\n components in this composite name. Subsequent changes to\n this composite name does not affect the name that is returned."}, {"method_name": "startsWith", "method_sig": "public boolean startsWith (Name n)", "description": "Determines whether a composite name is a prefix of this composite name.\n A composite name 'n' is a prefix if it is equal to\n getPrefix(n.size())--in other words, this composite name\n starts with 'n'. If 'n' is null or not a composite name, false is returned."}, {"method_name": "endsWith", "method_sig": "public boolean endsWith (Name n)", "description": "Determines whether a composite name is a suffix of this composite name.\n A composite name 'n' is a suffix if it is equal to\n getSuffix(size()-n.size())--in other words, this\n composite name ends with 'n'.\n If n is null or not a composite name, false is returned."}, {"method_name": "addAll", "method_sig": "public Name addAll (Name suffix)\n            throws InvalidNameException", "description": "Adds the components of a composite name -- in order -- to the end of\n this composite name."}, {"method_name": "addAll", "method_sig": "public Name addAll (int posn,\n                   Name n)\n            throws InvalidNameException", "description": "Adds the components of a composite name -- in order -- at a specified\n position within this composite name.\n Components of this composite name at or after the index of the first\n new component are shifted up (away from index 0)\n to accommodate the new components."}, {"method_name": "add", "method_sig": "public Name add (String comp)\n         throws InvalidNameException", "description": "Adds a single component to the end of this composite name."}, {"method_name": "add", "method_sig": "public Name add (int posn,\n                String comp)\n         throws InvalidNameException", "description": "Adds a single component at a specified position within this\n composite name.\n Components of this composite name at or after the index of the new\n component are shifted up by one (away from index 0) to accommodate\n the new component."}, {"method_name": "remove", "method_sig": "public Object remove (int posn)\n              throws InvalidNameException", "description": "Deletes a component from this composite name.\n The component of this composite name at position 'posn' is removed,\n and components at indices greater than 'posn'\n are shifted down (towards index 0) by one."}]}