{"name": "Interface LSSerializer", "module": "java.xml", "package": "org.w3c.dom.ls", "text": "A LSSerializer provides an API for serializing (writing) a\n DOM document out into XML. The XML data is written to a string or an\n output stream. Any changes or fixups made during the serialization affect\n only the serialized data. The Document object and its\n children are never altered by the serialization operation.\n  During serialization of XML data, namespace fixup is done as defined in\n [DOM Level 3 Core]\n , Appendix B. [DOM Level 2 Core]\n  allows empty strings as a real namespace URI. If the\n namespaceURI of a Node is empty string, the\n serialization will treat them as null, ignoring the prefix\n if any.\n  LSSerializer accepts any node type for serialization. For\n nodes of type Document or Entity, well-formed\n XML will be created when possible (well-formedness is guaranteed if the\n document or entity comes from a parse operation and is unchanged since it\n was created). The serialized output for these node types is either as a\n XML document or an External XML Entity, respectively, and is acceptable\n input for an XML parser. For all other types of nodes the serialized form\n is implementation dependent.\n Within a Document, DocumentFragment, or\n Entity being serialized, Nodes are processed as\n follows\n \n Document nodes are written, including the XML\n declaration (unless the parameter \"xml-declaration\" is set to\n false) and a DTD subset, if one exists in the DOM. Writing a\n Document node serializes the entire document.\n \n\nEntity nodes, when written directly by\n LSSerializer.write, outputs the entity expansion but no\n namespace fixup is done. The resulting output will be valid as an\n external entity.\n \n If the parameter\n \"entities\"\n is set to true, EntityReference nodes are\n serialized as an entity reference of the form \"\n &entityName;\" in the output. Child nodes (the expansion)\n of the entity reference are ignored. If the parameter\n \"entities\"\n is set to false, only the children of the entity reference\n are serialized. EntityReference nodes with no children (no\n corresponding Entity node or the corresponding\n Entity nodes have no children) are always serialized.\n \n\nCDATAsections containing content characters that cannot be\n represented in the specified output encoding are handled according to the\n \"split-cdata-sections\"\n parameter.  If the parameter is set to true,\n CDATAsections are split, and the unrepresentable characters\n are serialized as numeric character references in ordinary content. The\n exact position and number of splits is not specified.  If the parameter\n is set to false, unrepresentable characters in a\n CDATAsection are reported as\n \"wf-invalid-character\" errors if the parameter\n \"well-formed\"\n is set to true. The error is not recoverable - there is no\n mechanism for supplying alternative characters and continuing with the\n serialization.\n \n DocumentFragment nodes are serialized by\n serializing the children of the document fragment in the order they\n appear in the document fragment.\n \n All other node types (Element, Text,\n etc.) are serialized to their corresponding XML source form.\n \n\nNote:  The serialization of a Node does not always\n generate a well-formed XML document, i.e. a LSParser might\n throw fatal errors when parsing the resulting serialization.\n  Within the character data of a document (outside of markup), any\n characters that cannot be represented directly are replaced with\n character references. Occurrences of '<' and '&' are replaced by\n the predefined entities &lt; and &amp;. The other predefined\n entities (&gt;, &apos;, and &quot;) might not be used, except\n where needed (e.g. using &gt; in cases such as ']]>'). Any\n characters that cannot be represented directly in the output character\n encoding are serialized as numeric character references (and since\n character encoding standards commonly use hexadecimal representations of\n characters, using the hexadecimal representation when serializing\n character references is encouraged).\n  To allow attribute values to contain both single and double quotes, the\n apostrophe or single-quote character (') may be represented as\n \"&apos;\", and the double-quote character (\")  as \"&quot;\". New\n line characters and other characters that cannot be represented directly\n in attribute values in the output character encoding are serialized as a\n numeric character reference.\n  Within markup, but outside of attributes, any occurrence of a character\n that cannot be represented in the output character encoding is reported\n as a DOMError fatal error. An example would be serializing\n the element <LaCa\u00f1ada/> with encoding=\"us-ascii\".\n This will result with a generation of a DOMError\n \"wf-invalid-character-in-node-name\" (as proposed in\n \"well-formed\").\n  When requested by setting the parameter\n \"normalize-characters\"\n on LSSerializer to true, character normalization is\n performed according to the definition of\n fully\n normalized characters included in appendix E of\n [XML 1.1] on all\n data to be serialized, both markup and character data. The character\n normalization process affects only the data as it is being written; it\n does not alter the DOM's view of the document after serialization has\n completed.\n  Implementations are required to support the encodings \"UTF-8\",\n \"UTF-16\", \"UTF-16BE\", and \"UTF-16LE\" to guarantee that data is\n serializable in all encodings that are required to be supported by all\n XML parsers. When the encoding is UTF-8, whether or not a byte order mark\n is serialized, or if the output is big-endian or little-endian, is\n implementation dependent. When the encoding is UTF-16, whether or not the\n output is big-endian or little-endian is implementation dependent, but a\n Byte Order Mark must be generated for non-character outputs, such as\n LSOutput.byteStream or LSOutput.systemId. If\n the Byte Order Mark is not generated, a \"byte-order-mark-needed\" warning\n is reported. When the encoding is UTF-16LE or UTF-16BE, the output is\n big-endian (UTF-16BE) or little-endian (UTF-16LE) and the Byte Order Mark\n is not be generated. In all cases, the encoding declaration, if\n generated, will correspond to the encoding used during the serialization\n (e.g. encoding=\"UTF-16\" will appear if UTF-16 was\n requested).\n  Namespaces are fixed up during serialization, the serialization process\n will verify that namespace declarations, namespace prefixes and the\n namespace URI associated with elements and attributes are consistent. If\n inconsistencies are found, the serialized form of the document will be\n altered to remove them. The method used for doing the namespace fixup\n while serializing a document is the algorithm defined in Appendix B.1,\n \"Namespace normalization\", of\n [DOM Level 3 Core]\n .\n  While serializing a document, the parameter \"discard-default-content\"\n controls whether or not non-specified data is serialized.\n  While serializing, errors and warnings are reported to the application\n through the error handler (LSSerializer.domConfig's\n \"error-handler\"\n parameter). This specification does in no way try to define all possible\n errors and warnings that can occur while serializing a DOM node, but some\n common error and warning cases are defined. The types (\n DOMError.type) of errors and warnings defined by this\n specification are:\n \n\"no-output-specified\" [fatal]\n Raised when\n writing to a LSOutput if no output is specified in the\n LSOutput. \n\n\"unbound-prefix-in-entity-reference\" [fatal] \n Raised if the\n configuration parameter\n \"namespaces\"\n is set to true and an entity whose replacement text\n contains unbound namespace prefixes is referenced in a location where\n there are no bindings for the namespace prefixes. \n\n\"unsupported-encoding\" [fatal]\n Raised if an unsupported\n encoding is encountered. \n\n In addition to raising the defined errors and warnings, implementations\n are expected to raise implementation specific errors and warnings for any\n other error and warning cases such as IO errors (file not found,\n permission denied,...) and so on.\n See also the\n \nDocument Object Model (DOM) Level 3 Load and Save Specification.", "codes": ["public interface LSSerializer"], "fields": [], "methods": [{"method_name": "getDomConfig", "method_sig": "DOMConfiguration getDomConfig()", "description": "The DOMConfiguration object used by the\n LSSerializer when serializing a DOM node.\n  In addition to the parameters recognized by the\n DOMConfiguration\n interface defined in\n [DOM Level 3 Core]\n , the DOMConfiguration objects for\n LSSerializer adds, or modifies, the following\n parameters:\n \n\"canonical-form\"\n\n\ntrue\n[optional] Writes the document according to the rules specified in\n [Canonical XML].\n In addition to the behavior described in\n \"canonical-form\"\n [DOM Level 3 Core]\n , setting this parameter to true will set the parameters\n \"format-pretty-print\", \"discard-default-content\", and \"xml-declaration\n \", to false. Setting one of those parameters to\n true will set this parameter to false.\n Serializing an XML 1.1 document when \"canonical-form\" is\n true will generate a fatal error. \nfalse\n[required] (default) Do not canonicalize the output. \n\n\"discard-default-content\"\n\n\n\ntrue\n[required] (default) Use the Attr.specified attribute to decide what attributes\n should be discarded. Note that some implementations might use\n whatever information available to the implementation (i.e. XML\n schema, DTD, the Attr.specified attribute, and so on) to\n determine what attributes and content to discard if this parameter is\n set to true. \nfalse\n[required]Keep all attributes and all content.\n\n\"format-pretty-print\"\n\n\n\ntrue\n[optional] Formatting the output by adding whitespace to produce a pretty-printed,\n indented, human-readable form. The exact form of the transformations\n is not specified by this specification. Pretty-printing changes the\n content of the document and may affect the validity of the document,\n validating implementations should preserve validity. \n\nfalse\n[required] (default) Don't pretty-print the result. \n\n\n\"ignore-unknown-character-denormalizations\" \n\n\n\ntrue\n[required] (default) If, while verifying full normalization when\n [XML 1.1] is\n supported, a character is encountered for which the normalization\n properties cannot be determined, then raise a\n \"unknown-character-denormalization\" warning (instead of\n raising an error, if this parameter is not set) and ignore any\n possible denormalizations caused by these characters. \n\nfalse\n[optional] Report a fatal error if a character is encountered for which the\n processor cannot determine the normalization properties. \n\n\n\"normalize-characters\"\n This parameter is equivalent to\n the one defined by DOMConfiguration in\n [DOM Level 3 Core]\n . Unlike in the Core, the default value for this parameter is\n true. While DOM implementations are not required to\n support fully\n normalizing the characters in the document according to appendix E of\n [XML 1.1], this\n parameter must be activated by default if supported. \n\n\"xml-declaration\"\n\n\ntrue\n[required] (default) If a Document,\n Element, or Entity\n  node is serialized, the XML declaration, or text declaration, should\n be included. The version (Document.xmlVersion if the\n document is a Level 3 document and the version is non-null, otherwise\n use the value \"1.0\"), and the output encoding (see\n LSSerializer.write for details on how to find the output\n encoding) are specified in the serialized XML declaration. \n\nfalse\n[required] Do not serialize the XML and text declarations. Report a\n \"xml-declaration-needed\" warning if this will cause\n problems (i.e. the serialized data is of an XML version other than\n [XML 1.0], or an\n encoding would be needed to be able to re-parse the serialized data). \n\n"}, {"method_name": "getNewLine", "method_sig": "String getNewLine()", "description": "The end-of-line sequence of characters to be used in the XML being\n written out. Any string is supported, but XML treats only a certain\n set of characters sequence as end-of-line (See section 2.11,\n \"End-of-Line Handling\" in [XML 1.0],\n if the serialized content is XML 1.0 or section 2.11, \"End-of-Line Handling\"\n in [XML 1.1], if the\n serialized content is XML 1.1). Using other character sequences than\n the recommended ones can result in a document that is either not\n serializable or not well-formed).\n  On retrieval, the default value of this attribute is the\n implementation specific default end-of-line sequence. DOM\n implementations should choose the default to match the usual\n convention for text files in the environment being used.\n Implementations must choose a default sequence that matches one of\n those allowed by XML 1.0 or XML 1.1, depending on the serialized\n content. Setting this attribute to null will reset its\n value to the default value.\n "}, {"method_name": "setNewLine", "method_sig": "void setNewLine (String newLine)", "description": "The end-of-line sequence of characters to be used in the XML being\n written out. Any string is supported, but XML treats only a certain\n set of characters sequence as end-of-line (See section 2.11,\n \"End-of-Line Handling\" in [XML 1.0],\n if the serialized content is XML 1.0 or section 2.11, \"End-of-Line Handling\"\n in [XML 1.1], if the\n serialized content is XML 1.1). Using other character sequences than\n the recommended ones can result in a document that is either not\n serializable or not well-formed).\n  On retrieval, the default value of this attribute is the\n implementation specific default end-of-line sequence. DOM\n implementations should choose the default to match the usual\n convention for text files in the environment being used.\n Implementations must choose a default sequence that matches one of\n those allowed by XML 1.0 or XML 1.1, depending on the serialized\n content. Setting this attribute to null will reset its\n value to the default value.\n "}, {"method_name": "getFilter", "method_sig": "LSSerializerFilter getFilter()", "description": "When the application provides a filter, the serializer will call out\n to the filter before serializing each Node. The filter implementation\n can choose to remove the node from the stream or to terminate the\n serialization early.\n  The filter is invoked after the operations requested by the\n DOMConfiguration parameters have been applied. For\n example, CDATA sections won't be passed to the filter if\n \"cdata-sections\"\n is set to false."}, {"method_name": "setFilter", "method_sig": "void setFilter (LSSerializerFilter filter)", "description": "When the application provides a filter, the serializer will call out\n to the filter before serializing each Node. The filter implementation\n can choose to remove the node from the stream or to terminate the\n serialization early.\n  The filter is invoked after the operations requested by the\n DOMConfiguration parameters have been applied. For\n example, CDATA sections won't be passed to the filter if\n \"cdata-sections\"\n is set to false."}, {"method_name": "write", "method_sig": "boolean write (Node nodeArg,\n              LSOutput destination)\n       throws LSException", "description": "Serialize the specified node as described above in the general\n description of the LSSerializer interface. The output is\n written to the supplied LSOutput.\n  When writing to a LSOutput, the encoding is found by\n looking at the encoding information that is reachable through the\n LSOutput and the item to be written (or its owner\n document) in this order:\n \n LSOutput.encoding,\n \n\nDocument.inputEncoding,\n \n\nDocument.xmlEncoding.\n \n\n If no encoding is reachable through the above properties, a\n default encoding of \"UTF-8\" will be used. If the specified encoding\n is not supported an \"unsupported-encoding\" fatal error is raised.\n  If no output is specified in the LSOutput, a\n \"no-output-specified\" fatal error is raised.\n  The implementation is responsible of associating the appropriate\n media type with the serialized data.\n  When writing to a HTTP URI, a HTTP PUT is performed. When writing\n to other types of URIs, the mechanism for writing the data to the URI\n is implementation dependent."}, {"method_name": "writeToURI", "method_sig": "boolean writeToURI (Node nodeArg,\n                   String uri)\n            throws LSException", "description": "A convenience method that acts as if LSSerializer.write\n was called with a LSOutput with no encoding specified\n and LSOutput.systemId set to the uri\n argument."}, {"method_name": "writeToString", "method_sig": "String writeToString (Node nodeArg)\n              throws DOMException,\n                     LSException", "description": "Serialize the specified node as described above in the general\n description of the LSSerializer interface. The output is\n written to a DOMString that is returned to the caller.\n The encoding used is the encoding of the DOMString type,\n i.e. UTF-16. Note that no Byte Order Mark is generated in a\n DOMString object."}]}