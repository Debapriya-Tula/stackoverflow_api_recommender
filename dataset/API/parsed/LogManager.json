{"name": "Class LogManager", "module": "java.logging", "package": "java.util.logging", "text": "There is a single global LogManager object that is used to\n maintain a set of shared state about Loggers and log services.\n \n This LogManager object:\n \n Manages a hierarchical namespace of Logger objects.  All\n      named Loggers are stored in this namespace.\n  Manages a set of logging control properties.  These are\n      simple key-value pairs that can be used by Handlers and\n      other logging objects to configure themselves.\n \n\n The global LogManager object can be retrieved using LogManager.getLogManager().\n The LogManager object is created during class initialization and\n cannot subsequently be changed.\n \n At startup the LogManager class is located using the\n java.util.logging.manager system property.\n\n LogManager Configuration\n\n A LogManager initializes the logging configuration via\n the readConfiguration() method during LogManager initialization.\n By default, LogManager default configuration is used.\n The logging configuration read by LogManager must be in the\n properties file format.\n \n The LogManager defines two optional system properties that allow control over\n the initial configuration, as specified in the readConfiguration()\n method:\n \n\"java.util.logging.config.class\"\n \"java.util.logging.config.file\"\n \n\n These two system properties may be specified on the command line to the \"java\"\n command, or as system property definitions passed to JNI_CreateJavaVM.\n \n The properties for loggers and Handlers will have\n names starting with the dot-separated name for the handler or logger.\n The global logging properties may include:\n \nA property \"handlers\".  This defines a whitespace or comma separated\n list of class names for handler classes to load and register as\n handlers on the root Logger (the Logger named \"\").  Each class\n name must be for a Handler class which has a default constructor.\n Note that these Handlers may be created lazily, when they are\n first used.\n\n A property \"<logger>.handlers\". This defines a whitespace or\n comma separated list of class names for handlers classes to\n load and register as handlers to the specified logger. Each class\n name must be for a Handler class which has a default constructor.\n Note that these Handlers may be created lazily, when they are\n first used.\n\n A property \"<logger>.handlers.ensureCloseOnReset\". This defines a\n a boolean value. If \"<logger>.handlers\" is not defined or is empty,\n this property is ignored. Otherwise it defaults to true. When the\n value is true, the handlers associated with the logger are guaranteed\n to be closed on reset() and shutdown. This can be turned off\n by explicitly setting \"<logger>.handlers.ensureCloseOnReset=false\" in\n the configuration. Note that turning this property off causes the risk of\n introducing a resource leak, as the logger may get garbage collected before\n reset() is called, thus preventing its handlers from being closed\n on reset(). In that case it is the responsibility of the application\n to ensure that the handlers are closed before the logger is garbage\n collected.\n\n A property \"<logger>.useParentHandlers\". This defines a boolean\n value. By default every logger calls its parent in addition to\n handling the logging message itself, this often result in messages\n being handled by the root logger as well. When setting this property\n to false a Handler needs to be configured for this logger otherwise\n no logging messages are delivered.\n\n A property \"config\".  This property is intended to allow\n arbitrary configuration code to be run.  The property defines a\n whitespace or comma separated list of class names.  A new instance will be\n created for each named class.  The default constructor of each class\n may execute arbitrary code to update the logging configuration, such as\n setting logger levels, adding handlers, adding filters, etc.\n \n\n Note that all classes loaded during LogManager configuration are\n first searched on the system class path before any user class path.\n That includes the LogManager class, any config classes, and any\n handler classes.\n \n Loggers are organized into a naming hierarchy based on their\n dot separated names.  Thus \"a.b.c\" is a child of \"a.b\", but\n \"a.b1\" and a.b2\" are peers.\n \n All properties whose names end with \".level\" are assumed to define\n log levels for Loggers.  Thus \"foo.level\" defines a log level for\n the logger called \"foo\" and (recursively) for any of its children\n in the naming hierarchy.  Log Levels are applied in the order they\n are defined in the properties file.  Thus level settings for child\n nodes in the tree should come after settings for their parents.\n The property name \".level\" can be used to set the level for the\n root of the tree.\n \n All methods on the LogManager object are multi-thread safe.", "codes": ["public class LogManager\nextends Object"], "fields": [{"field_name": "LOGGING_MXBEAN_NAME", "field_sig": "public static final\u00a0String LOGGING_MXBEAN_NAME", "description": "String representation of the\n ObjectName for the management interface\n for the logging facility."}], "methods": [{"method_name": "getLogManager", "method_sig": "public static LogManager getLogManager()", "description": "Returns the global LogManager object."}, {"method_name": "addLogger", "method_sig": "public boolean addLogger (Logger logger)", "description": "Add a named logger.  This does nothing and returns false if a logger\n with the same name is already registered.\n \n The Logger factory methods call this method to register each\n newly created Logger.\n \n The application should retain its own reference to the Logger\n object to avoid it being garbage collected.  The LogManager\n may only retain a weak reference."}, {"method_name": "getLogger", "method_sig": "public Logger getLogger (String name)", "description": "Method to find a named logger.\n \n Note that since untrusted code may create loggers with\n arbitrary names this method should not be relied on to\n find Loggers for security sensitive logging.\n It is also important to note that the Logger associated with the\n String name may be garbage collected at any time if there\n is no strong reference to the Logger. The caller of this method\n must check the return value for null in order to properly handle\n the case where the Logger has been garbage collected."}, {"method_name": "getLoggerNames", "method_sig": "public Enumeration<String> getLoggerNames()", "description": "Get an enumeration of known logger names.\n \n Note:  Loggers may be added dynamically as new classes are loaded.\n This method only reports on the loggers that are currently registered.\n It is also important to note that this method only returns the name\n of a Logger, not a strong reference to the Logger itself.\n The returned String does nothing to prevent the Logger from being\n garbage collected. In particular, if the returned name is passed\n to LogManager.getLogger(), then the caller must check the\n return value from LogManager.getLogger() for null to properly\n handle the case where the Logger has been garbage collected in the\n time since its name was returned by this method."}, {"method_name": "readConfiguration", "method_sig": "public void readConfiguration()\n                       throws IOException,\n                              SecurityException", "description": "Reads and initializes the logging configuration.\n \n If the \"java.util.logging.config.class\" system property is set, then the\n property value is treated as a class name.  The given class will be\n loaded, an object will be instantiated, and that object's constructor\n is responsible for reading in the initial configuration.  (That object\n may use other system properties to control its configuration.)  The\n alternate configuration class can use readConfiguration(InputStream)\n to define properties in the LogManager.\n \n If \"java.util.logging.config.class\" system property is not set,\n then this method will read the initial configuration from a properties\n file and calls the readConfiguration(InputStream) method to initialize\n the configuration. The \"java.util.logging.config.file\" system property can be used\n to specify the properties file that will be read as the initial configuration;\n if not set, then the LogManager default configuration is used.\n The default configuration is typically loaded from the\n properties file \"conf/logging.properties\" in the Java installation\n directory.\n\n \n Any registered configuration\n listener will be invoked after the properties are read."}, {"method_name": "reset", "method_sig": "public void reset()\n           throws SecurityException", "description": "Reset the logging configuration.\n \n For all named loggers, the reset operation removes and closes\n all Handlers and (except for the root logger) sets the level\n to null. The root logger's level is set to Level.INFO."}, {"method_name": "readConfiguration", "method_sig": "public void readConfiguration (InputStream ins)\n                       throws IOException,\n                              SecurityException", "description": "Reads and initializes the logging configuration from the given input stream.\n\n \n Any registered configuration\n listener will be invoked after the properties are read."}, {"method_name": "updateConfiguration", "method_sig": "public void updateConfiguration (Function<String, BiFunction<String, String, String>> mapper)\n                         throws IOException", "description": "Updates the logging configuration.\n \n If the \"java.util.logging.config.file\" system property is set,\n then the property value specifies the properties file to be read\n as the new configuration. Otherwise, the LogManager default\n configuration is used.\n The default configuration is typically loaded from the\n properties file \"conf/logging.properties\" in the\n Java installation directory.\n \n This method reads the new configuration and calls the updateConfiguration(ins, mapper) method to\n update the configuration."}, {"method_name": "updateConfiguration", "method_sig": "public void updateConfiguration (InputStream ins,\n                                Function<String, BiFunction<String, String, String>> mapper)\n                         throws IOException", "description": "Updates the logging configuration.\n \n For each configuration key in the existing configuration and\n the given input stream configuration, the given mapper function\n is invoked to map from the configuration key to a function,\n f(o,n), that takes the old value and new value and returns\n the resulting value to be applied in the resulting configuration,\n as specified in the table below.\n Let k be a configuration key in the old or new configuration,\n o be the old value (i.e. the value associated\n with k in the old configuration), n be the\n new value (i.e. the value associated with k in the new\n configuration), and f be the function returned\n by mapper.apply(k): then v = f(o,n) is the\n resulting value. If v is not null, then a property\n k with value v will be added to the resulting configuration.\n Otherwise, it will be omitted.\n A null value may be passed to function\n f to indicate that the corresponding configuration has no\n configuration key k.\n The function f may return null to indicate that\n there will be no value associated with k in the resulting\n configuration.\n \n If mapper is null, then v will be set to\n n.\n \n LogManager properties are\n updated with the resulting value in the resulting configuration.\n \n The registered configuration\n listeners will be invoked after the configuration is successfully updated.\n \n\nUpdating configuration properties\n\n\nProperty\nResulting Behavior\n\n\n\n\n<logger>.level\n\n\nIf the resulting configuration defines a level for a logger and\n       if the resulting level is different than the level specified in the\n       the old configuration, or not specified in\n       the old configuration, then if the logger exists or if children for\n       that logger exist, the level for that logger will be updated,\n       and the change propagated to any existing logger children.\n       This may cause the logger to be created, if necessary.\n   \nIf the old configuration defined a level for a logger, and the\n       resulting configuration doesn't, then this change will not be\n       propagated to existing loggers, if any.\n       To completely replace a configuration - the caller should therefore\n       call reset to empty the current configuration,\n       before calling updateConfiguration.\n   \n\n\n\n<logger>.useParentHandlers\n\n\nIf either the resulting or the old value for the useParentHandlers\n       property is not null, then if the logger exists or if children for\n       that logger exist, that logger will be updated to the resulting\n       value.\n       The value of the useParentHandlers property is the value specified\n       in the configuration; if not specified, the default is true.\n   \n\n\n\n\n<logger>.handlers\n\n\nIf the resulting configuration defines a list of handlers for a\n       logger, and if the resulting list is different than the list\n       specified in the old configuration for that logger (that could be\n       empty), then if the logger exists or its children exist, the\n       handlers associated with that logger are closed and removed and\n       the new handlers will be created per the resulting configuration\n       and added to that logger, creating that logger if necessary.\n   \nIf the old configuration defined some handlers for a logger, and\n       the resulting configuration doesn't, if that logger exists,\n       its handlers will be removed and closed.\n   \nChanging the list of handlers on an existing logger will cause all\n       its previous handlers to be removed and closed, regardless of whether\n       they had been created from the configuration or programmatically.\n       The old handlers will be replaced by new handlers, if any.\n   \n\n\n\n\n<handler-name>.*\n\n\nProperties configured/changed on handler classes will only affect\n       newly created handlers. If a node is configured with the same list\n       of handlers in the old and the resulting configuration, then these\n       handlers will remain unchanged.\n   \n\n\n\n\nconfig and any other property\n\n\nThe resulting value for these property will be stored in the\n   LogManager properties, but updateConfiguration will not parse\n   or process their values.\n   \n\n\n\n\n\n\nExample mapper functions:\n\n\nReplace all logging properties with the new configuration:\n     (k) -> ((o, n) -> n):\n this is equivalent to passing a null mapper parameter.\n \nMerge the new configuration and old configuration and use the\n new value if k exists in the new configuration:\n     (k) -> ((o, n) -> n == null ? o : n):\n as if merging two collections as follows:\n result.putAll(oldc); result.putAll(newc).\nMerge the new configuration and old configuration and use the old\n value if k exists in the old configuration:\n     (k) -> ((o, n) -> o == null ? n : o):\n as if merging two collections as follows:\n result.putAll(newc); result.putAll(oldc).\nReplace all properties with the new configuration except the handler\n property to configure Logger's handler that is not root logger:\n \n(k) -> k.endsWith(\".handlers\")\n          ? ((o, n) -> (o == null ? n : o))\n          : ((o, n) -> n)\n\n\n\n To completely reinitialize a configuration, an application can first call\n reset to fully remove the old configuration, followed by\n updateConfiguration to initialize the new configuration."}, {"method_name": "getProperty", "method_sig": "public String getProperty (String name)", "description": "Get the value of a logging property.\n The method returns null if the property is not found."}, {"method_name": "checkAccess", "method_sig": "public void checkAccess()\n                 throws SecurityException", "description": "Check that the current context is trusted to modify the logging\n configuration.  This requires LoggingPermission(\"control\").\n \n If the check fails we throw a SecurityException, otherwise\n we return normally."}, {"method_name": "getLoggingMXBean", "method_sig": "@Deprecated(since=\"9\")\npublic static LoggingMXBean getLoggingMXBean()", "description": "Returns LoggingMXBean for managing loggers."}, {"method_name": "addConfigurationListener", "method_sig": "public LogManager addConfigurationListener (Runnable listener)", "description": "Adds a configuration listener to be invoked each time the logging\n configuration is read.\n If the listener is already registered the method does nothing.\n \n The listener is invoked with privileges that are restricted by the\n calling context of this method.\n The order in which the listeners are invoked is unspecified.\n \n It is recommended that listeners do not throw errors or exceptions.\n\n If a listener terminates with an uncaught error or exception then\n the first exception will be propagated to the caller of\n readConfiguration() (or readConfiguration(java.io.InputStream))\n after all listeners have been invoked."}, {"method_name": "removeConfigurationListener", "method_sig": "public void removeConfigurationListener (Runnable listener)", "description": "Removes a previously registered configuration listener.\n\n Returns silently if the listener is not found."}]}