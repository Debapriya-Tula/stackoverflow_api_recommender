{"name": "Class MemoryHandler", "module": "java.logging", "package": "java.util.logging", "text": "Handler that buffers requests in a circular buffer in memory.\n \n Normally this Handler simply stores incoming LogRecords\n into its memory buffer and discards earlier records.  This buffering\n is very cheap and avoids formatting costs.  On certain trigger\n conditions, the MemoryHandler will push out its current buffer\n contents to a target Handler, which will typically publish\n them to the outside world.\n \n There are three main models for triggering a push of the buffer:\n \n\n An incoming LogRecord has a type that is greater than\n a pre-defined level, the pushLevel. \n\n An external class calls the push method explicitly. \n\n A subclass overrides the log method and scans each incoming\n LogRecord and calls push if a record matches some\n desired criteria. \n\n\nConfiguration:\n By default each MemoryHandler is initialized using the following\n LogManager configuration properties where <handler-name>\n refers to the fully-qualified class name of the handler.\n If properties are not defined\n (or have invalid values) then the specified default values are used.\n If no default value is defined then a RuntimeException is thrown.\n \n   <handler-name>.level\n        specifies the level for the Handler\n        (defaults to Level.ALL). \n   <handler-name>.filter\n        specifies the name of a Filter class to use\n        (defaults to no Filter). \n   <handler-name>.size\n        defines the buffer size (defaults to 1000). \n   <handler-name>.push\n        defines the pushLevel (defaults to level.SEVERE). \n   <handler-name>.target\n        specifies the name of the target Handler  class.\n        (no default). \n\n\n For example, the properties for MemoryHandler would be:\n \n   java.util.logging.MemoryHandler.level=INFO \n   java.util.logging.MemoryHandler.formatter=java.util.logging.SimpleFormatter \n\n\n For a custom handler, e.g. com.foo.MyHandler, the properties would be:\n \n   com.foo.MyHandler.level=INFO \n   com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter \n", "codes": ["public class MemoryHandler\nextends Handler"], "fields": [], "methods": [{"method_name": "publish", "method_sig": "public void publish (LogRecord record)", "description": "Store a LogRecord in an internal buffer.\n \n If there is a Filter, its isLoggable\n method is called to check if the given log record is loggable.\n If not we return.  Otherwise the given record is copied into\n an internal circular buffer.  Then the record's level property is\n compared with the pushLevel. If the given level is\n greater than or equal to the pushLevel then push\n is called to write all buffered records to the target output\n Handler."}, {"method_name": "push", "method_sig": "public void push()", "description": "Push any buffered output to the target Handler.\n \n The buffer is then cleared."}, {"method_name": "flush", "method_sig": "public void flush()", "description": "Causes a flush on the target Handler.\n \n Note that the current contents of the MemoryHandler\n buffer are not written out.  That requires a \"push\"."}, {"method_name": "close", "method_sig": "public void close()\n           throws SecurityException", "description": "Close the Handler and free all associated resources.\n This will also close the target Handler."}, {"method_name": "setPushLevel", "method_sig": "public void setPushLevel (Level newLevel)\n                  throws SecurityException", "description": "Set the pushLevel.  After a LogRecord is copied\n into our internal buffer, if its level is greater than or equal to\n the pushLevel, then push will be called."}, {"method_name": "getPushLevel", "method_sig": "public Level getPushLevel()", "description": "Get the pushLevel."}, {"method_name": "isLoggable", "method_sig": "public boolean isLoggable (LogRecord record)", "description": "Check if this Handler would actually log a given\n LogRecord into its internal buffer.\n \n This method checks if the LogRecord has an appropriate level and\n whether it satisfies any Filter.  However it does not\n check whether the LogRecord would result in a \"push\" of the\n buffer contents. It will return false if the LogRecord is null."}]}