{"name": "Class BufferedInputStream", "module": "java.base", "package": "java.io", "text": "A BufferedInputStream adds\n functionality to another input stream-namely,\n the ability to buffer the input and to\n support the mark and reset\n methods. When  the BufferedInputStream\n is created, an internal buffer array is\n created. As bytes  from the stream are read\n or skipped, the internal buffer is refilled\n as necessary  from the contained input stream,\n many bytes at a time. The mark\n operation  remembers a point in the input\n stream and the reset operation\n causes all the  bytes read since the most\n recent mark operation to be\n reread before new bytes are  taken from\n the contained input stream.", "codes": ["public class BufferedInputStream\nextends FilterInputStream"], "fields": [{"field_name": "buf", "field_sig": "protected volatile\u00a0byte[] buf", "description": "The internal buffer array where the data is stored. When necessary,\n it may be replaced by another array of\n a different size."}, {"field_name": "count", "field_sig": "protected\u00a0int count", "description": "The index one greater than the index of the last valid byte in\n the buffer.\n This value is always\n in the range 0 through buf.length;\n elements buf[0]  through buf[count-1]\n contain buffered input data obtained\n from the underlying  input stream."}, {"field_name": "pos", "field_sig": "protected\u00a0int pos", "description": "The current position in the buffer. This is the index of the next\n character to be read from the buf array.\n \n This value is always in the range 0\n through count. If it is less\n than count, then  buf[pos]\n is the next byte to be supplied as input;\n if it is equal to count, then\n the  next read or skip\n operation will require more bytes to be\n read from the contained  input stream."}, {"field_name": "markpos", "field_sig": "protected\u00a0int markpos", "description": "The value of the pos field at the time the last\n mark method was called.\n \n This value is always\n in the range -1 through pos.\n If there is no marked position in  the input\n stream, this field is -1. If\n there is a marked position in the input\n stream,  then buf[markpos]\n is the first byte to be supplied as input\n after a reset operation. If\n markpos is not -1,\n then all bytes from positions buf[markpos]\n through  buf[pos-1] must remain\n in the buffer array (though they may be\n moved to  another place in the buffer array,\n with suitable adjustments to the values\n of count,  pos,\n and markpos); they may not\n be discarded unless and until the difference\n between pos and markpos\n exceeds marklimit."}, {"field_name": "marklimit", "field_sig": "protected\u00a0int marklimit", "description": "The maximum read ahead allowed after a call to the\n mark method before subsequent calls to the\n reset method fail.\n Whenever the difference between pos\n and markpos exceeds marklimit,\n then the  mark may be dropped by setting\n markpos to -1."}], "methods": [{"method_name": "read", "method_sig": "public int read()\n         throws IOException", "description": "See\n the general contract of the read\n method of InputStream."}, {"method_name": "read", "method_sig": "public int read (byte[] b,\n                int off,\n                int len)\n         throws IOException", "description": "Reads bytes from this byte-input stream into the specified byte array,\n starting at the given offset.\n\n  This method implements the general contract of the corresponding\n read method of\n the InputStream class.  As an additional\n convenience, it attempts to read as many bytes as possible by repeatedly\n invoking the read method of the underlying stream.  This\n iterated read continues until one of the following\n conditions becomes true: \n The specified number of bytes have been read,\n\n    The read method of the underlying stream returns\n   -1, indicating end-of-file, or\n\n    The available method of the underlying stream\n   returns zero, indicating that further input requests would block.\n\n  If the first read on the underlying stream returns\n -1 to indicate end-of-file then this method returns\n -1.  Otherwise this method returns the number of bytes\n actually read.\n\n  Subclasses of this class are encouraged, but not required, to\n attempt to read as many bytes as possible in the same fashion."}, {"method_name": "skip", "method_sig": "public long skip (long n)\n          throws IOException", "description": "See the general contract of the skip\n method of InputStream."}, {"method_name": "available", "method_sig": "public int available()\n              throws IOException", "description": "Returns an estimate of the number of bytes that can be read (or\n skipped over) from this input stream without blocking by the next\n invocation of a method for this input stream. The next invocation might be\n the same thread or another thread.  A single read or skip of this\n many bytes will not block, but may read or skip fewer bytes.\n \n This method returns the sum of the number of bytes remaining to be read in\n the buffer (count\u00a0- pos) and the result of calling the\n in.available()."}, {"method_name": "mark", "method_sig": "public void mark (int readlimit)", "description": "See the general contract of the mark\n method of InputStream."}, {"method_name": "reset", "method_sig": "public void reset()\n           throws IOException", "description": "See the general contract of the reset\n method of InputStream.\n \n If markpos is -1\n (no mark has been set or the mark has been\n invalidated), an IOException\n is thrown. Otherwise, pos is\n set equal to markpos."}, {"method_name": "markSupported", "method_sig": "public boolean markSupported()", "description": "Tests if this input stream supports the mark\n and reset methods. The markSupported\n method of BufferedInputStream returns\n true."}, {"method_name": "close", "method_sig": "public void close()\n           throws IOException", "description": "Closes this input stream and releases any system resources\n associated with the stream.\n Once the stream has been closed, further read(), available(), reset(),\n or skip() invocations will throw an IOException.\n Closing a previously closed stream has no effect."}]}