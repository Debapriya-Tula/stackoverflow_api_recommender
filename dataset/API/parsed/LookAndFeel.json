{"name": "Class LookAndFeel", "module": "java.desktop", "package": "javax.swing", "text": "LookAndFeel, as the name implies, encapsulates a look and\n feel. Beyond installing a look and feel most developers never need to\n interact directly with LookAndFeel. In general only developers\n creating a custom look and feel need to concern themselves with this class.\n \n Swing is built upon the foundation that each JComponent\n subclass has an implementation of a specific ComponentUI\n subclass. The ComponentUI is often referred to as \"the ui\",\n \"component ui\", or \"look and feel delegate\". The ComponentUI\n subclass is responsible for providing the look and feel specific\n functionality of the component. For example, JTree requires\n an implementation of the ComponentUI subclass \n TreeUI. The implementation of the specific \n ComponentUI subclass is provided by the LookAndFeel. Each\n JComponent subclass identifies the ComponentUI\n subclass it requires by way of the JComponent method \n getUIClassID.\n \n Each LookAndFeel implementation must provide\n an implementation of the appropriate ComponentUI subclass by\n specifying a value for each of Swing's ui class ids in the \n UIDefaults object returned from getDefaults. For example,\n BasicLookAndFeel uses BasicTreeUI as the concrete\n implementation for TreeUI. This is accomplished by \n BasicLookAndFeel providing the key-value pair \n \"TreeUI\"-\"javax.swing.plaf.basic.BasicTreeUI\", in the\n UIDefaults returned from getDefaults. Refer to\n UIDefaults.getUI(JComponent) for details on how the implementation\n of the ComponentUI subclass is obtained.\n \n When a LookAndFeel is installed the UIManager does\n not check that an entry exists for all ui class ids. As such,\n random exceptions will occur if the current look and feel has not\n provided a value for a particular ui class id and an instance of\n the JComponent subclass is created.\n\n Recommendations for Look and Feels\n\n As noted in UIManager each LookAndFeel has the opportunity\n to provide a set of defaults that are layered in with developer and\n system defaults. Some of Swing's components require the look and feel\n to provide a specific set of defaults. These are documented in the\n classes that require the specific default.\n\n ComponentUIs and defaults\n\n All ComponentUIs typically need to set various properties\n on the JComponent the ComponentUI is providing the\n look and feel for. This is typically done when the \n ComponentUI is installed on the JComponent. Setting a\n property should only be done if the developer has not set the\n property. For non-primitive values it is recommended that the\n ComponentUI only change the property on the \n JComponent if the current value is null or implements\n UIResource. If the current value is null or\n implements UIResource it indicates the property has not\n been set by the developer, and the ui is free to change it.  For\n example, BasicButtonUI.installDefaults only changes the\n font on the JButton if the return value from \n button.getFont() is null or implements \n UIResource. On the other hand if button.getFont() returned\n a non-null value that did not implement UIResource\n then BasicButtonUI.installDefaults would not change the\n JButton's font.\n \n For primitive values, such as opaque, the method \n installProperty should be invoked.  installProperty only changes\n the corresponding property if the value has not been changed by the\n developer.\n \nComponentUI implementations should use the various install methods\n provided by this class as they handle the necessary checking and install\n the property using the recommended guidelines.\n\n Exceptions\n\n All of the install methods provided by LookAndFeel need to\n access the defaults if the value of the property being changed is\n null or a UIResource. For example, installing the\n font does the following:\n \n   JComponent c;\n   Font font = c.getFont();\n   if (font == null || (font instanceof UIResource)) {\n       c.setFont(UIManager.getFont(\"fontKey\"));\n   }\n \n If the font is null or a UIResource, the\n defaults table is queried with the key fontKey. All of\n UIDefault's get methods throw a \n NullPointerException if passed in null. As such, unless\n otherwise noted each of the various install methods of \n LookAndFeel throw a NullPointerException if the current\n value is null or a UIResource and the supplied\n defaults key is null. In addition, unless otherwise specified\n all of the install methods throw a NullPointerException if\n a null component is passed in.", "codes": ["public abstract class LookAndFeel\nextends Object"], "fields": [], "methods": [{"method_name": "installColors", "method_sig": "public static void installColors (JComponent c,\n                                 String defaultBgName,\n                                 String defaultFgName)", "description": "Convenience method for setting a component's foreground\n and background color properties with values from the\n defaults.  The properties are only set if the current\n value is either null or a UIResource."}, {"method_name": "installColorsAndFont", "method_sig": "public static void installColorsAndFont (JComponent c,\n                                        String defaultBgName,\n                                        String defaultFgName,\n                                        String defaultFontName)", "description": "Convenience method for setting a component's foreground,\n background and font properties with values from the\n defaults.  The properties are only set if the current\n value is either null or a UIResource."}, {"method_name": "installBorder", "method_sig": "public static void installBorder (JComponent c,\n                                 String defaultBorderName)", "description": "Convenience method for setting a component's border property with\n a value from the defaults. The border is only set if the border is\n null or an instance of UIResource."}, {"method_name": "uninstallBorder", "method_sig": "public static void uninstallBorder (JComponent c)", "description": "Convenience method for uninstalling a border. If the border of\n the component is a UIResource, it is set to \n null."}, {"method_name": "installProperty", "method_sig": "public static void installProperty (JComponent c,\n                                   String propertyName,\n                                   Object propertyValue)", "description": "Convenience method for installing a property with the specified name\n and value on a component if that property has not already been set\n by the developer.  This method is intended to be used by\n ui delegate instances that need to specify a default value for a\n property of primitive type (boolean, int, ..), but do not wish\n to override a value set by the client.  Since primitive property\n values cannot be wrapped with the UIResource marker, this method\n uses private state to determine whether the property has been set\n by the client."}, {"method_name": "makeKeyBindings", "method_sig": "public static JTextComponent.KeyBinding[] makeKeyBindings (Object[] keyBindingList)", "description": "Convenience method for building an array of \n KeyBindings. While this method is not deprecated, developers\n should instead use ActionMap and InputMap for\n supplying key bindings.\n \n This method returns an array of KeyBindings, one for each\n alternating key-action pair in keyBindingList.\n A key can either be a String in the format\n specified by the KeyStroke.getKeyStroke method, or\n a KeyStroke. The action part of the pair is a\n String that corresponds to the name of the \n Action.\n \n The following example illustrates creating a KeyBinding array\n from six alternating key-action pairs:\n \n  JTextComponent.KeyBinding[] multilineBindings = makeKeyBindings( new Object[] {\n          \"UP\", DefaultEditorKit.upAction,\n        \"DOWN\", DefaultEditorKit.downAction,\n     \"PAGE_UP\", DefaultEditorKit.pageUpAction,\n   \"PAGE_DOWN\", DefaultEditorKit.pageDownAction,\n       \"ENTER\", DefaultEditorKit.insertBreakAction,\n         \"TAB\", DefaultEditorKit.insertTabAction\n  });\n \n If keyBindingList's length is odd, the last element is\n ignored.\n \n Supplying a null value for either the key or\n action part of the key-action pair results in\n creating a KeyBinding with the corresponding value\n null. As other parts of Swing's expect non-null values\n in a KeyBinding, you should avoid supplying null as\n either the key or action part of the key-action\n pair."}, {"method_name": "makeInputMap", "method_sig": "public static InputMap makeInputMap (Object[] keys)", "description": "Creates an InputMapUIResource from keys. This is\n a convenience method for creating a new InputMapUIResource,\n invoking loadKeyBindings(map, keys), and returning the\n InputMapUIResource."}, {"method_name": "makeComponentInputMap", "method_sig": "public static ComponentInputMap makeComponentInputMap (JComponent c,\n                                                      Object[] keys)", "description": "Creates a ComponentInputMapUIResource from\n keys. This is a convenience method for creating a\n new ComponentInputMapUIResource, invoking \n loadKeyBindings(map, keys), and returning the \n ComponentInputMapUIResource."}, {"method_name": "loadKeyBindings", "method_sig": "public static void loadKeyBindings (InputMap retMap,\n                                   Object[] keys)", "description": "Populates an InputMap with the specified bindings.\n The bindings are supplied as a list of alternating\n keystroke-action key pairs. The keystroke is either\n an instance of KeyStroke, or a String\n that identifies the KeyStroke for the binding. Refer\n to KeyStroke.getKeyStroke(String) for the specific\n format. The action key part of the pair is the key\n registered in the InputMap for the KeyStroke.\n \n The following illustrates loading an InputMap with two\n key-action pairs:\n \n   LookAndFeel.loadKeyBindings(inputMap, new Object[] {\n     \"control X\", \"cut\",\n     \"control V\", \"paste\"\n   });\n \n\n Supplying a null list of bindings (keys) does not\n change retMap in any way.\n \n Specifying a null action key results in\n removing the keystroke's entry from the InputMap.\n A null keystroke is ignored."}, {"method_name": "makeIcon", "method_sig": "public static Object makeIcon (Class<?> baseClass,\n                              String gifFile)", "description": "Creates and returns a UIDefault.LazyValue that loads an\n image. The returned value is an implementation of \n UIDefaults.LazyValue. When createValue is invoked on\n the returned object, the image is loaded. If the image is \n non-null, it is then wrapped in an Icon that implements \n UIResource. The image is loaded using \n Class.getResourceAsStream(gifFile).\n \n This method does not check the arguments in any way. It is\n strongly recommended that non-null values are supplied else\n exceptions may occur when createValue is invoked on the\n returned object."}, {"method_name": "getLayoutStyle", "method_sig": "public LayoutStyle getLayoutStyle()", "description": "Returns the LayoutStyle for this look\n and feel.  This never returns null.\n \n You generally don't use the LayoutStyle from\n the look and feel, instead use the LayoutStyle\n method getInstance."}, {"method_name": "provideErrorFeedback", "method_sig": "public void provideErrorFeedback (Component component)", "description": "Invoked when the user attempts an invalid operation,\n such as pasting into an uneditable JTextField\n that has focus. The default implementation beeps. Subclasses\n that wish different behavior should override this and provide\n the additional feedback."}, {"method_name": "getDesktopPropertyValue", "method_sig": "public static Object getDesktopPropertyValue (String systemPropertyName,\n                                             Object fallbackValue)", "description": "Returns the value of the specified system desktop property by\n invoking Toolkit.getDefaultToolkit().getDesktopProperty().\n If the value of the specified property is null,\n fallbackValue is returned."}, {"method_name": "getDisabledIcon", "method_sig": "public Icon getDisabledIcon (JComponent component,\n                            Icon icon)", "description": "Returns an Icon with a disabled appearance.\n This method is used to generate a disabled Icon when\n one has not been specified.  For example, if you create a\n JButton and only specify an Icon via\n setIcon this method will be called to generate the\n disabled Icon. If null is passed as\n icon this method returns null.\n \n Some look and feels might not render the disabled Icon, in which\n case they will ignore this."}, {"method_name": "getDisabledSelectedIcon", "method_sig": "public Icon getDisabledSelectedIcon (JComponent component,\n                                    Icon icon)", "description": "Returns an Icon for use by disabled\n components that are also selected. This method is used to generate an\n Icon for components that are in both the disabled and\n selected states but do not have a specific Icon for this\n state.  For example, if you create a JButton and only\n specify an Icon via setIcon this method\n will be called to generate the disabled and selected\n Icon. If null is passed as icon this\n methods returns null.\n \n Some look and feels might not render the disabled and selected\n Icon, in which case they will ignore this."}, {"method_name": "getName", "method_sig": "public abstract String getName()", "description": "Return a short string that identifies this look and feel, e.g.\n \"CDE/Motif\".  This string should be appropriate for a menu item.\n Distinct look and feels should have different names, e.g.\n a subclass of MotifLookAndFeel that changes the way a few components\n are rendered should be called \"CDE/Motif My Way\"; something\n that would be useful to a user trying to select a L&F from a list\n of names."}, {"method_name": "getID", "method_sig": "public abstract String getID()", "description": "Return a string that identifies this look and feel.  This string\n will be used by applications/services that want to recognize\n well known look and feel implementations.  Presently\n the well known names are \"Motif\", \"Windows\", \"Mac\", \"Metal\".  Note\n that a LookAndFeel derived from a well known superclass\n that doesn't make any fundamental changes to the look or feel\n shouldn't override this method."}, {"method_name": "getDescription", "method_sig": "public abstract String getDescription()", "description": "Return a one line description of this look and feel implementation,\n e.g. \"The CDE/Motif Look and Feel\".   This string is intended for\n the user, e.g. in the title of a window or in a ToolTip message."}, {"method_name": "getSupportsWindowDecorations", "method_sig": "public boolean getSupportsWindowDecorations()", "description": "Returns true if the LookAndFeel returned\n RootPaneUI instances support providing Window\n decorations in a JRootPane.\n \n The default implementation returns false, subclasses that\n support Window decorations should override this and return\n true."}, {"method_name": "isNativeLookAndFeel", "method_sig": "public abstract boolean isNativeLookAndFeel()", "description": "If the underlying platform has a \"native\" look and feel, and\n this is an implementation of it, return true.  For\n example, when the underlying platform is Solaris running CDE\n a CDE/Motif look and feel implementation would return \n true."}, {"method_name": "isSupportedLookAndFeel", "method_sig": "public abstract boolean isSupportedLookAndFeel()", "description": "Return true if the underlying platform supports and or permits\n this look and feel.  This method returns false if the look\n and feel depends on special resources or legal agreements that\n aren't defined for the current platform."}, {"method_name": "initialize", "method_sig": "public void initialize()", "description": "Initializes the look and feel. While this method is public,\n it should only be invoked by the UIManager when a\n look and feel is installed as the current look and feel. This\n method is invoked before the UIManager invokes\n getDefaults. This method is intended to perform any\n initialization for the look and feel. Subclasses\n should do any one-time setup they need here, rather than\n in a static initializer, because look and feel class objects\n may be loaded just to discover that isSupportedLookAndFeel()\n returns false."}, {"method_name": "uninitialize", "method_sig": "public void uninitialize()", "description": "Uninitializes the look and feel. While this method is public,\n it should only be invoked by the UIManager when\n the look and feel is uninstalled. For example,\n UIManager.setLookAndFeel invokes this when the look and\n feel is changed.\n \n Subclasses may choose to free up some resources here."}, {"method_name": "getDefaults", "method_sig": "public UIDefaults getDefaults()", "description": "Returns the look and feel defaults. While this method is public,\n it should only be invoked by the UIManager when the\n look and feel is set as the current look and feel and after\n initialize has been invoked."}, {"method_name": "toString", "method_sig": "public String toString()", "description": "Returns a string that displays and identifies this\n object's properties."}]}