{"name": "Class RecursiveAction", "module": "java.base", "package": "java.util.concurrent", "text": "A recursive resultless ForkJoinTask.  This class\n establishes conventions to parameterize resultless actions as\n Void ForkJoinTasks. Because null is the\n only valid value of type Void, methods such as join\n always return null upon completion.\n\n Sample Usages. Here is a simple but complete ForkJoin\n sort that sorts a given long[] array:\n\n  \n static class SortTask extends RecursiveAction {\n   final long[] array; final int lo, hi;\n   SortTask(long[] array, int lo, int hi) {\n     this.array = array; this.lo = lo; this.hi = hi;\n   }\n   SortTask(long[] array) { this(array, 0, array.length); }\n   protected void compute() {\n     if (hi - lo < THRESHOLD)\n       sortSequentially(lo, hi);\n     else {\n       int mid = (lo + hi) >>> 1;\n       invokeAll(new SortTask(array, lo, mid),\n                 new SortTask(array, mid, hi));\n       merge(lo, mid, hi);\n     }\n   }\n   // implementation details follow:\n   static final int THRESHOLD = 1000;\n   void sortSequentially(int lo, int hi) {\n     Arrays.sort(array, lo, hi);\n   }\n   void merge(int lo, int mid, int hi) {\n     long[] buf = Arrays.copyOfRange(array, lo, mid);\n     for (int i = 0, j = lo, k = mid; i < buf.length; j++)\n       array[j] = (k == hi || buf[i] < array[k]) ?\n         buf[i++] : array[k++];\n   }\n }\n\n You could then sort anArray by creating new\n SortTask(anArray) and invoking it in a ForkJoinPool.  As a more\n concrete simple example, the following task increments each element\n of an array:\n  \n class IncrementTask extends RecursiveAction {\n   final long[] array; final int lo, hi;\n   IncrementTask(long[] array, int lo, int hi) {\n     this.array = array; this.lo = lo; this.hi = hi;\n   }\n   protected void compute() {\n     if (hi - lo < THRESHOLD) {\n       for (int i = lo; i < hi; ++i)\n         array[i]++;\n     }\n     else {\n       int mid = (lo + hi) >>> 1;\n       invokeAll(new IncrementTask(array, lo, mid),\n                 new IncrementTask(array, mid, hi));\n     }\n   }\n }\nThe following example illustrates some refinements and idioms\n that may lead to better performance: RecursiveActions need not be\n fully recursive, so long as they maintain the basic\n divide-and-conquer approach. Here is a class that sums the squares\n of each element of a double array, by subdividing out only the\n right-hand-sides of repeated divisions by two, and keeping track of\n them with a chain of next references. It uses a dynamic\n threshold based on method getSurplusQueuedTaskCount, but\n counterbalances potential excess partitioning by directly\n performing leaf actions on unstolen tasks rather than further\n subdividing.\n\n  \n double sumOfSquares(ForkJoinPool pool, double[] array) {\n   int n = array.length;\n   Applyer a = new Applyer(array, 0, n, null);\n   pool.invoke(a);\n   return a.result;\n }\n\n class Applyer extends RecursiveAction {\n   final double[] array;\n   final int lo, hi;\n   double result;\n   Applyer next; // keeps track of right-hand-side tasks\n   Applyer(double[] array, int lo, int hi, Applyer next) {\n     this.array = array; this.lo = lo; this.hi = hi;\n     this.next = next;\n   }\n\n   double atLeaf(int l, int h) {\n     double sum = 0;\n     for (int i = l; i < h; ++i) // perform leftmost base step\n       sum += array[i] * array[i];\n     return sum;\n   }\n\n   protected void compute() {\n     int l = lo;\n     int h = hi;\n     Applyer right = null;\n     while (h - l > 1 && getSurplusQueuedTaskCount() <= 3) {\n       int mid = (l + h) >>> 1;\n       right = new Applyer(array, mid, h, right);\n       right.fork();\n       h = mid;\n     }\n     double sum = atLeaf(l, h);\n     while (right != null) {\n       if (right.tryUnfork()) // directly calculate if not stolen\n         sum += right.atLeaf(right.lo, right.hi);\n       else {\n         right.join();\n         sum += right.result;\n       }\n       right = right.next;\n     }\n     result = sum;\n   }\n }", "codes": ["public abstract class RecursiveAction\nextends ForkJoinTask<Void>"], "fields": [], "methods": [{"method_name": "compute", "method_sig": "protected abstract void compute()", "description": "The main computation performed by this task."}, {"method_name": "getRawResult", "method_sig": "public final Void getRawResult()", "description": "Always returns null."}, {"method_name": "setRawResult", "method_sig": "protected final void setRawResult (Void mustBeNull)", "description": "Requires null completion value."}, {"method_name": "exec", "method_sig": "protected final boolean exec()", "description": "Implements execution conventions for RecursiveActions."}]}