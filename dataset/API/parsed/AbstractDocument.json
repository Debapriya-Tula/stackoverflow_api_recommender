{"name": "Class AbstractDocument", "module": "java.desktop", "package": "javax.swing.text", "text": "An implementation of the document interface to serve as a\n basis for implementing various kinds of documents.  At this\n level there is very little policy, so there is a corresponding\n increase in difficulty of use.\n \n This class implements a locking mechanism for the document.  It\n allows multiple readers or one writer, and writers must wait until\n all observers of the document have been notified of a previous\n change before beginning another mutation to the document.  The\n read lock is acquired and released using the render\n method.  A write lock is acquired by the methods that mutate the\n document, and are held for the duration of the method call.\n Notification is done on the thread that produced the mutation,\n and the thread has full read access to the document for the\n duration of the notification, but other readers are kept out\n until the notification has finished.  The notification is a\n beans event notification which does not allow any further\n mutations until all listeners have been notified.\n \n Any models subclassed from this class and used in conjunction\n with a text component that has a look and feel implementation\n that is derived from BasicTextUI may be safely updated\n asynchronously, because all access to the View hierarchy\n is serialized by BasicTextUI if the document is of type\n AbstractDocument.  The locking assumes that an\n independent thread will access the View hierarchy only from\n the DocumentListener methods, and that there will be only\n one event thread active at a time.\n \n If concurrency support is desired, there are the following\n additional implications.  The code path for any DocumentListener\n implementation and any UndoListener implementation must be threadsafe,\n and not access the component lock if trying to be safe from deadlocks.\n The repaint and revalidate methods\n on JComponent are safe.\n \n AbstractDocument models an implied break at the end of the document.\n Among other things this allows you to position the caret after the last\n character. As a result of this, getLength returns one less\n than the length of the Content. If you create your own Content, be\n sure and initialize it to have an additional character. Refer to\n StringContent and GapContent for examples of this. Another implication\n of this is that Elements that model the implied end character will have\n an endOffset == (getLength() + 1). For example, in DefaultStyledDocument\n getParagraphElement(getLength()).getEndOffset() == getLength() + 1\n .\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans\u2122\n has been added to the java.beans package.\n Please see XMLEncoder.", "codes": ["public abstract class AbstractDocument\nextends Object\nimplements Document, Serializable"], "fields": [{"field_name": "listenerList", "field_sig": "protected\u00a0EventListenerList listenerList", "description": "The event listener list for the document."}, {"field_name": "BAD_LOCATION", "field_sig": "protected static final\u00a0String BAD_LOCATION", "description": "Error message to indicate a bad location."}, {"field_name": "ParagraphElementName", "field_sig": "public static final\u00a0String ParagraphElementName", "description": "Name of elements used to represent paragraphs"}, {"field_name": "ContentElementName", "field_sig": "public static final\u00a0String ContentElementName", "description": "Name of elements used to represent content"}, {"field_name": "SectionElementName", "field_sig": "public static final\u00a0String SectionElementName", "description": "Name of elements used to hold sections (lines/paragraphs)."}, {"field_name": "BidiElementName", "field_sig": "public static final\u00a0String BidiElementName", "description": "Name of elements used to hold a unidirectional run"}, {"field_name": "ElementNameAttribute", "field_sig": "public static final\u00a0String ElementNameAttribute", "description": "Name of the attribute used to specify element\n names."}], "methods": [{"method_name": "getDocumentProperties", "method_sig": "public Dictionary<Object, Object> getDocumentProperties()", "description": "Supports managing a set of properties. Callers\n can use the documentProperties dictionary\n to annotate the document with document-wide properties."}, {"method_name": "setDocumentProperties", "method_sig": "public void setDocumentProperties (Dictionary<Object, Object> x)", "description": "Replaces the document properties dictionary for this document."}, {"method_name": "fireInsertUpdate", "method_sig": "protected void fireInsertUpdate (DocumentEvent e)", "description": "Notifies all listeners that have registered interest for\n notification on this event type.  The event instance\n is lazily created using the parameters passed into\n the fire method."}, {"method_name": "fireChangedUpdate", "method_sig": "protected void fireChangedUpdate (DocumentEvent e)", "description": "Notifies all listeners that have registered interest for\n notification on this event type.  The event instance\n is lazily created using the parameters passed into\n the fire method."}, {"method_name": "fireRemoveUpdate", "method_sig": "protected void fireRemoveUpdate (DocumentEvent e)", "description": "Notifies all listeners that have registered interest for\n notification on this event type.  The event instance\n is lazily created using the parameters passed into\n the fire method."}, {"method_name": "fireUndoableEditUpdate", "method_sig": "protected void fireUndoableEditUpdate (UndoableEditEvent e)", "description": "Notifies all listeners that have registered interest for\n notification on this event type.  The event instance\n is lazily created using the parameters passed into\n the fire method."}, {"method_name": "getListeners", "method_sig": "public <T extends EventListener> T[] getListeners (Class<T> listenerType)", "description": "Returns an array of all the objects currently registered\n as FooListeners\n upon this document.\n FooListeners are registered using the\n addFooListener method.\n\n \n You can specify the listenerType argument\n with a class literal, such as\n FooListener.class.\n For example, you can query a\n document d\n for its document listeners with the following code:\n\n DocumentListener[] mls = (DocumentListener[])(d.getListeners(DocumentListener.class));\n\n If no such listeners exist, this method returns an empty array."}, {"method_name": "getAsynchronousLoadPriority", "method_sig": "public int getAsynchronousLoadPriority()", "description": "Gets the asynchronous loading priority.  If less than zero,\n the document should not be loaded asynchronously."}, {"method_name": "setAsynchronousLoadPriority", "method_sig": "public void setAsynchronousLoadPriority (int p)", "description": "Sets the asynchronous loading priority."}, {"method_name": "setDocumentFilter", "method_sig": "public void setDocumentFilter (DocumentFilter filter)", "description": "Sets the DocumentFilter. The DocumentFilter\n is passed insert and remove to conditionally\n allow inserting/deleting of the text.  A null value\n indicates that no filtering will occur."}, {"method_name": "getDocumentFilter", "method_sig": "public DocumentFilter getDocumentFilter()", "description": "Returns the DocumentFilter that is responsible for\n filtering of insertion/removal. A null return value\n implies no filtering is to occur."}, {"method_name": "render", "method_sig": "public void render (Runnable r)", "description": "This allows the model to be safely rendered in the presence\n of currency, if the model supports being updated asynchronously.\n The given runnable will be executed in a way that allows it\n to safely read the model with no changes while the runnable\n is being executed.  The runnable itself may not\n make any mutations.\n \n This is implemented to acquire a read lock for the duration\n of the runnables execution.  There may be multiple runnables\n executing at the same time, and all writers will be blocked\n while there are active rendering runnables.  If the runnable\n throws an exception, its lock will be safely released.\n There is no protection against a runnable that never exits,\n which will effectively leave the document locked for it's\n lifetime.\n \n If the given runnable attempts to make any mutations in\n this implementation, a deadlock will occur.  There is\n no tracking of individual rendering threads to enable\n detecting this situation, but a subclass could incur\n the overhead of tracking them and throwing an error.\n \n This method is thread safe, although most Swing methods\n are not. Please see\n Concurrency\n in Swing for more information."}, {"method_name": "getLength", "method_sig": "public int getLength()", "description": "Returns the length of the data.  This is the number of\n characters of content that represents the users data."}, {"method_name": "addDocumentListener", "method_sig": "public void addDocumentListener (DocumentListener listener)", "description": "Adds a document listener for notification of any changes."}, {"method_name": "removeDocumentListener", "method_sig": "public void removeDocumentListener (DocumentListener listener)", "description": "Removes a document listener."}, {"method_name": "getDocumentListeners", "method_sig": "public DocumentListener[] getDocumentListeners()", "description": "Returns an array of all the document listeners\n registered on this document."}, {"method_name": "addUndoableEditListener", "method_sig": "public void addUndoableEditListener (UndoableEditListener listener)", "description": "Adds an undo listener for notification of any changes.\n Undo/Redo operations performed on the UndoableEdit\n will cause the appropriate DocumentEvent to be fired to keep\n the view(s) in sync with the model."}, {"method_name": "removeUndoableEditListener", "method_sig": "public void removeUndoableEditListener (UndoableEditListener listener)", "description": "Removes an undo listener."}, {"method_name": "getUndoableEditListeners", "method_sig": "public UndoableEditListener[] getUndoableEditListeners()", "description": "Returns an array of all the undoable edit listeners\n registered on this document."}, {"method_name": "getProperty", "method_sig": "public final Object getProperty (Object key)", "description": "A convenience method for looking up a property value. It is\n equivalent to:\n \n getDocumentProperties().get(key);\n "}, {"method_name": "putProperty", "method_sig": "public final void putProperty (Object key,\n                              Object value)", "description": "A convenience method for storing up a property value.  It is\n equivalent to:\n \n getDocumentProperties().put(key, value);\n \n If value is null this method will\n remove the property."}, {"method_name": "remove", "method_sig": "public void remove (int offs,\n                   int len)\n            throws BadLocationException", "description": "Removes some content from the document.\n Removing content causes a write lock to be held while the\n actual changes are taking place.  Observers are notified\n of the change on the thread that called this method.\n \n This method is thread safe, although most Swing methods\n are not. Please see\n Concurrency\n in Swing for more information."}, {"method_name": "replace", "method_sig": "public void replace (int offset,\n                    int length,\n                    String text,\n                    AttributeSet attrs)\n             throws BadLocationException", "description": "Deletes the region of text from offset to\n offset + length, and replaces it with text.\n It is up to the implementation as to how this is implemented, some\n implementations may treat this as two distinct operations: a remove\n followed by an insert, others may treat the replace as one atomic\n operation."}, {"method_name": "insertString", "method_sig": "public void insertString (int offs,\n                         String str,\n                         AttributeSet a)\n                  throws BadLocationException", "description": "Inserts some content into the document.\n Inserting content causes a write lock to be held while the\n actual changes are taking place, followed by notification\n to the observers on the thread that grabbed the write lock.\n \n This method is thread safe, although most Swing methods\n are not. Please see\n Concurrency\n in Swing for more information."}, {"method_name": "getText", "method_sig": "public String getText (int offset,\n                      int length)\n               throws BadLocationException", "description": "Gets a sequence of text from the document."}, {"method_name": "getText", "method_sig": "public void getText (int offset,\n                    int length,\n                    Segment txt)\n             throws BadLocationException", "description": "Fetches the text contained within the given portion\n of the document.\n \n If the partialReturn property on the txt parameter is false, the\n data returned in the Segment will be the entire length requested and\n may or may not be a copy depending upon how the data was stored.\n If the partialReturn property is true, only the amount of text that\n can be returned without creating a copy is returned.  Using partial\n returns will give better performance for situations where large\n parts of the document are being scanned.  The following is an example\n of using the partial return to access the entire document:\n\n \n \u00a0 int nleft = doc.getDocumentLength();\n \u00a0 Segment text = new Segment();\n \u00a0 int offs = 0;\n \u00a0 text.setPartialReturn(true);\n \u00a0 while (nleft > 0) {\n \u00a0     doc.getText(offs, nleft, text);\n \u00a0     // do something with text\n \u00a0     nleft -= text.count;\n \u00a0     offs += text.count;\n \u00a0 }\n "}, {"method_name": "createPosition", "method_sig": "public Position createPosition (int offs)\n                        throws BadLocationException", "description": "Returns a position that will track change as the document\n is altered.\n \n This method is thread safe, although most Swing methods\n are not. Please see\n Concurrency\n in Swing for more information."}, {"method_name": "getStartPosition", "method_sig": "public final Position getStartPosition()", "description": "Returns a position that represents the start of the document.  The\n position returned can be counted on to track change and stay\n located at the beginning of the document."}, {"method_name": "getEndPosition", "method_sig": "public final Position getEndPosition()", "description": "Returns a position that represents the end of the document.  The\n position returned can be counted on to track change and stay\n located at the end of the document."}, {"method_name": "getRootElements", "method_sig": "public Element[] getRootElements()", "description": "Gets all root elements defined.  Typically, there\n will only be one so the default implementation\n is to return the default root element."}, {"method_name": "getDefaultRootElement", "method_sig": "public abstract Element getDefaultRootElement()", "description": "Returns the root element that views should be based upon\n unless some other mechanism for assigning views to element\n structures is provided."}, {"method_name": "getBidiRootElement", "method_sig": "public Element getBidiRootElement()", "description": "Returns the root element of the bidirectional structure for this\n document.  Its children represent character runs with a given\n Unicode bidi level."}, {"method_name": "getParagraphElement", "method_sig": "public abstract Element getParagraphElement (int pos)", "description": "Get the paragraph element containing the given position.  Sub-classes\n must define for themselves what exactly constitutes a paragraph.  They\n should keep in mind however that a paragraph should at least be the\n unit of text over which to run the Unicode bidirectional algorithm."}, {"method_name": "getAttributeContext", "method_sig": "protected final AbstractDocument.AttributeContext getAttributeContext()", "description": "Fetches the context for managing attributes.  This\n method effectively establishes the strategy used\n for compressing AttributeSet information."}, {"method_name": "insertUpdate", "method_sig": "protected void insertUpdate (AbstractDocument.DefaultDocumentEvent chng,\n                            AttributeSet attr)", "description": "Updates document structure as a result of text insertion.  This\n will happen within a write lock.  If a subclass of\n this class reimplements this method, it should delegate to the\n superclass as well."}, {"method_name": "removeUpdate", "method_sig": "protected void removeUpdate (AbstractDocument.DefaultDocumentEvent chng)", "description": "Updates any document structure as a result of text removal.  This\n method is called before the text is actually removed from the Content.\n This will happen within a write lock. If a subclass\n of this class reimplements this method, it should delegate to the\n superclass as well."}, {"method_name": "postRemoveUpdate", "method_sig": "protected void postRemoveUpdate (AbstractDocument.DefaultDocumentEvent chng)", "description": "Updates any document structure as a result of text removal.  This\n method is called after the text has been removed from the Content.\n This will happen within a write lock. If a subclass\n of this class reimplements this method, it should delegate to the\n superclass as well."}, {"method_name": "dump", "method_sig": "public void dump (PrintStream out)", "description": "Gives a diagnostic dump."}, {"method_name": "getContent", "method_sig": "protected final AbstractDocument.Content getContent()", "description": "Gets the content for the document."}, {"method_name": "createLeafElement", "method_sig": "protected Element createLeafElement (Element parent,\n                                    AttributeSet a,\n                                    int p0,\n                                    int p1)", "description": "Creates a document leaf element.\n Hook through which elements are created to represent the\n document structure.  Because this implementation keeps\n structure and content separate, elements grow automatically\n when content is extended so splits of existing elements\n follow.  The document itself gets to decide how to generate\n elements to give flexibility in the type of elements used."}, {"method_name": "createBranchElement", "method_sig": "protected Element createBranchElement (Element parent,\n                                      AttributeSet a)", "description": "Creates a document branch element, that can contain other elements."}, {"method_name": "getCurrentWriter", "method_sig": "protected final Thread getCurrentWriter()", "description": "Fetches the current writing thread if there is one.\n This can be used to distinguish whether a method is\n being called as part of an existing modification or\n if a lock needs to be acquired and a new transaction\n started."}, {"method_name": "writeLock", "method_sig": "protected final void writeLock()", "description": "Acquires a lock to begin mutating the document this lock\n protects.  There can be no writing, notification of changes, or\n reading going on in order to gain the lock.  Additionally a thread is\n allowed to gain more than one writeLock,\n as long as it doesn't attempt to gain additional writeLocks\n from within document notification.  Attempting to gain a\n writeLock from within a DocumentListener notification will\n result in an IllegalStateException.  The ability\n to obtain more than one writeLock per thread allows\n subclasses to gain a writeLock, perform a number of operations, then\n release the lock.\n \n Calls to writeLock\n must be balanced with calls to writeUnlock, else the\n Document will be left in a locked state so that no\n reading or writing can be done."}, {"method_name": "writeUnlock", "method_sig": "protected final void writeUnlock()", "description": "Releases a write lock previously obtained via writeLock.\n After decrementing the lock count if there are no outstanding locks\n this will allow a new writer, or readers."}, {"method_name": "readLock", "method_sig": "public final void readLock()", "description": "Acquires a lock to begin reading some state from the\n document.  There can be multiple readers at the same time.\n Writing blocks the readers until notification of the change\n to the listeners has been completed.  This method should\n be used very carefully to avoid unintended compromise\n of the document.  It should always be balanced with a\n readUnlock."}, {"method_name": "readUnlock", "method_sig": "public final void readUnlock()", "description": "Does a read unlock.  This signals that one\n of the readers is done.  If there are no more readers\n then writing can begin again.  This should be balanced\n with a readLock, and should occur in a finally statement\n so that the balance is guaranteed.  The following is an\n example.\n \n \u00a0   readLock();\n \u00a0   try {\n \u00a0       // do something\n \u00a0   } finally {\n \u00a0       readUnlock();\n \u00a0   }\n "}]}