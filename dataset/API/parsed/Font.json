{"name": "Class Font", "module": "java.desktop", "package": "java.awt", "text": "The Font class represents fonts, which are used to\n render text in a visible way.\n A font provides the information needed to map sequences of\n characters to sequences of glyphs\n and to render sequences of glyphs on Graphics and\n Component objects.\n\n Characters and Glyphs\n\n A character is a symbol that represents an item such as a letter,\n a digit, or punctuation in an abstract way. For example, 'g',\n LATIN SMALL LETTER G, is a character.\n \n A glyph is a shape used to render a character or a sequence of\n characters. In simple writing systems, such as Latin, typically one glyph\n represents one character. In general, however, characters and glyphs do not\n have one-to-one correspondence. For example, the character '\u00e1'\n LATIN SMALL LETTER A WITH ACUTE, can be represented by\n two glyphs: one for 'a' and one for '\u00b4'. On the other hand, the\n two-character string \"fi\" can be represented by a single glyph, an\n \"fi\" ligature. In complex writing systems, such as Arabic or the South\n and South-East Asian writing systems, the relationship between characters\n and glyphs can be more complicated and involve context-dependent selection\n of glyphs as well as glyph reordering.\n\n A font encapsulates the collection of glyphs needed to render a selected set\n of characters as well as the tables needed to map sequences of characters to\n corresponding sequences of glyphs.\n\n Physical and Logical Fonts\n\n The Java Platform distinguishes between two kinds of fonts:\n physical fonts and logical fonts.\n \nPhysical fonts are the actual font libraries containing glyph data\n and tables to map from character sequences to glyph sequences, using a font\n technology such as TrueType or PostScript Type 1.\n All implementations of the Java Platform must support TrueType fonts;\n support for other font technologies is implementation dependent.\n Physical fonts may use names such as Helvetica, Palatino, HonMincho, or\n any number of other font names.\n Typically, each physical font supports only a limited set of writing\n systems, for example, only Latin characters or only Japanese and Basic\n Latin.\n The set of available physical fonts varies between configurations.\n Applications that require specific fonts can bundle them and instantiate\n them using the createFont method.\n \nLogical fonts are the five font families defined by the Java\n platform which must be supported by any Java runtime environment:\n Serif, SansSerif, Monospaced, Dialog, and DialogInput.\n These logical fonts are not actual font libraries. Instead, the logical\n font names are mapped to physical fonts by the Java runtime environment.\n The mapping is implementation and usually locale dependent, so the look\n and the metrics provided by them vary.\n Typically, each logical font name maps to several physical fonts in order to\n cover a large range of characters.\n \n Peered AWT components, such as Label and\n TextField, can only use logical fonts.\n \n For a discussion of the relative advantages and disadvantages of using\n physical or logical fonts, see the\n \n    Physical and Logical Fonts\n in The Java Tutorials\n document.\n\n Font Faces and Names\n\n A Font\n can have many faces, such as heavy, medium, oblique, gothic and\n regular. All of these faces have similar typographic design.\n \n There are three different names that you can get from a\n Font object.  The logical font name is simply the\n name that was used to construct the font.\n The font face name, or just font name for\n short, is the name of a particular font face, like Helvetica Bold. The\n family name is the name of the font family that determines the\n typographic design across several faces, like Helvetica.\n \n The Font class represents an instance of a font face from\n a collection of  font faces that are present in the system resources\n of the host system.  As examples, Arial Bold and Courier Bold Italic\n are font faces.  There can be several Font objects\n associated with a font face, each differing in size, style, transform\n and font features.\n \n Glyphs may not always be rendered with the requested properties (e.g, font\n and style) due to platform limitations such as the absence of suitable\n platform fonts to implement a logical font.\n \n The getAllFonts method\n of the GraphicsEnvironment class returns an\n array of all font faces available in the system. These font faces are\n returned as Font objects with a size of 1, identity\n transform and default font features. These\n base fonts can then be used to derive new Font objects\n with varying sizes, styles, transforms and font features via the\n deriveFont methods in this class.\n\n Font and TextAttribute\nFont supports most\n TextAttributes.  This makes some operations, such as\n rendering underlined text, convenient since it is not\n necessary to explicitly construct a TextLayout object.\n Attributes can be set on a Font by constructing or deriving it\n using a Map of TextAttribute values.\n\n The values of some TextAttributes are not\n serializable, and therefore attempting to serialize an instance of\n Font that has such values will not serialize them.\n This means a Font deserialized from such a stream will not compare\n equal to the original Font that contained the non-serializable\n attributes.  This should very rarely pose a problem\n since these attributes are typically used only in special\n circumstances and are unlikely to be serialized.\n\n \nFOREGROUND and BACKGROUND use\n Paint values. The subclass Color is\n serializable, while GradientPaint and\n TexturePaint are not.\nCHAR_REPLACEMENT uses\n GraphicAttribute values.  The subclasses\n ShapeGraphicAttribute and\n ImageGraphicAttribute are not serializable.\nINPUT_METHOD_HIGHLIGHT uses\n InputMethodHighlight values, which are\n not serializable.  See InputMethodHighlight.\n\nClients who create custom subclasses of Paint and\n GraphicAttribute can make them serializable and\n avoid this problem.  Clients who use input method highlights can\n convert these to the platform-specific attributes for that\n highlight on the current platform and set them on the Font as\n a workaround.\n\n The Map-based constructor and\n deriveFont APIs ignore the FONT attribute, and it is\n not retained by the Font; the static getFont(java.util.Map<? extends java.text.AttributedCharacterIterator.Attribute, ?>) method should\n be used if the FONT attribute might be present.  See TextAttribute.FONT for more information.\nSeveral attributes will cause additional rendering overhead\n and potentially invoke layout.  If a Font has such\n attributes, the hasLayoutAttributes() method\n will return true.\nNote: Font rotations can cause text baselines to be rotated.  In\n order to account for this (rare) possibility, font APIs are\n specified to return metrics and take parameters 'in\n baseline-relative coordinates'.  This maps the 'x' coordinate to\n the advance along the baseline, (positive x is forward along the\n baseline), and the 'y' coordinate to a distance along the\n perpendicular to the baseline at 'x' (positive y is 90 degrees\n clockwise from the baseline vector).  APIs for which this is\n especially important are called out as having 'baseline-relative\n coordinates.'", "codes": ["public class Font\nextends Object\nimplements Serializable"], "fields": [{"field_name": "DIALOG", "field_sig": "public static final\u00a0String DIALOG", "description": "A String constant for the canonical family name of the\n logical font \"Dialog\". It is useful in Font construction\n to provide compile-time verification of the name."}, {"field_name": "DIALOG_INPUT", "field_sig": "public static final\u00a0String DIALOG_INPUT", "description": "A String constant for the canonical family name of the\n logical font \"DialogInput\". It is useful in Font construction\n to provide compile-time verification of the name."}, {"field_name": "SANS_SERIF", "field_sig": "public static final\u00a0String SANS_SERIF", "description": "A String constant for the canonical family name of the\n logical font \"SansSerif\". It is useful in Font construction\n to provide compile-time verification of the name."}, {"field_name": "SERIF", "field_sig": "public static final\u00a0String SERIF", "description": "A String constant for the canonical family name of the\n logical font \"Serif\". It is useful in Font construction\n to provide compile-time verification of the name."}, {"field_name": "MONOSPACED", "field_sig": "public static final\u00a0String MONOSPACED", "description": "A String constant for the canonical family name of the\n logical font \"Monospaced\". It is useful in Font construction\n to provide compile-time verification of the name."}, {"field_name": "PLAIN", "field_sig": "public static final\u00a0int PLAIN", "description": "The plain style constant."}, {"field_name": "BOLD", "field_sig": "public static final\u00a0int BOLD", "description": "The bold style constant.  This can be combined with the other style\n constants (except PLAIN) for mixed styles."}, {"field_name": "ITALIC", "field_sig": "public static final\u00a0int ITALIC", "description": "The italicized style constant.  This can be combined with the other\n style constants (except PLAIN) for mixed styles."}, {"field_name": "ROMAN_BASELINE", "field_sig": "public static final\u00a0int ROMAN_BASELINE", "description": "The baseline used in most Roman scripts when laying out text."}, {"field_name": "CENTER_BASELINE", "field_sig": "public static final\u00a0int CENTER_BASELINE", "description": "The baseline used in ideographic scripts like Chinese, Japanese,\n and Korean when laying out text."}, {"field_name": "HANGING_BASELINE", "field_sig": "public static final\u00a0int HANGING_BASELINE", "description": "The baseline used in Devanagari and similar scripts when laying\n out text."}, {"field_name": "TRUETYPE_FONT", "field_sig": "public static final\u00a0int TRUETYPE_FONT", "description": "Identify a font resource of type TRUETYPE.\n Used to specify a TrueType font resource to the\n createFont(int, java.io.InputStream) method.\n The TrueType format was extended to become the OpenType\n format, which adds support for fonts with Postscript outlines,\n this tag therefore references these fonts, as well as those\n with TrueType outlines."}, {"field_name": "TYPE1_FONT", "field_sig": "public static final\u00a0int TYPE1_FONT", "description": "Identify a font resource of type TYPE1.\n Used to specify a Type1 font resource to the\n createFont(int, java.io.InputStream) method."}, {"field_name": "name", "field_sig": "protected\u00a0String name", "description": "The logical name of this Font, as passed to the\n constructor."}, {"field_name": "style", "field_sig": "protected\u00a0int style", "description": "The style of this Font, as passed to the constructor.\n This style can be PLAIN, BOLD, ITALIC, or BOLD+ITALIC."}, {"field_name": "size", "field_sig": "protected\u00a0int size", "description": "The point size of this Font, rounded to integer."}, {"field_name": "pointSize", "field_sig": "protected\u00a0float pointSize", "description": "The point size of this Font in float."}, {"field_name": "LAYOUT_LEFT_TO_RIGHT", "field_sig": "public static final\u00a0int LAYOUT_LEFT_TO_RIGHT", "description": "A flag to layoutGlyphVector indicating that text is left-to-right as\n determined by Bidi analysis."}, {"field_name": "LAYOUT_RIGHT_TO_LEFT", "field_sig": "public static final\u00a0int LAYOUT_RIGHT_TO_LEFT", "description": "A flag to layoutGlyphVector indicating that text is right-to-left as\n determined by Bidi analysis."}, {"field_name": "LAYOUT_NO_START_CONTEXT", "field_sig": "public static final\u00a0int LAYOUT_NO_START_CONTEXT", "description": "A flag to layoutGlyphVector indicating that text in the char array\n before the indicated start should not be examined."}, {"field_name": "LAYOUT_NO_LIMIT_CONTEXT", "field_sig": "public static final\u00a0int LAYOUT_NO_LIMIT_CONTEXT", "description": "A flag to layoutGlyphVector indicating that text in the char array\n after the indicated limit should not be examined."}], "methods": [{"method_name": "textRequiresLayout", "method_sig": "public static boolean textRequiresLayout (char[] chars,\n                                         int start,\n                                         int end)", "description": "Returns true if any part of the specified text is from a\n complex script for which the implementation will need to invoke\n layout processing in order to render correctly when using\n drawString(String,int,int)\n and other text rendering methods. Measurement of the text\n may similarly need the same extra processing.\n The start and end indices are provided so that\n the application can request only a subset of the text be considered.\n The last char index examined is at \"end-1\",\n i.e a request to examine the entire array would be\n \n Font.textRequiresLayout(chars, 0, chars.length);\n \n An application may find this information helpful in\n performance sensitive code.\n \n Note that even if this method returns false, layout processing\n may still be invoked when used with any Font\n for which hasLayoutAttributes() returns true,\n so that method will need to be consulted for the specific font,\n in order to obtain an answer which accounts for such font attributes."}, {"method_name": "getFont", "method_sig": "public static Font getFont (Map<? extends AttributedCharacterIterator.Attribute, ?> attributes)", "description": "Returns a Font appropriate to the attributes.\n If attributes contains a FONT attribute\n with a valid Font as its value, it will be\n merged with any remaining attributes.  See\n TextAttribute.FONT for more\n information."}, {"method_name": "createFonts", "method_sig": "public static Font[] createFonts (InputStream fontStream)\n                          throws FontFormatException,\n                                 IOException", "description": "Returns a new array of Font decoded from the specified stream.\n The returned Font[] will have at least one element.\n \n The explicit purpose of this variation on the\n createFont(int, InputStream) method is to support font\n sources which represent a TrueType/OpenType font collection and\n be able to return all individual fonts in that collection.\n Consequently this method will throw FontFormatException\n if the data source does not contain at least one TrueType/OpenType\n font. The same exception will also be thrown if any of the fonts in\n the collection does not contain the required font tables.\n \n The condition \"at least one\", allows for the stream to represent\n a single OpenType/TrueType font. That is, it does not have to be\n a collection.\n Each Font element of the returned array is\n created with a point size of 1 and style PLAIN.\n This base font can then be used with the deriveFont\n methods in this class to derive new Font objects with\n varying sizes, styles, transforms and font features.\n This method does not close the InputStream.\n \n To make each Font available to Font constructors it\n must be registered in the GraphicsEnvironment by calling\n registerFont(Font)."}, {"method_name": "createFonts", "method_sig": "public static Font[] createFonts (File fontFile)\n                          throws FontFormatException,\n                                 IOException", "description": "Returns a new array of Font decoded from the specified file.\n The returned Font[] will have at least one element.\n \n The explicit purpose of this variation on the\n createFont(int, File) method is to support font\n sources which represent a TrueType/OpenType font collection and\n be able to return all individual fonts in that collection.\n Consequently this method will throw FontFormatException\n if the data source does not contain at least one TrueType/OpenType\n font. The same exception will also be thrown if any of the fonts in\n the collection does not contain the required font tables.\n \n The condition \"at least one\", allows for the stream to represent\n a single OpenType/TrueType font. That is, it does not have to be\n a collection.\n Each Font element of the returned array is\n created with a point size of 1 and style PLAIN.\n This base font can then be used with the deriveFont\n methods in this class to derive new Font objects with\n varying sizes, styles, transforms and font features.\n \n To make each Font available to Font constructors it\n must be registered in the GraphicsEnvironment by calling\n registerFont(Font)."}, {"method_name": "createFont", "method_sig": "public static Font createFont (int fontFormat,\n                              InputStream fontStream)\n                       throws FontFormatException,\n                              IOException", "description": "Returns a new Font using the specified font type\n and input data.  The new Font is\n created with a point size of 1 and style PLAIN.\n This base font can then be used with the deriveFont\n methods in this class to derive new Font objects with\n varying sizes, styles, transforms and font features.  This\n method does not close the InputStream.\n \n To make the Font available to Font constructors the\n returned Font must be registered in the\n GraphicsEnvironment by calling\n registerFont(Font)."}, {"method_name": "createFont", "method_sig": "public static Font createFont (int fontFormat,\n                              File fontFile)\n                       throws FontFormatException,\n                              IOException", "description": "Returns a new Font using the specified font type\n and the specified font file.  The new Font is\n created with a point size of 1 and style PLAIN.\n This base font can then be used with the deriveFont\n methods in this class to derive new Font objects with\n varying sizes, styles, transforms and font features."}, {"method_name": "getTransform", "method_sig": "public AffineTransform getTransform()", "description": "Returns a copy of the transform associated with this\n Font.  This transform is not necessarily the one\n used to construct the font.  If the font has algorithmic\n superscripting or width adjustment, this will be incorporated\n into the returned AffineTransform.\n \n Typically, fonts will not be transformed.  Clients generally\n should call isTransformed() first, and only call this\n method if isTransformed returns true."}, {"method_name": "getFamily", "method_sig": "public String getFamily()", "description": "Returns the family name of this Font.\n\n The family name of a font is font specific. Two fonts such as\n Helvetica Italic and Helvetica Bold have the same family name,\n Helvetica, whereas their font face names are\n Helvetica Bold and Helvetica Italic. The list of\n available family names may be obtained by using the\n GraphicsEnvironment.getAvailableFontFamilyNames() method.\n\n Use getName to get the logical name of the font.\n Use getFontName to get the font face name of the font."}, {"method_name": "getFamily", "method_sig": "public String getFamily (Locale l)", "description": "Returns the family name of this Font, localized for\n the specified locale.\n\n The family name of a font is font specific. Two fonts such as\n Helvetica Italic and Helvetica Bold have the same family name,\n Helvetica, whereas their font face names are\n Helvetica Bold and Helvetica Italic. The list of\n available family names may be obtained by using the\n GraphicsEnvironment.getAvailableFontFamilyNames() method.\n\n Use getFontName to get the font face name of the font."}, {"method_name": "getPSName", "method_sig": "public String getPSName()", "description": "Returns the postscript name of this Font.\n Use getFamily to get the family name of the font.\n Use getFontName to get the font face name of the font."}, {"method_name": "getName", "method_sig": "public String getName()", "description": "Returns the logical name of this Font.\n Use getFamily to get the family name of the font.\n Use getFontName to get the font face name of the font."}, {"method_name": "getFontName", "method_sig": "public String getFontName()", "description": "Returns the font face name of this Font.  For example,\n Helvetica Bold could be returned as a font face name.\n Use getFamily to get the family name of the font.\n Use getName to get the logical name of the font."}, {"method_name": "getFontName", "method_sig": "public String getFontName (Locale l)", "description": "Returns the font face name of the Font, localized\n for the specified locale. For example, Helvetica Fett could be\n returned as the font face name.\n Use getFamily to get the family name of the font."}, {"method_name": "getStyle", "method_sig": "public int getStyle()", "description": "Returns the style of this Font.  The style can be\n PLAIN, BOLD, ITALIC, or BOLD+ITALIC."}, {"method_name": "getSize", "method_sig": "public int getSize()", "description": "Returns the point size of this Font, rounded to\n an integer.\n Most users are familiar with the idea of using point size to\n specify the size of glyphs in a font. This point size defines a\n measurement between the baseline of one line to the baseline of the\n following line in a single spaced text document. The point size is\n based on typographic points, approximately 1/72 of an inch.\n \n The Java(tm)2D API adopts the convention that one point is\n equivalent to one unit in user coordinates.  When using a\n normalized transform for converting user space coordinates to\n device space coordinates 72 user\n space units equal 1 inch in device space.  In this case one point\n is 1/72 of an inch."}, {"method_name": "getSize2D", "method_sig": "public float getSize2D()", "description": "Returns the point size of this Font in\n float value."}, {"method_name": "isPlain", "method_sig": "public boolean isPlain()", "description": "Indicates whether or not this Font object's style is\n PLAIN."}, {"method_name": "isBold", "method_sig": "public boolean isBold()", "description": "Indicates whether or not this Font object's style is\n BOLD."}, {"method_name": "isItalic", "method_sig": "public boolean isItalic()", "description": "Indicates whether or not this Font object's style is\n ITALIC."}, {"method_name": "isTransformed", "method_sig": "public boolean isTransformed()", "description": "Indicates whether or not this Font object has a\n transform that affects its size in addition to the Size\n attribute."}, {"method_name": "hasLayoutAttributes", "method_sig": "public boolean hasLayoutAttributes()", "description": "Return true if this Font contains attributes that require extra\n layout processing."}, {"method_name": "getFont", "method_sig": "public static Font getFont (String nm)", "description": "Returns a Font object from the system properties list.\n nm is treated as the name of a system property to be\n obtained.  The String value of this property is then\n interpreted as a Font object according to the\n specification of Font.decode(String)\n If the specified property is not found, or the executing code does\n not have permission to read the property, null is returned instead."}, {"method_name": "decode", "method_sig": "public static Font decode (String str)", "description": "Returns the Font that the str\n argument describes.\n To ensure that this method returns the desired Font,\n format the str parameter in\n one of these ways\n\n \nfontname-style-pointsize\nfontname-pointsize\nfontname-style\nfontname\nfontname style pointsize\nfontname pointsize\nfontname style\nfontname\n\n in which style is one of the four\n case-insensitive strings:\n \"PLAIN\", \"BOLD\", \"BOLDITALIC\", or\n \"ITALIC\", and pointsize is a positive decimal integer\n representation of the point size.\n For example, if you want a font that is Arial, bold, with\n a point size of 18, you would call this method with:\n \"Arial-BOLD-18\".\n This is equivalent to calling the Font constructor :\n new Font(\"Arial\", Font.BOLD, 18);\n and the values are interpreted as specified by that constructor.\n \n A valid trailing decimal field is always interpreted as the pointsize.\n Therefore a fontname containing a trailing decimal value should not\n be used in the fontname only form.\n \n If a style name field is not one of the valid style strings, it is\n interpreted as part of the font name, and the default style is used.\n \n Only one of ' ' or '-' may be used to separate fields in the input.\n The identified separator is the one closest to the end of the string\n which separates a valid pointsize, or a valid style name from\n the rest of the string.\n Null (empty) pointsize and style fields are treated\n as valid fields with the default value for that field.\n\n Some font names may include the separator characters ' ' or '-'.\n If str is not formed with 3 components, e.g. such that\n style or pointsize fields are not present in\n str, and fontname also contains a\n character determined to be the separator character\n then these characters where they appear as intended to be part of\n fontname may instead be interpreted as separators\n so the font name may not be properly recognised.\n\n \n The default size is 12 and the default style is PLAIN.\n If str does not specify a valid size, the returned\n Font has a size of 12.  If str does not\n specify a valid style, the returned Font has a style of PLAIN.\n If you do not specify a valid font name in\n the str argument, this method will return\n a font with the family name \"Dialog\".\n To determine what font family names are available on\n your system, use the\n GraphicsEnvironment.getAvailableFontFamilyNames() method.\n If str is null, a new Font\n is returned with the family name \"Dialog\", a size of 12 and a\n PLAIN style."}, {"method_name": "getFont", "method_sig": "public static Font getFont (String nm,\n                           Font font)", "description": "Gets the specified Font from the system properties\n list.  As in the getProperty method of\n System, the first\n argument is treated as the name of a system property to be\n obtained.  The String value of this property is then\n interpreted as a Font object.\n \n The property value should be one of the forms accepted by\n Font.decode(String)\n If the specified property is not found, or the executing code does not\n have permission to read the property, the font\n argument is returned instead."}, {"method_name": "hashCode", "method_sig": "public int hashCode()", "description": "Returns a hashcode for this Font."}, {"method_name": "equals", "method_sig": "public boolean equals (Object obj)", "description": "Compares this Font object to the specified\n Object."}, {"method_name": "toString", "method_sig": "public String toString()", "description": "Converts this Font object to a String\n representation."}, {"method_name": "getNumGlyphs", "method_sig": "public int getNumGlyphs()", "description": "Returns the number of glyphs in this Font. Glyph codes\n for this Font range from 0 to\n getNumGlyphs() - 1."}, {"method_name": "getMissingGlyphCode", "method_sig": "public int getMissingGlyphCode()", "description": "Returns the glyphCode which is used when this Font\n does not have a glyph for a specified unicode code point."}, {"method_name": "getBaselineFor", "method_sig": "public byte getBaselineFor (char c)", "description": "Returns the baseline appropriate for displaying this character.\n \n Large fonts can support different writing systems, and each system can\n use a different baseline.\n The character argument determines the writing system to use. Clients\n should not assume all characters use the same baseline."}, {"method_name": "getAttributes", "method_sig": "public Map<TextAttribute, ?> getAttributes()", "description": "Returns a map of font attributes available in this\n Font.  Attributes include things like ligatures and\n glyph substitution."}, {"method_name": "getAvailableAttributes", "method_sig": "public AttributedCharacterIterator.Attribute[] getAvailableAttributes()", "description": "Returns the keys of all the attributes supported by this\n Font.  These attributes can be used to derive other\n fonts."}, {"method_name": "deriveFont", "method_sig": "public Font deriveFont (int style,\n                       float size)", "description": "Creates a new Font object by replicating this\n Font object and applying a new style and size."}, {"method_name": "deriveFont", "method_sig": "public Font deriveFont (int style,\n                       AffineTransform trans)", "description": "Creates a new Font object by replicating this\n Font object and applying a new style and transform."}, {"method_name": "deriveFont", "method_sig": "public Font deriveFont (float size)", "description": "Creates a new Font object by replicating the current\n Font object and applying a new size to it."}, {"method_name": "deriveFont", "method_sig": "public Font deriveFont (AffineTransform trans)", "description": "Creates a new Font object by replicating the current\n Font object and applying a new transform to it."}, {"method_name": "deriveFont", "method_sig": "public Font deriveFont (int style)", "description": "Creates a new Font object by replicating the current\n Font object and applying a new style to it."}, {"method_name": "deriveFont", "method_sig": "public Font deriveFont (Map<? extends AttributedCharacterIterator.Attribute, ?> attributes)", "description": "Creates a new Font object by replicating the current\n Font object and applying a new set of font attributes\n to it."}, {"method_name": "canDisplay", "method_sig": "public boolean canDisplay (char c)", "description": "Checks if this Font has a glyph for the specified\n character.\n\n  Note: This method cannot handle  supplementary\n characters. To support all Unicode characters, including\n supplementary characters, use the canDisplay(int)\n method or canDisplayUpTo methods."}, {"method_name": "canDisplay", "method_sig": "public boolean canDisplay (int codePoint)", "description": "Checks if this Font has a glyph for the specified\n character."}, {"method_name": "canDisplayUpTo", "method_sig": "public int canDisplayUpTo (String str)", "description": "Indicates whether or not this Font can display a\n specified String.  For strings with Unicode encoding,\n it is important to know if a particular font can display the\n string. This method returns an offset into the String\nstr which is the first character this\n Font cannot display without using the missing glyph\n code. If the Font can display all characters, -1 is\n returned."}, {"method_name": "canDisplayUpTo", "method_sig": "public int canDisplayUpTo (char[] text,\n                          int start,\n                          int limit)", "description": "Indicates whether or not this Font can display\n the characters in the specified text\n starting at start and ending at\n limit.  This method is a convenience overload."}, {"method_name": "canDisplayUpTo", "method_sig": "public int canDisplayUpTo (CharacterIterator iter,\n                          int start,\n                          int limit)", "description": "Indicates whether or not this Font can display the\n text specified by the iter starting at\n start and ending at limit."}, {"method_name": "getItalicAngle", "method_sig": "public float getItalicAngle()", "description": "Returns the italic angle of this Font.  The italic angle\n is the inverse slope of the caret which best matches the posture of this\n Font."}, {"method_name": "hasUniformLineMetrics", "method_sig": "public boolean hasUniformLineMetrics()", "description": "Checks whether or not this Font has uniform\n line metrics.  A logical Font might be a\n composite font, which means that it is composed of different\n physical fonts to cover different code ranges.  Each of these\n fonts might have different LineMetrics.  If the\n logical Font is a single\n font then the metrics would be uniform."}, {"method_name": "getLineMetrics", "method_sig": "public LineMetrics getLineMetrics (String str,\n                                  FontRenderContext frc)", "description": "Returns a LineMetrics object created with the specified\n String and FontRenderContext."}, {"method_name": "getLineMetrics", "method_sig": "public LineMetrics getLineMetrics (String str,\n                                  int beginIndex,\n                                  int limit,\n                                  FontRenderContext frc)", "description": "Returns a LineMetrics object created with the\n specified arguments."}, {"method_name": "getLineMetrics", "method_sig": "public LineMetrics getLineMetrics (char[] chars,\n                                  int beginIndex,\n                                  int limit,\n                                  FontRenderContext frc)", "description": "Returns a LineMetrics object created with the\n specified arguments."}, {"method_name": "getLineMetrics", "method_sig": "public LineMetrics getLineMetrics (CharacterIterator ci,\n                                  int beginIndex,\n                                  int limit,\n                                  FontRenderContext frc)", "description": "Returns a LineMetrics object created with the\n specified arguments."}, {"method_name": "getStringBounds", "method_sig": "public Rectangle2D getStringBounds (String str,\n                                   FontRenderContext frc)", "description": "Returns the logical bounds of the specified String in\n the specified FontRenderContext.  The logical bounds\n contains the origin, ascent, advance, and height, which includes\n the leading.  The logical bounds does not always enclose all the\n text.  For example, in some languages and in some fonts, accent\n marks can be positioned above the ascent or below the descent.\n To obtain a visual bounding box, which encloses all the text,\n use the getBounds method of\n TextLayout.\n Note: The returned bounds is in baseline-relative coordinates\n (see class notes)."}, {"method_name": "getStringBounds", "method_sig": "public Rectangle2D getStringBounds (String str,\n                                   int beginIndex,\n                                   int limit,\n                                   FontRenderContext frc)", "description": "Returns the logical bounds of the specified String in\n the specified FontRenderContext.  The logical bounds\n contains the origin, ascent, advance, and height, which includes\n the leading.  The logical bounds does not always enclose all the\n text.  For example, in some languages and in some fonts, accent\n marks can be positioned above the ascent or below the descent.\n To obtain a visual bounding box, which encloses all the text,\n use the getBounds method of\n TextLayout.\n Note: The returned bounds is in baseline-relative coordinates\n (see class notes)."}, {"method_name": "getStringBounds", "method_sig": "public Rectangle2D getStringBounds (char[] chars,\n                                   int beginIndex,\n                                   int limit,\n                                   FontRenderContext frc)", "description": "Returns the logical bounds of the specified array of characters\n in the specified FontRenderContext.  The logical\n bounds contains the origin, ascent, advance, and height, which\n includes the leading.  The logical bounds does not always enclose\n all the text.  For example, in some languages and in some fonts,\n accent marks can be positioned above the ascent or below the\n descent.  To obtain a visual bounding box, which encloses all the\n text, use the getBounds method of\n TextLayout.\n Note: The returned bounds is in baseline-relative coordinates\n (see class notes)."}, {"method_name": "getStringBounds", "method_sig": "public Rectangle2D getStringBounds (CharacterIterator ci,\n                                   int beginIndex,\n                                   int limit,\n                                   FontRenderContext frc)", "description": "Returns the logical bounds of the characters indexed in the\n specified CharacterIterator in the\n specified FontRenderContext.  The logical bounds\n contains the origin, ascent, advance, and height, which includes\n the leading.  The logical bounds does not always enclose all the\n text.  For example, in some languages and in some fonts, accent\n marks can be positioned above the ascent or below the descent.\n To obtain a visual bounding box, which encloses all the text,\n use the getBounds method of\n TextLayout.\n Note: The returned bounds is in baseline-relative coordinates\n (see class notes)."}, {"method_name": "getMaxCharBounds", "method_sig": "public Rectangle2D getMaxCharBounds (FontRenderContext frc)", "description": "Returns the bounds for the character with the maximum\n bounds as defined in the specified FontRenderContext.\n Note: The returned bounds is in baseline-relative coordinates\n (see class notes)."}, {"method_name": "createGlyphVector", "method_sig": "public GlyphVector createGlyphVector (FontRenderContext frc,\n                                     String str)", "description": "Creates a GlyphVector by\n mapping characters to glyphs one-to-one based on the\n Unicode cmap in this Font.  This method does no other\n processing besides the mapping of glyphs to characters.  This\n means that this method is not useful for some scripts, such\n as Arabic, Hebrew, Thai, and Indic, that require reordering,\n shaping, or ligature substitution."}, {"method_name": "createGlyphVector", "method_sig": "public GlyphVector createGlyphVector (FontRenderContext frc,\n                                     char[] chars)", "description": "Creates a GlyphVector by\n mapping characters to glyphs one-to-one based on the\n Unicode cmap in this Font.  This method does no other\n processing besides the mapping of glyphs to characters.  This\n means that this method is not useful for some scripts, such\n as Arabic, Hebrew, Thai, and Indic, that require reordering,\n shaping, or ligature substitution."}, {"method_name": "createGlyphVector", "method_sig": "public GlyphVector createGlyphVector (FontRenderContext frc,\n                                     CharacterIterator ci)", "description": "Creates a GlyphVector by\n mapping the specified characters to glyphs one-to-one based on the\n Unicode cmap in this Font.  This method does no other\n processing besides the mapping of glyphs to characters.  This\n means that this method is not useful for some scripts, such\n as Arabic, Hebrew, Thai, and Indic, that require reordering,\n shaping, or ligature substitution."}, {"method_name": "createGlyphVector", "method_sig": "public GlyphVector createGlyphVector (FontRenderContext frc,\n                                     int[] glyphCodes)", "description": "Creates a GlyphVector by\n mapping characters to glyphs one-to-one based on the\n Unicode cmap in this Font.  This method does no other\n processing besides the mapping of glyphs to characters.  This\n means that this method is not useful for some scripts, such\n as Arabic, Hebrew, Thai, and Indic, that require reordering,\n shaping, or ligature substitution."}, {"method_name": "layoutGlyphVector", "method_sig": "public GlyphVector layoutGlyphVector (FontRenderContext frc,\n                                     char[] text,\n                                     int start,\n                                     int limit,\n                                     int flags)", "description": "Returns a new GlyphVector object, performing full\n layout of the text if possible.  Full layout is required for\n complex text, such as Arabic or Hindi.  Support for different\n scripts depends on the font and implementation.\n \n Layout requires bidi analysis, as performed by\n Bidi, and should only be performed on text that\n has a uniform direction.  The direction is indicated in the\n flags parameter,by using LAYOUT_RIGHT_TO_LEFT to indicate a\n right-to-left (Arabic and Hebrew) run direction, or\n LAYOUT_LEFT_TO_RIGHT to indicate a left-to-right (English)\n run direction.\n \n In addition, some operations, such as Arabic shaping, require\n context, so that the characters at the start and limit can have\n the proper shapes.  Sometimes the data in the buffer outside\n the provided range does not have valid data.  The values\n LAYOUT_NO_START_CONTEXT and LAYOUT_NO_LIMIT_CONTEXT can be\n added to the flags parameter to indicate that the text before\n start, or after limit, respectively, should not be examined\n for context.\n \n All other values for the flags parameter are reserved."}]}