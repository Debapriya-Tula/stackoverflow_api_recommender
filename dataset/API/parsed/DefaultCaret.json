{"name": "Class DefaultCaret", "module": "java.desktop", "package": "javax.swing.text", "text": "A default implementation of Caret.  The caret is rendered as\n a vertical line in the color specified by the CaretColor property\n of the associated JTextComponent.  It can blink at the rate specified\n by the BlinkRate property.\n \n This implementation expects two sources of asynchronous notification.\n The timer thread fires asynchronously, and causes the caret to simply\n repaint the most recent bounding box.  The caret also tracks change\n as the document is modified.  Typically this will happen on the\n event dispatch thread as a result of some mouse or keyboard event.\n The caret behavior on both synchronous and asynchronous documents updates\n is controlled by UpdatePolicy property. The repaint of the\n new caret location will occur on the event thread in any case, as calls to\n modelToView are only safe on the event thread.\n \n The caret acts as a mouse and focus listener on the text component\n it has been installed in, and defines the caret semantics based upon\n those events.  The listener methods can be reimplemented to change the\n semantics.\n By default, the first mouse button will be used to set focus and caret\n position.  Dragging the mouse pointer with the first mouse button will\n sweep out a selection that is contiguous in the model.  If the associated\n text component is editable, the caret will become visible when focus\n is gained, and invisible when focus is lost.\n \n The Highlighter bound to the associated text component is used to\n render the selection by default.\n Selection appearance can be customized by supplying a\n painter to use for the highlights.  By default a painter is used that\n will render a solid color as specified in the associated text component\n in the SelectionColor property.  This can easily be changed\n by reimplementing the\n getSelectionPainter\n method.\n \n A customized caret appearance can be achieved by reimplementing\n the paint method.  If the paint method is changed, the damage method\n should also be reimplemented to cause a repaint for the area needed\n to render the caret.  The caret extends the Rectangle class which\n is used to hold the bounding box for where the caret was last rendered.\n This enables the caret to repaint in a thread-safe manner when the\n caret moves without making a call to modelToView which is unstable\n between model updates and view repair (i.e. the order of delivery\n to DocumentListeners is not guaranteed).\n \n The magic caret position is set to null when the caret position changes.\n A timer is used to determine the new location (after the caret change).\n When the timer fires, if the magic caret position is still null it is\n reset to the current caret position. Any actions that change\n the caret position and want the magic caret position to remain the\n same, must remember the magic caret position, change the cursor, and\n then set the magic caret position to its original value. This has the\n benefit that only actions that want the magic caret position to persist\n (such as open/down) need to know about it.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans\u2122\n has been added to the java.beans package.\n Please see XMLEncoder.", "codes": ["public class DefaultCaret\nextends Rectangle\nimplements Caret, FocusListener, MouseListener, MouseMotionListener"], "fields": [{"field_name": "UPDATE_WHEN_ON_EDT", "field_sig": "public static final\u00a0int UPDATE_WHEN_ON_EDT", "description": "Indicates that the caret position is to be updated only when\n document changes are performed on the Event Dispatching Thread."}, {"field_name": "NEVER_UPDATE", "field_sig": "public static final\u00a0int NEVER_UPDATE", "description": "Indicates that the caret should remain at the same\n absolute position in the document regardless of any document\n updates, except when the document length becomes less than\n the current caret position due to removal. In that case the caret\n position is adjusted to the end of the document."}, {"field_name": "ALWAYS_UPDATE", "field_sig": "public static final\u00a0int ALWAYS_UPDATE", "description": "Indicates that the caret position is to be always\n updated accordingly to the document changes regardless whether\n the document updates are performed on the Event Dispatching Thread\n or not."}, {"field_name": "listenerList", "field_sig": "protected\u00a0EventListenerList listenerList", "description": "The event listener list."}, {"field_name": "changeEvent", "field_sig": "protected transient\u00a0ChangeEvent changeEvent", "description": "The change event for the model.\n Only one ChangeEvent is needed per model instance since the\n event's only (read-only) state is the source property.  The source\n of events generated here is always \"this\"."}], "methods": [{"method_name": "setUpdatePolicy", "method_sig": "public void setUpdatePolicy (int policy)", "description": "Sets the caret movement policy on the document updates. Normally\n the caret updates its absolute position within the document on\n insertions occurred before or at the caret position and\n on removals before the caret position. 'Absolute position'\n means here the position relative to the start of the document.\n For example if\n a character is typed within editable text component it is inserted\n at the caret position and the caret moves to the next absolute\n position within the document due to insertion and if\n BACKSPACE is typed then caret decreases its absolute\n position due to removal of a character before it. Sometimes\n it may be useful to turn off the caret position updates so that\n the caret stays at the same absolute position within the\n document position regardless of any document updates.\n \n The following update policies are allowed:\n \nNEVER_UPDATE: the caret stays at the same\n       absolute position in the document regardless of any document\n       updates, except when document length becomes less than\n       the current caret position due to removal. In that case caret\n       position is adjusted to the end of the document.\n       The caret doesn't try to keep itself visible by scrolling\n       the associated view when using this policy. \nALWAYS_UPDATE: the caret always tracks document\n       changes. For regular changes it increases its position\n       if an insertion occurs before or at its current position,\n       and decreases position if a removal occurs before\n       its current position. For undo/redo updates it is always\n       moved to the position where update occurred. The caret\n       also tries to keep itself visible by calling\n       adjustVisibility method.\nUPDATE_WHEN_ON_EDT: acts like ALWAYS_UPDATE\n       if the document updates are performed on the Event Dispatching Thread\n       and like NEVER_UPDATE if updates are performed on\n       other thread. \n \n The default property value is UPDATE_WHEN_ON_EDT."}, {"method_name": "getUpdatePolicy", "method_sig": "public int getUpdatePolicy()", "description": "Gets the caret movement policy on document updates."}, {"method_name": "getComponent", "method_sig": "protected final JTextComponent getComponent()", "description": "Gets the text editor component that this caret is\n is bound to."}, {"method_name": "repaint", "method_sig": "protected final void repaint()", "description": "Cause the caret to be painted.  The repaint\n area is the bounding box of the caret (i.e.\n the caret rectangle or this).\n \n This method is thread safe, although most Swing methods\n are not. Please see\n Concurrency\n in Swing for more information."}, {"method_name": "damage", "method_sig": "protected void damage (Rectangle r)", "description": "Damages the area surrounding the caret to cause\n it to be repainted in a new location.  If paint()\n is reimplemented, this method should also be\n reimplemented.  This method should update the\n caret bounds (x, y, width, and height)."}, {"method_name": "adjustVisibility", "method_sig": "protected void adjustVisibility (Rectangle nloc)", "description": "Scrolls the associated view (if necessary) to make\n the caret visible.  Since how this should be done\n is somewhat of a policy, this method can be\n reimplemented to change the behavior.  By default\n the scrollRectToVisible method is called on the\n associated component."}, {"method_name": "getSelectionPainter", "method_sig": "protected Highlighter.HighlightPainter getSelectionPainter()", "description": "Gets the painter for the Highlighter."}, {"method_name": "positionCaret", "method_sig": "protected void positionCaret (MouseEvent e)", "description": "Tries to set the position of the caret from\n the coordinates of a mouse event, using viewToModel()."}, {"method_name": "moveCaret", "method_sig": "protected void moveCaret (MouseEvent e)", "description": "Tries to move the position of the caret from\n the coordinates of a mouse event, using viewToModel().\n This will cause a selection if the dot and mark\n are different."}, {"method_name": "focusGained", "method_sig": "public void focusGained (FocusEvent e)", "description": "Called when the component containing the caret gains\n focus.  This is implemented to set the caret to visible\n if the component is editable."}, {"method_name": "focusLost", "method_sig": "public void focusLost (FocusEvent e)", "description": "Called when the component containing the caret loses\n focus.  This is implemented to set the caret to visibility\n to false."}, {"method_name": "mouseClicked", "method_sig": "public void mouseClicked (MouseEvent e)", "description": "Called when the mouse is clicked.  If the click was generated\n from button1, a double click selects a word,\n and a triple click the current line."}, {"method_name": "mousePressed", "method_sig": "public void mousePressed (MouseEvent e)", "description": "If button 1 is pressed, this is implemented to\n request focus on the associated text component,\n and to set the caret position. If the shift key is held down,\n the caret will be moved, potentially resulting in a selection,\n otherwise the\n caret position will be set to the new location.  If the component\n is not enabled, there will be no request for focus."}, {"method_name": "mouseReleased", "method_sig": "public void mouseReleased (MouseEvent e)", "description": "Called when the mouse is released."}, {"method_name": "mouseEntered", "method_sig": "public void mouseEntered (MouseEvent e)", "description": "Called when the mouse enters a region."}, {"method_name": "mouseExited", "method_sig": "public void mouseExited (MouseEvent e)", "description": "Called when the mouse exits a region."}, {"method_name": "mouseDragged", "method_sig": "public void mouseDragged (MouseEvent e)", "description": "Moves the caret position\n according to the mouse pointer's current\n location.  This effectively extends the\n selection.  By default, this is only done\n for mouse button 1."}, {"method_name": "mouseMoved", "method_sig": "public void mouseMoved (MouseEvent e)", "description": "Called when the mouse is moved."}, {"method_name": "paint", "method_sig": "public void paint (Graphics g)", "description": "Renders the caret as a vertical line.  If this is reimplemented\n the damage method should also be reimplemented as it assumes the\n shape of the caret is a vertical line.  Sets the caret color to\n the value returned by getCaretColor().\n \n If there are multiple text directions present in the associated\n document, a flag indicating the caret bias will be rendered.\n This will occur only if the associated document is a subclass\n of AbstractDocument and there are multiple bidi levels present\n in the bidi element structure (i.e. the text has multiple\n directions associated with it)."}, {"method_name": "install", "method_sig": "public void install (JTextComponent c)", "description": "Called when the UI is being installed into the\n interface of a JTextComponent.  This can be used\n to gain access to the model that is being navigated\n by the implementation of this interface.  Sets the dot\n and mark to 0, and establishes document, property change,\n focus, mouse, and mouse motion listeners."}, {"method_name": "deinstall", "method_sig": "public void deinstall (JTextComponent c)", "description": "Called when the UI is being removed from the\n interface of a JTextComponent.  This is used to\n unregister any listeners that were attached."}, {"method_name": "addChangeListener", "method_sig": "public void addChangeListener (ChangeListener l)", "description": "Adds a listener to track whenever the caret position has\n been changed."}, {"method_name": "removeChangeListener", "method_sig": "public void removeChangeListener (ChangeListener l)", "description": "Removes a listener that was tracking caret position changes."}, {"method_name": "getChangeListeners", "method_sig": "public ChangeListener[] getChangeListeners()", "description": "Returns an array of all the change listeners\n registered on this caret."}, {"method_name": "fireStateChanged", "method_sig": "protected void fireStateChanged()", "description": "Notifies all listeners that have registered interest for\n notification on this event type.  The event instance\n is lazily created using the parameters passed into\n the fire method.  The listener list is processed last to first."}, {"method_name": "getListeners", "method_sig": "public <T extends EventListener> T[] getListeners (Class<T> listenerType)", "description": "Returns an array of all the objects currently registered\n as FooListeners\n upon this caret.\n FooListeners are registered using the\n addFooListener method.\n\n \n\n You can specify the listenerType argument\n with a class literal,\n such as\n FooListener.class.\n For example, you can query a\n DefaultCaret c\n for its change listeners with the following code:\n\n ChangeListener[] cls = (ChangeListener[])(c.getListeners(ChangeListener.class));\n\n If no such listeners exist, this method returns an empty array."}, {"method_name": "setSelectionVisible", "method_sig": "public void setSelectionVisible (boolean vis)", "description": "Changes the selection visibility."}, {"method_name": "isSelectionVisible", "method_sig": "public boolean isSelectionVisible()", "description": "Checks whether the current selection is visible."}, {"method_name": "isActive", "method_sig": "public boolean isActive()", "description": "Determines if the caret is currently active.\n \n This method returns whether or not the Caret\n is currently in a blinking state. It does not provide\n information as to whether it is currently blinked on or off.\n To determine if the caret is currently painted use the\n isVisible method."}, {"method_name": "isVisible", "method_sig": "public boolean isVisible()", "description": "Indicates whether or not the caret is currently visible. As the\n caret flashes on and off the return value of this will change\n between true, when the caret is painted, and false, when the\n caret is not painted. isActive indicates whether\n or not the caret is in a blinking state, such that it can\n be visible, and isVisible indicates whether or not\n the caret is actually visible.\n \n Subclasses that wish to render a different flashing caret\n should override paint and only paint the caret if this method\n returns true."}, {"method_name": "setVisible", "method_sig": "public void setVisible (boolean e)", "description": "Sets the caret visibility, and repaints the caret.\n It is important to understand the relationship between this method,\n isVisible and isActive.\n Calling this method with a value of true activates the\n caret blinking. Setting it to false turns it completely off.\n To determine whether the blinking is active, you should call\n isActive. In effect, isActive is an\n appropriate corresponding \"getter\" method for this one.\n isVisible can be used to fetch the current\n visibility status of the caret, meaning whether or not it is currently\n painted. This status will change as the caret blinks on and off.\n \n Here's a list showing the potential return values of both\n isActive and isVisible\n after calling this method:\n \nsetVisible(true):\n \nisActive(): true\nisVisible(): true or false depending on whether\n         or not the caret is blinked on or off\n\n\nsetVisible(false):\n \nisActive(): false\nisVisible(): false\n"}, {"method_name": "setBlinkRate", "method_sig": "public void setBlinkRate (int rate)", "description": "Sets the caret blink rate."}, {"method_name": "getBlinkRate", "method_sig": "public int getBlinkRate()", "description": "Gets the caret blink rate."}, {"method_name": "getDot", "method_sig": "public int getDot()", "description": "Fetches the current position of the caret."}, {"method_name": "getMark", "method_sig": "public int getMark()", "description": "Fetches the current position of the mark.  If there is a selection,\n the dot and mark will not be the same."}, {"method_name": "setDot", "method_sig": "public void setDot (int dot)", "description": "Sets the caret position and mark to the specified position,\n with a forward bias. This implicitly sets the\n selection range to zero."}, {"method_name": "moveDot", "method_sig": "public void moveDot (int dot)", "description": "Moves the caret position to the specified position,\n with a forward bias."}, {"method_name": "moveDot", "method_sig": "public void moveDot (int dot,\n                    Position.Bias dotBias)", "description": "Moves the caret position to the specified position, with the\n specified bias."}, {"method_name": "setDot", "method_sig": "public void setDot (int dot,\n                   Position.Bias dotBias)", "description": "Sets the caret position and mark to the specified position, with the\n specified bias. This implicitly sets the selection range\n to zero."}, {"method_name": "getDotBias", "method_sig": "public Position.Bias getDotBias()", "description": "Returns the bias of the caret position."}, {"method_name": "getMarkBias", "method_sig": "public Position.Bias getMarkBias()", "description": "Returns the bias of the mark."}, {"method_name": "setMagicCaretPosition", "method_sig": "public void setMagicCaretPosition (Point p)", "description": "Saves the current caret position.  This is used when\n caret up/down actions occur, moving between lines\n that have uneven end positions."}, {"method_name": "getMagicCaretPosition", "method_sig": "public Point getMagicCaretPosition()", "description": "Gets the saved caret position."}, {"method_name": "equals", "method_sig": "public boolean equals (Object obj)", "description": "Compares this object to the specified object.\n The superclass behavior of comparing rectangles\n is not desired, so this is changed to the Object\n behavior."}]}