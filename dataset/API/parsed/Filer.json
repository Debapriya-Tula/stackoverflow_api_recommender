{"name": "Interface Filer", "module": "java.compiler", "package": "javax.annotation.processing", "text": "This interface supports the creation of new files by an annotation\n processor.  Files created in this way will be known to the\n annotation processing tool implementing this interface, better\n enabling the tool to manage them.  Source and class files so\n created will be considered for processing by the tool in a subsequent round of processing after the close\n method has been called on the Writer or \n OutputStream used to write the contents of the file.\n\n Three kinds of files are distinguished: source files, class files,\n and auxiliary resource files.\n\n  There are two distinguished supported locations (subtrees\n within the logical file system) where newly created files are\n placed: one for new source files, and\n one for new\n class files.  (These might be specified on a tool's command line,\n for example, using flags such as -s and -d.)  The\n actual locations for new source files and new class files may or\n may not be distinct on a particular run of the tool.  Resource\n files may be created in either location.  The methods for reading\n and writing resources take a relative name argument.  A relative\n name is a non-null, non-empty sequence of path segments separated\n by '/'; '.' and '..' are invalid path\n segments.  A valid relative name must match the\n \"path-rootless\" rule of RFC 3986, section\n 3.3.\n\n The file creation methods take a variable number of arguments to\n allow the originating elements to be provided as hints to\n the tool infrastructure to better manage dependencies.  The\n originating elements are the types or packages (representing \n package-info files) or modules (representing \n module-info files) which caused an annotation processor to\n attempt to create a new file.  For example, if an annotation\n processor tries to create a source file, \n GeneratedFromUserSource, in response to processing\n\n \n  @Generate\n  public class UserSource {}\n \n\n the type element for UserSource should be passed as part of\n the creation method call as in:\n\n \n      filer.createSourceFile(\"GeneratedFromUserSource\",\n                             eltUtils.getTypeElement(\"UserSource\"));\n \n\n If there are no originating elements, none need to be passed.  This\n information may be used in an incremental environment to determine\n the need to rerun processors or remove generated files.\n Non-incremental environments may ignore the originating element\n information.\n\n  During each run of an annotation processing tool, a file with a\n given pathname may be created only once.  If that file already\n exists before the first attempt to create it, the old contents will\n be deleted.  Any subsequent attempt to create the same file during\n a run will throw a FilerException, as will attempting to\n create both a class file and source file for the same type name or\n same package name.  The initial inputs to\n the tool are considered to be created by the zeroth round;\n therefore, attempting to create a source or class file\n corresponding to one of those inputs will result in a FilerException.\n\n  In general, processors must not knowingly attempt to overwrite\n existing files that were not generated by some processor.  A \n Filer may reject attempts to open a file corresponding to an\n existing type, like java.lang.Object.  Likewise, the\n invoker of the annotation processing tool must not knowingly\n configure the tool such that the discovered processors will attempt\n to overwrite existing files that were not generated.\n\n  Processors can indicate a source or class file is generated by\n including a javax.annotation.Generated annotation if the\n environment is configured so that that type is accessible.", "codes": ["public interface Filer"], "fields": [], "methods": [{"method_name": "createSourceFile", "method_sig": "JavaFileObject createSourceFile (CharSequence name,\n                                Element... originatingElements)\n                         throws IOException", "description": "Creates a new source file and returns an object to allow\n writing to it. A source file for a type, or a package can\n be created.\n\n The file's name and path (relative to the root output location for source\n files) are based on the name of the item to be declared in\n that file as well as the specified module for the item (if\n any).\n\n If more than one type is being declared in a single file (that\n is, a single compilation unit), the name of the file should\n correspond to the name of the principal top-level type (the\n public one, for example).\n\n A source file can also be created to hold information about\n a package, including package annotations.  To create a source\n file for a named package, have the name argument be the\n package's name followed by \".package-info\"; to create a\n source file for an unnamed package, use \"package-info\".\n\n The optional module name is prefixed to the type name or\n package name and separated using a \"/\" character. For\n example, to create a source file for type a.B in module\n foo, use a name argument of \"foo/a.B\".\n\n If no explicit module prefix is given and modules are supported\n in the environment, a suitable module is inferred. If a suitable\n module cannot be inferred FilerException is thrown.\n An implementation may use information about the configuration of\n the annotation processing tool as part of the inference.\n\n Creating a source file in or for an unnamed package in a named\n module is not supported."}, {"method_name": "createClassFile", "method_sig": "JavaFileObject createClassFile (CharSequence name,\n                               Element... originatingElements)\n                        throws IOException", "description": "Creates a new class file, and returns an object to allow\n writing to it. A class file for a type, or a package can\n be created.\n\n The file's name and path (relative to the root output location for class\n files) are based on the name of the item to be declared as\n well as the specified module for the item (if any).\n\n A class file can also be created to hold information about a\n package, including package annotations. To create a class file\n for a named package, have the name argument be the\n package's name followed by \".package-info\"; creating a\n class file for an unnamed package is not supported.\n\n The optional module name is prefixed to the type name or\n package name and separated using a \"/\" character. For\n example, to create a class file for type a.B in module\n foo, use a name argument of \"foo/a.B\".\n\n If no explicit module prefix is given and modules are supported\n in the environment, a suitable module is inferred. If a suitable\n module cannot be inferred FilerException is thrown.\n An implementation may use information about the configuration of\n the annotation processing tool as part of the inference.\n\n Creating a class file in or for an unnamed package in a named\n module is not supported."}, {"method_name": "createResource", "method_sig": "FileObject createResource (JavaFileManager.Location location,\n                          CharSequence moduleAndPkg,\n                          CharSequence relativeName,\n                          Element... originatingElements)\n                   throws IOException", "description": "Creates a new auxiliary resource file for writing and returns a\n file object for it.  The file may be located along with the\n newly created source files, newly created binary files, or\n other supported location.  The locations CLASS_OUTPUT and SOURCE_OUTPUT must be\n supported. The resource may be named relative to some module\n and/or package (as are source and class files), and from there\n by a relative pathname.  In a loose sense, the full pathname of\n the new file will be the concatenation of location,\n moduleAndPkg, and relativeName.\n\n If moduleAndPkg contains a \"/\" character, the\n prefix before the \"/\" character is the module name and\n the suffix after the \"/\" character is the package\n name. The package suffix may be empty. If moduleAndPkg\n does not contain a \"/\" character, the entire argument\n is interpreted as a package name.\n\n If the given location is neither a module oriented location, nor an output location containing multiple modules, and the explicit\n module prefix is given, FilerException is thrown.\n\n If the given location is either a module oriented location,\n or an output location containing multiple modules, and no explicit\n modules prefix is given, a suitable module is\n inferred. If a suitable module cannot be inferred FilerException is thrown. An implementation may use information\n about the configuration of the annotation processing tool\n as part of the inference.\n\n Files created via this method are not registered for\n annotation processing, even if the full pathname of the file\n would correspond to the full pathname of a new source file\n or new class file."}, {"method_name": "getResource", "method_sig": "FileObject getResource (JavaFileManager.Location location,\n                       CharSequence moduleAndPkg,\n                       CharSequence relativeName)\n                throws IOException", "description": "Returns an object for reading an existing resource.  The\n locations CLASS_OUTPUT\n and SOURCE_OUTPUT must\n be supported.\n\n If moduleAndPkg contains a \"/\" character, the\n prefix before the \"/\" character is the module name and\n the suffix after the \"/\" character is the package\n name. The package suffix may be empty; however, if a module\n name is present, it must be nonempty. If moduleAndPkg\n does not contain a \"/\" character, the entire argument\n is interpreted as a package name.\n\n If the given location is neither a module oriented location, nor an output location containing multiple modules, and the explicit\n module prefix is given, FilerException is thrown.\n\n If the given location is either a module oriented location,\n or an output location containing multiple modules, and no explicit\n modules prefix is given, a suitable module is\n inferred. If a suitable module cannot be inferred FilerException is thrown. An implementation may use information\n about the configuration of the annotation processing tool\n as part of the inference."}]}