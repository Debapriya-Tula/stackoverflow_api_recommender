{"name": "Interface UndoableEdit", "module": "java.desktop", "package": "javax.swing.undo", "text": "An UndoableEdit represents an edit.  The edit may\n be undone, or if already undone the edit may be redone.\n \nUndoableEdit is designed to be used with the\n UndoManager.  As UndoableEdits are generated\n by an UndoableEditListener they are typically added to\n the UndoManager.  When an UndoableEdit\n is added to an UndoManager the following occurs (assuming\n end has not been called on the UndoManager):\n \nIf the UndoManager contains edits it will call\n     addEdit on the current edit passing in the new edit\n     as the argument.  If addEdit returns true the\n     new edit is assumed to have been incorporated into the current edit and\n     the new edit will not be added to the list of current edits.\n     Edits can use addEdit as a way for smaller edits to\n     be incorporated into a larger edit and treated as a single edit.\n If addEdit returns false replaceEdit\n     is called on the new edit with the current edit passed in as the\n     argument. This is the inverse of addEdit \u2014\n     if the new edit returns true from replaceEdit, the new\n     edit replaces the current edit.\n \n The UndoManager makes use of\n isSignificant to determine how many edits should be\n undone or redone.  The UndoManager will undo or redo\n all insignificant edits (isSignificant returns false)\n between the current edit and the last or\n next significant edit.   addEdit and\n replaceEdit can be used to treat multiple edits as\n a single edit, returning false from isSignificant\n allows for treating can be used to\n have many smaller edits undone or redone at once.  Similar functionality\n can also be done using the addEdit method.", "codes": ["public interface UndoableEdit"], "fields": [], "methods": [{"method_name": "undo", "method_sig": "void undo()\n   throws CannotUndoException", "description": "Undo the edit."}, {"method_name": "canUndo", "method_sig": "boolean canUndo()", "description": "Returns true if this edit may be undone."}, {"method_name": "redo", "method_sig": "void redo()\n   throws CannotRedoException", "description": "Re-applies the edit."}, {"method_name": "canRedo", "method_sig": "boolean canRedo()", "description": "Returns true if this edit may be redone."}, {"method_name": "die", "method_sig": "void die()", "description": "Informs the edit that it should no longer be used. Once an\n UndoableEdit has been marked as dead it can no longer\n be undone or redone.\n \n This is a useful hook for cleaning up state no longer\n needed once undoing or redoing is impossible--for example,\n deleting file resources used by objects that can no longer be\n undeleted. UndoManager calls this before it dequeues edits.\n \n Note that this is a one-way operation. There is no \"un-die\"\n method."}, {"method_name": "addEdit", "method_sig": "boolean addEdit (UndoableEdit anEdit)", "description": "Adds an UndoableEdit to this UndoableEdit.\n This method can be used to coalesce smaller edits into a larger\n compound edit.  For example, text editors typically allow\n undo operations to apply to words or sentences.  The text\n editor may choose to generate edits on each key event, but allow\n those edits to be coalesced into a more user-friendly unit, such as\n a word. In this case, the UndoableEdit would\n override addEdit to return true when the edits may\n be coalesced.\n \n A return value of true indicates anEdit was incorporated\n into this edit.  A return value of false indicates anEdit\n may not be incorporated into this edit.\n Typically the receiver is already in the queue of a\n UndoManager (or other UndoableEditListener),\n and is being given a chance to incorporate anEdit\n rather than letting it be added to the queue in turn.\nIf true is returned, from now on anEdit must return\n false from canUndo and canRedo,\n and must throw the appropriate exception on undo or\n redo."}, {"method_name": "replaceEdit", "method_sig": "boolean replaceEdit (UndoableEdit anEdit)", "description": "Returns true if this UndoableEdit should replace\n anEdit. This method is used by CompoundEdit\n and the UndoManager; it is called if\n anEdit could not be added to the current edit\n (addEdit returns false).\n \n This method provides a way for an edit to replace an existing edit.\n This message is the opposite of addEdit--anEdit has typically\n already been queued in an UndoManager (or other\n UndoableEditListener), and the receiver is being given a chance\n to take its place.\nIf true is returned, from now on anEdit must return false from\n canUndo() and canRedo(), and must throw the appropriate\n exception on undo() or redo()."}, {"method_name": "isSignificant", "method_sig": "boolean isSignificant()", "description": "Returns true if this edit is considered significant.  A significant\n edit is typically an edit that should be presented to the user, perhaps\n on a menu item or tooltip.  The UndoManager will undo,\n or redo, all insignificant edits to the next significant edit."}, {"method_name": "getPresentationName", "method_sig": "String getPresentationName()", "description": "Returns a localized, human-readable description of this edit, suitable\n for use in a change log, for example."}, {"method_name": "getUndoPresentationName", "method_sig": "String getUndoPresentationName()", "description": "Returns a localized, human-readable description of the undoable form of\n this edit, suitable for use as an Undo menu item, for example.\n This is typically derived from getPresentationName."}, {"method_name": "getRedoPresentationName", "method_sig": "String getRedoPresentationName()", "description": "Returns a localized, human-readable description of the redoable form of\n this edit, suitable for use as a Redo menu item, for example. This is\n typically derived from getPresentationName."}]}