{"name": "Class DynamicLinker", "module": "jdk.dynalink", "package": "jdk.dynalink", "text": "The linker for RelinkableCallSite objects. A dynamic linker is a main\n objects when using Dynalink, it coordinates linking of call sites with\n linkers of available language runtimes that are represented by\n GuardingDynamicLinker objects (you only need to deal with these if\n you are yourself implementing a language runtime with its own object model\n and/or type conversions). To use Dynalink, you have to create one or more\n dynamic linkers using a DynamicLinkerFactory. Subsequently, you need\n to invoke its link(RelinkableCallSite) method from\n invokedynamic bootstrap methods to let it manage all the call sites\n they create. Usual usage would be to create at least one class per language\n runtime to contain one linker instance as:\n \n\n class MyLanguageRuntime {\n     private static final GuardingDynamicLinker myLanguageLinker = new MyLanguageLinker();\n     private static final DynamicLinker dynamicLinker = createDynamicLinker();\n\n     private static DynamicLinker createDynamicLinker() {\n         final DynamicLinkerFactory factory = new DynamicLinkerFactory();\n         factory.setPrioritizedLinker(myLanguageLinker);\n         return factory.createLinker();\n     }\n\n     public static CallSite bootstrap(MethodHandles.Lookup lookup, String name, MethodType type) {\n         return dynamicLinker.link(\n             new SimpleRelinkableCallSite(\n                 new CallSiteDescriptor(lookup, parseOperation(name), type)));\n     }\n\n     private static Operation parseOperation(String name) {\n         ...\n     }\n }\n \n The above setup of one static linker instance is often too simple. You will\n often have your language runtime have a concept of some kind of\n \"context class loader\" and you will want to create one dynamic linker per\n such class loader, to ensure it incorporates linkers for all other language\n runtimes visible to that class loader (see\n DynamicLinkerFactory.setClassLoader(ClassLoader)).\n \n There are three components you need to provide in the above example:\n \nYou are expected to provide a GuardingDynamicLinker for your own\n language. If your runtime doesn't have its own object model or type\n conversions, you don't need to implement a GuardingDynamicLinker; you\n would simply not invoke the setPrioritizedLinker method on the factory.\nThe performance of the programs can depend on your choice of the class to\n represent call sites. The above example used\n SimpleRelinkableCallSite, but you might want to use\n ChainedCallSite instead. You'll need to experiment and decide what\n fits your runtime the best. You can further subclass either of these or\n implement your own.\nYou also need to provide CallSiteDescriptors to your call sites.\n They are immutable objects that contain all the information about the call\n site: the class performing the lookups, the operation being invoked, and the\n method signature. You will have to supply your own scheme to encode and\n decode operations in the call site name or static parameters, that is why\n in the above example the parseOperation method is left unimplemented.\n", "codes": ["public final class DynamicLinker\nextends Object"], "fields": [], "methods": [{"method_name": "link", "method_sig": "public <T extends RelinkableCallSite> T link (T callSite)", "description": "Links an invokedynamic call site. It will install a method handle into\n the call site that invokes the relinking mechanism of this linker. Next\n time the call site is invoked, it will be linked for the actual arguments\n it was invoked with."}, {"method_name": "getLinkerServices", "method_sig": "public LinkerServices getLinkerServices()", "description": "Returns the object representing the linker services of this class that\n are normally exposed to individual language-specific linkers. While as a user of this class you normally\n only care about the link(RelinkableCallSite) method, in certain\n circumstances you might want to use the lower level services directly;\n either to lookup specific method handles, to access the type converters,\n and so on."}, {"method_name": "getLinkedCallSiteLocation", "method_sig": "public static StackTraceElement getLinkedCallSiteLocation()", "description": "Returns a stack trace element describing the location of the\n invokedynamic call site currently being linked on the current\n thread. The operation is potentially expensive as it needs to generate a\n stack trace to inspect it and is intended for use in diagnostics code.\n For \"free-floating\" call sites (not associated with an\n invokedynamic instruction), the result is not well-defined."}]}