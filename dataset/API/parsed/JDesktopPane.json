{"name": "Class JDesktopPane", "module": "java.desktop", "package": "javax.swing", "text": "A container used to create a multiple-document interface or a virtual desktop.\n You create JInternalFrame objects and add them to the\n JDesktopPane. JDesktopPane extends\n JLayeredPane to manage the potentially overlapping internal\n frames. It also maintains a reference to an instance of\n DesktopManager that is set by the UI\n class for the current look and feel (L&F).  Note that JDesktopPane\n does not support borders.\n \n This class is normally used as the parent of JInternalFrames\n to provide a pluggable DesktopManager object to the\n JInternalFrames. The installUI of the\n L&F specific implementation is responsible for setting the\n desktopManager variable appropriately.\n When the parent of a JInternalFrame is a JDesktopPane,\n it should delegate most of its behavior to the desktopManager\n (closing, resizing, etc).\n \n For further documentation and examples see\n How to Use Internal Frames,\n a section in The Java Tutorial.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans\u2122\n has been added to the java.beans package.\n Please see XMLEncoder.", "codes": ["@JavaBean(defaultProperty=\"UI\")\npublic class JDesktopPane\nextends JLayeredPane\nimplements Accessible"], "fields": [{"field_name": "LIVE_DRAG_MODE", "field_sig": "public static final\u00a0int LIVE_DRAG_MODE", "description": "Indicates that the entire contents of the item being dragged\n should appear inside the desktop pane."}, {"field_name": "OUTLINE_DRAG_MODE", "field_sig": "public static final\u00a0int OUTLINE_DRAG_MODE", "description": "Indicates that an outline only of the item being dragged\n should appear inside the desktop pane."}], "methods": [{"method_name": "getUI", "method_sig": "public DesktopPaneUI getUI()", "description": "Returns the L&F object that renders this component."}, {"method_name": "setUI", "method_sig": "@BeanProperty(hidden=true,\n              visualUpdate=true,\n              description=\"The UI object that implements the Component\\'s LookAndFeel.\")\npublic void setUI (DesktopPaneUI ui)", "description": "Sets the L&F object that renders this component."}, {"method_name": "setDragMode", "method_sig": "@BeanProperty(enumerationValues={\"JDesktopPane.LIVE_DRAG_MODE\",\"JDesktopPane.OUTLINE_DRAG_MODE\"},\n              description=\"Dragging style for internal frame children.\")\npublic void setDragMode (int dragMode)", "description": "Sets the \"dragging style\" used by the desktop pane.\n You may want to change to one mode or another for\n performance or aesthetic reasons."}, {"method_name": "getDragMode", "method_sig": "public int getDragMode()", "description": "Gets the current \"dragging style\" used by the desktop pane."}, {"method_name": "getDesktopManager", "method_sig": "public DesktopManager getDesktopManager()", "description": "Returns the DesktopManger that handles\n desktop-specific UI actions."}, {"method_name": "setDesktopManager", "method_sig": "@BeanProperty(description=\"Desktop manager to handle the internal frames in the desktop pane.\")\npublic void setDesktopManager (DesktopManager d)", "description": "Sets the DesktopManger that will handle\n desktop-specific UI actions. This may be overridden by\n LookAndFeel."}, {"method_name": "updateUI", "method_sig": "public void updateUI()", "description": "Notification from the UIManager that the L&F has changed.\n Replaces the current UI object with the latest version from the\n UIManager."}, {"method_name": "getUIClassID", "method_sig": "@BeanProperty(bound=false)\npublic String getUIClassID()", "description": "Returns the name of the L&F class that renders this component."}, {"method_name": "getAllFrames", "method_sig": "@BeanProperty(bound=false)\npublic JInternalFrame[] getAllFrames()", "description": "Returns all JInternalFrames currently displayed in the\n desktop. Returns iconified frames as well as expanded frames."}, {"method_name": "getSelectedFrame", "method_sig": "public JInternalFrame getSelectedFrame()", "description": "Returns the currently active JInternalFrame\n in this JDesktopPane, or null\n if no JInternalFrame is currently active."}, {"method_name": "setSelectedFrame", "method_sig": "public void setSelectedFrame (JInternalFrame f)", "description": "Sets the currently active JInternalFrame\n  in this JDesktopPane. This method is used to bridge\n  the package gap between JDesktopPane and the platform implementation\n  code and should not be called directly. To visually select the frame\n  the client must call JInternalFrame.setSelected(true) to activate\n  the frame."}, {"method_name": "getAllFramesInLayer", "method_sig": "public JInternalFrame[] getAllFramesInLayer (int layer)", "description": "Returns all JInternalFrames currently displayed in the\n specified layer of the desktop. Returns iconified frames as well\n expanded frames."}, {"method_name": "selectFrame", "method_sig": "public JInternalFrame selectFrame (boolean forward)", "description": "Selects the next JInternalFrame in this desktop pane."}, {"method_name": "addImpl", "method_sig": "protected void addImpl (Component comp,\n                       Object constraints,\n                       int index)", "description": "Adds the specified component to this container at the specified\n index. This method also notifies the layout manager to add\n the component to this container's layout using the specified\n constraints object via the addLayoutComponent\n method.\n \n The constraints are\n defined by the particular layout manager being used.  For\n example, the BorderLayout class defines five\n constraints: BorderLayout.NORTH,\n BorderLayout.SOUTH, BorderLayout.EAST,\n BorderLayout.WEST, and BorderLayout.CENTER.\n \n The GridBagLayout class requires a\n GridBagConstraints object.  Failure to pass\n the correct type of constraints object results in an\n IllegalArgumentException.\n \n If the current layout manager implements LayoutManager2, then\n LayoutManager2.addLayoutComponent(Component,Object) is invoked on\n it. If the current layout manager does not implement\n LayoutManager2, and constraints is a String, then\n LayoutManager.addLayoutComponent(String,Component) is invoked on it.\n \n If the component is not an ancestor of this container and has a non-null\n parent, it is removed from its current parent before it is added to this\n container.\n \n This is the method to override if a program needs to track\n every add request to a container as all other add methods defer\n to this one. An overriding method should\n usually include a call to the superclass's version of the method:\n\n \nsuper.addImpl(comp, constraints, index)\n\n\n This method changes layout-related information, and therefore,\n invalidates the component hierarchy. If the container has already been\n displayed, the hierarchy must be validated thereafter in order to\n display the added component."}, {"method_name": "remove", "method_sig": "public void remove (int index)", "description": "Remove the indexed component from this pane.\n This is the absolute index, ignoring layers."}, {"method_name": "removeAll", "method_sig": "public void removeAll()", "description": "Removes all the components from this container."}, {"method_name": "setComponentZOrder", "method_sig": "public void setComponentZOrder (Component comp,\n                               int index)", "description": "Moves the specified component to the specified z-order index in\n the container. The z-order determines the order that components\n are painted; the component with the highest z-order paints first\n and the component with the lowest z-order paints last.\n Where components overlap, the component with the lower\n z-order paints over the component with the higher z-order.\n \n If the component is a child of some other container, it is\n removed from that container before being added to this container.\n The important difference between this method and\n java.awt.Container.add(Component, int) is that this method\n doesn't call removeNotify on the component while\n removing it from its previous container unless necessary and when\n allowed by the underlying native windowing system. This way, if the\n component has the keyboard focus, it maintains the focus when\n moved to the new position.\n \n This property is guaranteed to apply only to lightweight\n non-Container components.\n \n This method changes layout-related information, and therefore,\n invalidates the component hierarchy.\n \nNote: Not all platforms support changing the z-order of\n heavyweight components from one container into another without\n the call to removeNotify. There is no way to detect\n whether a platform supports this, so developers shouldn't make\n any assumptions."}, {"method_name": "paramString", "method_sig": "protected String paramString()", "description": "Returns a string representation of this JDesktopPane.\n This method is intended to be used only for debugging purposes, and the\n content and format of the returned string may vary between\n implementations. The returned string may be empty but may not\n be null."}, {"method_name": "getAccessibleContext", "method_sig": "@BeanProperty(bound=false)\npublic AccessibleContext getAccessibleContext()", "description": "Gets the AccessibleContext associated with this\n JDesktopPane. For desktop panes, the\n AccessibleContext takes the form of an\n AccessibleJDesktopPane.\n A new AccessibleJDesktopPane instance is created if necessary."}]}