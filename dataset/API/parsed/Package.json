{"name": "Class Package", "module": "java.base", "package": "java.lang", "text": "Represents metadata about a run-time package associated with a class loader.\n Metadata includes annotations, versioning, and sealing.\n \n Annotations for the run-time package are read from package-info.class\n at the same code source as classes in the run-time package.\n \n The set of classes that make up the run-time package may implement a\n particular specification. The specification title, version, and vendor\n (indicating the owner/maintainer of the specification) can be provided\n when the Package is defined. An application can ask if the\n Package is compatible with a particular specification version\n by using the Package.isCompatibleWith(String)\n method. In addition, information about the actual classes that make up the\n run-time package can be provided when the Package is defined.\n This information consists of an implementation title, version, and vendor\n (indicating the supplier of the classes).\n \n A Package may be explicitly defined with\n the ClassLoader.definePackage(String, String, String, String,\n String, String, String, URL) method.\n The caller supplies the specification and implementation titles, versions, and\n vendors. The caller also indicates whether the package is\n sealed.\n If a Package is not explicitly defined for a run-time package when\n a class in that run-time package is defined, then a Package is\n automatically defined by the class's defining class loader, as follows.\n \n A Package automatically defined for classes in a named module has\n the following properties:\n \nThe name of the package is derived from the binary names\n     of the classes. Since classes in a named module must be in a named package,\n     the derived name is never empty.\nThe package is sealed with the module location as the code source, if known.\nThe specification and implementation titles, versions, and vendors\n     are unspecified.\nAny annotations on the package are read from package-info.class\n     as specified above.\n\n\n A Package automatically defined for classes in an unnamed module\n has the following properties:\n \nThe name of the package is either \"\" (for classes in an unnamed package)\n     or derived from the binary names of the classes\n     (for classes in a named package).\nThe package is not sealed.\nThe specification and implementation titles, versions, and vendors\n     are unspecified.\nAny annotations on the package are read from package-info.class\n     as specified above.\n\n\n A Package can be obtained with the Package.getPackage(String) and ClassLoader.getDefinedPackage(String) methods.\n Every Package defined by a class loader can be obtained\n with the Package.getPackages() and\n ClassLoader.getDefinedPackages() methods.", "codes": ["public class Package\nextends Object\nimplements AnnotatedElement"], "fields": [], "methods": [{"method_name": "getName", "method_sig": "public String getName()", "description": "Return the name of this package."}, {"method_name": "getSpecificationTitle", "method_sig": "public String getSpecificationTitle()", "description": "Return the title of the specification that this package implements."}, {"method_name": "getSpecificationVersion", "method_sig": "public String getSpecificationVersion()", "description": "Returns the version number of the specification\n that this package implements.\n This version string must be a sequence of non-negative decimal\n integers separated by \".\"'s and may have leading zeros.\n When version strings are compared the most significant\n numbers are compared.\n\n\n Specification version numbers use a syntax that consists of non-negative\n decimal integers separated by periods \".\", for example \"2.0\" or\n \"1.2.3.4.5.6.7\".  This allows an extensible number to be used to represent\n major, minor, micro, etc. versions.  The version specification is described\n by the following formal grammar:\n \n\nSpecificationVersion:\nDigits RefinedVersionopt\nRefinedVersion:\n. Digits\n. Digits RefinedVersion\nDigits:\nDigit\nDigits\nDigit:\nany character for which Character.isDigit(char) returns true,\n e.g. 0, 1, 2, ...\n \n"}, {"method_name": "getSpecificationVendor", "method_sig": "public String getSpecificationVendor()", "description": "Return the name of the organization, vendor,\n or company that owns and maintains the specification\n of the classes that implement this package."}, {"method_name": "getImplementationTitle", "method_sig": "public String getImplementationTitle()", "description": "Return the title of this package."}, {"method_name": "getImplementationVersion", "method_sig": "public String getImplementationVersion()", "description": "Return the version of this implementation. It consists of any string\n assigned by the vendor of this implementation and does\n not have any particular syntax specified or expected by the Java\n runtime. It may be compared for equality with other\n package version strings used for this implementation\n by this vendor for this package."}, {"method_name": "getImplementationVendor", "method_sig": "public String getImplementationVendor()", "description": "Returns the vendor that implemented this package, null\n is returned if it is not known."}, {"method_name": "isSealed", "method_sig": "public boolean isSealed()", "description": "Returns true if this package is sealed."}, {"method_name": "isSealed", "method_sig": "public boolean isSealed (URL url)", "description": "Returns true if this package is sealed with respect to the specified\n code source url."}, {"method_name": "isCompatibleWith", "method_sig": "public boolean isCompatibleWith (String desired)\n                         throws NumberFormatException", "description": "Compare this package's specification version with a\n desired version. It returns true if\n this packages specification version number is greater than or equal\n to the desired version number. \n\n Version numbers are compared by sequentially comparing corresponding\n components of the desired and specification strings.\n Each component is converted as a decimal integer and the values\n compared.\n If the specification value is greater than the desired\n value true is returned. If the value is less false is returned.\n If the values are equal the period is skipped and the next pair of\n components is compared."}, {"method_name": "getPackage", "method_sig": "@Deprecated(since=\"9\")\npublic static Package getPackage (String name)", "description": "Finds a package by name in the caller's class loader and its\n ancestors.\n \n If the caller's class loader defines a Package of the given name,\n the Package is returned. Otherwise, the ancestors of the\n caller's class loader are searched recursively (parent by parent)\n for a Package of the given name.\n \n Calling this method is equivalent to calling ClassLoader.getPackage(java.lang.String)\n on a ClassLoader instance which is the caller's class loader."}, {"method_name": "getPackages", "method_sig": "public static Package[] getPackages()", "description": "Returns all of the Packages defined by the caller's class loader\n and its ancestors.  The returned array may contain more than one\n Package object of the same package name, each defined by\n a different class loader in the class loader hierarchy.\n \n Calling this method is equivalent to calling ClassLoader.getPackages()\n on a ClassLoader instance which is the caller's class loader."}, {"method_name": "hashCode", "method_sig": "public int hashCode()", "description": "Return the hash code computed from the package name."}, {"method_name": "toString", "method_sig": "public String toString()", "description": "Returns the string representation of this Package.\n Its value is the string \"package \" and the package name.\n If the package title is defined it is appended.\n If the package version is defined it is appended."}, {"method_name": "getAnnotation", "method_sig": "public <A extends Annotation> A getAnnotation (Class<A> annotationClass)", "description": "Description copied from interface:\u00a0AnnotatedElement"}, {"method_name": "isAnnotationPresent", "method_sig": "public boolean isAnnotationPresent (Class<? extends Annotation> annotationClass)", "description": "Returns true if an annotation for the specified type\n is present on this element, else false.  This method\n is designed primarily for convenient access to marker annotations.\n\n The truth value returned by this method is equivalent to:\n getAnnotation(annotationClass) != null\nThe body of the default method is specified to be the code\n above."}, {"method_name": "getAnnotationsByType", "method_sig": "public <A extends Annotation> A[] getAnnotationsByType (Class<A> annotationClass)", "description": "Description copied from interface:\u00a0AnnotatedElement"}, {"method_name": "getAnnotations", "method_sig": "public Annotation[] getAnnotations()", "description": "Description copied from interface:\u00a0AnnotatedElement"}, {"method_name": "getDeclaredAnnotation", "method_sig": "public <A extends Annotation> A getDeclaredAnnotation (Class<A> annotationClass)", "description": "Description copied from interface:\u00a0AnnotatedElement"}, {"method_name": "getDeclaredAnnotationsByType", "method_sig": "public <A extends Annotation> A[] getDeclaredAnnotationsByType (Class<A> annotationClass)", "description": "Description copied from interface:\u00a0AnnotatedElement"}, {"method_name": "getDeclaredAnnotations", "method_sig": "public Annotation[] getDeclaredAnnotations()", "description": "Description copied from interface:\u00a0AnnotatedElement"}]}