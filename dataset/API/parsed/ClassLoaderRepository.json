{"name": "Interface ClassLoaderRepository", "module": "java.management", "package": "javax.management.loading", "text": "Instances of this interface are used to keep the list of ClassLoaders\n registered in an MBean Server.\n They provide the necessary methods to load classes using the registered\n ClassLoaders.\nThe first ClassLoader in a ClassLoaderRepository is\n always the MBean Server's own ClassLoader.\nWhen an MBean is registered in an MBean Server, if it is of a\n subclass of ClassLoader and if it does not\n implement the interface PrivateClassLoader, it is added to\n the end of the MBean Server's ClassLoaderRepository.\n If it is subsequently unregistered from the MBean Server, it is\n removed from the ClassLoaderRepository.\nThe order of MBeans in the ClassLoaderRepository is\n significant.  For any two MBeans X and Y in the\n ClassLoaderRepository, X must appear before\n Y if the registration of X was completed before\n the registration of Y started.  If X and\n Y were registered concurrently, their order is\n indeterminate.  The registration of an MBean corresponds to the\n call to MBeanServer.registerMBean(java.lang.Object, javax.management.ObjectName) or one of the MBeanServer.createMBean methods.", "codes": ["public interface ClassLoaderRepository"], "fields": [], "methods": [{"method_name": "loadClass", "method_sig": "Class<?> loadClass (String className)\n            throws ClassNotFoundException", "description": "Load the given class name through the list of class loaders.\n Each ClassLoader in turn from the ClassLoaderRepository is\n asked to load the class via its ClassLoader.loadClass(String) method.  If it successfully\n returns a Class object, that is the result of this\n method.  If it throws a ClassNotFoundException, the\n search continues with the next ClassLoader.  If it throws\n another exception, the exception is propagated from this\n method.  If the end of the list is reached, a ClassNotFoundException is thrown."}, {"method_name": "loadClassWithout", "method_sig": "Class<?> loadClassWithout (ClassLoader exclude,\n                          String className)\n                   throws ClassNotFoundException", "description": "Load the given class name through the list of class loaders,\n excluding the given one.  Each ClassLoader in turn from the\n ClassLoaderRepository, except exclude, is asked to\n load the class via its ClassLoader.loadClass(String)\n method.  If it successfully returns a Class object,\n that is the result of this method.  If it throws a ClassNotFoundException, the search continues with the next\n ClassLoader.  If it throws another exception, the exception is\n propagated from this method.  If the end of the list is\n reached, a ClassNotFoundException is thrown.\nBe aware that if a ClassLoader in the ClassLoaderRepository\n calls this method from its loadClass method, it exposes itself to a deadlock if another\n ClassLoader in the ClassLoaderRepository does the same thing at\n the same time.  The loadClassBefore(java.lang.ClassLoader, java.lang.String) method is\n recommended to avoid the risk of deadlock."}, {"method_name": "loadClassBefore", "method_sig": "Class<?> loadClassBefore (ClassLoader stop,\n                         String className)\n                  throws ClassNotFoundException", "description": "Load the given class name through the list of class loaders,\n stopping at the given one.  Each ClassLoader in turn from the\n ClassLoaderRepository is asked to load the class via its ClassLoader.loadClass(String) method.  If it successfully\n returns a Class object, that is the result of this\n method.  If it throws a ClassNotFoundException, the\n search continues with the next ClassLoader.  If it throws\n another exception, the exception is propagated from this\n method.  If the search reaches stop or the end of\n the list, a ClassNotFoundException is thrown.\nTypically this method is called from the loadClass method of\n stop, to consult loaders that appear before it\n in the ClassLoaderRepository.  By stopping the\n search as soon as stop is reached, a potential\n deadlock with concurrent class loading is avoided."}]}