{"name": "Class MaskFormatter", "module": "java.desktop", "package": "javax.swing.text", "text": "MaskFormatter is used to format and edit strings. The behavior\n of a MaskFormatter is controlled by way of a String mask\n that specifies the valid characters that can be contained at a particular\n location in the Document model. The following characters can\n be specified:\n\n \nValid characters and their descriptions\n\n\nCharacter\n     Description\n \n\n\n#\n     Any valid number, uses Character.isDigit.\n   \n'\n     Escape character, used to escape any of the special formatting\n     characters.\n   \nU\n     Any character (Character.isLetter). All lowercase letters are\n     mapped to upper case.\n   \nL\n     Any character (Character.isLetter). All upper case letters\n     are mapped to lower case.\n   \nA\n     Any character or number (Character.isLetter or\n     Character.isDigit).\n   \n?\n     Any character (Character.isLetter).\n   \n*\n     Anything.\n   \nH\n     Any hex character (0-9, a-f or A-F).\n \n\n\n Typically characters correspond to one char, but in certain languages this\n is not the case. The mask is on a per character basis, and will thus\n adjust to fit as many chars as are needed.\n \n You can further restrict the characters that can be input by the\n setInvalidCharacters and setValidCharacters\n methods. setInvalidCharacters allows you to specify\n which characters are not legal. setValidCharacters allows\n you to specify which characters are valid. For example, the following\n code block is equivalent to a mask of '0xHHH' with no invalid/valid\n characters:\n \n MaskFormatter formatter = new MaskFormatter(\"0x***\");\n formatter.setValidCharacters(\"0123456789abcdefABCDEF\");\n \n\n When initially formatting a value if the length of the string is\n less than the length of the mask, two things can happen. Either\n the placeholder string will be used, or the placeholder character will\n be used. Precedence is given to the placeholder string. For example:\n \n   MaskFormatter formatter = new MaskFormatter(\"###-####\");\n   formatter.setPlaceholderCharacter('_');\n   formatter.getDisplayValue(tf, \"123\");\n \n\n Would result in the string '123-____'. If\n setPlaceholder(\"555-1212\") was invoked '123-1212' would\n result. The placeholder String is only used on the initial format,\n on subsequent formats only the placeholder character will be used.\n \n If a MaskFormatter is configured to only allow valid characters\n (setAllowsInvalid(false)) literal characters will be skipped as\n necessary when editing. Consider a MaskFormatter with\n the mask \"###-####\" and current value \"555-1212\". Using the right\n arrow key to navigate through the field will result in (| indicates the\n position of the caret):\n \n   |555-1212\n   5|55-1212\n   55|5-1212\n   555-|1212\n   555-1|212\n \n The '-' is a literal (non-editable) character, and is skipped.\n \n Similar behavior will result when editing. Consider inserting the string\n '123-45' and '12345' into the MaskFormatter in the\n previous example. Both inserts will result in the same String,\n '123-45__'. When MaskFormatter\n is processing the insert at character position 3 (the '-'), two things can\n happen:\n \nIf the inserted character is '-', it is accepted.\n   If the inserted character matches the mask for the next non-literal\n       character, it is accepted at the new location.\n   Anything else results in an invalid edit\n \n\n By default MaskFormatter will not allow invalid edits, you can\n change this with the setAllowsInvalid method, and will\n commit edits on valid edits (use the setCommitsOnValidEdit to\n change this).\n \n By default, MaskFormatter is in overwrite mode. That is as\n characters are typed a new character is not inserted, rather the character\n at the current location is replaced with the newly typed character. You\n can change this behavior by way of the method setOverwriteMode.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans\u2122\n has been added to the java.beans package.\n Please see XMLEncoder.", "codes": ["public class MaskFormatter\nextends DefaultFormatter"], "fields": [], "methods": [{"method_name": "setMask", "method_sig": "public void setMask (String mask)\n             throws ParseException", "description": "Sets the mask dictating the legal characters.\n This will throw a ParseException if mask is\n not valid."}, {"method_name": "getMask", "method_sig": "public String getMask()", "description": "Returns the formatting mask."}, {"method_name": "setValidCharacters", "method_sig": "public void setValidCharacters (String validCharacters)", "description": "Allows for further restricting of the characters that can be input.\n Only characters specified in the mask, not in the\n invalidCharacters, and in\n validCharacters will be allowed to be input. Passing\n in null (the default) implies the valid characters are only bound\n by the mask and the invalid characters."}, {"method_name": "getValidCharacters", "method_sig": "public String getValidCharacters()", "description": "Returns the valid characters that can be input."}, {"method_name": "setInvalidCharacters", "method_sig": "public void setInvalidCharacters (String invalidCharacters)", "description": "Allows for further restricting of the characters that can be input.\n Only characters specified in the mask, not in the\n invalidCharacters, and in\n validCharacters will be allowed to be input. Passing\n in null (the default) implies the valid characters are only bound\n by the mask and the valid characters."}, {"method_name": "getInvalidCharacters", "method_sig": "public String getInvalidCharacters()", "description": "Returns the characters that are not valid for input."}, {"method_name": "setPlaceholder", "method_sig": "public void setPlaceholder (String placeholder)", "description": "Sets the string to use if the value does not completely fill in\n the mask. A null value implies the placeholder char should be used."}, {"method_name": "getPlaceholder", "method_sig": "public String getPlaceholder()", "description": "Returns the String to use if the value does not completely fill\n in the mask."}, {"method_name": "setPlaceholderCharacter", "method_sig": "public void setPlaceholderCharacter (char placeholder)", "description": "Sets the character to use in place of characters that are not present\n in the value, ie the user must fill them in. The default value is\n a space.\n \n This is only applicable if the placeholder string has not been\n specified, or does not completely fill in the mask."}, {"method_name": "getPlaceholderCharacter", "method_sig": "public char getPlaceholderCharacter()", "description": "Returns the character to use in place of characters that are not present\n in the value, ie the user must fill them in."}, {"method_name": "setValueContainsLiteralCharacters", "method_sig": "public void setValueContainsLiteralCharacters (boolean containsLiteralChars)", "description": "If true, the returned value and set value will also contain the literal\n characters in mask.\n \n For example, if the mask is '(###) ###-####', the\n current value is '(415) 555-1212', and\n valueContainsLiteralCharacters is\n true stringToValue will return\n '(415) 555-1212'. On the other hand, if\n valueContainsLiteralCharacters is false,\n stringToValue will return '4155551212'."}, {"method_name": "getValueContainsLiteralCharacters", "method_sig": "public boolean getValueContainsLiteralCharacters()", "description": "Returns true if stringToValue should return literal\n characters in the mask."}, {"method_name": "stringToValue", "method_sig": "public Object stringToValue (String value)\n                     throws ParseException", "description": "Parses the text, returning the appropriate Object representation of\n the String value. This strips the literal characters as\n necessary and invokes supers stringToValue, so that if\n you have specified a value class (setValueClass) an\n instance of it will be created. This will throw a\n ParseException if the value does not match the current\n mask.  Refer to setValueContainsLiteralCharacters(boolean) for details\n on how literals are treated."}, {"method_name": "valueToString", "method_sig": "public String valueToString (Object value)\n                     throws ParseException", "description": "Returns a String representation of the Object value\n based on the mask.  Refer to\n setValueContainsLiteralCharacters(boolean) for details\n on how literals are treated."}, {"method_name": "install", "method_sig": "public void install (JFormattedTextField ftf)", "description": "Installs the DefaultFormatter onto a particular\n JFormattedTextField.\n This will invoke valueToString to convert the\n current value from the JFormattedTextField to\n a String. This will then install the Actions from\n getActions, the DocumentFilter\n returned from getDocumentFilter and the\n NavigationFilter returned from\n getNavigationFilter onto the\n JFormattedTextField.\n \n Subclasses will typically only need to override this if they\n wish to install additional listeners on the\n JFormattedTextField.\n \n If there is a ParseException in converting the\n current value to a String, this will set the text to an empty\n String, and mark the JFormattedTextField as being\n in an invalid state.\n \n While this is a public method, this is typically only useful\n for subclassers of JFormattedTextField.\n JFormattedTextField will invoke this method at\n the appropriate times when the value changes, or its internal\n state changes."}]}