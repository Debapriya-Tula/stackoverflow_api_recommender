{"name": "Class Cipher", "module": "java.base", "package": "javax.crypto", "text": "This class provides the functionality of a cryptographic cipher for\n encryption and decryption. It forms the core of the Java Cryptographic\n Extension (JCE) framework.\n\n In order to create a Cipher object, the application calls the\n Cipher's getInstance method, and passes the name of the\n requested transformation to it. Optionally, the name of a provider\n may be specified.\n\n A transformation is a string that describes the operation (or\n set of operations) to be performed on the given input, to produce some\n output. A transformation always includes the name of a cryptographic\n algorithm (e.g., AES), and may be followed by a feedback mode and\n padding scheme.\n\n  A transformation is of the form:\n\n \n\"algorithm/mode/padding\" or\n\n \"algorithm\"\n \n (in the latter case,\n provider-specific default values for the mode and padding scheme are used).\n For example, the following is a valid transformation:\n\n \n     Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n \n\n Using modes such as CFB and OFB, block\n ciphers can encrypt data in units smaller than the cipher's actual\n block size.  When requesting such a mode, you may optionally specify\n the number of bits to be processed at a time by appending this number\n to the mode name as shown in the \"AES/CFB8/NoPadding\" and\n \"AES/OFB32/PKCS5Padding\" transformations. If no such\n number is specified, a provider-specific default is used.\n (See the\n JDK Providers Documentation\n for the JDK Providers default values.)\n Thus, block ciphers can be turned into byte-oriented stream ciphers by\n using an 8 bit mode such as CFB8 or OFB8.\n \n Modes such as Authenticated Encryption with Associated Data (AEAD)\n provide authenticity assurances for both confidential data and\n Additional Associated Data (AAD) that is not encrypted.  (Please see\n  RFC 5116  for more\n information on AEAD and AAD algorithms such as GCM/CCM.) Both\n confidential and AAD data can be used when calculating the\n authentication tag (similar to a Mac).  This tag is appended\n to the ciphertext during encryption, and is verified on decryption.\n \n AEAD modes such as GCM/CCM perform all AAD authenticity calculations\n before starting the ciphertext authenticity calculations.  To avoid\n implementations having to internally buffer ciphertext, all AAD data\n must be supplied to GCM/CCM implementations (via the updateAAD\n methods) before the ciphertext is processed (via\n the update and doFinal methods).\n \n Note that GCM mode has a uniqueness requirement on IVs used in\n encryption with a given key. When IVs are repeated for GCM\n encryption, such usages are subject to forgery attacks. Thus, after\n each encryption operation using GCM mode, callers should re-initialize\n the cipher objects with GCM parameters which have a different IV value.\n \n     GCMParameterSpec s = ...;\n     cipher.init(..., s);\n\n     // If the GCM parameters were generated by the provider, it can\n     // be retrieved by:\n     // cipher.getParameters().getParameterSpec(GCMParameterSpec.class);\n\n     cipher.updateAAD(...);  // AAD\n     cipher.update(...);     // Multi-part update\n     cipher.doFinal(...);    // conclusion of operation\n\n     // Use a different IV value for every encryption\n     byte[] newIv = ...;\n     s = new GCMParameterSpec(s.getTLen(), newIv);\n     cipher.init(..., s);\n     ...\n\n \n The ChaCha20 and ChaCha20-Poly1305 algorithms have a similar requirement\n for unique nonces with a given key.  After each encryption or decryption\n operation, callers should re-initialize their ChaCha20 or ChaCha20-Poly1305\n ciphers with parameters that specify a different nonce value.  Please\n see RFC 7539 for more\n information on the ChaCha20 and ChaCha20-Poly1305 algorithms.\n \n Every implementation of the Java platform is required to support\n the following standard Cipher transformations with the keysizes\n in parentheses:\n \nAES/CBC/NoPadding (128)\nAES/CBC/PKCS5Padding (128)\nAES/ECB/NoPadding (128)\nAES/ECB/PKCS5Padding (128)\nAES/GCM/NoPadding (128)\nDES/CBC/NoPadding (56)\nDES/CBC/PKCS5Padding (56)\nDES/ECB/NoPadding (56)\nDES/ECB/PKCS5Padding (56)\nDESede/CBC/NoPadding (168)\nDESede/CBC/PKCS5Padding (168)\nDESede/ECB/NoPadding (168)\nDESede/ECB/PKCS5Padding (168)\nRSA/ECB/PKCS1Padding (1024, 2048)\nRSA/ECB/OAEPWithSHA-1AndMGF1Padding (1024, 2048)\nRSA/ECB/OAEPWithSHA-256AndMGF1Padding (1024, 2048)\n\n These transformations are described in the\n \n Cipher section of the\n Java Security Standard Algorithm Names Specification.\n Consult the release documentation for your implementation to see if any\n other transformations are supported.", "codes": ["public class Cipher\nextends Object"], "fields": [{"field_name": "ENCRYPT_MODE", "field_sig": "public static final\u00a0int ENCRYPT_MODE", "description": "Constant used to initialize cipher to encryption mode."}, {"field_name": "DECRYPT_MODE", "field_sig": "public static final\u00a0int DECRYPT_MODE", "description": "Constant used to initialize cipher to decryption mode."}, {"field_name": "WRAP_MODE", "field_sig": "public static final\u00a0int WRAP_MODE", "description": "Constant used to initialize cipher to key-wrapping mode."}, {"field_name": "UNWRAP_MODE", "field_sig": "public static final\u00a0int UNWRAP_MODE", "description": "Constant used to initialize cipher to key-unwrapping mode."}, {"field_name": "PUBLIC_KEY", "field_sig": "public static final\u00a0int PUBLIC_KEY", "description": "Constant used to indicate the to-be-unwrapped key is a \"public key\"."}, {"field_name": "PRIVATE_KEY", "field_sig": "public static final\u00a0int PRIVATE_KEY", "description": "Constant used to indicate the to-be-unwrapped key is a \"private key\"."}, {"field_name": "SECRET_KEY", "field_sig": "public static final\u00a0int SECRET_KEY", "description": "Constant used to indicate the to-be-unwrapped key is a \"secret key\"."}], "methods": [{"method_name": "getInstance", "method_sig": "public static final Cipher getInstance (String transformation)\n                                throws NoSuchAlgorithmException,\n                                       NoSuchPaddingException", "description": "Returns a Cipher object that implements the specified\n transformation.\n\n  This method traverses the list of registered security Providers,\n starting with the most preferred Provider.\n A new Cipher object encapsulating the\n CipherSpi implementation from the first\n Provider that supports the specified algorithm is returned.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."}, {"method_name": "getInstance", "method_sig": "public static final Cipher getInstance (String transformation,\n                                       String provider)\n                                throws NoSuchAlgorithmException,\n                                       NoSuchProviderException,\n                                       NoSuchPaddingException", "description": "Returns a Cipher object that implements the specified\n transformation.\n\n  A new Cipher object encapsulating the\n CipherSpi implementation from the specified provider\n is returned.  The specified provider must be registered\n in the security provider list.\n\n  Note that the list of registered providers may be retrieved via\n the Security.getProviders() method."}, {"method_name": "getInstance", "method_sig": "public static final Cipher getInstance (String transformation,\n                                       Provider provider)\n                                throws NoSuchAlgorithmException,\n                                       NoSuchPaddingException", "description": "Returns a Cipher object that implements the specified\n transformation.\n\n  A new Cipher object encapsulating the\n CipherSpi implementation from the specified Provider\n object is returned.  Note that the specified Provider object\n does not have to be registered in the provider list."}, {"method_name": "getProvider", "method_sig": "public final Provider getProvider()", "description": "Returns the provider of this Cipher object."}, {"method_name": "getAlgorithm", "method_sig": "public final String getAlgorithm()", "description": "Returns the algorithm name of this Cipher object.\n\n This is the same name that was specified in one of the\n getInstance calls that created this Cipher\n object.."}, {"method_name": "getBlockSize", "method_sig": "public final int getBlockSize()", "description": "Returns the block size (in bytes)."}, {"method_name": "getOutputSize", "method_sig": "public final int getOutputSize (int inputLen)", "description": "Returns the length in bytes that an output buffer would need to be in\n order to hold the result of the next update or\n doFinal operation, given the input length\n inputLen (in bytes).\n\n This call takes into account any unprocessed (buffered) data from a\n previous update call, padding, and AEAD tagging.\n\n The actual output length of the next update or\n doFinal call may be smaller than the length returned by\n this method."}, {"method_name": "getIV", "method_sig": "public final byte[] getIV()", "description": "Returns the initialization vector (IV) in a new buffer.\n\n This is useful in the case where a random IV was created,\n or in the context of password-based encryption or\n decryption, where the IV is derived from a user-supplied password."}, {"method_name": "getParameters", "method_sig": "public final AlgorithmParameters getParameters()", "description": "Returns the parameters used with this cipher.\n\n The returned parameters may be the same that were used to initialize\n this cipher, or may contain a combination of default and random\n parameter values used by the underlying cipher implementation if this\n cipher requires algorithm parameters but was not initialized with any."}, {"method_name": "getExemptionMechanism", "method_sig": "public final ExemptionMechanism getExemptionMechanism()", "description": "Returns the exemption mechanism object used with this cipher."}, {"method_name": "init", "method_sig": "public final void init (int opmode,\n                       Key key)\n                throws InvalidKeyException", "description": "Initializes this cipher with a key.\n\n The cipher is initialized for one of the following four operations:\n encryption, decryption, key wrapping or key unwrapping, depending\n on the value of opmode.\n\n If this cipher requires any algorithm parameters that cannot be\n derived from the given key, the underlying cipher\n implementation is supposed to generate the required parameters itself\n (using provider-specific default or random values) if it is being\n initialized for encryption or key wrapping, and raise an\n InvalidKeyException if it is being\n initialized for decryption or key unwrapping.\n The generated parameters can be retrieved using\n getParameters or\n getIV (if the parameter is an IV).\n\n If this cipher requires algorithm parameters that cannot be\n derived from the input parameters, and there are no reasonable\n provider-specific default values, initialization will\n necessarily fail.\n\n If this cipher (including its underlying feedback or padding scheme)\n requires any random bytes (e.g., for parameter generation), it will get\n them using the SecureRandom\n implementation of the highest-priority\n installed provider as the source of randomness.\n (If none of the installed providers supply an implementation of\n SecureRandom, a system-provided source of randomness will be used.)\n\n Note that when a Cipher object is initialized, it loses all\n previously-acquired state. In other words, initializing a Cipher is\n equivalent to creating a new instance of that Cipher and initializing\n it."}, {"method_name": "init", "method_sig": "public final void init (int opmode,\n                       Key key,\n                       SecureRandom random)\n                throws InvalidKeyException", "description": "Initializes this cipher with a key and a source of randomness.\n\n The cipher is initialized for one of the following four operations:\n encryption, decryption, key wrapping or  key unwrapping, depending\n on the value of opmode.\n\n If this cipher requires any algorithm parameters that cannot be\n derived from the given key, the underlying cipher\n implementation is supposed to generate the required parameters itself\n (using provider-specific default or random values) if it is being\n initialized for encryption or key wrapping, and raise an\n InvalidKeyException if it is being\n initialized for decryption or key unwrapping.\n The generated parameters can be retrieved using\n getParameters or\n getIV (if the parameter is an IV).\n\n If this cipher requires algorithm parameters that cannot be\n derived from the input parameters, and there are no reasonable\n provider-specific default values, initialization will\n necessarily fail.\n\n If this cipher (including its underlying feedback or padding scheme)\n requires any random bytes (e.g., for parameter generation), it will get\n them from random.\n\n Note that when a Cipher object is initialized, it loses all\n previously-acquired state. In other words, initializing a Cipher is\n equivalent to creating a new instance of that Cipher and initializing\n it."}, {"method_name": "init", "method_sig": "public final void init (int opmode,\n                       Key key,\n                       AlgorithmParameterSpec params)\n                throws InvalidKeyException,\n                       InvalidAlgorithmParameterException", "description": "Initializes this cipher with a key and a set of algorithm\n parameters.\n\n The cipher is initialized for one of the following four operations:\n encryption, decryption, key wrapping or  key unwrapping, depending\n on the value of opmode.\n\n If this cipher requires any algorithm parameters and\n params is null, the underlying cipher implementation is\n supposed to generate the required parameters itself (using\n provider-specific default or random values) if it is being\n initialized for encryption or key wrapping, and raise an\n InvalidAlgorithmParameterException if it is being\n initialized for decryption or key unwrapping.\n The generated parameters can be retrieved using\n getParameters or\n getIV (if the parameter is an IV).\n\n If this cipher requires algorithm parameters that cannot be\n derived from the input parameters, and there are no reasonable\n provider-specific default values, initialization will\n necessarily fail.\n\n If this cipher (including its underlying feedback or padding scheme)\n requires any random bytes (e.g., for parameter generation), it will get\n them using the SecureRandom\n implementation of the highest-priority\n installed provider as the source of randomness.\n (If none of the installed providers supply an implementation of\n SecureRandom, a system-provided source of randomness will be used.)\n\n Note that when a Cipher object is initialized, it loses all\n previously-acquired state. In other words, initializing a Cipher is\n equivalent to creating a new instance of that Cipher and initializing\n it."}, {"method_name": "init", "method_sig": "public final void init (int opmode,\n                       Key key,\n                       AlgorithmParameterSpec params,\n                       SecureRandom random)\n                throws InvalidKeyException,\n                       InvalidAlgorithmParameterException", "description": "Initializes this cipher with a key, a set of algorithm\n parameters, and a source of randomness.\n\n The cipher is initialized for one of the following four operations:\n encryption, decryption, key wrapping or  key unwrapping, depending\n on the value of opmode.\n\n If this cipher requires any algorithm parameters and\n params is null, the underlying cipher implementation is\n supposed to generate the required parameters itself (using\n provider-specific default or random values) if it is being\n initialized for encryption or key wrapping, and raise an\n InvalidAlgorithmParameterException if it is being\n initialized for decryption or key unwrapping.\n The generated parameters can be retrieved using\n getParameters or\n getIV (if the parameter is an IV).\n\n If this cipher requires algorithm parameters that cannot be\n derived from the input parameters, and there are no reasonable\n provider-specific default values, initialization will\n necessarily fail.\n\n If this cipher (including its underlying feedback or padding scheme)\n requires any random bytes (e.g., for parameter generation), it will get\n them from random.\n\n Note that when a Cipher object is initialized, it loses all\n previously-acquired state. In other words, initializing a Cipher is\n equivalent to creating a new instance of that Cipher and initializing\n it."}, {"method_name": "init", "method_sig": "public final void init (int opmode,\n                       Key key,\n                       AlgorithmParameters params)\n                throws InvalidKeyException,\n                       InvalidAlgorithmParameterException", "description": "Initializes this cipher with a key and a set of algorithm\n parameters.\n\n The cipher is initialized for one of the following four operations:\n encryption, decryption, key wrapping or  key unwrapping, depending\n on the value of opmode.\n\n If this cipher requires any algorithm parameters and\n params is null, the underlying cipher implementation is\n supposed to generate the required parameters itself (using\n provider-specific default or random values) if it is being\n initialized for encryption or key wrapping, and raise an\n InvalidAlgorithmParameterException if it is being\n initialized for decryption or key unwrapping.\n The generated parameters can be retrieved using\n getParameters or\n getIV (if the parameter is an IV).\n\n If this cipher requires algorithm parameters that cannot be\n derived from the input parameters, and there are no reasonable\n provider-specific default values, initialization will\n necessarily fail.\n\n If this cipher (including its underlying feedback or padding scheme)\n requires any random bytes (e.g., for parameter generation), it will get\n them using the SecureRandom\n implementation of the highest-priority\n installed provider as the source of randomness.\n (If none of the installed providers supply an implementation of\n SecureRandom, a system-provided source of randomness will be used.)\n\n Note that when a Cipher object is initialized, it loses all\n previously-acquired state. In other words, initializing a Cipher is\n equivalent to creating a new instance of that Cipher and initializing\n it."}, {"method_name": "init", "method_sig": "public final void init (int opmode,\n                       Key key,\n                       AlgorithmParameters params,\n                       SecureRandom random)\n                throws InvalidKeyException,\n                       InvalidAlgorithmParameterException", "description": "Initializes this cipher with a key, a set of algorithm\n parameters, and a source of randomness.\n\n The cipher is initialized for one of the following four operations:\n encryption, decryption, key wrapping or  key unwrapping, depending\n on the value of opmode.\n\n If this cipher requires any algorithm parameters and\n params is null, the underlying cipher implementation is\n supposed to generate the required parameters itself (using\n provider-specific default or random values) if it is being\n initialized for encryption or key wrapping, and raise an\n InvalidAlgorithmParameterException if it is being\n initialized for decryption or key unwrapping.\n The generated parameters can be retrieved using\n getParameters or\n getIV (if the parameter is an IV).\n\n If this cipher requires algorithm parameters that cannot be\n derived from the input parameters, and there are no reasonable\n provider-specific default values, initialization will\n necessarily fail.\n\n If this cipher (including its underlying feedback or padding scheme)\n requires any random bytes (e.g., for parameter generation), it will get\n them from random.\n\n Note that when a Cipher object is initialized, it loses all\n previously-acquired state. In other words, initializing a Cipher is\n equivalent to creating a new instance of that Cipher and initializing\n it."}, {"method_name": "init", "method_sig": "public final void init (int opmode,\n                       Certificate certificate)\n                throws InvalidKeyException", "description": "Initializes this cipher with the public key from the given certificate.\n  The cipher is initialized for one of the following four operations:\n encryption, decryption, key wrapping or  key unwrapping, depending\n on the value of opmode.\n\n If the certificate is of type X.509 and has a key usage\n extension field marked as critical, and the value of the key usage\n extension field implies that the public key in\n the certificate and its corresponding private key are not\n supposed to be used for the operation represented by the value\n of opmode,\n an InvalidKeyException\n is thrown.\n\n  If this cipher requires any algorithm parameters that cannot be\n derived from the public key in the given certificate, the underlying\n cipher\n implementation is supposed to generate the required parameters itself\n (using provider-specific default or random values) if it is being\n initialized for encryption or key wrapping, and raise an\n InvalidKeyException if it is being initialized for decryption or\n key unwrapping.\n The generated parameters can be retrieved using\n getParameters or\n getIV (if the parameter is an IV).\n\n If this cipher requires algorithm parameters that cannot be\n derived from the input parameters, and there are no reasonable\n provider-specific default values, initialization will\n necessarily fail.\n\n If this cipher (including its underlying feedback or padding scheme)\n requires any random bytes (e.g., for parameter generation), it will get\n them using the\n SecureRandom\n implementation of the highest-priority\n installed provider as the source of randomness.\n (If none of the installed providers supply an implementation of\n SecureRandom, a system-provided source of randomness will be used.)\n\n Note that when a Cipher object is initialized, it loses all\n previously-acquired state. In other words, initializing a Cipher is\n equivalent to creating a new instance of that Cipher and initializing\n it."}, {"method_name": "init", "method_sig": "public final void init (int opmode,\n                       Certificate certificate,\n                       SecureRandom random)\n                throws InvalidKeyException", "description": "Initializes this cipher with the public key from the given certificate\n and\n a source of randomness.\n\n The cipher is initialized for one of the following four operations:\n encryption, decryption, key wrapping\n or key unwrapping, depending on\n the value of opmode.\n\n If the certificate is of type X.509 and has a key usage\n extension field marked as critical, and the value of the key usage\n extension field implies that the public key in\n the certificate and its corresponding private key are not\n supposed to be used for the operation represented by the value of\n opmode,\n an InvalidKeyException\n is thrown.\n\n If this cipher requires any algorithm parameters that cannot be\n derived from the public key in the given certificate,\n the underlying cipher\n implementation is supposed to generate the required parameters itself\n (using provider-specific default or random values) if it is being\n initialized for encryption or key wrapping, and raise an\n InvalidKeyException if it is being\n initialized for decryption or key unwrapping.\n The generated parameters can be retrieved using\n getParameters or\n getIV (if the parameter is an IV).\n\n If this cipher requires algorithm parameters that cannot be\n derived from the input parameters, and there are no reasonable\n provider-specific default values, initialization will\n necessarily fail.\n\n If this cipher (including its underlying feedback or padding scheme)\n requires any random bytes (e.g., for parameter generation), it will get\n them from random.\n\n Note that when a Cipher object is initialized, it loses all\n previously-acquired state. In other words, initializing a Cipher is\n equivalent to creating a new instance of that Cipher and initializing\n it."}, {"method_name": "update", "method_sig": "public final byte[] update (byte[] input)", "description": "Continues a multiple-part encryption or decryption operation\n (depending on how this cipher was initialized), processing another data\n part.\n\n The bytes in the input buffer are processed, and the\n result is stored in a new buffer.\n\n If input has a length of zero, this method returns\n null."}, {"method_name": "update", "method_sig": "public final byte[] update (byte[] input,\n                           int inputOffset,\n                           int inputLen)", "description": "Continues a multiple-part encryption or decryption operation\n (depending on how this cipher was initialized), processing another data\n part.\n\n The first inputLen bytes in the input\n buffer, starting at inputOffset inclusive, are processed,\n and the result is stored in a new buffer.\n\n If inputLen is zero, this method returns\n null."}, {"method_name": "update", "method_sig": "public final int update (byte[] input,\n                        int inputOffset,\n                        int inputLen,\n                        byte[] output)\n                 throws ShortBufferException", "description": "Continues a multiple-part encryption or decryption operation\n (depending on how this cipher was initialized), processing another data\n part.\n\n The first inputLen bytes in the input\n buffer, starting at inputOffset inclusive, are processed,\n and the result is stored in the output buffer.\n\n If the output buffer is too small to hold the result,\n a ShortBufferException is thrown. In this case, repeat this\n call with a larger output buffer. Use\n getOutputSize to determine how big\n the output buffer should be.\n\n If inputLen is zero, this method returns\n a length of zero.\n\n Note: this method should be copy-safe, which means the\n input and output buffers can reference\n the same byte array and no unprocessed input data is overwritten\n when the result is copied into the output buffer."}, {"method_name": "update", "method_sig": "public final int update (byte[] input,\n                        int inputOffset,\n                        int inputLen,\n                        byte[] output,\n                        int outputOffset)\n                 throws ShortBufferException", "description": "Continues a multiple-part encryption or decryption operation\n (depending on how this cipher was initialized), processing another data\n part.\n\n The first inputLen bytes in the input\n buffer, starting at inputOffset inclusive, are processed,\n and the result is stored in the output buffer, starting at\n outputOffset inclusive.\n\n If the output buffer is too small to hold the result,\n a ShortBufferException is thrown. In this case, repeat this\n call with a larger output buffer. Use\n getOutputSize to determine how big\n the output buffer should be.\n\n If inputLen is zero, this method returns\n a length of zero.\n\n Note: this method should be copy-safe, which means the\n input and output buffers can reference\n the same byte array and no unprocessed input data is overwritten\n when the result is copied into the output buffer."}, {"method_name": "update", "method_sig": "public final int update (ByteBuffer input,\n                        ByteBuffer output)\n                 throws ShortBufferException", "description": "Continues a multiple-part encryption or decryption operation\n (depending on how this cipher was initialized), processing another data\n part.\n\n All input.remaining() bytes starting at\n input.position() are processed. The result is stored\n in the output buffer.\n Upon return, the input buffer's position will be equal\n to its limit; its limit will not have changed. The output buffer's\n position will have advanced by n, where n is the value returned\n by this method; the output buffer's limit will not have changed.\n\n If output.remaining() bytes are insufficient to\n hold the result, a ShortBufferException is thrown.\n In this case, repeat this call with a larger output buffer. Use\n getOutputSize to determine how big\n the output buffer should be.\n\n Note: this method should be copy-safe, which means the\n input and output buffers can reference\n the same block of memory and no unprocessed input data is overwritten\n when the result is copied into the output buffer."}, {"method_name": "doFinal", "method_sig": "public final byte[] doFinal()\n                     throws IllegalBlockSizeException,\n                            BadPaddingException", "description": "Finishes a multiple-part encryption or decryption operation, depending\n on how this cipher was initialized.\n\n Input data that may have been buffered during a previous\n update operation is processed, with padding (if requested)\n being applied.\n If an AEAD mode such as GCM/CCM is being used, the authentication\n tag is appended in the case of encryption, or verified in the\n case of decryption.\n The result is stored in a new buffer.\n\n Upon finishing, this method resets this cipher object to the state\n it was in when previously initialized via a call to init.\n That is, the object is reset and available to encrypt or decrypt\n (depending on the operation mode that was specified in the call to\n init) more data.\n\n Note: if any exception is thrown, this cipher object may need to\n be reset before it can be used again."}, {"method_name": "doFinal", "method_sig": "public final int doFinal (byte[] output,\n                         int outputOffset)\n                  throws IllegalBlockSizeException,\n                         ShortBufferException,\n                         BadPaddingException", "description": "Finishes a multiple-part encryption or decryption operation, depending\n on how this cipher was initialized.\n\n Input data that may have been buffered during a previous\n update operation is processed, with padding (if requested)\n being applied.\n If an AEAD mode such as GCM/CCM is being used, the authentication\n tag is appended in the case of encryption, or verified in the\n case of decryption.\n The result is stored in the output buffer, starting at\n outputOffset inclusive.\n\n If the output buffer is too small to hold the result,\n a ShortBufferException is thrown. In this case, repeat this\n call with a larger output buffer. Use\n getOutputSize to determine how big\n the output buffer should be.\n\n Upon finishing, this method resets this cipher object to the state\n it was in when previously initialized via a call to init.\n That is, the object is reset and available to encrypt or decrypt\n (depending on the operation mode that was specified in the call to\n init) more data.\n\n Note: if any exception is thrown, this cipher object may need to\n be reset before it can be used again."}, {"method_name": "doFinal", "method_sig": "public final byte[] doFinal (byte[] input)\n                     throws IllegalBlockSizeException,\n                            BadPaddingException", "description": "Encrypts or decrypts data in a single-part operation, or finishes a\n multiple-part operation. The data is encrypted or decrypted,\n depending on how this cipher was initialized.\n\n The bytes in the input buffer, and any input bytes that\n may have been buffered during a previous update operation,\n are processed, with padding (if requested) being applied.\n If an AEAD mode such as GCM/CCM is being used, the authentication\n tag is appended in the case of encryption, or verified in the\n case of decryption.\n The result is stored in a new buffer.\n\n Upon finishing, this method resets this cipher object to the state\n it was in when previously initialized via a call to init.\n That is, the object is reset and available to encrypt or decrypt\n (depending on the operation mode that was specified in the call to\n init) more data.\n\n Note: if any exception is thrown, this cipher object may need to\n be reset before it can be used again."}, {"method_name": "doFinal", "method_sig": "public final byte[] doFinal (byte[] input,\n                            int inputOffset,\n                            int inputLen)\n                     throws IllegalBlockSizeException,\n                            BadPaddingException", "description": "Encrypts or decrypts data in a single-part operation, or finishes a\n multiple-part operation. The data is encrypted or decrypted,\n depending on how this cipher was initialized.\n\n The first inputLen bytes in the input\n buffer, starting at inputOffset inclusive, and any input\n bytes that may have been buffered during a previous update\n operation, are processed, with padding (if requested) being applied.\n If an AEAD mode such as GCM/CCM is being used, the authentication\n tag is appended in the case of encryption, or verified in the\n case of decryption.\n The result is stored in a new buffer.\n\n Upon finishing, this method resets this cipher object to the state\n it was in when previously initialized via a call to init.\n That is, the object is reset and available to encrypt or decrypt\n (depending on the operation mode that was specified in the call to\n init) more data.\n\n Note: if any exception is thrown, this cipher object may need to\n be reset before it can be used again."}, {"method_name": "doFinal", "method_sig": "public final int doFinal (byte[] input,\n                         int inputOffset,\n                         int inputLen,\n                         byte[] output)\n                  throws ShortBufferException,\n                         IllegalBlockSizeException,\n                         BadPaddingException", "description": "Encrypts or decrypts data in a single-part operation, or finishes a\n multiple-part operation. The data is encrypted or decrypted,\n depending on how this cipher was initialized.\n\n The first inputLen bytes in the input\n buffer, starting at inputOffset inclusive, and any input\n bytes that may have been buffered during a previous update\n operation, are processed, with padding (if requested) being applied.\n If an AEAD mode such as GCM/CCM is being used, the authentication\n tag is appended in the case of encryption, or verified in the\n case of decryption.\n The result is stored in the output buffer.\n\n If the output buffer is too small to hold the result,\n a ShortBufferException is thrown. In this case, repeat this\n call with a larger output buffer. Use\n getOutputSize to determine how big\n the output buffer should be.\n\n Upon finishing, this method resets this cipher object to the state\n it was in when previously initialized via a call to init.\n That is, the object is reset and available to encrypt or decrypt\n (depending on the operation mode that was specified in the call to\n init) more data.\n\n Note: if any exception is thrown, this cipher object may need to\n be reset before it can be used again.\n\n Note: this method should be copy-safe, which means the\n input and output buffers can reference\n the same byte array and no unprocessed input data is overwritten\n when the result is copied into the output buffer."}, {"method_name": "doFinal", "method_sig": "public final int doFinal (byte[] input,\n                         int inputOffset,\n                         int inputLen,\n                         byte[] output,\n                         int outputOffset)\n                  throws ShortBufferException,\n                         IllegalBlockSizeException,\n                         BadPaddingException", "description": "Encrypts or decrypts data in a single-part operation, or finishes a\n multiple-part operation. The data is encrypted or decrypted,\n depending on how this cipher was initialized.\n\n The first inputLen bytes in the input\n buffer, starting at inputOffset inclusive, and any input\n bytes that may have been buffered during a previous\n update operation, are processed, with padding\n (if requested) being applied.\n If an AEAD mode such as GCM/CCM is being used, the authentication\n tag is appended in the case of encryption, or verified in the\n case of decryption.\n The result is stored in the output buffer, starting at\n outputOffset inclusive.\n\n If the output buffer is too small to hold the result,\n a ShortBufferException is thrown. In this case, repeat this\n call with a larger output buffer. Use\n getOutputSize to determine how big\n the output buffer should be.\n\n Upon finishing, this method resets this cipher object to the state\n it was in when previously initialized via a call to init.\n That is, the object is reset and available to encrypt or decrypt\n (depending on the operation mode that was specified in the call to\n init) more data.\n\n Note: if any exception is thrown, this cipher object may need to\n be reset before it can be used again.\n\n Note: this method should be copy-safe, which means the\n input and output buffers can reference\n the same byte array and no unprocessed input data is overwritten\n when the result is copied into the output buffer."}, {"method_name": "doFinal", "method_sig": "public final int doFinal (ByteBuffer input,\n                         ByteBuffer output)\n                  throws ShortBufferException,\n                         IllegalBlockSizeException,\n                         BadPaddingException", "description": "Encrypts or decrypts data in a single-part operation, or finishes a\n multiple-part operation. The data is encrypted or decrypted,\n depending on how this cipher was initialized.\n\n All input.remaining() bytes starting at\n input.position() are processed.\n If an AEAD mode such as GCM/CCM is being used, the authentication\n tag is appended in the case of encryption, or verified in the\n case of decryption.\n The result is stored in the output buffer.\n Upon return, the input buffer's position will be equal\n to its limit; its limit will not have changed. The output buffer's\n position will have advanced by n, where n is the value returned\n by this method; the output buffer's limit will not have changed.\n\n If output.remaining() bytes are insufficient to\n hold the result, a ShortBufferException is thrown.\n In this case, repeat this call with a larger output buffer. Use\n getOutputSize to determine how big\n the output buffer should be.\n\n Upon finishing, this method resets this cipher object to the state\n it was in when previously initialized via a call to init.\n That is, the object is reset and available to encrypt or decrypt\n (depending on the operation mode that was specified in the call to\n init) more data.\n\n Note: if any exception is thrown, this cipher object may need to\n be reset before it can be used again.\n\n Note: this method should be copy-safe, which means the\n input and output buffers can reference\n the same byte array and no unprocessed input data is overwritten\n when the result is copied into the output buffer."}, {"method_name": "wrap", "method_sig": "public final byte[] wrap (Key key)\n                  throws IllegalBlockSizeException,\n                         InvalidKeyException", "description": "Wrap a key."}, {"method_name": "unwrap", "method_sig": "public final Key unwrap (byte[] wrappedKey,\n                        String wrappedKeyAlgorithm,\n                        int wrappedKeyType)\n                 throws InvalidKeyException,\n                        NoSuchAlgorithmException", "description": "Unwrap a previously wrapped key."}, {"method_name": "getMaxAllowedKeyLength", "method_sig": "public static final int getMaxAllowedKeyLength (String transformation)\n                                        throws NoSuchAlgorithmException", "description": "Returns the maximum key length for the specified transformation\n according to the installed JCE jurisdiction policy files. If\n JCE unlimited strength jurisdiction policy files are installed,\n Integer.MAX_VALUE will be returned.\n For more information on the default key sizes and the JCE jurisdiction\n policy files, please see the Cryptographic defaults and limitations in\n the JDK Providers Documentation."}, {"method_name": "getMaxAllowedParameterSpec", "method_sig": "public static final AlgorithmParameterSpec getMaxAllowedParameterSpec (String transformation)\n                                                               throws NoSuchAlgorithmException", "description": "Returns an AlgorithmParameterSpec object which contains\n the maximum cipher parameter value according to the\n jurisdiction policy file. If JCE unlimited strength jurisdiction\n policy files are installed or there is no maximum limit on the\n parameters for the specified transformation in the policy file,\n null will be returned."}, {"method_name": "updateAAD", "method_sig": "public final void updateAAD (byte[] src)", "description": "Continues a multi-part update of the Additional Authentication\n Data (AAD).\n \n Calls to this method provide AAD to the cipher when operating in\n modes such as AEAD (GCM/CCM).  If this cipher is operating in\n either GCM or CCM mode, all AAD must be supplied before beginning\n operations on the ciphertext (via the update and\n doFinal methods)."}, {"method_name": "updateAAD", "method_sig": "public final void updateAAD (byte[] src,\n                            int offset,\n                            int len)", "description": "Continues a multi-part update of the Additional Authentication\n Data (AAD), using a subset of the provided buffer.\n \n Calls to this method provide AAD to the cipher when operating in\n modes such as AEAD (GCM/CCM).  If this cipher is operating in\n either GCM or CCM mode, all AAD must be supplied before beginning\n operations on the ciphertext (via the update\n and doFinal methods)."}, {"method_name": "updateAAD", "method_sig": "public final void updateAAD (ByteBuffer src)", "description": "Continues a multi-part update of the Additional Authentication\n Data (AAD).\n \n Calls to this method provide AAD to the cipher when operating in\n modes such as AEAD (GCM/CCM).  If this cipher is operating in\n either GCM or CCM mode, all AAD must be supplied before beginning\n operations on the ciphertext (via the update\n and doFinal methods).\n \n All src.remaining() bytes starting at\n src.position() are processed.\n Upon return, the input buffer's position will be equal\n to its limit; its limit will not have changed."}]}