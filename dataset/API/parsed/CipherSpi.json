{"name": "Class CipherSpi", "module": "java.base", "package": "javax.crypto", "text": "This class defines the Service Provider Interface (SPI)\n for the Cipher class.\n All the abstract methods in this class must be implemented by each\n cryptographic service provider who wishes to supply the implementation\n of a particular cipher algorithm.\n\n In order to create an instance of Cipher, which\n encapsulates an instance of this CipherSpi class, an\n application calls one of the\n getInstance\n factory methods of the\n Cipher engine class and specifies the requested\n transformation.\n Optionally, the application may also specify the name of a provider.\n\n A transformation is a string that describes the operation (or\n set of operations) to be performed on the given input, to produce some\n output. A transformation always includes the name of a cryptographic\n algorithm (e.g., AES), and may be followed by a feedback mode and\n padding scheme.\n\n  A transformation is of the form:\n\n \n\"algorithm/mode/padding\" or\n\n \"algorithm\"\n \n (in the latter case,\n provider-specific default values for the mode and padding scheme are used).\n For example, the following is a valid transformation:\n\n \n     Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n \nA provider may supply a separate class for each combination\n of algorithm/mode/padding, or may decide to provide more generic\n classes representing sub-transformations corresponding to\n algorithm or algorithm/mode or algorithm//padding\n (note the double slashes),\n in which case the requested mode and/or padding are set automatically by\n the getInstance methods of Cipher, which invoke\n the engineSetMode and\n engineSetPadding\n methods of the provider's subclass of CipherSpi.\n\n A Cipher property in a provider master class may have one of\n the following formats:\n\n \n\n\n     // provider's subclass of \"CipherSpi\" implements \"algName\" with\n     // pluggable mode and padding\n     Cipher.algName\n \n\n\n     // provider's subclass of \"CipherSpi\" implements \"algName\" in the\n     // specified \"mode\", with pluggable padding\n     Cipher.algName/mode\n \n\n\n     // provider's subclass of \"CipherSpi\" implements \"algName\" with the\n     // specified \"padding\", with pluggable mode\n     Cipher.algName//padding\n \n\n\n     // provider's subclass of \"CipherSpi\" implements \"algName\" with the\n     // specified \"mode\" and \"padding\"\n     Cipher.algName/mode/padding\n \n\nFor example, a provider may supply a subclass of CipherSpi\n that implements AES/ECB/PKCS5Padding, one that implements\n AES/CBC/PKCS5Padding, one that implements\n AES/CFB/PKCS5Padding, and yet another one that implements\n AES/OFB/PKCS5Padding. That provider would have the following\n Cipher properties in its master class:\n\n \n\n\n     Cipher.AES/ECB/PKCS5Padding\n \n\n\n     Cipher.AES/CBC/PKCS5Padding\n \n\n\n     Cipher.AES/CFB/PKCS5Padding\n \n\n\n     Cipher.AES/OFB/PKCS5Padding\n \n\nAnother provider may implement a class for each of the above modes\n (i.e., one class for ECB, one for CBC, one for CFB,\n and one for OFB), one class for PKCS5Padding,\n and a generic AES class that subclasses from CipherSpi.\n That provider would have the following\n Cipher properties in its master class:\n\n \n\n\n     Cipher.AES\n \n\nThe getInstance factory method of the Cipher\n engine class follows these rules in order to instantiate a provider's\n implementation of CipherSpi for a\n transformation of the form \"algorithm\":\n\n \n\n Check if the provider has registered a subclass of CipherSpi\n for the specified \"algorithm\".\n If the answer is YES, instantiate this\n class, for whose mode and padding scheme default values (as supplied by\n the provider) are used.\n If the answer is NO, throw a NoSuchAlgorithmException\n exception.\n \nThe getInstance factory method of the Cipher\n engine class follows these rules in order to instantiate a provider's\n implementation of CipherSpi for a\n transformation of the form \"algorithm/mode/padding\":\n\n \n\n Check if the provider has registered a subclass of CipherSpi\n for the specified \"algorithm/mode/padding\" transformation.\n If the answer is YES, instantiate it.\n If the answer is NO, go to the next step.\n \n Check if the provider has registered a subclass of CipherSpi\n for the sub-transformation \"algorithm/mode\".\n If the answer is YES, instantiate it, and call\n engineSetPadding(padding) on the new instance.\n If the answer is NO, go to the next step.\n \n Check if the provider has registered a subclass of CipherSpi\n for the sub-transformation \"algorithm//padding\" (note the double\n slashes).\n If the answer is YES, instantiate it, and call\n engineSetMode(mode) on the new instance.\n If the answer is NO, go to the next step.\n \n Check if the provider has registered a subclass of CipherSpi\n for the sub-transformation \"algorithm\".\n If the answer is YES, instantiate it, and call\n engineSetMode(mode) and\n engineSetPadding(padding) on the new instance.\n If the answer is NO, throw a NoSuchAlgorithmException\n exception.\n ", "codes": ["public abstract class CipherSpi\nextends Object"], "fields": [], "methods": [{"method_name": "engineSetMode", "method_sig": "protected abstract void engineSetMode (String mode)\n                               throws NoSuchAlgorithmException", "description": "Sets the mode of this cipher."}, {"method_name": "engineSetPadding", "method_sig": "protected abstract void engineSetPadding (String padding)\n                                  throws NoSuchPaddingException", "description": "Sets the padding mechanism of this cipher."}, {"method_name": "engineGetBlockSize", "method_sig": "protected abstract int engineGetBlockSize()", "description": "Returns the block size (in bytes)."}, {"method_name": "engineGetOutputSize", "method_sig": "protected abstract int engineGetOutputSize (int inputLen)", "description": "Returns the length in bytes that an output buffer would\n need to be in order to hold the result of the next update\n or doFinal operation, given the input length\n inputLen (in bytes).\n\n This call takes into account any unprocessed (buffered) data from a\n previous update call, padding, and AEAD tagging.\n\n The actual output length of the next update or\n doFinal call may be smaller than the length returned by\n this method."}, {"method_name": "engineGetIV", "method_sig": "protected abstract byte[] engineGetIV()", "description": "Returns the initialization vector (IV) in a new buffer.\n\n  This is useful in the context of password-based encryption or\n decryption, where the IV is derived from a user-provided passphrase."}, {"method_name": "engineGetParameters", "method_sig": "protected abstract AlgorithmParameters engineGetParameters()", "description": "Returns the parameters used with this cipher.\n\n The returned parameters may be the same that were used to initialize\n this cipher, or may contain a combination of default and random\n parameter values used by the underlying cipher implementation if this\n cipher requires algorithm parameters but was not initialized with any."}, {"method_name": "engineInit", "method_sig": "protected abstract void engineInit (int opmode,\n                                   Key key,\n                                   SecureRandom random)\n                            throws InvalidKeyException", "description": "Initializes this cipher with a key and a source\n of randomness.\n\n The cipher is initialized for one of the following four operations:\n encryption, decryption, key wrapping or key unwrapping, depending on\n the value of opmode.\n\n If this cipher requires any algorithm parameters that cannot be\n derived from the given key, the underlying cipher\n implementation is supposed to generate the required parameters itself\n (using provider-specific default or random values) if it is being\n initialized for encryption or key wrapping, and raise an\n InvalidKeyException if it is being\n initialized for decryption or key unwrapping.\n The generated parameters can be retrieved using\n engineGetParameters or\n engineGetIV (if the parameter is an IV).\n\n If this cipher requires algorithm parameters that cannot be\n derived from the input parameters, and there are no reasonable\n provider-specific default values, initialization will\n necessarily fail.\n\n If this cipher (including its underlying feedback or padding scheme)\n requires any random bytes (e.g., for parameter generation), it will get\n them from random.\n\n Note that when a Cipher object is initialized, it loses all\n previously-acquired state. In other words, initializing a Cipher is\n equivalent to creating a new instance of that Cipher and initializing\n it."}, {"method_name": "engineInit", "method_sig": "protected abstract void engineInit (int opmode,\n                                   Key key,\n                                   AlgorithmParameterSpec params,\n                                   SecureRandom random)\n                            throws InvalidKeyException,\n                                   InvalidAlgorithmParameterException", "description": "Initializes this cipher with a key, a set of\n algorithm parameters, and a source of randomness.\n\n The cipher is initialized for one of the following four operations:\n encryption, decryption, key wrapping or key unwrapping, depending on\n the value of opmode.\n\n If this cipher requires any algorithm parameters and\n params is null, the underlying cipher implementation is\n supposed to generate the required parameters itself (using\n provider-specific default or random values) if it is being\n initialized for encryption or key wrapping, and raise an\n InvalidAlgorithmParameterException if it is being\n initialized for decryption or key unwrapping.\n The generated parameters can be retrieved using\n engineGetParameters or\n engineGetIV (if the parameter is an IV).\n\n If this cipher requires algorithm parameters that cannot be\n derived from the input parameters, and there are no reasonable\n provider-specific default values, initialization will\n necessarily fail.\n\n If this cipher (including its underlying feedback or padding scheme)\n requires any random bytes (e.g., for parameter generation), it will get\n them from random.\n\n Note that when a Cipher object is initialized, it loses all\n previously-acquired state. In other words, initializing a Cipher is\n equivalent to creating a new instance of that Cipher and initializing\n it."}, {"method_name": "engineInit", "method_sig": "protected abstract void engineInit (int opmode,\n                                   Key key,\n                                   AlgorithmParameters params,\n                                   SecureRandom random)\n                            throws InvalidKeyException,\n                                   InvalidAlgorithmParameterException", "description": "Initializes this cipher with a key, a set of\n algorithm parameters, and a source of randomness.\n\n The cipher is initialized for one of the following four operations:\n encryption, decryption, key wrapping or key unwrapping, depending on\n the value of opmode.\n\n If this cipher requires any algorithm parameters and\n params is null, the underlying cipher implementation is\n supposed to generate the required parameters itself (using\n provider-specific default or random values) if it is being\n initialized for encryption or key wrapping, and raise an\n InvalidAlgorithmParameterException if it is being\n initialized for decryption or key unwrapping.\n The generated parameters can be retrieved using\n engineGetParameters or\n engineGetIV (if the parameter is an IV).\n\n If this cipher requires algorithm parameters that cannot be\n derived from the input parameters, and there are no reasonable\n provider-specific default values, initialization will\n necessarily fail.\n\n If this cipher (including its underlying feedback or padding scheme)\n requires any random bytes (e.g., for parameter generation), it will get\n them from random.\n\n Note that when a Cipher object is initialized, it loses all\n previously-acquired state. In other words, initializing a Cipher is\n equivalent to creating a new instance of that Cipher and initializing\n it."}, {"method_name": "engineUpdate", "method_sig": "protected abstract byte[] engineUpdate (byte[] input,\n                                       int inputOffset,\n                                       int inputLen)", "description": "Continues a multiple-part encryption or decryption operation\n (depending on how this cipher was initialized), processing another data\n part.\n\n The first inputLen bytes in the input\n buffer, starting at inputOffset inclusive, are processed,\n and the result is stored in a new buffer."}, {"method_name": "engineUpdate", "method_sig": "protected abstract int engineUpdate (byte[] input,\n                                    int inputOffset,\n                                    int inputLen,\n                                    byte[] output,\n                                    int outputOffset)\n                             throws ShortBufferException", "description": "Continues a multiple-part encryption or decryption operation\n (depending on how this cipher was initialized), processing another data\n part.\n\n The first inputLen bytes in the input\n buffer, starting at inputOffset inclusive, are processed,\n and the result is stored in the output buffer, starting at\n outputOffset inclusive.\n\n If the output buffer is too small to hold the result,\n a ShortBufferException is thrown."}, {"method_name": "engineUpdate", "method_sig": "protected int engineUpdate (ByteBuffer input,\n                           ByteBuffer output)\n                    throws ShortBufferException", "description": "Continues a multiple-part encryption or decryption operation\n (depending on how this cipher was initialized), processing another data\n part.\n\n All input.remaining() bytes starting at\n input.position() are processed. The result is stored\n in the output buffer.\n Upon return, the input buffer's position will be equal\n to its limit; its limit will not have changed. The output buffer's\n position will have advanced by n, where n is the value returned\n by this method; the output buffer's limit will not have changed.\n\n If output.remaining() bytes are insufficient to\n hold the result, a ShortBufferException is thrown.\n\n Subclasses should consider overriding this method if they can\n process ByteBuffers more efficiently than byte arrays."}, {"method_name": "engineDoFinal", "method_sig": "protected abstract byte[] engineDoFinal (byte[] input,\n                                        int inputOffset,\n                                        int inputLen)\n                                 throws IllegalBlockSizeException,\n                                        BadPaddingException", "description": "Encrypts or decrypts data in a single-part operation,\n or finishes a multiple-part operation.\n The data is encrypted or decrypted, depending on how this cipher was\n initialized.\n\n The first inputLen bytes in the input\n buffer, starting at inputOffset inclusive, and any input\n bytes that may have been buffered during a previous update\n operation, are processed, with padding (if requested) being applied.\n If an AEAD mode such as GCM/CCM is being used, the authentication\n tag is appended in the case of encryption, or verified in the\n case of decryption.\n The result is stored in a new buffer.\n\n Upon finishing, this method resets this cipher object to the state\n it was in when previously initialized via a call to\n engineInit.\n That is, the object is reset and available to encrypt or decrypt\n (depending on the operation mode that was specified in the call to\n engineInit) more data.\n\n Note: if any exception is thrown, this cipher object may need to\n be reset before it can be used again."}, {"method_name": "engineDoFinal", "method_sig": "protected abstract int engineDoFinal (byte[] input,\n                                     int inputOffset,\n                                     int inputLen,\n                                     byte[] output,\n                                     int outputOffset)\n                              throws ShortBufferException,\n                                     IllegalBlockSizeException,\n                                     BadPaddingException", "description": "Encrypts or decrypts data in a single-part operation,\n or finishes a multiple-part operation.\n The data is encrypted or decrypted, depending on how this cipher was\n initialized.\n\n The first inputLen bytes in the input\n buffer, starting at inputOffset inclusive, and any input\n bytes that may have been buffered during a previous update\n operation, are processed, with padding (if requested) being applied.\n If an AEAD mode such as GCM/CCM is being used, the authentication\n tag is appended in the case of encryption, or verified in the\n case of decryption.\n The result is stored in the output buffer, starting at\n outputOffset inclusive.\n\n If the output buffer is too small to hold the result,\n a ShortBufferException is thrown.\n\n Upon finishing, this method resets this cipher object to the state\n it was in when previously initialized via a call to\n engineInit.\n That is, the object is reset and available to encrypt or decrypt\n (depending on the operation mode that was specified in the call to\n engineInit) more data.\n\n Note: if any exception is thrown, this cipher object may need to\n be reset before it can be used again."}, {"method_name": "engineDoFinal", "method_sig": "protected int engineDoFinal (ByteBuffer input,\n                            ByteBuffer output)\n                     throws ShortBufferException,\n                            IllegalBlockSizeException,\n                            BadPaddingException", "description": "Encrypts or decrypts data in a single-part operation,\n or finishes a multiple-part operation.\n The data is encrypted or decrypted, depending on how this cipher was\n initialized.\n\n All input.remaining() bytes starting at\n input.position() are processed.\n If an AEAD mode such as GCM/CCM is being used, the authentication\n tag is appended in the case of encryption, or verified in the\n case of decryption.\n The result is stored in the output buffer.\n Upon return, the input buffer's position will be equal\n to its limit; its limit will not have changed. The output buffer's\n position will have advanced by n, where n is the value returned\n by this method; the output buffer's limit will not have changed.\n\n If output.remaining() bytes are insufficient to\n hold the result, a ShortBufferException is thrown.\n\n Upon finishing, this method resets this cipher object to the state\n it was in when previously initialized via a call to\n engineInit.\n That is, the object is reset and available to encrypt or decrypt\n (depending on the operation mode that was specified in the call to\n engineInit) more data.\n\n Note: if any exception is thrown, this cipher object may need to\n be reset before it can be used again.\n\n Subclasses should consider overriding this method if they can\n process ByteBuffers more efficiently than byte arrays."}, {"method_name": "engineWrap", "method_sig": "protected byte[] engineWrap (Key key)\n                     throws IllegalBlockSizeException,\n                            InvalidKeyException", "description": "Wrap a key.\n\n This concrete method has been added to this previously-defined\n abstract class. (For backwards compatibility, it cannot be abstract.)\n It may be overridden by a provider to wrap a key.\n Such an override is expected to throw an IllegalBlockSizeException or\n InvalidKeyException (under the specified circumstances),\n if the given key cannot be wrapped.\n If this method is not overridden, it always throws an\n UnsupportedOperationException."}, {"method_name": "engineUnwrap", "method_sig": "protected Key engineUnwrap (byte[] wrappedKey,\n                           String wrappedKeyAlgorithm,\n                           int wrappedKeyType)\n                    throws InvalidKeyException,\n                           NoSuchAlgorithmException", "description": "Unwrap a previously wrapped key.\n\n This concrete method has been added to this previously-defined\n abstract class. (For backwards compatibility, it cannot be abstract.)\n It may be overridden by a provider to unwrap a previously wrapped key.\n Such an override is expected to throw an InvalidKeyException if\n the given wrapped key cannot be unwrapped.\n If this method is not overridden, it always throws an\n UnsupportedOperationException."}, {"method_name": "engineGetKeySize", "method_sig": "protected int engineGetKeySize (Key key)\n                        throws InvalidKeyException", "description": "Returns the key size of the given key object in bits.\n This concrete method has been added to this previously-defined\n abstract class. It throws an UnsupportedOperationException\n if it is not overridden by the provider."}, {"method_name": "engineUpdateAAD", "method_sig": "protected void engineUpdateAAD (byte[] src,\n                               int offset,\n                               int len)", "description": "Continues a multi-part update of the Additional Authentication\n Data (AAD), using a subset of the provided buffer.\n \n Calls to this method provide AAD to the cipher when operating in\n modes such as AEAD (GCM/CCM).  If this cipher is operating in\n either GCM or CCM mode, all AAD must be supplied before beginning\n operations on the ciphertext (via the update and \n doFinal methods)."}, {"method_name": "engineUpdateAAD", "method_sig": "protected void engineUpdateAAD (ByteBuffer src)", "description": "Continues a multi-part update of the Additional Authentication\n Data (AAD).\n \n Calls to this method provide AAD to the cipher when operating in\n modes such as AEAD (GCM/CCM).  If this cipher is operating in\n either GCM or CCM mode, all AAD must be supplied before beginning\n operations on the ciphertext (via the update and \n doFinal methods).\n \n All src.remaining() bytes starting at\n src.position() are processed.\n Upon return, the input buffer's position will be equal\n to its limit; its limit will not have changed."}]}