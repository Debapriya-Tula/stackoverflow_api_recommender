{"name": "Class SecurityPermission", "module": "java.base", "package": "java.security", "text": "This class is for security permissions. A SecurityPermission\n contains a name (also referred to as a \"target name\") but no actions list;\n you either have the named permission or you don't.\n \n The target name is the name of a security configuration parameter\n (see below). Currently the SecurityPermission object is used to\n guard access to the AccessControlContext, Policy,\n Provider, Security, Signer, and Identity\n objects.\n \n The following table lists the standard SecurityPermission\n target names, and for each provides a description of what the permission\n allows and a discussion of the risks of granting code the permission.\n\n \ntarget name, what the permission allows, and associated risks\n\n\nPermission Target Name\nWhat the Permission Allows\nRisks of Allowing this Permission\n\n\n\n\nauthProvider.{provider name}\nAllow the named provider to be an AuthProvider for login and\n logout operations. \nThis allows the named provider to perform login and logout\n operations. The named provider must extend AuthProvider\n and care must be taken to grant to a trusted provider since\n login operations involve sensitive authentication information\n such as PINs and passwords. \n\n\ncreateAccessControlContext\nCreation of an AccessControlContext\nThis allows someone to instantiate an AccessControlContext\n with a DomainCombiner.  Extreme care must be taken when\n granting this permission. Malicious code could create a DomainCombiner\n that augments the set of permissions granted to code, and even grant the\n code AllPermission.\n\n\ngetDomainCombiner\nRetrieval of an AccessControlContext's DomainCombiner\nThis allows someone to retrieve an AccessControlContext's\n DomainCombiner.  Since DomainCombiners may contain\n sensitive information, this could potentially lead to a privacy leak.\n\n\ngetPolicy\nRetrieval of the system-wide security policy (specifically, of the\n currently-installed Policy object)\nThis allows someone to query the policy via the\n getPermissions call,\n which discloses which permissions would be granted to a given CodeSource.\n While revealing the policy does not compromise the security of\n the system, it does provide malicious code with additional information\n which it may use to better aim an attack. It is wise\n not to divulge more information than necessary.\n\n\nsetPolicy\nSetting of the system-wide security policy (specifically,\n the Policy object)\nGranting this permission is extremely dangerous, as malicious\n code may grant itself all the necessary permissions it needs\n to successfully mount an attack on the system.\n\n\ncreatePolicy.{policy type}\nGetting an instance of a Policy implementation from a provider\nGranting this permission enables code to obtain a Policy object.\n Malicious code may query the Policy object to determine what permissions\n have been granted to code other than itself. \n\n\ngetProperty.{key}\nRetrieval of the security property with the specified key\nDepending on the particular key for which access has\n been granted, the code may have access to the list of security\n providers, as well as the location of the system-wide and user\n security policies.  while revealing this information does not\n compromise the security of the system, it does provide malicious\n code with additional information which it may use to better aim\n an attack.\n\n\n\nsetProperty.{key}\nSetting of the security property with the specified key\nThis could include setting a security provider or defining\n the location of the system-wide security policy.  Malicious\n code that has permission to set a new security provider may\n set a rogue provider that steals confidential information such\n as cryptographic private keys. In addition, malicious code with\n permission to set the location of the system-wide security policy\n may point it to a security policy that grants the attacker\n all the necessary permissions it requires to successfully mount\n an attack on the system.\n\n\n\ninsertProvider\nAddition of a new provider\nThis would allow somebody to introduce a possibly\n malicious provider (e.g., one that discloses the private keys passed\n to it) as the highest-priority provider. This would be possible\n because the Security object (which manages the installed providers)\n currently does not check the integrity or authenticity of a provider\n before attaching it. The \"insertProvider\" permission subsumes the\n \"insertProvider.{provider name}\" permission (see the section below for\n more information).\n \n\n\nremoveProvider.{provider name}\nRemoval of the specified provider\nThis may change the behavior or disable execution of other\n parts of the program. If a provider subsequently requested by the\n program has been removed, execution may fail. Also, if the removed\n provider is not explicitly requested by the rest of the program, but\n it would normally be the provider chosen when a cryptography service\n is requested (due to its previous order in the list of providers),\n a different provider will be chosen instead, or no suitable provider\n will be found, thereby resulting in program failure.\n\n\nclearProviderProperties.{provider name}\n\"Clearing\" of a Provider so that it no longer contains the properties\n used to look up services implemented by the provider\nThis disables the lookup of services implemented by the provider.\n This may thus change the behavior or disable execution of other\n parts of the program that would normally utilize the Provider, as\n described under the \"removeProvider.{provider name}\" permission.\n\n\nputProviderProperty.{provider name}\nSetting of properties for the specified Provider\nThe provider properties each specify the name and location\n of a particular service implemented by the provider. By granting\n this permission, you let code replace the service specification\n with another one, thereby specifying a different implementation.\n\n\nremoveProviderProperty.{provider name}\nRemoval of properties from the specified Provider\nThis disables the lookup of services implemented by the\n provider. They are no longer accessible due to removal of the properties\n specifying their names and locations. This\n may change the behavior or disable execution of other\n parts of the program that would normally utilize the Provider, as\n described under the \"removeProvider.{provider name}\" permission.\n\n\n\n\n The following permissions have been superseded by newer permissions or are\n associated with classes that have been deprecated: Identity,\n IdentityScope, Signer. Use of them is discouraged. See the\n applicable classes for more information.\n\n \ntarget name, what the permission allows, and associated risks\n\n\nPermission Target Name\nWhat the Permission Allows\nRisks of Allowing this Permission\n\n\n\n\ninsertProvider.{provider name}\nAddition of a new provider, with the specified name\nUse of this permission is discouraged from further use because it is\n possible to circumvent the name restrictions by overriding the\n Provider.getName() method. Also, there is an equivalent\n level of risk associated with granting code permission to insert a provider\n with a specific name, or any name it chooses. Users should use the\n \"insertProvider\" permission instead.\n This would allow somebody to introduce a possibly\n malicious provider (e.g., one that discloses the private keys passed\n to it) as the highest-priority provider. This would be possible\n because the Security object (which manages the installed providers)\n currently does not check the integrity or authenticity of a provider\n before attaching it.\n\n\nsetSystemScope\nSetting of the system identity scope\nThis would allow an attacker to configure the system identity scope with\n certificates that should not be trusted, thereby granting applet or\n application code signed with those certificates privileges that\n would have been denied by the system's original identity scope.\n\n\nsetIdentityPublicKey\nSetting of the public key for an Identity\nIf the identity is marked as \"trusted\", this allows an attacker to\n introduce a different public key (e.g., its own) that is not trusted\n by the system's identity scope, thereby granting applet or\n application code signed with that public key privileges that\n would have been denied otherwise.\n\n\nsetIdentityInfo\nSetting of a general information string for an Identity\nThis allows attackers to set the general description for\n an identity.  This may trick applications into using a different\n identity than intended or may prevent applications from finding a\n particular identity.\n\n\naddIdentityCertificate\nAddition of a certificate for an Identity\nThis allows attackers to set a certificate for\n an identity's public key.  This is dangerous because it affects\n the trust relationship across the system. This public key suddenly\n becomes trusted to a wider audience than it otherwise would be.\n\n\nremoveIdentityCertificate\nRemoval of a certificate for an Identity\nThis allows attackers to remove a certificate for\n an identity's public key. This is dangerous because it affects\n the trust relationship across the system. This public key suddenly\n becomes considered less trustworthy than it otherwise would be.\n\n\nprintIdentity\nViewing the name of a principal\n and optionally the scope in which it is used, and whether\n or not it is considered \"trusted\" in that scope\nThe scope that is printed out may be a filename, in which case\n it may convey local system information. For example, here's a sample\n printout of an identity named \"carol\", who is\n marked not trusted in the user's identity database:\n   carol[/home/luehe/identitydb.obj][not trusted]\n\n\ngetSignerPrivateKey\nRetrieval of a Signer's private key\nIt is very dangerous to allow access to a private key; private\n keys are supposed to be kept secret. Otherwise, code can use the\n private key to sign various files and claim the signature came from\n the Signer.\n\n\nsetSignerKeyPair\nSetting of the key pair (public key and private key) for a Signer\nThis would allow an attacker to replace somebody else's (the \"target's\")\n keypair with a possibly weaker keypair (e.g., a keypair of a smaller\n keysize).  This also would allow the attacker to listen in on encrypted\n communication between the target and its peers. The target's peers\n might wrap an encryption session key under the target's \"new\" public\n key, which would allow the attacker (who possesses the corresponding\n private key) to unwrap the session key and decipher the communication\n data encrypted under that session key.\n\n\n", "codes": ["public final class SecurityPermission\nextends BasicPermission"], "fields": [], "methods": []}