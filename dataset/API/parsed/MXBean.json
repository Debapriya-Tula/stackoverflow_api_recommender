{"name": "Annotation Type MXBean", "module": "java.management", "package": "javax.management", "text": "Annotation to mark an interface explicitly as being an MXBean\n    interface, or as not being an MXBean interface.  By default, an\n    interface is an MXBean interface if it is public and its name ends\n    with MXBean, as in SomethingMXBean.  The following\n    interfaces are MXBean interfaces:\n\n    public interface WhatsitMXBean {}\n\n    @MXBean\n    public interface Whatsit1Interface {}\n\n    @MXBean(true)\n    public interface Whatsit2Interface {}\n    \nThe following interfaces are not MXBean interfaces:\n\n    interface NonPublicInterfaceNotMXBean{}\n\n    public interface Whatsit3Interface{}\n\n    @MXBean(false)\n    public interface MisleadingMXBean {}\n    \nMXBean specification\nThe MXBean concept provides a simple way to code an MBean\n      that only references a predefined set of types, the ones defined\n      by javax.management.openmbean.  In this way, you can be\n      sure that your MBean will be usable by any client, including\n      remote clients, without any requirement that the client have\n      access to model-specific classes representing the types\n      of your MBeans.\nThe concepts are easier to understand by comparison with the\n      Standard MBean concept.  Here is how a managed object might be\n      represented as a Standard MBean, and as an MXBean:\n\nStandard MBean\n\npublic interface MemoryPoolMBean {\n    String getName();\n    MemoryUsage getUsage();\n    // ...\n}\n          \n\n\nMXBean\n\npublic interface MemoryPoolMXBean {\n    String getName();\n    MemoryUsage getUsage();\n    // ...\n}\n          \n\nAs you can see, the definitions are very similar.  The only\n      difference is that the convention for naming the interface is to use\n      SomethingMXBean for MXBeans, rather than\n      SomethingMBean for Standard MBeans.\nIn this managed object, there is an attribute called\n      Usage of type MemoryUsage.  The point of an\n      attribute like this is that it gives a coherent snapshot of a set\n      of data items.  For example, it might include the current amount\n      of used memory in the memory pool, and the current maximum of the\n      memory pool.  If these were separate items, obtained with separate\n      getAttribute calls, then we could\n      get values seen at different times that were not consistent.  We\n      might get a used value that was greater than the\n      max value.\nSo, we might define MemoryUsage like this:\n\nStandard MBean\n\npublic class MemoryUsage implements Serializable {\n    // standard JavaBean conventions with getters\n\n    public MemoryUsage(long init, long used,\n                       long committed, long max) {...}\n    long getInit() {...}\n    long getUsed() {...}\n    long getCommitted() {...}\n    long getMax() {...}\n}\n        \n\n\nMXBean\n\npublic class MemoryUsage {\n    // standard JavaBean conventions with getters\n    @ConstructorParameters({\"init\", \"used\", \"committed\", \"max\"})\n    public MemoryUsage(long init, long used,\n                       long committed, long max) {...}\n    long getInit() {...}\n    long getUsed() {...}\n    long getCommitted() {...}\n    long getMax() {...}\n}\n        \n\nThe definitions are the same in the two cases, except\n      that with the MXBean, MemoryUsage no longer needs to\n      be marked Serializable (though it can be).  On\n      the other hand, we have added a @ConstructorParameters\n      annotation to link the constructor parameters to the corresponding getters.\n      We will see more about this below.\nMemoryUsage is a model-specific class.\n      With Standard MBeans, a client of the MBean Server cannot access the\n      Usage attribute if it does not know the class\n      MemoryUsage.  Suppose the client is a generic console\n      based on JMX technology.  Then the console would have to be\n      configured with the model-specific classes of every application it\n      might connect to.  The problem is even worse for clients that are\n      not written in the Java language.  Then there may not be any way\n      to tell the client what a MemoryUsage looks like.\nThis is where MXBeans differ from Standard MBeans.  Although we\n      define the management interface in almost exactly the same way,\n      the MXBean framework converts model-specific classes into\n      standard classes from the Java platform.  Using arrays and the\n      CompositeData and\n      TabularData classes\n      from the standard javax.management.openmbean package, it\n      is possible to build data structures of arbitrary complexity\n      using only standard classes.\nThis becomes clearer if we compare what the clients of the two\n      models might look like:\n\nStandard MBean\n\nString name = (String)\n    mbeanServer.getAttribute(objectName, \"Name\");\nMemoryUsage usage = (MemoryUsage)\n    mbeanServer.getAttribute(objectName, \"Usage\");\nlong used = usage.getUsed();\n        \n\n\nMXBean\n\nString name = (String)\n    mbeanServer.getAttribute(objectName, \"Name\");\nCompositeData usage = (CompositeData)\n    mbeanServer.getAttribute(objectName, \"Usage\");\nlong used = (Long) usage.get(\"used\");\n        \n\nFor attributes with simple types like String, the\n      code is the same.  But for attributes with complex types, the\n      Standard MBean code requires the client to know the model-specific\n      class MemoryUsage, while the MXBean code requires no\n      non-standard classes.\nThe client code shown here is slightly more complicated for the\n      MXBean client.  But, if the client does in fact know the model,\n      here the interface MemoryPoolMXBean and the\n      class MemoryUsage, then it can construct a\n      proxy.  This is the recommended way to interact with\n      managed objects when you know the model beforehand, regardless\n      of whether you are using Standard MBeans or MXBeans:\n\nStandard MBean\n\nMemoryPoolMBean proxy =\n    JMX.newMBeanProxy(\n        mbeanServer,\n        objectName,\n        MemoryPoolMBean.class);\nString name = proxy.getName();\nMemoryUsage usage = proxy.getUsage();\nlong used = usage.getUsed();\n          \n\n\nMXBean\n\nMemoryPoolMXBean proxy =\n    JMX.newMXBeanProxy(\n        mbeanServer,\n        objectName,\n        MemoryPoolMXBean.class);\nString name = proxy.getName();\nMemoryUsage usage = proxy.getUsage();\nlong used = usage.getUsed();\n          \n\nImplementing the MemoryPool object works similarly for both\n      Standard MBeans and MXBeans.\n\nStandard MBean\n\npublic class MemoryPool\n        implements MemoryPoolMBean {\n    public String getName() {...}\n    public MemoryUsage getUsage() {...}\n    // ...\n}\n        \n\n\nMXBean\n\npublic class MemoryPool\n        implements MemoryPoolMXBean {\n    public String getName() {...}\n    public MemoryUsage getUsage() {...}\n    // ...\n}\n        \n\nRegistering the MBean in the MBean Server works in the same way\n      in both cases:\n\nStandard MBean\n\n{\n    MemoryPoolMBean pool = new MemoryPool();\n    mbeanServer.registerMBean(pool, objectName);\n}\n        \n\n\nMXBean\n\n{\n    MemoryPoolMXBean pool = new MemoryPool();\n    mbeanServer.registerMBean(pool, objectName);\n}\n        \n\nDefinition of an MXBean\nAn MXBean is a kind of MBean.  An MXBean object can be\n      registered directly in the MBean Server, or it can be used as an\n      argument to StandardMBean and the resultant MBean\n      registered in the MBean Server.\nWhen an object is registered in the MBean Server using the\n      registerMBean or createMBean methods of the\n      MBeanServer interface, the object's class is examined\n      to determine what type of MBean it is:\n\nIf the class implements the interface DynamicMBean\n        then the MBean is a Dynamic MBean.  Note that the class\n        StandardMBean implements this interface, so this\n        case applies to a Standard MBean or MXBean created using\n        the class StandardMBean.\nOtherwise, if the class matches the Standard MBean naming\n        conventions, then the MBean is a Standard MBean.\nOtherwise, it may be an MXBean.  The set of interfaces\n        implemented by the object is examined for interfaces that:\n\n        \nhave a class name SMXBean where\n            S is any non-empty string, and\n            do not have an annotation @MXBean(false); and/or\nhave an annotation @MXBean(true)\n            or just @MXBean.\n\n\n        If there is exactly one such interface, or if there is one\n        such interface that is a subinterface of all the others, then\n        the object is an MXBean.  The interface in question is the\n        MXBean interface.  In the example above, the MXBean\n        interface is MemoryPoolMXBean.\n\n      If none of these conditions is met, the MBean is invalid and\n        the attempt to register it will generate NotCompliantMBeanException.\n    \nEvery Java type that appears as the parameter or return type of a\n      method in an MXBean interface must be convertible using\n      the rules below.  Additionally, parameters must be\n      reconstructible as defined below.\nAn attempt to construct an MXBean that does not conform to the\n      above rules will produce an exception.\nNaming conventions\nThe same naming conventions are applied to the methods in an\n      MXBean as in a Standard MBean:\n\nA method T getN(), where\n        T is a Java type (not void)\n        and N is a non-empty string, specifies\n        that there is a readable attribute called\n        N.  The Java type and Open type of the\n        attribute are determined by the mapping rules below.\n        The method final Class getClass() inherited from \n        Object is ignored when looking for getters.\nA method boolean isN() specifies that\n        there is a readable attribute called N\n        with Java type boolean and Open type\n        SimpleType.Boolean.\nA method void setN(T x)\n        specifies that there is a writeable attribute called\n        N.  The Java type and Open type of the\n        attribute are determined by the mapping rules below.  (Of\n        course, the name x of the parameter is\n        irrelevant.)\nEvery other method specifies that there is an operation with\n        the same name as the method.  The Java type and Open type of the\n        return value and of each parameter are determined by the mapping\n        rules below.\n\nThe rules for getN and\n      isN collectively define the notion of a\n      getter.  The rule for setN defines\n      the notion of a setter.\nIt is an error for there to be two getters with the same name, or\n      two setters with the same name.  If there is a getter and a setter\n      for the same name, then the type T in both\n      must be the same.  In this case the attribute is read/write.  If\n      there is only a getter or only a setter, the attribute is\n      read-only or write-only respectively.\nType mapping rules\nAn MXBean is a kind of Open MBean, as defined by the javax.management.openmbean package.  This means that the types of\n      attributes, operation parameters, and operation return values must\n      all be describable using Open Types, that is the four\n      standard subclasses of OpenType.\n      MXBeans achieve this by mapping Java types into Open Types.\nFor every Java type J, the MXBean mapping is described\n      by the following information:\n\nThe corresponding Open Type, opentype(J).  This is\n        an instance of a subclass of OpenType.\nThe mapped Java type, opendata(J), which is\n        always the same for any given opentype(J).  This is a Java\n        class.\nHow a value is converted from type J to type\n        opendata(J).\nHow a value is converted from type opendata(J) to\n        type J, if it can be.\n\nFor example, for the Java type List<String>:\n\nThe Open Type, opentype(\n        List<String>), is ArrayType(1, SimpleType.STRING), representing a 1-dimensional\n          array of Strings.\nThe mapped Java type, opendata(\n        List<String>), is String[].\nA List<String> can be converted to a String[]\n          using List.toArray(new\n          String[0]).\nA String[] can be converted to a List<String>\n          using Arrays.asList.\n\nIf no mapping rules exist to derive opentype(J) from\n      J, then J cannot be the type of a method\n      parameter or return value in an MXBean interface.\nIf there is a way to convert\n      opendata(J) back to J then we say that J is\n      reconstructible.  All method parameters in an MXBean\n      interface must be reconstructible, because when the MXBean\n      framework is invoking a method it will need to convert those\n      parameters from opendata(J) to J.  In a proxy\n      generated by JMX.newMXBeanProxy, it is the return values\n      of the methods in the MXBean interface that must be\n      reconstructible.\nNull values are allowed for all Java types and Open Types,\n      except primitive Java types where they are not possible.  When\n      converting from type J to type opendata(J) or\n      from type opendata(J) to type J, a null value is\n      mapped to a null value.\nThe following table summarizes the type mapping rules.\n\nType Mapping Rules\n\n\nJava type J\nopentype(J)\nopendata(J)\n\n\n\n\nint, boolean, etc\n            (the 8 primitive Java types)\nSimpleType.INTEGER,\nSimpleType.BOOLEAN, etc\nInteger, Boolean, etc\n            (the corresponding boxed types)\n\n\nInteger, ObjectName, etc\n            (the types covered by SimpleType)\nthe corresponding SimpleType\nJ, the same type\n\n\nint[] etc\n            (a one-dimensional array with primitive element type)\nArrayType.getPrimitiveArrayType(int[].class) etc\nJ, the same type\n\nE[]\n            (an array with non-primitive element type E;\n              this includes int[][], where E is int[])\nArrayType.getArrayType(opentype(E))\nopendata(E)[]\n\n\nList<E>\nSet<E>\nSortedSet<E> (see below)\nsame as for E[]\nsame as for E[]\n\n\nAn enumeration E\n            (declared in Java as enum E\n{...})\nSimpleType.STRING\nString\n\n\nMap<K,V>\nSortedMap<K,V>\nTabularType\n            (see below)\nTabularData\n            (see below)\n\n\nAn MXBean interface\nSimpleType.OBJECTNAME\n            (see below)\nObjectName\n            (see below)\n\n\nAny other type\nCompositeType,\n            if possible\n            (see below)\nCompositeData\n\n\nThe following sections give further details of these rules.\nMappings for primitive types\nThe 8 primitive Java types\n      (boolean, byte, short, int, \n      long, float, double, char) are mapped to the\n      corresponding boxed types from java.lang, namely \n      Boolean, Byte, etc.  The Open Type is the corresponding\n      SimpleType.  Thus, opentype(\n      long) is SimpleType.LONG, and\n      opendata(long) is \n      java.lang.Long.\nAn array of primitive type such as long[] can be represented\n      directly as an Open Type.  Thus, openType(\n      long[]) is \n      ArrayType.getPrimitiveArrayType(long[].class), and\n      opendata(long[]) is \n      long[].\nIn practice, the difference between a plain int and \n      Integer, etc, does not show up because operations in the JMX API\n      are always on Java objects, not primitives.  However, the\n      difference does show up with arrays.\nMappings for collections (List<E> etc)\nA List<E> or \n      Set<E>, such as List<String> or \n        Set<ObjectName>, is mapped in the same way as an array of the\n          same element type, such as String[] or \n          ObjectName[].\nA SortedSet<E> is also mapped in the\n      same way as an E[], but it is only convertible if\n      E is a class or interface that implements Comparable.  Thus, a SortedSet<String> or\n        SortedSet<Integer> is convertible, but a \n          SortedSet<int[]> or SortedSet<List<String>> is not.  The\n                conversion of a SortedSet instance will fail with an\n                IllegalArgumentException if it has a\n                non-null comparator().\nA List<E> is reconstructed as a\n      java.util.ArrayList<E>;\n      a Set<E> as a\n      java.util.HashSet<E>;\n      a SortedSet<E> as a\n      java.util.TreeSet<E>.\nMappings for maps (Map<K,V> etc)\nA Map<K,V> or \n      SortedMap<K,V>, for example \n      Map<String,ObjectName>, has Open Type TabularType and is mapped\n        to a TabularData.\n        The TabularType has two items called key and\n        value.  The Open Type of key is\n        opentype(K), and the Open Type of value is\n        opentype(V).  The index of the TabularType is the\n        single item key.\nFor example, the TabularType for a \n      Map<String,ObjectName> might be constructed with code like\n        this:\n\nString typeName =\n    \"java.util.Map<java.lang.String, javax.management.ObjectName>\";\nString[] keyValue =\n    new String[] {\"key\", \"value\"};\nOpenType[] openTypes =\n    new OpenType[] {SimpleType.STRING, SimpleType.OBJECTNAME};\nCompositeType rowType =\n    new CompositeType(typeName, typeName, keyValue, keyValue, openTypes);\nTabularType tabularType =\n    new TabularType(typeName, typeName, rowType, new String[] {\"key\"});\n    \nThe typeName here is determined by the \n      type name rules detailed below.\n\n    A SortedMap<K,V> is mapped in the\n      same way, but it is only convertible if\n      K is a class or interface that implements Comparable.  Thus, a SortedMap<String,int[]>\n        is convertible, but a\n        SortedMap<int[],String> is not.  The conversion of a\n          SortedMap instance will fail with an \n          IllegalArgumentException if it has a non-null comparator().\nA Map<K,V> is reconstructed as\n      a java.util.HashMap<K,V>;\n      a SortedMap<K,V> as\n      a java.util.TreeMap<K,V>.\nTabularData is an interface.  The concrete class that is\n      used to represent a Map<K,V> as\n      Open Data is TabularDataSupport,\n      or another class implementing \n      TabularData that serializes as TabularDataSupport.\nMappings for MXBean interfaces\nAn MXBean interface, or a type referenced within an MXBean\n      interface, can reference another MXBean interface, J.\n      Then opentype(J) is SimpleType.OBJECTNAME and\n      opendata(J) is ObjectName.\nFor example, suppose you have two MXBean interfaces like this:\n\npublic interface ProductMXBean {\n    public ModuleMXBean[] getModules();\n}\n\npublic interface ModuleMXBean {\n    public ProductMXBean getProduct();\n}\n    \nThe object implementing the ModuleMXBean interface\n      returns from its getProduct method an object\n      implementing the ProductMXBean interface.  The\n      ModuleMXBean object and the returned \n      ProductMXBean objects must both be registered as MXBeans in the\n      same MBean Server.\nThe method ModuleMXBean.getProduct() defines an\n      attribute called Product.  The Open Type for this\n      attribute is SimpleType.OBJECTNAME, and the corresponding\n      ObjectName value will be the name under which the\n      referenced ProductMXBean is registered in the MBean\n      Server.\nIf you make an MXBean proxy for a ModuleMXBean and\n      call its getProduct() method, the proxy will map the\n      ObjectName back into a ProductMXBean by making\n      another MXBean proxy.  More formally, when a proxy made with\n      JMX.newMXBeanProxy(mbeanServerConnection, objectNameX,\n      interfaceX) needs to map objectNameY back into \n      interfaceY, another MXBean interface, it does so with \n      JMX.newMXBeanProxy(mbeanServerConnection, objectNameY,\n      interfaceY).  The implementation may return a proxy that was\n      previously created by a call to JMX.newMXBeanProxy\n      with the same parameters, or it may create a new proxy.\nThe reverse mapping is illustrated by the following change to the\n      ModuleMXBean interface:\n\npublic interface ModuleMXBean {\n    public ProductMXBean getProduct();\n    public void setProduct(ProductMXBean c);\n}\n    \nThe presence of the setProduct method now means that the\n      Product attribute is read/write.  As before, the value\n      of this attribute is an ObjectName.  When the attribute is\n      set, the ObjectName must be converted into the\n      ProductMXBean object that the setProduct method\n      expects.  This object will be an MXBean proxy for the given\n      ObjectName in the same MBean Server.\nIf you make an MXBean proxy for a ModuleMXBean and\n      call its setProduct method, the proxy will map its\n      ProductMXBean argument back into an ObjectName.\n      This will only work if the argument is in fact another proxy,\n      for a ProductMXBean in the same \n      MBeanServerConnection.  The proxy can have been returned from\n      another proxy (like ModuleMXBean.getProduct() which\n      returns a proxy for a ProductMXBean); or it can have\n      been created by JMX.newMXBeanProxy; or it can have been created using Proxy with an invocation handler that\n      is MBeanServerInvocationHandler or a subclass.\nIf the same MXBean were registered under two different\n      ObjectNames, a reference to that MXBean from another\n      MXBean would be ambiguous.  Therefore, if an MXBean object is\n      already registered in an MBean Server and an attempt is made to\n      register it in the same MBean Server under another name, the\n      result is an InstanceAlreadyExistsException.  Registering\n      the same MBean object under more than one name is discouraged in\n      general, notably because it does not work well for MBeans that are\n      NotificationBroadcasters.\nMappings for other types\nGiven a Java class or interface J that does not match the other\n      rules in the table above, the MXBean framework will attempt to map\n      it to a CompositeType as follows.  The type name of this\n      CompositeType is determined by the \n      type name rules below.\nThe class is examined for getters using the conventions\n      above.  (Getters must be public\n      instance methods.)  If there are no getters, or if\n      any getter has a type that is not convertible, then J is\n      not convertible.\nIf there is at least one getter and every getter has a\n      convertible type, then opentype(J) is a \n      CompositeType with one item for every getter.  If the getter is\n\n    \nT getName()\n\n\n    then the item in the CompositeType is called name\n    and has type opentype(T).  For example, if the item is\n\n    \nString getOwner()\n\n\n    then the item is called owner and has Open Type \n    SimpleType.STRING.  If the getter is\n\n    \nboolean isName()\n\n\n    then the item in the CompositeType is called name\n    and has type SimpleType.BOOLEAN.\n\n    Notice that the first character (or code point) is converted to\n      lower case.  This follows the Java Beans convention, which for\n      historical reasons is different from the Standard MBean\n      convention.  In a Standard MBean or MXBean interface, a method\n      getOwner defines an attribute called Owner, while\n      in a Java Bean or mapped CompositeType, a method \n      getOwner defines a property or item called owner.\nIf two methods produce the same item name (for example, \n      getOwner and isOwner, or getOwner and \n      getowner) then the type is not convertible.\nWhen the Open Type is CompositeType, the corresponding\n      mapped Java type (opendata(J)) is CompositeData.  The mapping from an instance of J to a\n      CompositeData corresponding to the CompositeType\n      just described is done as follows.  First, if J\n      implements the interface CompositeDataView, then that\n      interface's toCompositeData method is called to do the conversion.\n      Otherwise, the CompositeData is constructed by calling\n      the getter for each item and converting it to the corresponding\n      Open Data type.  Thus, a getter such as\n\nList<String> getNames()\n\nwill have been mapped to an item with name \"names\" and\n      Open Type ArrayType(1, SimpleType.STRING).  The conversion\n      to CompositeData will call getNames() and convert\n      the resultant List<String> into a String[] for the\n        item \"names\".\nCompositeData is an interface.  The concrete class that is\n      used to represent a type as Open Data is CompositeDataSupport, or another class implementing \n      CompositeData that serializes as \n      CompositeDataSupport.\nReconstructing an instance of Java type J from\n      a CompositeData\nIf opendata(J) is CompositeData for a Java type\n      J, then either an instance of J can be\n      reconstructed from a CompositeData, or J is not\n      reconstructible.  If any item in the CompositeData is not\n      reconstructible, then J is not reconstructible either.\nFor any given J, the following rules are consulted to\n      determine how to reconstruct instances of J from\n      CompositeData.  The first applicable rule in the list is\n      the one that will be used.\n\nIf J has a method\npublic static J from(CompositeData cd)\n        then that method is called to reconstruct an instance of\n        J.\nOtherwise, if J has at least one public\n        constructor with either @javax.management.ConstructorParameters or\n        @java.beans.ConstructoProperties annotation, then one of those\n        constructors (not necessarily always the same one) will be called to\n        reconstruct an instance of J.\n        If a constructor is annotated with both\n        @javax.management.ConstructorParameters and\n        @java.beans.ConstructorProperties,\n        @javax.management.ConstructorParameters will be used and\n        @java.beans.ConstructorProperties will be ignored.\n        Every such annotation must list as many strings as the\n        constructor has parameters; each string must name a property\n        corresponding to a getter of J; and the type of this\n        getter must be the same as the corresponding constructor\n        parameter.  It is not an error for there to be getters that\n        are not mentioned in the @ConstructorParameters or\n        @ConstructorProperties annotations (these may correspond to\n        information that is not needed to reconstruct the object).\nAn instance of J is reconstructed by calling a\n        constructor with the appropriate reconstructed items from the\n        CompositeData.  The constructor to be called will be\n        determined at runtime based on the items actually present in\n        the CompositeData, given that this \n        CompositeData might come from an earlier version of\n        J where not all the items were present.  A\n        constructor is applicable if all the properties named\n        in its @ConstructorParameters or @ConstructorProperties\n        annotation are present as items in the CompositeData.\n        If no constructor is applicable, then the attempt to reconstruct\n        J fails.\nFor any possible combination of properties, it must be the\n        case that either (a) there are no applicable constructors, or\n        (b) there is exactly one applicable constructor, or (c) one of\n        the applicable constructors names a proper superset of the\n        properties named by each other applicable constructor.  (In\n        other words, there should never be ambiguity over which\n        constructor to choose.)  If this condition is not true, then\n        J is not reconstructible.\nOtherwise, if J has a public no-arg constructor, and\n        for every getter in J with type\n        T and name N there is a corresponding setter\n        with the same name and type, then an instance of J is\n        constructed with the no-arg constructor and the setters are\n        called with the reconstructed items from the CompositeData\n        to restore the values.  For example, if there is a method\npublic List<String> getNames()\n          then there must also be a method\npublic void setNames(List<String> names)\n            for this rule to apply.\nIf the CompositeData came from an earlier version of\n        J, some items might not be present.  In this case,\n        the corresponding setters will not be called.\nOtherwise, if J is an interface that has no methods\n        other than getters, an instance of J is constructed\n        using a Proxy with a CompositeDataInvocationHandler backed by the \n        CompositeData being converted.\nOtherwise, J is not reconstructible.\n\nRule 2 is not applicable when java.beans.ConstructorProperties\n    is not visible (e.g. when the java.desktop module is not readable or when\n    the runtime image does not contain the java.desktop module). When\n    targeting a runtime that does not include the java.beans package,\n    and where there is a mismatch between the compile-time and runtime\n    environment whereby J is compiled with a public constructor\n    and the ConstructorProperties annotation, then J is\n    not reconstructible unless another rule applies.\nHere are examples showing different ways to code a type \n      NamedNumber that consists of an int and a \n      String.  In each case, the CompositeType looks like this:\n\n\nCompositeType(\n    \"NamedNumber\",                      // typeName\n    \"NamedNumber\",                      // description\n    new String[] {\"number\", \"name\"},    // itemNames\n    new String[] {\"number\", \"name\"},    // itemDescriptions\n    new OpenType[] {SimpleType.INTEGER,\n                    SimpleType.STRING}  // itemTypes\n);\n      \n\n\nStatic from method:\n\n        \n\npublic class NamedNumber {\n    public int getNumber() {return number;}\n    public String getName() {return name;}\n    private NamedNumber(int number, String name) {\n        this.number = number;\n        this.name = name;\n    }\n    public static NamedNumber from(CompositeData cd) {\n        return new NamedNumber((Integer) cd.get(\"number\"),\n                               (String) cd.get(\"name\"));\n    }\n    private final int number;\n    private final String name;\n}\n          \n\n\nPublic constructor with @ConstructorParameters annotation:\n\n        \n\npublic class NamedNumber {\n    public int getNumber() {return number;}\n    public String getName() {return name;}\n    @ConstructorParameters({\"number\", \"name\"})\n    public NamedNumber(int number, String name) {\n        this.number = number;\n        this.name = name;\n    }\n    private final int number;\n    private final String name;\n}\n          \n\n\nSetter for every getter:\n\n        \n\npublic class NamedNumber {\n    public int getNumber() {return number;}\n    public void setNumber(int number) {this.number = number;}\n    public String getName() {return name;}\n    public void setName(String name) {this.name = name;}\n    public NamedNumber() {}\n    private int number;\n    private String name;\n}\n          \n\n\nInterface with only getters:\n\n        \n\npublic interface NamedNumber {\n    public int getNumber();\n    public String getName();\n}\n          \n\n\n\nIt is usually better for classes that simply represent a\n      collection of data to be immutable.  An instance of an\n      immutable class cannot be changed after it has been constructed.\n      Notice that CompositeData itself is immutable.\n      Immutability has many advantages, notably with regard to\n      thread-safety and security.  So the approach using setters should\n      generally be avoided if possible.\nRecursive types\nRecursive (self-referential) types cannot be used in MXBean\n      interfaces.  This is a consequence of the immutability of CompositeType.  For example, the following type could not be the\n      type of an attribute, because it refers to itself:\n\npublic interface Node {\n    public String getName();\n    public int getPriority();\n    public Node getNext();\n}\n\nIt is always possible to rewrite recursive types like this so\n      they are no longer recursive.  Doing so may require introducing\n      new types.  For example:\n\npublic interface NodeList {\n    public List<Node> getNodes();\n}\n\npublic interface Node {\n    public String getName();\n    public int getPriority();\n}\n\nMBeanInfo contents for an MXBean\nAn MXBean is a type of Open MBean.  However, for compatibility\n      reasons, its MBeanInfo is not an OpenMBeanInfo.\n      In particular, when the type of an attribute, parameter, or\n      operation return value is a primitive type such as int,\n      or is void (for a return type), then the attribute,\n      parameter, or operation will be represented respectively by an\n      MBeanAttributeInfo, MBeanParameterInfo, or\n      MBeanOperationInfo whose getType() or \n      getReturnType() returns the primitive name (\"int\" etc).\n      This is so even though the mapping rules above specify that the\n      opendata mapping is the wrapped type (Integer\n      etc).\nThe array of public constructors returned by MBeanInfo.getConstructors() for an MXBean that is directly\n      registered in the MBean Server will contain all of the public\n      constructors of that MXBean.  If the class of the MXBean is not\n      public then its constructors are not considered public either.\n      The list returned for an MXBean that is constructed using the\n      StandardMBean class is derived in the same way as for\n      Standard MBeans.  Regardless of how the MXBean was constructed,\n      its constructor parameters are not subject to MXBean mapping\n      rules and do not have a corresponding OpenType.\nThe array of notification types returned by MBeanInfo.getNotifications() for an MXBean that is directly\n      registered in the MBean Server will be empty if the MXBean does\n      not implement the NotificationBroadcaster interface.\n      Otherwise, it will be the result of calling NotificationBroadcaster.getNotificationInfo() at the time the MXBean\n      was registered.  Even if the result of this method changes\n      subsequently, the result of MBeanInfo.getNotifications()\n      will not.  The list returned for an MXBean that is constructed\n      using the StandardMBean or StandardEmitterMBean\n      class is derived in the same way as for Standard MBeans.\nThe Descriptor for all of the\n      MBeanAttributeInfo, MBeanParameterInfo, and\n      MBeanOperationInfo objects contained in the MBeanInfo\n      will have a field openType whose value is the OpenType\n      specified by the mapping rules above.  So even when getType()\n      is \"int\", getDescriptor().getField(\"openType\") will\n      be SimpleType.INTEGER.\nThe Descriptor for each of these objects will also have a\n      field originalType that is a string representing the Java type\n      that appeared in the MXBean interface.  The format of this string\n      is described in the section Type Names\n      below.\nThe Descriptor for the MBeanInfo will have a field\n      mxbean whose value is the string \"true\".\nType Names\nSometimes the unmapped type T of a method parameter or\n    return value in an MXBean must be represented as a string.  If\n    T is a non-generic type, this string is the value\n    returned by Class.getName().  Otherwise it is the value of\n    genericstring(T), defined as follows:\n\n    \nIf T is a non-generic non-array type,\n      genericstring(T) is the value returned by Class.getName(), for example \"int\" or \n      \"java.lang.String\".\n\n      If T is an array E[],\n      genericstring(T) is genericstring(E) followed\n      by \"[]\".  For example, genericstring(int[])\n      is \"int[]\", and genericstring(\n      List<String>[][]) is \n      \"java.util.List<java.lang.String>[][]\".\n\n    Otherwise, T is a parameterized type such as \n    List<String> and genericstring(T) consists of the\n    following: the fully-qualified name of the parameterized type as\n    returned by Class.getName(); a left angle bracket (\n    \"<\"); genericstring(A) where A is the first\n    type parameter; if there is a second type parameter B\n    then \", \" (a comma and a single space) followed by\n    genericstring(B); a right angle bracket (\">\").\n\n    \nNote that if a method returns int[], this will be\n      represented by the string \"[I\" returned by \n      Class.getName(), but if a method returns List<int[]>,\n      this will be represented by the string \n      \"java.util.List<int[]>\".\n\n    Exceptions\nA problem with mapping from Java types to\n      Open types is signaled with an OpenDataException.  This\n      can happen when an MXBean interface is being analyzed, for\n      example if it references a type like java.util.Random that has no getters.  Or it can happen when an\n      instance is being converted (a return value from a method in an\n      MXBean or a parameter to a method in an MXBean proxy), for\n      example when converting from SortedSet<String> to \n      String[] if the SortedSet has a non-null \n      Comparator.\nA problem with mapping to Java types from\n      Open types is signaled with an InvalidObjectException.\n      This can happen when an MXBean interface is being analyzed, for\n      example if it references a type that is not\n      reconstructible according to the rules above, in a\n      context where a reconstructible type is required.  Or it can\n      happen when an instance is being converted (a parameter to a\n      method in an MXBean or a return value from a method in an MXBean\n      proxy), for example from a String to an Enum if there is no Enum\n      constant with that name.\nDepending on the context, the OpenDataException or\n      InvalidObjectException may be wrapped in another\n      exception such as RuntimeMBeanException or UndeclaredThrowableException.  For every thrown exception,\n      the condition C will be true: \"e is \n      OpenDataException or InvalidObjectException (as\n      appropriate), or C is true of e.getCause()\".", "codes": ["@Documented\n@Retention(RUNTIME)\n@Target(TYPE)\npublic @interface MXBean"], "fields": [], "methods": []}