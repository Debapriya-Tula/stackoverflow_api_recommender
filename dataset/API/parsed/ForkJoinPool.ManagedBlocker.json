{"name": "Interface ForkJoinPool.ManagedBlocker", "module": "java.base", "package": "java.util.concurrent", "text": "Interface for extending managed parallelism for tasks running\n in ForkJoinPools.\n\n A ManagedBlocker provides two methods.  Method\n isReleasable() must return true if blocking is\n not necessary. Method block() blocks the current thread\n if necessary (perhaps internally invoking isReleasable\n before actually blocking). These actions are performed by any\n thread invoking ForkJoinPool.managedBlock(ManagedBlocker).\n The unusual methods in this API accommodate synchronizers that\n may, but don't usually, block for long periods. Similarly, they\n allow more efficient internal handling of cases in which\n additional workers may be, but usually are not, needed to\n ensure sufficient parallelism.  Toward this end,\n implementations of method isReleasable must be amenable\n to repeated invocation.\n\n For example, here is a ManagedBlocker based on a\n ReentrantLock:\n  \n class ManagedLocker implements ManagedBlocker {\n   final ReentrantLock lock;\n   boolean hasLock = false;\n   ManagedLocker(ReentrantLock lock) { this.lock = lock; }\n   public boolean block() {\n     if (!hasLock)\n       lock.lock();\n     return true;\n   }\n   public boolean isReleasable() {\n     return hasLock || (hasLock = lock.tryLock());\n   }\n }\nHere is a class that possibly blocks waiting for an\n item on a given queue:\n  \n class QueueTaker<E> implements ManagedBlocker {\n   final BlockingQueue<E> queue;\n   volatile E item = null;\n   QueueTaker(BlockingQueue<E> q) { this.queue = q; }\n   public boolean block() throws InterruptedException {\n     if (item == null)\n       item = queue.take();\n     return true;\n   }\n   public boolean isReleasable() {\n     return item != null || (item = queue.poll()) != null;\n   }\n   public E getItem() { // call after pool.managedBlock completes\n     return item;\n   }\n }", "codes": ["public static interface ForkJoinPool.ManagedBlocker"], "fields": [], "methods": [{"method_name": "block", "method_sig": "boolean block()\n       throws InterruptedException", "description": "Possibly blocks the current thread, for example waiting for\n a lock or condition."}, {"method_name": "isReleasable", "method_sig": "boolean isReleasable()", "description": "Returns true if blocking is unnecessary."}]}