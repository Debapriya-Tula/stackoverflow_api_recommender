{"name": "Class AccessController", "module": "java.base", "package": "java.security", "text": " The AccessController class is used for access control operations\n and decisions.\n\n  More specifically, the AccessController class is used for\n three purposes:\n\n \n to decide whether an access to a critical system\n resource is to be allowed or denied, based on the security policy\n currently in effect,\n to mark code as being \"privileged\", thus affecting subsequent\n access determinations, and\n to obtain a \"snapshot\" of the current calling context so\n access-control decisions from a different context can be made with\n respect to the saved context. \n The checkPermission method\n determines whether the access request indicated by a specified\n permission should be granted or denied. A sample call appears\n below. In this example, checkPermission will determine\n whether or not to grant \"read\" access to the file named \"testFile\" in\n the \"/temp\" directory.\n\n \n\n FilePermission perm = new FilePermission(\"/temp/testFile\", \"read\");\n AccessController.checkPermission(perm);\n\n \n If a requested access is allowed,\n checkPermission returns quietly. If denied, an\n AccessControlException is\n thrown. AccessControlException can also be thrown if the requested\n permission is of an incorrect type or contains an invalid value.\n Such information is given whenever possible.\n\n Suppose the current thread traversed m callers, in the order of caller 1\n to caller 2 to caller m. Then caller m invoked the\n checkPermission method.\n The checkPermission method determines whether access\n is granted or denied based on the following algorithm:\n\n   \n for (int i = m; i > 0; i--) {\n\n     if (caller i's domain does not have the permission)\n         throw AccessControlException\n\n     else if (caller i is marked as privileged) {\n         if (a context was specified in the call to doPrivileged)\n             context.checkPermission(permission)\n         if (limited permissions were specified in the call to doPrivileged) {\n             for (each limited permission) {\n                 if (the limited permission implies the requested permission)\n                     return;\n             }\n         } else\n             return;\n     }\n }\n\n // Next, check the context inherited when the thread was created.\n // Whenever a new thread is created, the AccessControlContext at\n // that time is stored and associated with the new thread, as the\n // \"inherited\" context.\n\n inheritedContext.checkPermission(permission);\n \n A caller can be marked as being \"privileged\"\n (see doPrivileged and below).\n When making access control decisions, the checkPermission\n method stops checking if it reaches a caller that\n was marked as \"privileged\" via a doPrivileged\n call without a context argument (see below for information about a\n context argument). If that caller's domain has the\n specified permission and at least one limiting permission argument (if any)\n implies the requested permission, no further checking is done and\n checkPermission\n returns quietly, indicating that the requested access is allowed.\n If that domain does not have the specified permission, an exception\n is thrown, as usual. If the caller's domain had the specified permission\n but it was not implied by any limiting permission arguments given in the call\n to doPrivileged then the permission checking continues\n until there are no more callers or another doPrivileged\n call matches the requested permission and returns normally.\n\n  The normal use of the \"privileged\" feature is as follows. If you\n don't need to return a value from within the \"privileged\" block, do\n the following:\n\n   \n somemethod() {\n     ...normal code here...\n     AccessController.doPrivileged(new PrivilegedAction<Void>() {\n         public Void run() {\n             // privileged code goes here, for example:\n             System.loadLibrary(\"awt\");\n             return null; // nothing to return\n         }\n     });\n     ...normal code here...\n }\n\n PrivilegedAction is an interface with a single method, named\n run.\n The above example shows creation of an implementation\n of that interface; a concrete implementation of the\n run method is supplied.\n When the call to doPrivileged is made, an\n instance of the PrivilegedAction implementation is passed\n to it. The doPrivileged method calls the\n run method from the PrivilegedAction\n implementation after enabling privileges, and returns the\n run method's return value as the\n doPrivileged return value (which is\n ignored in this example).\n\n  If you need to return a value, you can do something like the following:\n\n   \n somemethod() {\n     ...normal code here...\n     String user = AccessController.doPrivileged(\n         new PrivilegedAction<String>() {\n         public String run() {\n             return System.getProperty(\"user.name\");\n             }\n         });\n     ...normal code here...\n }\nIf the action performed in your run method could\n throw a \"checked\" exception (those listed in the throws clause\n of a method), then you need to use the\n PrivilegedExceptionAction interface instead of the\n PrivilegedAction interface:\n\n   \n somemethod() throws FileNotFoundException {\n     ...normal code here...\n     try {\n         FileInputStream fis = AccessController.doPrivileged(\n         new PrivilegedExceptionAction<FileInputStream>() {\n             public FileInputStream run() throws FileNotFoundException {\n                 return new FileInputStream(\"someFile\");\n             }\n         });\n     } catch (PrivilegedActionException e) {\n         // e.getException() should be an instance of FileNotFoundException,\n         // as only \"checked\" exceptions will be \"wrapped\" in a\n         // PrivilegedActionException.\n         throw (FileNotFoundException) e.getException();\n     }\n     ...normal code here...\n  }\n Be *very* careful in your use of the \"privileged\" construct, and\n always remember to make the privileged code section as small as possible.\n You can pass Permission arguments to further limit the\n scope of the \"privilege\" (see below).\n\n\n  Note that checkPermission always performs security checks\n within the context of the currently executing thread.\n Sometimes a security check that should be made within a given context\n will actually need to be done from within a\n different context (for example, from within a worker thread).\n The getContext method and\n AccessControlContext class are provided\n for this situation. The getContext method takes a \"snapshot\"\n of the current calling context, and places\n it in an AccessControlContext object, which it returns. A sample call is\n the following:\n\n \n\n AccessControlContext acc = AccessController.getContext()\n\n \n\n AccessControlContext itself has a checkPermission method\n that makes access decisions based on the context it encapsulates,\n rather than that of the current execution thread.\n Code within a different context can thus call that method on the\n previously-saved AccessControlContext object. A sample call is the\n following:\n\n \n\n acc.checkPermission(permission)\n\n \n There are also times where you don't know a priori which permissions\n to check the context against. In these cases you can use the\n doPrivileged method that takes a context. You can also limit the scope\n of the privileged code by passing additional Permission\n parameters.\n\n   \n somemethod() {\n     AccessController.doPrivileged(new PrivilegedAction<Object>() {\n         public Object run() {\n             // Code goes here. Any permission checks within this\n             // run method will require that the intersection of the\n             // caller's protection domain and the snapshot's\n             // context have the desired permission. If a requested\n             // permission is not implied by the limiting FilePermission\n             // argument then checking of the thread continues beyond the\n             // caller of doPrivileged.\n         }\n     }, acc, new FilePermission(\"/temp/*\", read));\n     ...normal code here...\n }\n Passing a limiting Permission argument of an instance of\n AllPermission is equivalent to calling the equivalent\n doPrivileged method without limiting Permission\n arguments. Passing a zero length array of Permission disables\n the code privileges so that checking always continues beyond the caller of\n that doPrivileged method.", "codes": ["public final class AccessController\nextends Object"], "fields": [], "methods": [{"method_name": "doPrivileged", "method_sig": "public static <T> T doPrivileged (PrivilegedAction<T> action)", "description": "Performs the specified PrivilegedAction with privileges\n enabled. The action is performed with all of the permissions\n possessed by the caller's protection domain.\n\n  If the action's run method throws an (unchecked)\n exception, it will propagate through this method.\n\n  Note that any DomainCombiner associated with the current\n AccessControlContext will be ignored while the action is performed."}, {"method_name": "doPrivilegedWithCombiner", "method_sig": "public static <T> T doPrivilegedWithCombiner (PrivilegedAction<T> action)", "description": "Performs the specified PrivilegedAction with privileges\n enabled. The action is performed with all of the permissions\n possessed by the caller's protection domain.\n\n  If the action's run method throws an (unchecked)\n exception, it will propagate through this method.\n\n  This method preserves the current AccessControlContext's\n DomainCombiner (which may be null) while the action is performed."}, {"method_name": "doPrivileged", "method_sig": "public static <T> T doPrivileged (PrivilegedAction<T> action,\n                                 AccessControlContext context)", "description": "Performs the specified PrivilegedAction with privileges\n enabled and restricted by the specified AccessControlContext.\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions."}, {"method_name": "doPrivileged", "method_sig": "public static <T> T doPrivileged (PrivilegedAction<T> action,\n                                 AccessControlContext context,\n                                 Permission... perms)", "description": "Performs the specified PrivilegedAction with privileges\n enabled and restricted by the specified\n AccessControlContext and with a privilege scope limited\n by specified Permission arguments.\n\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified\n AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions."}, {"method_name": "doPrivilegedWithCombiner", "method_sig": "public static <T> T doPrivilegedWithCombiner (PrivilegedAction<T> action,\n                                             AccessControlContext context,\n                                             Permission... perms)", "description": "Performs the specified PrivilegedAction with privileges\n enabled and restricted by the specified\n AccessControlContext and with a privilege scope limited\n by specified Permission arguments.\n\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified\n AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n\n  This method preserves the current AccessControlContext's\n DomainCombiner (which may be null) while the action is performed.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions."}, {"method_name": "doPrivileged", "method_sig": "public static <T> T doPrivileged (PrivilegedExceptionAction<T> action)\n                          throws PrivilegedActionException", "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled.  The action is performed with all of the\n permissions possessed by the caller's protection domain.\n\n  If the action's run method throws an unchecked\n exception, it will propagate through this method.\n\n  Note that any DomainCombiner associated with the current\n AccessControlContext will be ignored while the action is performed."}, {"method_name": "doPrivilegedWithCombiner", "method_sig": "public static <T> T doPrivilegedWithCombiner (PrivilegedExceptionAction<T> action)\n                                      throws PrivilegedActionException", "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled.  The action is performed with all of the\n permissions possessed by the caller's protection domain.\n\n  If the action's run method throws an unchecked\n exception, it will propagate through this method.\n\n  This method preserves the current AccessControlContext's\n DomainCombiner (which may be null) while the action is performed."}, {"method_name": "doPrivileged", "method_sig": "public static <T> T doPrivileged (PrivilegedExceptionAction<T> action,\n                                 AccessControlContext context)\n                          throws PrivilegedActionException", "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled and restricted by the specified\n AccessControlContext.  The action is performed with the\n intersection of the permissions possessed by the caller's\n protection domain, and those possessed by the domains represented by the\n specified AccessControlContext.\n \n If the action's run method throws an unchecked\n exception, it will propagate through this method.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions."}, {"method_name": "doPrivileged", "method_sig": "public static <T> T doPrivileged (PrivilegedExceptionAction<T> action,\n                                 AccessControlContext context,\n                                 Permission... perms)\n                          throws PrivilegedActionException", "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled and restricted by the specified\n AccessControlContext and with a privilege scope limited by\n specified Permission arguments.\n\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified\n AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions."}, {"method_name": "doPrivilegedWithCombiner", "method_sig": "public static <T> T doPrivilegedWithCombiner (PrivilegedExceptionAction<T> action,\n                                             AccessControlContext context,\n                                             Permission... perms)\n                                      throws PrivilegedActionException", "description": "Performs the specified PrivilegedExceptionAction with\n privileges enabled and restricted by the specified\n AccessControlContext and with a privilege scope limited by\n specified Permission arguments.\n\n The action is performed with the intersection of the permissions\n possessed by the caller's protection domain, and those possessed\n by the domains represented by the specified\n AccessControlContext.\n \n If the action's run method throws an (unchecked) exception,\n it will propagate through this method.\n\n  This method preserves the current AccessControlContext's\n DomainCombiner (which may be null) while the action is performed.\n \n If a security manager is installed and the specified\n AccessControlContext was not created by system code and the\n caller's ProtectionDomain has not been granted the\n \"createAccessControlContext\"\n SecurityPermission, then the action is performed\n with no permissions."}, {"method_name": "getContext", "method_sig": "public static AccessControlContext getContext()", "description": "This method takes a \"snapshot\" of the current calling context, which\n includes the current Thread's inherited AccessControlContext and any\n limited privilege scope, and places it in an AccessControlContext object.\n This context may then be checked at a later point, possibly in another thread."}, {"method_name": "checkPermission", "method_sig": "public static void checkPermission (Permission perm)\n                            throws AccessControlException", "description": "Determines whether the access request indicated by the\n specified permission should be allowed or denied, based on\n the current AccessControlContext and security policy.\n This method quietly returns if the access request\n is permitted, or throws an AccessControlException otherwise. The\n getPermission method of the AccessControlException returns the\n perm Permission object instance."}]}