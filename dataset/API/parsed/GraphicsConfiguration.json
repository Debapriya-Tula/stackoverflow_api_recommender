{"name": "Class GraphicsConfiguration", "module": "java.desktop", "package": "java.awt", "text": "The GraphicsConfiguration class describes the\n characteristics of a graphics destination such as a printer or monitor.\n There can be many GraphicsConfiguration objects associated\n with a single graphics device, representing different drawing modes or\n capabilities.  The corresponding native structure will vary from platform\n to platform.  For example, on X11 windowing systems,\n each visual is a different GraphicsConfiguration.\n On Microsoft Windows, GraphicsConfigurations represent\n PixelFormats available in the current resolution and color depth.\n \n In a virtual device multi-screen environment in which the desktop\n area could span multiple physical screen devices, the bounds of the\n GraphicsConfiguration objects are relative to the\n virtual coordinate system.  When setting the location of a\n component, use getBounds to get the bounds of\n the desired GraphicsConfiguration and offset the location\n with the coordinates of the GraphicsConfiguration,\n as the following code sample illustrates:\n \n\n      Frame f = new Frame(gc);  // where gc is a GraphicsConfiguration\n      Rectangle bounds = gc.getBounds();\n      f.setLocation(10 + bounds.x, 10 + bounds.y); \n\n To determine if your environment is a virtual device\n environment, call getBounds on all of the\n GraphicsConfiguration objects in your system.  If\n any of the origins of the returned bounds is not (0,\u00a00),\n your environment is a virtual device environment.\n\n \n You can also use getBounds to determine the bounds\n of the virtual device.  To do this, first call getBounds on all\n of the GraphicsConfiguration objects in your\n system.  Then calculate the union of all of the bounds returned\n from the calls to getBounds.  The union is the\n bounds of the virtual device.  The following code sample\n calculates the bounds of the virtual device.\n\n \n      Rectangle virtualBounds = new Rectangle();\n      GraphicsEnvironment ge = GraphicsEnvironment.\n              getLocalGraphicsEnvironment();\n      GraphicsDevice[] gs =\n              ge.getScreenDevices();\n      for (int j = 0; j < gs.length; j++) {\n          GraphicsDevice gd = gs[j];\n          GraphicsConfiguration[] gc =\n              gd.getConfigurations();\n          for (int i=0; i < gc.length; i++) {\n              virtualBounds =\n                  virtualBounds.union(gc[i].getBounds());\n          }\n      } ", "codes": ["public abstract class GraphicsConfiguration\nextends Object"], "fields": [], "methods": [{"method_name": "getDevice", "method_sig": "public abstract GraphicsDevice getDevice()", "description": "Returns the GraphicsDevice associated with this\n GraphicsConfiguration."}, {"method_name": "createCompatibleImage", "method_sig": "public BufferedImage createCompatibleImage (int width,\n                                           int height)", "description": "Returns a BufferedImage with a data layout and color model\n compatible with this GraphicsConfiguration.  This\n method has nothing to do with memory-mapping\n a device.  The returned BufferedImage has\n a layout and color model that is closest to this native device\n configuration and can therefore be optimally blitted to this\n device."}, {"method_name": "createCompatibleImage", "method_sig": "public BufferedImage createCompatibleImage (int width,\n                                           int height,\n                                           int transparency)", "description": "Returns a BufferedImage that supports the specified\n transparency and has a data layout and color model\n compatible with this GraphicsConfiguration.  This\n method has nothing to do with memory-mapping\n a device. The returned BufferedImage has a layout and\n color model that can be optimally blitted to a device\n with this GraphicsConfiguration."}, {"method_name": "createCompatibleVolatileImage", "method_sig": "public VolatileImage createCompatibleVolatileImage (int width,\n                                                   int height)", "description": "Returns a VolatileImage with a data layout and color model\n compatible with this GraphicsConfiguration.\n The returned VolatileImage\n may have data that is stored optimally for the underlying graphics\n device and may therefore benefit from platform-specific rendering\n acceleration."}, {"method_name": "createCompatibleVolatileImage", "method_sig": "public VolatileImage createCompatibleVolatileImage (int width,\n                                                   int height,\n                                                   int transparency)", "description": "Returns a VolatileImage with a data layout and color model\n compatible with this GraphicsConfiguration.\n The returned VolatileImage\n may have data that is stored optimally for the underlying graphics\n device and may therefore benefit from platform-specific rendering\n acceleration."}, {"method_name": "createCompatibleVolatileImage", "method_sig": "public VolatileImage createCompatibleVolatileImage (int width,\n                                                   int height,\n                                                   ImageCapabilities caps)\n                                            throws AWTException", "description": "Returns a VolatileImage with a data layout and color model\n compatible with this GraphicsConfiguration, using\n the specified image capabilities.\n If the caps parameter is null, it is effectively ignored\n and this method will create a VolatileImage without regard to\n ImageCapabilities constraints.\n\n The returned VolatileImage has\n a layout and color model that is closest to this native device\n configuration and can therefore be optimally blitted to this\n device."}, {"method_name": "createCompatibleVolatileImage", "method_sig": "public VolatileImage createCompatibleVolatileImage (int width,\n                                                   int height,\n                                                   ImageCapabilities caps,\n                                                   int transparency)\n                                            throws AWTException", "description": "Returns a VolatileImage with a data layout and color model\n compatible with this GraphicsConfiguration, using\n the specified image capabilities and transparency value.\n If the caps parameter is null, it is effectively ignored\n and this method will create a VolatileImage without regard to\n ImageCapabilities constraints.\n\n The returned VolatileImage has\n a layout and color model that is closest to this native device\n configuration and can therefore be optimally blitted to this\n device."}, {"method_name": "getColorModel", "method_sig": "public abstract ColorModel getColorModel()", "description": "Returns the ColorModel associated with this\n GraphicsConfiguration."}, {"method_name": "getColorModel", "method_sig": "public abstract ColorModel getColorModel (int transparency)", "description": "Returns the ColorModel associated with this\n GraphicsConfiguration that supports the specified\n transparency."}, {"method_name": "getDefaultTransform", "method_sig": "public abstract AffineTransform getDefaultTransform()", "description": "Returns the default AffineTransform for this\n GraphicsConfiguration. This\n AffineTransform is typically the Identity transform\n for most normal screens.  The default AffineTransform\n maps coordinates onto the device such that 72 user space\n coordinate units measure approximately 1 inch in device\n space.  The normalizing transform can be used to make\n this mapping more exact.  Coordinates in the coordinate space\n defined by the default AffineTransform for screen and\n printer devices have the origin in the upper left-hand corner of\n the target region of the device, with X coordinates\n increasing to the right and Y coordinates increasing downwards.\n For image buffers not associated with a device, such as those not\n created by createCompatibleImage,\n this AffineTransform is the Identity transform."}, {"method_name": "getNormalizingTransform", "method_sig": "public abstract AffineTransform getNormalizingTransform()", "description": "Returns an AffineTransform that can be concatenated\n with the default AffineTransform\n of a GraphicsConfiguration so that 72 units in user\n space equals 1 inch in device space.\n \n For a particular Graphics2D, g, one\n can reset the transformation to create\n such a mapping by using the following pseudocode:\n \n      GraphicsConfiguration gc = g.getDeviceConfiguration();\n\n      g.setTransform(gc.getDefaultTransform());\n      g.transform(gc.getNormalizingTransform());\n \n Note that sometimes this AffineTransform is identity,\n such as for printers or metafile output, and that this\n AffineTransform is only as accurate as the information\n supplied by the underlying system.  For image buffers not\n associated with a device, such as those not created by\n createCompatibleImage, this\n AffineTransform is the Identity transform\n since there is no valid distance measurement."}, {"method_name": "getBounds", "method_sig": "public abstract Rectangle getBounds()", "description": "Returns the bounds of the GraphicsConfiguration\n in the device coordinates. In a multi-screen environment\n with a virtual device, the bounds can have negative X\n or Y origins."}, {"method_name": "getBufferCapabilities", "method_sig": "public BufferCapabilities getBufferCapabilities()", "description": "Returns the buffering capabilities of this\n GraphicsConfiguration."}, {"method_name": "getImageCapabilities", "method_sig": "public ImageCapabilities getImageCapabilities()", "description": "Returns the image capabilities of this\n GraphicsConfiguration."}, {"method_name": "isTranslucencyCapable", "method_sig": "public boolean isTranslucencyCapable()", "description": "Returns whether this GraphicsConfiguration supports\n the PERPIXEL_TRANSLUCENT kind of translucency."}]}