{"name": "Class JShell", "module": "jdk.jshell", "package": "jdk.jshell", "text": "The JShell evaluation state engine.  This is the central class in the JShell\n API.  A JShell instance holds the evolving compilation and\n execution state.  The state is changed with the instance methods\n eval(String),\n drop(Snippet) and\n addToClasspath(String).\n The majority of methods query the state.\n A JShell instance also allows registering for events with\n onSnippetEvent(Consumer)\n and onShutdown(Consumer), which\n are unregistered with\n unsubscribe(Subscription).\n Access to the source analysis utilities is via\n sourceCodeAnalysis().\n When complete the instance should be closed to free resources --\n close().\n \n An instance of JShell is created with\n JShell.create().\n \n This class is not thread safe, except as noted, all access should be through\n a single thread.", "codes": ["public class JShell\nextends Object\nimplements AutoCloseable"], "fields": [], "methods": [{"method_name": "create", "method_sig": "public static JShell create()\n                     throws IllegalStateException", "description": "Create a new JShell state engine.\n That is, create an instance of JShell.\n \n Equivalent to JShell.builder().build()."}, {"method_name": "builder", "method_sig": "public static JShell.Builder builder()", "description": "Factory method for JShell.Builder which, in-turn, is used\n for creating instances of JShell.\n Create a default instance of JShell with\n JShell.builder().build(). For more construction options\n see JShell.Builder."}, {"method_name": "sourceCodeAnalysis", "method_sig": "public SourceCodeAnalysis sourceCodeAnalysis()", "description": "Access to source code analysis functionality.\n An instance of JShell will always return the same\n SourceCodeAnalysis instance from\n sourceCodeAnalysis()."}, {"method_name": "eval", "method_sig": "public List<SnippetEvent> eval (String input)\n                        throws IllegalStateException", "description": "Evaluate the input String, including definition and/or execution, if\n applicable. The input is checked for errors, unless the errors can be\n deferred (as is the case with some unresolvedDependencies references),\n errors will abort evaluation.\n \n The input should be\n exactly one complete snippet of source code, that is, one expression,\n statement, variable declaration, method declaration, class declaration,\n or import.\n To break arbitrary input into individual complete snippets, use\n SourceCodeAnalysis.analyzeCompletion(String).\n \n For imports, the import is added.  Classes, interfaces. methods,\n and variables are defined.  The initializer of variables, statements,\n and expressions are executed.\n The modifiers public, protected, private, static, and final are not\n allowed on op-level declarations and are ignored with a warning.\n Synchronized, native, abstract, and default top-level methods are not\n allowed and are errors.\n If a previous definition of a declaration is overwritten then there will\n be an event showing its status changed to OVERWRITTEN, this will not\n occur for dropped, rejected, or already overwritten declarations.\n \n If execution environment is out of process, as is the default case, then\n if the evaluated code\n causes the execution environment to terminate, this JShell\n instance will be closed but the calling process and VM remain valid."}, {"method_name": "drop", "method_sig": "public List<SnippetEvent> drop (Snippet snippet)\n                        throws IllegalStateException", "description": "Remove a declaration from the state.  That is, if the snippet is an\n active\npersistent snippet, remove the\n snippet and update the JShell evaluation state accordingly.\n For all active snippets, change the status to\n DROPPED."}, {"method_name": "addToClasspath", "method_sig": "public void addToClasspath (String path)", "description": "The specified path is added to the end of the classpath used in eval().\n Note that the unnamed package is not accessible from the package in which\n eval(String) code is placed."}, {"method_name": "stop", "method_sig": "public void stop()", "description": "Attempt to stop currently running evaluation. When called while\n the eval(java.lang.String) method is running and the\n user's code being executed, an attempt will be made to stop user's code.\n Note that typically this method needs to be called from a different thread\n than the one running the eval method.\n \n If the eval(java.lang.String) method is not running, does nothing.\n \n The attempt to stop the user's code may fail in some case, which may include\n when the execution is blocked on an I/O operation, or when the user's code is\n catching the ThreadDeath exception."}, {"method_name": "close", "method_sig": "public void close()", "description": "Close this state engine. Frees resources. Should be called when this\n state engine is no longer needed."}, {"method_name": "snippets", "method_sig": "public Stream<Snippet> snippets()", "description": "Return all snippets."}, {"method_name": "variables", "method_sig": "public Stream<VarSnippet> variables()", "description": "Returns the active variable snippets.\n This convenience method is equivalent to snippets() filtered for\n status(snippet).isActive()\n&& snippet.kind() == Kind.VARIABLE\n and cast to VarSnippet."}, {"method_name": "methods", "method_sig": "public Stream<MethodSnippet> methods()", "description": "Returns the active method snippets.\n This convenience method is equivalent to snippets() filtered for\n status(snippet).isActive()\n&& snippet.kind() == Kind.METHOD\n and cast to MethodSnippet."}, {"method_name": "types", "method_sig": "public Stream<TypeDeclSnippet> types()", "description": "Returns the active type declaration (class, interface, annotation type, and enum) snippets.\n This convenience method is equivalent to snippets() filtered for\n status(snippet).isActive()\n&& snippet.kind() == Kind.TYPE_DECL\n and cast to TypeDeclSnippet."}, {"method_name": "imports", "method_sig": "public Stream<ImportSnippet> imports()", "description": "Returns the active import snippets.\n This convenience method is equivalent to snippets() filtered for\n status(snippet).isActive()\n&& snippet.kind() == Kind.IMPORT\n and cast to ImportSnippet."}, {"method_name": "status", "method_sig": "public Snippet.Status status (Snippet snippet)", "description": "Return the status of the snippet.\n This is updated either because of an explicit eval() call or\n an automatic update triggered by a dependency."}, {"method_name": "diagnostics", "method_sig": "public Stream<Diag> diagnostics (Snippet snippet)", "description": "Return the diagnostics of the most recent evaluation of the snippet.\n The evaluation can either because of an explicit eval() call or\n an automatic update triggered by a dependency."}, {"method_name": "unresolvedDependencies", "method_sig": "public Stream<String> unresolvedDependencies (DeclarationSnippet snippet)", "description": "For RECOVERABLE_DEFINED or\n RECOVERABLE_NOT_DEFINED\n declarations, the names of current unresolved dependencies for\n the snippet.\n The returned value of this method, for a given method may change when an\n eval() or drop() of another snippet causes\n an update of a dependency."}, {"method_name": "varValue", "method_sig": "public String varValue (VarSnippet snippet)\n                throws IllegalStateException", "description": "Get the current value of a variable."}, {"method_name": "onSnippetEvent", "method_sig": "public JShell.Subscription onSnippetEvent (Consumer<SnippetEvent> listener)\n                                   throws IllegalStateException", "description": "Register a callback to be called when the Status of a snippet changes.\n Each call adds a new subscription."}, {"method_name": "onShutdown", "method_sig": "public JShell.Subscription onShutdown (Consumer<JShell> listener)\n                               throws IllegalStateException", "description": "Register a callback to be called when this JShell instance terminates.\n This occurs either because the client process has ended (e.g. called System.exit(0))\n or the connection has been shutdown, as by close().\n Each call adds a new subscription."}, {"method_name": "unsubscribe", "method_sig": "public void unsubscribe (JShell.Subscription token)", "description": "Cancel a callback subscription."}]}