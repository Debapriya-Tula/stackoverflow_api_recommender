{"name": "Class SizeSequence", "module": "java.desktop", "package": "javax.swing", "text": "A SizeSequence object\n efficiently maintains an ordered list\n of sizes and corresponding positions.\n One situation for which SizeSequence\n might be appropriate is in a component\n that displays multiple rows of unequal size.\n In this case, a single SizeSequence\n object could be used to track the heights\n and Y positions of all rows.\n \n Another example would be a multi-column component,\n such as a JTable,\n in which the column sizes are not all equal.\n The JTable might use a single\n SizeSequence object\n to store the widths and X positions of all the columns.\n The JTable could then use the\n SizeSequence object\n to find the column corresponding to a certain position.\n The JTable could update the\n SizeSequence object\n whenever one or more column sizes changed.\n\n \n The following figure shows the relationship between size and position data\n for a multi-column component.\n\n \n\n\n In the figure, the first index (0) corresponds to the first column,\n the second index (1) to the second column, and so on.\n The first column's position starts at 0,\n and the column occupies size0 pixels,\n where size0 is the value returned by\n getSize(0).\n Thus, the first column ends at size0 - 1.\n The second column then begins at\n the position size0\n and occupies size1 (getSize(1)) pixels.\n \n Note that a SizeSequence object simply represents intervals\n along an axis.\n In our examples, the intervals represent height or width in pixels.\n However, any other unit of measure (for example, time in days)\n could be just as valid.\n\n\n Implementation Notes\n\n Normally when storing the size and position of entries,\n one would choose between\n storing the sizes or storing their positions\n instead. The two common operations that are needed during\n rendering are: getIndex(position)\n and setSize(index, size).\n Whichever choice of internal format is made one of these\n operations is costly when the number of entries becomes large.\n If sizes are stored, finding the index of the entry\n that encloses a particular position is linear in the\n number of entries. If positions are stored instead, setting\n the size of an entry at a particular index requires updating\n the positions of the affected entries, which is also a linear\n calculation.\n \n Like the above techniques this class holds an array of N integers\n internally but uses a hybrid encoding, which is halfway\n between the size-based and positional-based approaches.\n The result is a data structure that takes the same space to store\n the information but can perform most operations in Log(N) time\n instead of O(N), where N is the number of entries in the list.\n \n Two operations that remain O(N) in the number of entries are\n the insertEntries\n and removeEntries methods, both\n of which are implemented by converting the internal array to\n a set of integer sizes, copying it into the new array, and then\n reforming the hybrid representation in place.", "codes": ["public class SizeSequence\nextends Object"], "fields": [], "methods": [{"method_name": "setSizes", "method_sig": "public void setSizes (int[] sizes)", "description": "Resets this SizeSequence object,\n using the data in the sizes argument.\n This method reinitializes this object so that it\n contains as many entries as the sizes array.\n Each entry's size is initialized to the value of the\n corresponding item in sizes."}, {"method_name": "getSizes", "method_sig": "public int[] getSizes()", "description": "Returns the size of all entries."}, {"method_name": "getPosition", "method_sig": "public int getPosition (int index)", "description": "Returns the start position for the specified entry.\n For example, getPosition(0) returns 0,\n getPosition(1) is equal to\n   getSize(0),\n getPosition(2) is equal to\n   getSize(0) + getSize(1),\n and so on.\n Note that if index is greater than\n length the value returned may\n be meaningless."}, {"method_name": "getIndex", "method_sig": "public int getIndex (int position)", "description": "Returns the index of the entry\n that corresponds to the specified position.\n For example, getIndex(0) is 0,\n since the first entry always starts at position 0."}, {"method_name": "getSize", "method_sig": "public int getSize (int index)", "description": "Returns the size of the specified entry.\n If index is out of the range\n (0 <= index < getSizes().length)\n the behavior is unspecified."}, {"method_name": "setSize", "method_sig": "public void setSize (int index,\n                    int size)", "description": "Sets the size of the specified entry.\n Note that if the value of index\n does not fall in the range:\n (0 <= index < getSizes().length)\n the behavior is unspecified."}, {"method_name": "insertEntries", "method_sig": "public void insertEntries (int start,\n                          int length,\n                          int value)", "description": "Adds a contiguous group of entries to this SizeSequence.\n Note that the values of start and\n length must satisfy the following\n conditions:  (0 <= start < getSizes().length)\n AND (length >= 0).  If these conditions are\n not met, the behavior is unspecified and an exception\n may be thrown."}, {"method_name": "removeEntries", "method_sig": "public void removeEntries (int start,\n                          int length)", "description": "Removes a contiguous group of entries\n from this SizeSequence.\n Note that the values of start and\n length must satisfy the following\n conditions:  (0 <= start < getSizes().length)\n AND (length >= 0).  If these conditions are\n not met, the behavior is unspecified and an exception\n may be thrown."}]}