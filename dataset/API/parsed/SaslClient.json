{"name": "Interface SaslClient", "module": "java.security.sasl", "package": "javax.security.sasl", "text": "Performs SASL authentication as a client.\n\n A protocol library such as one for LDAP gets an instance of this\n class in order to perform authentication defined by a specific SASL\n mechanism. Invoking methods on the SaslClient instance\n process challenges and create responses according to the SASL\n mechanism implemented by the SaslClient.\n As the authentication proceeds, the instance\n encapsulates the state of a SASL client's authentication exchange.\n\n Here's an example of how an LDAP library might use a SaslClient.\n It first gets an instance of a SaslClient:\n\n SaslClient sc = Sasl.createSaslClient(mechanisms,\n     authorizationId, protocol, serverName, props, callbackHandler);\n\n It can then proceed to use the client for authentication.\n For example, an LDAP library might use the client as follows:\n\n // Get initial response and send to server\n byte[] response = (sc.hasInitialResponse() ? sc.evaluateChallenge(new byte[0]) :\n     null);\n LdapResult res = ldap.sendBindRequest(dn, sc.getName(), response);\n while (!sc.isComplete() &&\n     (res.status == SASL_BIND_IN_PROGRESS || res.status == SUCCESS)) {\n     response = sc.evaluateChallenge(res.getBytes());\n     if (res.status == SUCCESS) {\n         // we're done; don't expect to send another BIND\n         if (response != null) {\n             throw new SaslException(\n                 \"Protocol error: attempting to send response after completion\");\n         }\n         break;\n     }\n     res = ldap.sendBindRequest(dn, sc.getName(), response);\n }\n if (sc.isComplete() && res.status == SUCCESS) {\n    String qop = (String) sc.getNegotiatedProperty(Sasl.QOP);\n    if (qop != null\n        && (qop.equalsIgnoreCase(\"auth-int\")\n            || qop.equalsIgnoreCase(\"auth-conf\"))) {\n\n      // Use SaslClient.wrap() and SaslClient.unwrap() for future\n      // communication with server\n      ldap.in = new SecureInputStream(sc, ldap.in);\n      ldap.out = new SecureOutputStream(sc, ldap.out);\n    }\n }\n\n\n If the mechanism has an initial response, the library invokes\n evaluateChallenge() with an empty\n challenge and to get initial response.\n Protocols such as IMAP4, which do not include an initial response with\n their first authentication command to the server, initiates the\n authentication without first calling hasInitialResponse()\n or evaluateChallenge().\n When the server responds to the command, it sends an initial challenge.\n For a SASL mechanism in which the client sends data first, the server should\n have issued a challenge with no data. This will then result in a call\n (on the client) to evaluateChallenge() with an empty challenge.", "codes": ["public interface SaslClient"], "fields": [], "methods": [{"method_name": "getMechanismName", "method_sig": "String getMechanismName()", "description": "Returns the IANA-registered mechanism name of this SASL client.\n (e.g. \"CRAM-MD5\", \"GSSAPI\")."}, {"method_name": "hasInitialResponse", "method_sig": "boolean hasInitialResponse()", "description": "Determines whether this mechanism has an optional initial response.\n If true, caller should call evaluateChallenge() with an\n empty array to get the initial response."}, {"method_name": "evaluateChallenge", "method_sig": "byte[] evaluateChallenge (byte[] challenge)\n                  throws SaslException", "description": "Evaluates the challenge data and generates a response.\n If a challenge is received from the server during the authentication\n process, this method is called to prepare an appropriate next\n response to submit to the server."}, {"method_name": "isComplete", "method_sig": "boolean isComplete()", "description": "Determines whether the authentication exchange has completed.\n This method may be called at any time, but typically, it\n will not be called until the caller has received indication\n from the server\n (in a protocol-specific manner) that the exchange has completed."}, {"method_name": "unwrap", "method_sig": "byte[] unwrap (byte[] incoming,\n              int offset,\n              int len)\n       throws SaslException", "description": "Unwraps a byte array received from the server.\n This method can be called only after the authentication exchange has\n completed (i.e., when isComplete() returns true) and only if\n the authentication exchange has negotiated integrity and/or privacy\n as the quality of protection; otherwise, an\n IllegalStateException is thrown.\n\nincoming is the contents of the SASL buffer as defined in RFC 2222\n without the leading four octet field that represents the length.\n offset and len specify the portion of incoming\n to use."}, {"method_name": "wrap", "method_sig": "byte[] wrap (byte[] outgoing,\n            int offset,\n            int len)\n     throws SaslException", "description": "Wraps a byte array to be sent to the server.\n This method can be called only after the authentication exchange has\n completed (i.e., when isComplete() returns true) and only if\n the authentication exchange has negotiated integrity and/or privacy\n as the quality of protection; otherwise, an\n IllegalStateException is thrown.\n\n The result of this method will make up the contents of the SASL buffer\n as defined in RFC 2222 without the leading four octet field that\n represents the length.\n offset and len specify the portion of outgoing\n to use."}, {"method_name": "getNegotiatedProperty", "method_sig": "Object getNegotiatedProperty (String propName)", "description": "Retrieves the negotiated property.\n This method can be called only after the authentication exchange has\n completed (i.e., when isComplete() returns true); otherwise, an\n IllegalStateException is thrown.\n \n The Sasl class includes several well-known property names\n (For example, Sasl.QOP). A SASL provider can support other\n properties which are specific to the vendor and/or a mechanism."}, {"method_name": "dispose", "method_sig": "void dispose()\n      throws SaslException", "description": "Disposes of any system resources or security-sensitive information\n the SaslClient might be using. Invoking this method invalidates\n the SaslClient instance. This method is idempotent."}]}