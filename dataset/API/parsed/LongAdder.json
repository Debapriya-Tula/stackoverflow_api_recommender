{"name": "Class LongAdder", "module": "java.base", "package": "java.util.concurrent.atomic", "text": "One or more variables that together maintain an initially zero\n long sum.  When updates (method add(long)) are contended\n across threads, the set of variables may grow dynamically to reduce\n contention. Method sum() (or, equivalently, longValue()) returns the current total combined across the\n variables maintaining the sum.\n\n This class is usually preferable to AtomicLong when\n multiple threads update a common sum that is used for purposes such\n as collecting statistics, not for fine-grained synchronization\n control.  Under low update contention, the two classes have similar\n characteristics. But under high contention, expected throughput of\n this class is significantly higher, at the expense of higher space\n consumption.\n\n LongAdders can be used with a ConcurrentHashMap to maintain a scalable\n frequency map (a form of histogram or multiset). For example, to\n add a count to a ConcurrentHashMap<String,LongAdder> freqs,\n initializing if not already present, you can use \n freqs.computeIfAbsent(key, k -> new LongAdder()).increment();\nThis class extends Number, but does not define\n methods such as equals, hashCode and \n compareTo because instances are expected to be mutated, and so are\n not useful as collection keys.", "codes": ["public class LongAdder\nextends Number\nimplements Serializable"], "fields": [], "methods": [{"method_name": "add", "method_sig": "public void add (long x)", "description": "Adds the given value."}, {"method_name": "increment", "method_sig": "public void increment()", "description": "Equivalent to add(1)."}, {"method_name": "decrement", "method_sig": "public void decrement()", "description": "Equivalent to add(-1)."}, {"method_name": "sum", "method_sig": "public long sum()", "description": "Returns the current sum.  The returned value is NOT an\n atomic snapshot; invocation in the absence of concurrent\n updates returns an accurate result, but concurrent updates that\n occur while the sum is being calculated might not be\n incorporated."}, {"method_name": "reset", "method_sig": "public void reset()", "description": "Resets variables maintaining the sum to zero.  This method may\n be a useful alternative to creating a new adder, but is only\n effective if there are no concurrent updates.  Because this\n method is intrinsically racy, it should only be used when it is\n known that no threads are concurrently updating."}, {"method_name": "sumThenReset", "method_sig": "public long sumThenReset()", "description": "Equivalent in effect to sum() followed by reset(). This method may apply for example during quiescent\n points between multithreaded computations.  If there are\n updates concurrent with this method, the returned value is\n not guaranteed to be the final value occurring before\n the reset."}, {"method_name": "toString", "method_sig": "public String toString()", "description": "Returns the String representation of the sum()."}, {"method_name": "longValue", "method_sig": "public long longValue()", "description": "Equivalent to sum()."}, {"method_name": "intValue", "method_sig": "public int intValue()", "description": "Returns the sum() as an int after a narrowing\n primitive conversion."}, {"method_name": "floatValue", "method_sig": "public float floatValue()", "description": "Returns the sum() as a float\n after a widening primitive conversion."}, {"method_name": "doubleValue", "method_sig": "public double doubleValue()", "description": "Returns the sum() as a double after a widening\n primitive conversion."}]}