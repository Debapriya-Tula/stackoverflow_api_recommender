{"name": "Class Flow", "module": "java.base", "package": "java.util.concurrent", "text": "Interrelated interfaces and static methods for establishing\n flow-controlled components in which Publishers\n produce items consumed by one or more Subscribers, each managed by a Subscription.\n\n These interfaces correspond to the  reactive-streams\n specification.  They apply in both concurrent and distributed\n asynchronous settings: All (seven) methods are defined in \n void \"one-way\" message style. Communication relies on a simple form\n of flow control (method Flow.Subscription.request(long)) that can be\n used to avoid resource management problems that may otherwise occur\n in \"push\" based systems.\n\n Examples. A Flow.Publisher usually defines its own\n Flow.Subscription implementation; constructing one in method\n subscribe and issuing it to the calling Flow.Subscriber. It publishes items to the subscriber asynchronously,\n normally using an Executor.  For example, here is a very\n simple publisher that only issues (when requested) a single \n TRUE item to a single subscriber.  Because the subscriber receives\n only a single item, this class does not use buffering and ordering\n control required in most implementations (for example SubmissionPublisher).\n\n  \n class OneShotPublisher implements Publisher<Boolean> {\n   private final ExecutorService executor = ForkJoinPool.commonPool(); // daemon-based\n   private boolean subscribed; // true after first subscribe\n   public synchronized void subscribe(Subscriber<? super Boolean> subscriber) {\n     if (subscribed)\n       subscriber.onError(new IllegalStateException()); // only one allowed\n     else {\n       subscribed = true;\n       subscriber.onSubscribe(new OneShotSubscription(subscriber, executor));\n     }\n   }\n   static class OneShotSubscription implements Subscription {\n     private final Subscriber<? super Boolean> subscriber;\n     private final ExecutorService executor;\n     private Future<?> future; // to allow cancellation\n     private boolean completed;\n     OneShotSubscription(Subscriber<? super Boolean> subscriber,\n                         ExecutorService executor) {\n       this.subscriber = subscriber;\n       this.executor = executor;\n     }\n     public synchronized void request(long n) {\n       if (!completed) {\n         completed = true;\n         if (n <= 0) {\n           IllegalArgumentException ex = new IllegalArgumentException();\n           executor.execute(() -> subscriber.onError(ex));\n         } else {\n           future = executor.submit(() -> {\n             subscriber.onNext(Boolean.TRUE);\n             subscriber.onComplete();\n           });\n         }\n       }\n     }\n     public synchronized void cancel() {\n       completed = true;\n       if (future != null) future.cancel(false);\n     }\n   }\n }\nA Flow.Subscriber arranges that items be requested and\n processed.  Items (invocations of Flow.Subscriber.onNext(T)) are\n not issued unless requested, but multiple items may be requested.\n Many Subscriber implementations can arrange this in the style of\n the following example, where a buffer size of 1 single-steps, and\n larger sizes usually allow for more efficient overlapped processing\n with less communication; for example with a value of 64, this keeps\n total outstanding requests between 32 and 64.\n Because Subscriber method invocations for a given Flow.Subscription are strictly ordered, there is no need for these\n methods to use locks or volatiles unless a Subscriber maintains\n multiple Subscriptions (in which case it is better to instead\n define multiple Subscribers, each with its own Subscription).\n\n  \n class SampleSubscriber<T> implements Subscriber<T> {\n   final Consumer<? super T> consumer;\n   Subscription subscription;\n   final long bufferSize;\n   long count;\n   SampleSubscriber(long bufferSize, Consumer<? super T> consumer) {\n     this.bufferSize = bufferSize;\n     this.consumer = consumer;\n   }\n   public void onSubscribe(Subscription subscription) {\n     long initialRequestSize = bufferSize;\n     count = bufferSize - bufferSize / 2; // re-request when half consumed\n     (this.subscription = subscription).request(initialRequestSize);\n   }\n   public void onNext(T item) {\n     if (--count <= 0)\n       subscription.request(count = bufferSize - bufferSize / 2);\n     consumer.accept(item);\n   }\n   public void onError(Throwable ex) { ex.printStackTrace(); }\n   public void onComplete() {}\n }\nThe default value of defaultBufferSize() may provide a\n useful starting point for choosing request sizes and capacities in\n Flow components based on expected rates, resources, and usages.\n Or, when flow control is never needed, a subscriber may initially\n request an effectively unbounded number of items, as in:\n\n  \n class UnboundedSubscriber<T> implements Subscriber<T> {\n   public void onSubscribe(Subscription subscription) {\n     subscription.request(Long.MAX_VALUE); // effectively unbounded\n   }\n   public void onNext(T item) { use(item); }\n   public void onError(Throwable ex) { ex.printStackTrace(); }\n   public void onComplete() {}\n   void use(T item) { ... }\n }", "codes": ["public final class Flow\nextends Object"], "fields": [], "methods": [{"method_name": "defaultBufferSize", "method_sig": "public static int defaultBufferSize()", "description": "Returns a default value for Publisher or Subscriber buffering,\n that may be used in the absence of other constraints."}]}