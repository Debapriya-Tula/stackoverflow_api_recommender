{"name": "Class SctpMultiChannel", "module": "jdk.sctp", "package": "com.sun.nio.sctp", "text": "A selectable channel for message-oriented SCTP sockets.\n\n  An SCTP multi channel supports many associations on a single socket.\n An SctpMultiChannel is created by invoking the\n open method of this class. A newly-created channel is open but\n not yet bound. An attempt to invoke the receive method of an\n unbound channel will cause the NotYetBoundException\n to be thrown. An attempt to invoke the send method of an\n unbound channel will cause it to first invoke the bind method.\n The address(es) that the channel's socket is bound to can be retrieved by\n calling getAllLocalAddresses.\n\n  Messages may be sent and received without explicitly setting up an\n association with the remote peer. The channel will implicitly setup\n a new association whenever it sends or receives a message from a remote\n peer if there is not already an association with that peer. Upon successful\n association setup, an association changed notification will be put to the SCTP stack with its\n event parameter set to COMM_UP. This notification can be received by invoking receive.\n\n  Socket options are configured using the\n setOption method. An\n SctpMultiChannel supports the following options:\n \n\nSocket options\n\n\nOption Name\nDescription\n\n\n\n\n SCTP_DISABLE_FRAGMENTS \n Enables or disables message fragmentation \n\n\n SCTP_EXPLICIT_COMPLETE \n Enables or disables explicit message completion \n\n\n SCTP_FRAGMENT_INTERLEAVE \n Controls how the presentation of messages occur for the message\n          receiver \n\n\n SCTP_INIT_MAXSTREAMS \n The maximum number of streams requested by the local endpoint during\n          association initialization \n\n\n SCTP_NODELAY \n Enables or disable a Nagle-like algorithm \n\n\n SCTP_PRIMARY_ADDR \n Requests that the local SCTP stack use the given peer address as the\n          association primary \n\n\n SCTP_SET_PEER_PRIMARY_ADDR \n Requests that the peer mark the enclosed address as the association\n          primary \n\n\n SO_SNDBUF \n The size of the socket send buffer \n\n\n SO_RCVBUF \n The size of the socket receive buffer \n\n\n SO_LINGER \n Linger on close if data is present (when configured in blocking mode\n          only) \n\n\n\n\n Additional (implementation specific) options may also be supported. The list\n of options supported is obtained by invoking the supportedOptions method.\n\n  SCTP multi channels are safe for use by multiple concurrent threads.\n They support concurrent sending and receiving, though at most one thread may be\n sending and at most one thread may be receiving at any given time.", "codes": ["public abstract class SctpMultiChannel\nextends AbstractSelectableChannel"], "fields": [], "methods": [{"method_name": "open", "method_sig": "public static SctpMultiChannel open()\n                             throws IOException", "description": "Opens an SCTP multi channel.\n\n  The new channel is unbound."}, {"method_name": "associations", "method_sig": "public abstract Set<Association> associations()\n                                       throws IOException", "description": "Returns the open associations on this channel's socket.\n\n  Only associations whose COMM_UP association change event has been received are included\n in the returned set of associations. Associations for which a\n COMM_LOST or SHUTDOWN association change\n event have been receive are removed from the set of associations.\n\n  The returned set of associations is a snapshot of the open\n associations at the time that this method is invoked."}, {"method_name": "bind", "method_sig": "public abstract SctpMultiChannel bind (SocketAddress local,\n                                      int backlog)\n                               throws IOException", "description": "Binds the channel's socket to a local address and configures the socket\n to listen for connections.\n\n  This method is used to establish a relationship between the socket\n and the local address. Once a relationship is established then\n the socket remains bound until the channel is closed. This relationship\n may not necesssarily be with the address local as it may be removed\n by unbindAddress, but there will always be at least one local\n address bound to the channel's socket once an invocation of this method\n successfully completes.\n\n  Once the channel's socket has been successfully bound to a specific\n address, that is not automatically assigned, more addresses\n may be bound to it using bindAddress, or removed\n using unbindAddress.\n\n  The backlog parameter is the maximum number of pending connections on\n the socket. Its exact semantics are implementation specific. An implementation\n may impose an implementation specific maximum length or may choose to ignore\n the parameter. If the backlog parameter has the value 0, or a negative\n value, then an implementation specific default is used."}, {"method_name": "bind", "method_sig": "public final SctpMultiChannel bind (SocketAddress local)\n                            throws IOException", "description": "Binds the channel's socket to a local address and configures the socket\n to listen for connections.\n\n  This method works as if invoking it were equivalent to evaluating the\n expression:\n \n bind(local, 0);\n "}, {"method_name": "bindAddress", "method_sig": "public abstract SctpMultiChannel bindAddress (InetAddress address)\n                                      throws IOException", "description": "Adds the given address to the bound addresses for the channel's\n socket.\n\n  The given address must not be the wildcard address.\n The channel must be first bound using bind before\n invoking this method, otherwise NotYetBoundException is thrown.\n The bind method takes a SocketAddress as its\n argument which typically contains a port number as well as an address.\n Addresses subquently bound using this method are simply addresses as the\n SCTP port number remains the same for the lifetime of the channel.\n\n  New associations setup after this method successfully completes\n will be associated with the given address. Adding addresses to existing\n associations is optional functionality. If the endpoint supports\n dynamic address reconfiguration then it may send the appropriate message\n to the peer to change the peers address lists."}, {"method_name": "unbindAddress", "method_sig": "public abstract SctpMultiChannel unbindAddress (InetAddress address)\n                                        throws IOException", "description": "Removes the given address from the bound addresses for the channel's\n socket.\n\n  The given address must not be the wildcard address.\n The channel must be first bound using bind before\n invoking this method, otherwise NotYetBoundException is thrown.\n\n  If this method is invoked on a channel that does\n not have address as one of its bound addresses, or that has only\n one local address bound to it, then this method throws\n IllegalUnbindException.\n\n  The initial address that the channel's socket is bound to using\n bind may be removed from the bound addresses for the\n channel's socket.\n\n  New associations setup after this method successfully completes\n will not be associated with the given address. Removing addresses from\n existing associations is optional functionality. If the endpoint supports\n dynamic address reconfiguration then it may send the appropriate message\n to the peer to change the peers address lists."}, {"method_name": "getAllLocalAddresses", "method_sig": "public abstract Set<SocketAddress> getAllLocalAddresses()\n                                                 throws IOException", "description": "Returns all of the socket addresses to which this channel's socket is\n bound."}, {"method_name": "getRemoteAddresses", "method_sig": "public abstract Set<SocketAddress> getRemoteAddresses (Association association)\n                                               throws IOException", "description": "Returns all of the remote addresses to which the given association on\n this channel's socket is connected."}, {"method_name": "shutdown", "method_sig": "public abstract SctpMultiChannel shutdown (Association association)\n                                   throws IOException", "description": "Shutdown an association without closing the channel."}, {"method_name": "getOption", "method_sig": "public abstract <T> T getOption (SctpSocketOption<T> name,\n                                Association association)\n                         throws IOException", "description": "Returns the value of a socket option.\n\n  Note that some options are retrieved on the channel's socket,\n therefore the association parameter is not applicable and will be\n ignored if given. However, if the option is association specific then the\n association must be given."}, {"method_name": "setOption", "method_sig": "public abstract <T> SctpMultiChannel setOption (SctpSocketOption<T> name,\n                                               T value,\n                                               Association association)\n                                        throws IOException", "description": "Sets the value of a socket option.\n\n  Note that some options are retrieved on the channel's socket,\n therefore the association parameter is not applicable and will be\n ignored if given. However, if the option is association specific then the\n association must be given."}, {"method_name": "supportedOptions", "method_sig": "public abstract Set<SctpSocketOption<?>> supportedOptions()", "description": "Returns a set of the socket options supported by this channel.\n\n  This method will continue to return the set of options even after the\n channel has been closed."}, {"method_name": "validOps", "method_sig": "public final int validOps()", "description": "Returns an operation set identifying this channel's supported operations.\n\n  SCTP multi channels support reading, and writing, so this\n method returns\n (SelectionKey.OP_READ |\u00a0SelectionKey.OP_WRITE).  "}, {"method_name": "receive", "method_sig": "public abstract <T> MessageInfo receive (ByteBuffer buffer,\n                                        T attachment,\n                                        NotificationHandler<T> handler)\n                                 throws IOException", "description": "Receives a message and/or handles a notification via this channel.\n\n  If a message or notification is immediately available, or if this\n channel is in blocking mode and one eventually becomes available, then\n the message or notification is returned or handled, respectively. If this\n channel is in non-blocking mode and a message or notification is not\n immediately available then this method immediately returns null.\n\n  If this method receives a message it is copied into the given byte\n buffer and an MessageInfo is returned.\n The message is transferred into the given byte buffer starting at its\n current position and the buffers position is incremented by the number of\n bytes read. If there are fewer bytes remaining in the buffer than are\n required to hold the message, or the underlying input buffer does not\n contain the complete message, then an invocation of isComplete on the returned \n MessageInfo will return false, and more invocations of this\n method will be necessary to completely consume the messgae. Only\n one message at a time will be partially delivered in any stream. The\n socket option SCTP_FRAGMENT_INTERLEAVE controls various aspects of what interlacing of\n messages occurs.\n\n  If this method receives a notification then the appropriate method of\n the given handler, if there is one, is invoked. If the handler returns CONTINUE then this method will try to receive another\n message/notification, otherwise, if RETURN is returned\n this method will return null. If an uncaught exception is thrown by the\n handler it will be propagated up the stack through this method.\n\n  If a security manager has been installed then for each new association\n setup this method verifies that the associations source address and port\n number are permitted by the security manager's checkAccept method.\n\n  This method may be invoked at any time. If another thread has\n already initiated a receive operation upon this channel, then an\n invocation of this method will block until the first operation is\n complete. The given handler is invoked without holding any locks used\n to enforce the above synchronization policy, that way handlers\n will not stall other threads from receiving. A handler should not invoke\n the receive method of this channel, if it does an\n IllegalReceiveException will be thrown."}, {"method_name": "send", "method_sig": "public abstract int send (ByteBuffer buffer,\n                         MessageInfo messageInfo)\n                  throws IOException", "description": "Sends a message via this channel.\n\n  If this channel is unbound then this method will invoke bind(null, 0) before sending any data.\n\n  If there is no association existing between this channel's socket\n and the intended receiver, identified by the address in the given messageInfo, then one\n will be automatically setup to the intended receiver. This is considered\n to be Implicit Association Setup. Upon successful association setup, an\n association changed\n notification will be put to the SCTP stack with its event parameter set\n to COMM_UP\n . This notification can be received by invoking receive.\n\n  If this channel is in blocking mode, there is sufficient room in the\n underlying output buffer, then the remaining bytes in the given byte\n buffer are transmitted as a single message. Sending a message\n is atomic unless explicit message completion SCTP_EXPLICIT_COMPLETE\n socket option is enabled on this channel's socket.\n\n  If this channel is in non-blocking mode, there is sufficient room\n in the underlying output buffer, and an implicit association setup is\n required, then the remaining bytes in the given byte buffer are\n transmitted as a single message, subject to SCTP_EXPLICIT_COMPLETE.\n If for any reason the message cannot\n be delivered an association\n changed notification is put on the SCTP stack with its event parameter set\n to CANT_START.\n\n  The message is transferred from the byte buffer as if by a regular\n write operation.\n\n  If a security manager has been installed then for each new association\n setup this method verifies that the given remote peers address and port\n number are permitted by the security manager's checkConnect method.\n\n  This method may be invoked at any time. If another thread has already\n initiated a send operation upon this channel, then an invocation of\n this method will block until the first operation is complete."}, {"method_name": "branch", "method_sig": "public abstract SctpChannel branch (Association association)\n                            throws IOException", "description": "Branches off an association.\n\n  An application can invoke this method to branch off an association\n into a separate channel. The new bound and connected SctpChannel\n will be created for the association. The branched off association will no\n longer be part of this channel.\n\n  This is particularly useful when, for instance, the application\n wishes to have a number of sporadic message senders/receivers remain\n under the original SCTP multi channel but branch off those\n associations carrying high volume data traffic into their own\n separate SCTP channels."}]}