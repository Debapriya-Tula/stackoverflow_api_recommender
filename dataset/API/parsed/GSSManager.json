{"name": "Class GSSManager", "module": "java.security.jgss", "package": "org.ietf.jgss", "text": "This class serves as a factory for other important\n GSS-API classes and also provides information about the mechanisms that\n are supported. It can create instances of classes\n implementing the following three GSS-API interfaces: GSSName, GSSCredential, and GSSContext. It also has methods to query for the list\n of available mechanisms and the nametypes that each mechanism\n supports.\n\n An instance of the default GSSManager subclass\n may be obtained through the static method getInstance, but applications are free to instantiate other subclasses\n of GSSManager. The default GSSManager instance\n will support the Kerberos v5 GSS-API mechanism in addition to any\n others. This mechanism is identified by the Oid \"1.2.840.113554.1.2.2\"\n and is defined in RFC 1964.\n\n A subclass extending the GSSManager abstract class may be\n implemented  as a modular provider based layer that utilizes some well\n known  service provider specification. The GSSManager API\n allows the application to set provider preferences on\n such an implementation. These methods also allow the implementation to\n throw a well-defined exception in case provider based configuration is\n not supported. Applications that expect to be portable should be aware\n of this and recover cleanly by catching the exception.\n\n It is envisioned that there will be three most common ways in which\n providers will be used:\n \n The application does not care about what provider is used (the\n default case).\n  The application wants a particular provider to be used\n preferentially, either for a particular mechanism or all the\n time, irrespective of mechanism.\n  The application wants to use the locally configured providers\n as far as possible but if support is missing for one or more\n mechanisms then it wants to fall back on its own provider.\n\n\n The GSSManager class has two methods that enable these modes of\n usage:  addProviderAtFront and\n addProviderAtEnd. These methods\n have the effect of creating an ordered list of <provider,\n oid> pairs  where each pair indicates a preference of provider\n for a given oid.\n\n It is important to note that there are certain interactions\n between the different GSS-API objects that are created by a\n GSSManager, where the provider that is used for a particular mechanism\n might need to be consistent across all objects. For instance, if a\n GSSCredential contains elements from a provider p for a mechanism\n m, it should generally be passed in to a GSSContext that will use\n provider p for the mechanism m. A simple rule of thumb\n that will maximize portability is that objects created from different\n GSSManager's should not be mixed, and if possible, a different\n GSSManager instance should be created if the application wants to invoke\n the addProviderAtFront method on a GSSManager that has\n already created an object.\n\n  Here is some sample code showing how the GSSManager might be used:\n \n     GSSManager manager = GSSManager.getInstance();\n\n     Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n     Oid krb5PrincipalNameType = new Oid(\"1.2.840.113554.1.2.2.1\");\n\n     // Identify who the client wishes to be\n     GSSName userName = manager.createName(\"duke\", GSSName.NT_USER_NAME);\n\n     // Identify the name of the server. This uses a Kerberos specific\n     // name format.\n     GSSName serverName = manager.createName(\"nfs/foo.sun.com\",\n                                             krb5PrincipalNameType);\n\n     // Acquire credentials for the user\n     GSSCredential userCreds = manager.createCredential(userName,\n                                             GSSCredential.DEFAULT_LIFETIME,\n                                             krb5Mechanism,\n                                             GSSCredential.INITIATE_ONLY);\n\n     // Instantiate and initialize a security context that will be\n     // established with the server\n     GSSContext context = manager.createContext(serverName,\n                                                krb5Mechanism,\n                                                userCreds,\n                                                GSSContext.DEFAULT_LIFETIME);\n \n\n The server side might use the following variation of this source:\n\n \n     // Acquire credentials for the server\n     GSSCredential serverCreds = manager.createCredential(serverName,\n                                             GSSCredential.DEFAULT_LIFETIME,\n                                             krb5Mechanism,\n                                             GSSCredential.ACCEPT_ONLY);\n\n     // Instantiate and initialize a security context that will\n     // wait for an establishment request token from the client\n     GSSContext context = manager.createContext(serverCreds);\n ", "codes": ["public abstract class GSSManager\nextends Object"], "fields": [], "methods": [{"method_name": "getInstance", "method_sig": "public static GSSManager getInstance()", "description": "Returns the default GSSManager implementation."}, {"method_name": "getMechs", "method_sig": "public abstract Oid[] getMechs()", "description": "Returns a list of mechanisms that are available to GSS-API callers\n through this GSSManager. The default GSSManager obtained from the\n getInstance() method includes the Oid\n \"1.2.840.113554.1.2.2\" in its list. This Oid identifies the Kerberos\n v5 GSS-API mechanism that is defined in RFC 1964."}, {"method_name": "getNamesForMech", "method_sig": "public abstract Oid[] getNamesForMech (Oid mech)\n                               throws GSSException", "description": "Returns then name types supported by the indicated mechanism.\n\n The default GSSManager instance includes support for the Kerberos v5\n mechanism. When this mechanism (\"1.2.840.113554.1.2.2\") is indicated,\n the returned list will contain at least the following nametypes:\n GSSName.NT_HOSTBASED_SERVICE,\n GSSName.NT_EXPORT_NAME, and the\n Kerberos v5 specific Oid \"1.2.840.113554.1.2.2.1\". The namespace for\n the Oid \"1.2.840.113554.1.2.2.1\" is defined in RFC 1964."}, {"method_name": "getMechsForName", "method_sig": "public abstract Oid[] getMechsForName (Oid nameType)", "description": "Returns a list of mechanisms that support the indicated name type.\n\n The Kerberos v5 mechanism (\"1.2.840.113554.1.2.2\") will always be\n returned in this list when the indicated nametype is one of\n GSSName.NT_HOSTBASED_SERVICE,\n GSSName.NT_EXPORT_NAME, or\n \"1.2.840.113554.1.2.2.1\"."}, {"method_name": "createName", "method_sig": "public abstract GSSName createName (String nameStr,\n                                   Oid nameType)\n                            throws GSSException", "description": "Factory method to convert a string name from the\n specified namespace to a GSSName object. In general, the\n GSSName object created  will contain multiple\n representations of the name, one for each mechanism that is\n supported; two examples that are exceptions to this are when\n the namespace type parameter indicates NT_EXPORT_NAME or when the\n GSS-API implementation is not multi-mechanism. It is\n not recommended to use this method with a NT_EXPORT_NAME type because\n representing a previously exported name consisting of arbitrary bytes\n as a String might cause problems with character encoding schemes. In\n such cases it is recommended that the bytes be passed in directly to\n the overloaded form of this method createName."}, {"method_name": "createName", "method_sig": "public abstract GSSName createName (byte[] name,\n                                   Oid nameType)\n                            throws GSSException", "description": "Factory method to convert a byte array containing a\n name from the specified namespace to a GSSName object. In general,\n the GSSName object created  will contain multiple\n representations of the name, one for each mechanism that is\n supported; two examples that are exceptions to this are when the\n namespace type parameter indicates NT_EXPORT_NAME or when the\n GSS-API implementation is not multi-mechanism. The bytes that are\n passed in are interpreted by each underlying mechanism according to\n some encoding scheme of its choice for the given nametype."}, {"method_name": "createName", "method_sig": "public abstract GSSName createName (String nameStr,\n                                   Oid nameType,\n                                   Oid mech)\n                            throws GSSException", "description": "Factory method to convert a string name from the\n specified namespace to a GSSName object and canonicalize it at the\n same time for a mechanism. In other words, this method is\n a utility that does the equivalent of two steps: the createName and then also the GSSName.canonicalize."}, {"method_name": "createName", "method_sig": "public abstract GSSName createName (byte[] name,\n                                   Oid nameType,\n                                   Oid mech)\n                            throws GSSException", "description": "Factory method to convert a byte array containing a\n name from the specified namespace to a GSSName object and canonicalize\n it at the same time for a mechanism. In other words, this method is a\n utility that does the equivalent of two steps: the createName and then also GSSName.canonicalize."}, {"method_name": "createCredential", "method_sig": "public abstract GSSCredential createCredential (int usage)\n                                        throws GSSException", "description": "Factory method for acquiring default credentials.  This will cause\n the GSS-API to use system specific defaults for the set of mechanisms,\n name, and lifetime.\n\n GSS-API mechanism providers must impose a local access-control\n policy on callers to prevent unauthorized callers from acquiring\n credentials to which they are not entitled. The kinds of permissions\n needed by different mechanism providers will be documented on a\n per-mechanism basis. A failed permission check might cause a SecurityException to be thrown from\n this method."}, {"method_name": "createCredential", "method_sig": "public abstract GSSCredential createCredential (GSSName name,\n                                               int lifetime,\n                                               Oid mech,\n                                               int usage)\n                                        throws GSSException", "description": "Factory method for acquiring a single mechanism credential.\n\n GSS-API mechanism providers must impose a local access-control\n policy on callers to prevent unauthorized callers from acquiring\n credentials to which they are not entitled. The kinds of permissions\n needed by different mechanism providers will be documented on a\n per-mechanism basis. A failed permission check might cause a SecurityException to be thrown from\n this method. \n\n Non-default values for lifetime cannot always be honored by the\n underlying mechanisms, thus applications should be prepared to call\n getRemainingLifetime\n on the returned credential."}, {"method_name": "createCredential", "method_sig": "public abstract GSSCredential createCredential (GSSName name,\n                                               int lifetime,\n                                               Oid[] mechs,\n                                               int usage)\n                                        throws GSSException", "description": "Factory method for acquiring credentials over a set of\n mechanisms. This method attempts to acquire credentials for\n each of the mechanisms specified in the array called mechs.  To\n determine the list of mechanisms for which the acquisition of\n credentials succeeded, the caller should use the GSSCredential.getMechs method.\n\n GSS-API mechanism providers must impose a local access-control\n policy on callers to prevent unauthorized callers from acquiring\n credentials to which they are not entitled. The kinds of permissions\n needed by different mechanism providers will be documented on a\n per-mechanism basis. A failed permission check might cause a SecurityException to be thrown from\n this method.\n\n Non-default values for lifetime cannot always be honored by the\n underlying mechanisms, thus applications should be prepared to call\n getRemainingLifetime\n on the returned credential."}, {"method_name": "createContext", "method_sig": "public abstract GSSContext createContext (GSSName peer,\n                                         Oid mech,\n                                         GSSCredential myCred,\n                                         int lifetime)\n                                  throws GSSException", "description": "Factory method for creating a context on the initiator's\n side.\n\n Some mechanism providers might require that the caller be granted\n permission to initiate a security context. A failed permission check\n might cause a SecurityException\n to be thrown from this method.\n\n Non-default values for lifetime cannot always be honored by the\n underlying mechanism, thus applications should be prepared to call\n getLifetime on the returned\n context."}, {"method_name": "createContext", "method_sig": "public abstract GSSContext createContext (GSSCredential myCred)\n                                  throws GSSException", "description": "Factory method for creating a context on the acceptor' side.  The\n context's properties will be determined from the input token supplied\n to the accept method.\n\n Some mechanism providers might require that the caller be granted\n permission to accept a security context. A failed permission check\n might cause a SecurityException\n to be thrown from this method."}, {"method_name": "createContext", "method_sig": "public abstract GSSContext createContext (byte[] interProcessToken)\n                                  throws GSSException", "description": "Factory method for creating a previously exported context.  The\n context properties will be determined from the input token and\n cannot be modified through the set methods.\n\n Implementations are not required to support the inter-process\n transfer of security contexts.  Before exporting a context, calling\n the GSSContext.isTransferable\n will indicate if the context is transferable. Calling this method in\n an implementation that does not support it will result in a\n GSSException with the error\n code GSSException.UNAVAILABLE.\n\n Some mechanism providers might require that the caller be granted\n permission to initiate or accept a security context. A failed\n permission check might cause a SecurityException to be thrown from this method."}, {"method_name": "addProviderAtFront", "method_sig": "public abstract void addProviderAtFront (Provider p,\n                                        Oid mech)\n                                 throws GSSException", "description": "This method is used to indicate to the GSSManager that the\n application would like a particular provider to be used ahead of all\n others when support is desired for the given mechanism. When a value\n of null is used instead of an Oid for the mechanism,\n the GSSManager must use the indicated provider ahead of all others\n no matter what the mechanism is. Only when the indicated provider\n does not support the needed mechanism should the GSSManager move on\n to a different provider.\n\n Calling this method repeatedly preserves the older settings but\n lowers them in preference thus forming an ordered list of provider\n and Oid pairs that grows at the top.\n\n Calling addProviderAtFront with a null Oid will remove\n all previous preferences that were set for this provider in the\n GSSManager instance. Calling addProviderAtFront with a non-null\n Oid will remove any previous preference that was set\n using this mechanism and this provider together.\n\n If the GSSManager implementation does not support an SPI with a\n pluggable provider architecture it should throw a GSSException with\n the status code GSSException.UNAVAILABLE to indicate that the\n operation is unavailable.\n\n Suppose an application desired that the provider A always be checked\n first when any mechanism is needed, it would call:\n \n         GSSManager mgr = GSSManager.getInstance();\n         // mgr may at this point have its own pre-configured list\n         // of provider preferences. The following will prepend to\n         // any such list:\n\n         mgr.addProviderAtFront(A, null);\n \n Now if it also desired that the mechanism of Oid m1 always be\n obtained from the provider B before the previously set A was checked,\n it would call:\n \n         mgr.addProviderAtFront(B, m1);\n \n The GSSManager would then first check with B if m1 was needed. In\n case B did not provide support for m1, the GSSManager would continue\n on to check with A.  If any mechanism m2 is needed where m2 is\n different from m1 then the GSSManager would skip B and check with A\n directly.\n\n Suppose at a later time the following call is made to the same\n GSSManager instance:\n \n         mgr.addProviderAtFront(B, null)\n \n then the previous setting with the pair (B, m1) is subsumed by this\n and should be removed. Effectively the list of preferences now\n becomes {(B, null), (A, null),\n         ... //followed by the pre-configured list.\n\n Please note, however, that the following call:\n \n         mgr.addProviderAtFront(A, m3)\n \n does not subsume the previous setting of (A, null) and the list will\n effectively become {(A, m3), (B, null), (A, null), ...}"}, {"method_name": "addProviderAtEnd", "method_sig": "public abstract void addProviderAtEnd (Provider p,\n                                      Oid mech)\n                               throws GSSException", "description": "This method is used to indicate to the GSSManager that the\n application would like a particular provider to be used if no other\n provider can be found that supports the given mechanism. When a value\n of null is used instead of an Oid for the mechanism, the GSSManager\n must use the indicated provider for any mechanism.\n\n Calling this method repeatedly preserves the older settings but\n raises them above newer ones in preference thus forming an ordered\n list of providers and Oid pairs that grows at the bottom. Thus the\n older provider settings will be utilized first before this one is.\n\n If there are any previously existing preferences that conflict with\n the preference being set here, then the GSSManager should ignore this\n request.\n\n If the GSSManager implementation does not support an SPI with a\n pluggable provider architecture it should throw a GSSException with\n the status code GSSException.UNAVAILABLE to indicate that the\n operation is unavailable.\n\n Suppose an application desired that when a mechanism of Oid m1 is\n needed the system default providers always be checked first, and only\n when they do not support m1 should a provider A be checked. It would\n then make the call:\n \n         GSSManager mgr = GSSManager.getInstance();\n         mgr.addProviderAtEnd(A, m1);\n \n Now, if it also desired that for all mechanisms the provider B be\n checked after all configured providers have been checked, it would\n then call:\n \n         mgr.addProviderAtEnd(B, null);\n \n Effectively the list of preferences now becomes {..., (A, m1), (B,\n null)}.\n\n Suppose at a later time the following call is made to the same\n GSSManager instance:\n \n         mgr.addProviderAtEnd(B, m2)\n \n then the previous setting with the pair (B, null) subsumes this and\n therefore this request should be ignored. The same would happen if a\n request is made for the already existing pairs of (A, m1) or (B,\n null).\n\n Please note, however, that the following call:\n \n         mgr.addProviderAtEnd(A, null)\n \n is not subsumed by the previous setting of (A, m1) and the list will\n effectively become {..., (A, m1), (B, null), (A, null)}"}]}