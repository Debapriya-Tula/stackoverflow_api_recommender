{"name": "Class NamedOperation", "module": "jdk.dynalink", "package": "jdk.dynalink", "text": "Operation that associates a name with another operation. Typically used with\n operations that normally take a name or an index to bind them to a fixed\n name. E.g.\n \n     new NamedOperation(\n         new NamespaceOperation(\n             StandardOperation.GET,\n             StandardNamespace.PROPERTY),\n         \"color\")\n \n will be a named operation for getting the property named \"color\" on the\n object it is applied to, and\n \n     new NamedOperation(\n         new NamespaceOperation(\n             StandardOperation.GET,\n             StandardNamespace.ELEMENT),\n         3)\n \n will be a named operation for getting the element at index 3 from the collection\n it is applied to (\"name\" in this context is akin to \"address\" and encompasses both\n textual names, numeric indices, or any other kinds of addressing that linkers can\n understand). In these cases, the expected signature of the call site for the\n operation will change to no longer include the name parameter. Specifically,\n the documentation for all StandardOperation members describes how\n they are affected by being incorporated into a named operation.\n While NamedOperation can be constructed directly, it is often convenient\n to use the Operation.named(Object) factory method instead, e.g.:\n \n    StandardOperation.GET\n        .withNamespace(StandardNamespace.ELEMENT),\n        .named(3)\n     )\n \n\n Even though NamedOperation is most often used with NamespaceOperation as\n its base, it can have other operations as its base too (except another named operation).\n Specifically, StandardOperation.CALL as well as StandardOperation.NEW can\n both be used with NamedOperation directly. The contract for these operations is such\n that when they are used as named operations, their name is only used for diagnostic messages,\n usually containing the textual representation of the source expression that retrieved the\n callee, e.g. StandardOperation.CALL.named(\"window.open\").\n ", "codes": ["public final class NamedOperation\nextends Object\nimplements Operation"], "fields": [], "methods": [{"method_name": "getBaseOperation", "method_sig": "public Operation getBaseOperation()", "description": "Returns the base operation of this named operation."}, {"method_name": "getName", "method_sig": "public Object getName()", "description": "Returns the name of this named operation."}, {"method_name": "changeName", "method_sig": "public final NamedOperation changeName (String newName)", "description": "Finds or creates a named operation that differs from this one only in the name."}, {"method_name": "equals", "method_sig": "public boolean equals (Object obj)", "description": "Compares this named operation to another object. Returns true if the\n other object is also a named operation, and both their base operations\n and name are equal."}, {"method_name": "hashCode", "method_sig": "public int hashCode()", "description": "Returns the hash code of this named operation. It is defined to be equal\n to baseOperation.hashCode() + 31 * name.hashCode()."}, {"method_name": "toString", "method_sig": "public String toString()", "description": "Returns the string representation of this named operation. It is defined\n to be equal to baseOperation.toString() + \":\" + name.toString()."}, {"method_name": "getBaseOperation", "method_sig": "public static Operation getBaseOperation (Operation op)", "description": "If the passed operation is a named operation, returns its\n getBaseOperation(), otherwise returns the operation as is."}, {"method_name": "getName", "method_sig": "public static Object getName (Operation op)", "description": "If the passed operation is a named operation, returns its\n getName(), otherwise returns null. Note that a named operation\n object can never have a null name, therefore returning null is indicative\n that the passed operation is not, in fact, a named operation."}]}