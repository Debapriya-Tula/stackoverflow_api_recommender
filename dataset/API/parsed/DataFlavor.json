{"name": "Class DataFlavor", "module": "java.datatransfer", "package": "java.awt.datatransfer", "text": "A DataFlavor provides meta information about data. DataFlavor\n is typically used to access data on the clipboard, or during a drag and drop\n operation.\n \n An instance of DataFlavor encapsulates a content type as defined in\n RFC 2045 and\n RFC 2046. A content type is\n typically referred to as a MIME type.\n \n A content type consists of a media type (referred to as the primary type), a\n subtype, and optional parameters. See\n RFC 2045 for details on the\n syntax of a MIME type.\n \n The JRE data transfer implementation interprets the parameter\n \"class\" of a MIME type as a representation class. The\n representation class reflects the class of the object being transferred. In\n other words, the representation class is the type of object returned by\n Transferable.getTransferData(java.awt.datatransfer.DataFlavor). For example, the MIME type of\n imageFlavor is \"image/x-java-image;class=java.awt.Image\",\n the primary type is image, the subtype is x-java-image, and\n the representation class is java.awt.Image. When\n getTransferData is invoked with a DataFlavor of\n imageFlavor, an instance of java.awt.Image is returned. It's\n important to note that DataFlavor does no error checking against the\n representation class. It is up to consumers of DataFlavor, such as\n Transferable, to honor the representation class.\n \n Note, if you do not specify a representation class when creating a\n DataFlavor, the default representation class is used. See appropriate\n documentation for DataFlavor's constructors.\n \n Also, DataFlavor instances with the \"text\" primary MIME\n type may have a \"charset\" parameter. Refer to\n RFC 2046 and\n selectBestTextFlavor(java.awt.datatransfer.DataFlavor[]) for details on \"text\" MIME types and\n the \"charset\" parameter.\n \n Equality of DataFlavors is determined by the primary type, subtype,\n and representation class. Refer to equals(DataFlavor) for details.\n When determining equality, any optional parameters are ignored. For example,\n the following produces two DataFlavors that are considered identical:\n \n   DataFlavor flavor1 = new DataFlavor(Object.class, \"X-test/test; class=<java.lang.Object>; foo=bar\");\n   DataFlavor flavor2 = new DataFlavor(Object.class, \"X-test/test; class=<java.lang.Object>; x=y\");\n   // The following returns true.\n   flavor1.equals(flavor2);\n \n As mentioned, flavor1 and flavor2 are considered identical.\n As such, asking a Transferable for either DataFlavor returns\n the same results.\n \n For more information on using data transfer with Swing see the\n How\n to Use Drag and Drop and Data Transfer, section in\n The Java Tutorial.", "codes": ["public class DataFlavor\nextends Object\nimplements Externalizable, Cloneable"], "fields": [{"field_name": "stringFlavor", "field_sig": "public static final\u00a0DataFlavor stringFlavor", "description": "The DataFlavor representing a Java Unicode String class, where:\n \n     representationClass = java.lang.String\n     mimeType            = \"application/x-java-serialized-object\"\n "}, {"field_name": "imageFlavor", "field_sig": "public static final\u00a0DataFlavor imageFlavor", "description": "The DataFlavor representing a Java Image class, where:\n \n     representationClass = java.awt.Image\n     mimeType            = \"image/x-java-image\"\n \n Will be null if java.awt.Image is not visible, the\n java.desktop module is not loaded, or the java.desktop\n module is not in the run-time image."}, {"field_name": "plainTextFlavor", "field_sig": "@Deprecated\npublic static final\u00a0DataFlavor plainTextFlavor", "description": "The DataFlavor representing plain text with Unicode encoding,\n where:\n \n     representationClass = InputStream\n     mimeType            = \"text/plain; charset=unicode\"\n \n This DataFlavor has been deprecated because:\n \nIts representation is an InputStream, an 8-bit based representation,\n     while Unicode is a 16-bit character set\nThe charset \"unicode\" is not well-defined. \"unicode\" implies a\n     particular platform's implementation of Unicode, not a cross-platform\n     implementation\n"}, {"field_name": "javaSerializedObjectMimeType", "field_sig": "public static final\u00a0String javaSerializedObjectMimeType", "description": "A MIME Content-Type of application/x-java-serialized-object represents a\n graph of Java object(s) that have been made persistent.\n \n The representation class associated with this DataFlavor\n identifies the Java type of an object returned as a reference from an\n invocation java.awt.datatransfer.getTransferData."}, {"field_name": "javaFileListFlavor", "field_sig": "public static final\u00a0DataFlavor javaFileListFlavor", "description": "To transfer a list of files to/from Java (and the underlying platform) a\n DataFlavor of this type/subtype and representation class of\n java.util.List is used. Each element of the list is\n required/guaranteed to be of type java.io.File."}, {"field_name": "javaJVMLocalObjectMimeType", "field_sig": "public static final\u00a0String javaJVMLocalObjectMimeType", "description": "To transfer a reference to an arbitrary Java object reference that has no\n associated MIME Content-type, across a Transferable interface\n WITHIN THE SAME JVM, a DataFlavor with this type/subtype is used,\n with a representationClass equal to the type of the\n class/interface being passed across the Transferable.\n \n The object reference returned from Transferable.getTransferData\n for a DataFlavor with this MIME Content-Type is required to be an\n instance of the representation Class of the DataFlavor."}, {"field_name": "javaRemoteObjectMimeType", "field_sig": "public static final\u00a0String javaRemoteObjectMimeType", "description": "In order to pass a live link to a Remote object via a Drag and Drop\n ACTION_LINK operation a Mime Content Type of\n application/x-java-remote-object should be used, where the representation\n class of the DataFlavor represents the type of the Remote\n interface to be transferred."}, {"field_name": "selectionHtmlFlavor", "field_sig": "public static\u00a0DataFlavor selectionHtmlFlavor", "description": "Represents a piece of an HTML markup. The markup consists of the part\n selected on the source side. Therefore some tags in the markup may be\n unpaired. If the flavor is used to represent the data in a\n Transferable instance, no additional changes will be made. This\n DataFlavor instance represents the same HTML markup as DataFlavor\n instances which content MIME type does not contain document parameter\n and representation class is the String class.\n \n     representationClass = String\n     mimeType            = \"text/html\"\n "}, {"field_name": "fragmentHtmlFlavor", "field_sig": "public static\u00a0DataFlavor fragmentHtmlFlavor", "description": "Represents a piece of an HTML markup. If possible, the markup received\n from a native system is supplemented with pair tags to be a well-formed\n HTML markup. If the flavor is used to represent the data in a\n Transferable instance, no additional changes will be made.\n \n     representationClass = String\n     mimeType            = \"text/html\"\n "}, {"field_name": "allHtmlFlavor", "field_sig": "public static\u00a0DataFlavor allHtmlFlavor", "description": "Represents a piece of an HTML markup. If possible, the markup received\n from a native system is supplemented with additional tags to make up a\n well-formed HTML document. If the flavor is used to represent the data in\n a Transferable instance, no additional changes will be made.\n \n     representationClass = String\n     mimeType            = \"text/html\"\n "}], "methods": [{"method_name": "tryToLoadClass", "method_sig": "protected static final Class<?> tryToLoadClass (String className,\n                                               ClassLoader fallback)\n                                        throws ClassNotFoundException", "description": "Tries to load a class from: the bootstrap loader, the system loader, the\n context loader (if one is present) and finally the loader specified."}, {"method_name": "toString", "method_sig": "public String toString()", "description": "String representation of this DataFlavor and its parameters. The\n resulting String contains the name of the DataFlavor\n class, this flavor's MIME type, and its representation class. If this\n flavor has a primary MIME type of \"text\", supports the charset parameter,\n and has an encoded representation, the flavor's charset is also included.\n See selectBestTextFlavor for a list of text flavors which support\n the charset parameter."}, {"method_name": "getTextPlainUnicodeFlavor", "method_sig": "public static final DataFlavor getTextPlainUnicodeFlavor()", "description": "Returns a DataFlavor representing plain text with Unicode\n encoding, where:\n \n     representationClass = java.io.InputStream\n     mimeType            = \"text/plain;\n                            charset=<platform default Unicode encoding>\"\n "}, {"method_name": "selectBestTextFlavor", "method_sig": "public static final DataFlavor selectBestTextFlavor (DataFlavor[] availableFlavors)", "description": "Selects the best text DataFlavor from an array of\n DataFlavors. Only DataFlavor.stringFlavor, and equivalent\n flavors, and flavors that have a primary MIME type of \"text\", are\n considered for selection.\n \n Flavors are first sorted by their MIME types in the following order:\n \n\"text/sgml\"\n \"text/xml\"\n \"text/html\"\n \"text/rtf\"\n \"text/enriched\"\n \"text/richtext\"\n \"text/uri-list\"\n \"text/tab-separated-values\"\n \"text/t140\"\n \"text/rfc822-headers\"\n \"text/parityfec\"\n \"text/directory\"\n \"text/css\"\n \"text/calendar\"\n \"application/x-java-serialized-object\"\n \"text/plain\"\n \"text/<other>\"\n \n\n For example, \"text/sgml\" will be selected over \"text/html\", and\n DataFlavor.stringFlavor will be chosen over\n DataFlavor.plainTextFlavor.\n \n If two or more flavors share the best MIME type in the array, then that\n MIME type will be checked to see if it supports the charset parameter.\n \n The following MIME types support, or are treated as though they support,\n the charset parameter:\n \n\"text/sgml\"\n \"text/xml\"\n \"text/html\"\n \"text/enriched\"\n \"text/richtext\"\n \"text/uri-list\"\n \"text/directory\"\n \"text/css\"\n \"text/calendar\"\n \"application/x-java-serialized-object\"\n \"text/plain\"\n \n The following MIME types do not support, or are treated as though they do\n not support, the charset parameter:\n \n\"text/rtf\"\n \"text/tab-separated-values\"\n \"text/t140\"\n \"text/rfc822-headers\"\n \"text/parityfec\"\n \n For \"text/<other>\" MIME types, the first time the JRE needs to\n determine whether the MIME type supports the charset parameter, it will\n check whether the parameter is explicitly listed in an arbitrarily chosen\n DataFlavor which uses that MIME type. If so, the JRE will assume\n from that point on that the MIME type supports the charset parameter and\n will not check again. If the parameter is not explicitly listed, the JRE\n will assume from that point on that the MIME type does not support the\n charset parameter and will not check again. Because this check is\n performed on an arbitrarily chosen DataFlavor, developers must\n ensure that all DataFlavors with a \"text/<other>\" MIME type\n specify the charset parameter if it is supported by that MIME type.\n Developers should never rely on the JRE to substitute the platform's\n default charset for a \"text/<other>\" DataFlavor. Failure to adhere\n to this restriction will lead to undefined behavior.\n \n If the best MIME type in the array does not support the charset\n parameter, the flavors which share that MIME type will then be sorted by\n their representation classes in the following order:\n java.io.InputStream, java.nio.ByteBuffer, [B,\n <all others>.\n \n If two or more flavors share the best representation class, or if no\n flavor has one of the three specified representations, then one of those\n flavors will be chosen non-deterministically.\n \n If the best MIME type in the array does support the charset parameter,\n the flavors which share that MIME type will then be sorted by their\n representation classes in the following order: java.io.Reader,\n java.lang.String, java.nio.CharBuffer, [C,\n <all others>.\n \n If two or more flavors share the best representation class, and that\n representation is one of the four explicitly listed, then one of those\n flavors will be chosen non-deterministically. If, however, no flavor has\n one of the four specified representations, the flavors will then be\n sorted by their charsets. Unicode charsets, such as \"UTF-16\", \"UTF-8\",\n \"UTF-16BE\", \"UTF-16LE\", and their aliases, are considered best. After\n them, the platform default charset and its aliases are selected.\n \"US-ASCII\" and its aliases are worst. All other charsets are chosen in\n alphabetical order, but only charsets supported by this implementation of\n the Java platform will be considered.\n \n If two or more flavors share the best charset, the flavors will then\n again be sorted by their representation classes in the following order:\n java.io.InputStream, java.nio.ByteBuffer, [B,\n <all others>.\n \n If two or more flavors share the best representation class, or if no\n flavor has one of the three specified representations, then one of those\n flavors will be chosen non-deterministically."}, {"method_name": "getReaderForText", "method_sig": "public Reader getReaderForText (Transferable transferable)\n                        throws UnsupportedFlavorException,\n                               IOException", "description": "Gets a Reader for a text flavor, decoded, if necessary, for the expected\n charset (encoding). The supported representation classes are\n java.io.Reader, java.lang.String,\n java.nio.CharBuffer, [C, java.io.InputStream,\n java.nio.ByteBuffer, and [B.\n \n Because text flavors which do not support the charset parameter are\n encoded in a non-standard format, this method should not be called for\n such flavors. However, in order to maintain backward-compatibility, if\n this method is called for such a flavor, this method will treat the\n flavor as though it supports the charset parameter and attempt to decode\n it accordingly. See selectBestTextFlavor for a list of text\n flavors which do not support the charset parameter."}, {"method_name": "getMimeType", "method_sig": "public String getMimeType()", "description": "Returns the MIME type string for this DataFlavor."}, {"method_name": "getRepresentationClass", "method_sig": "public Class<?> getRepresentationClass()", "description": "Returns the Class which objects supporting this\n DataFlavor will return when this DataFlavor is requested."}, {"method_name": "getHumanPresentableName", "method_sig": "public String getHumanPresentableName()", "description": "Returns the human presentable name for the data format that this\n DataFlavor represents. This name would be localized for different\n countries."}, {"method_name": "getPrimaryType", "method_sig": "public String getPrimaryType()", "description": "Returns the primary MIME type for this DataFlavor."}, {"method_name": "getSubType", "method_sig": "public String getSubType()", "description": "Returns the sub MIME type of this DataFlavor."}, {"method_name": "getParameter", "method_sig": "public String getParameter (String paramName)", "description": "Returns the human presentable name for this DataFlavor if\n paramName equals \"humanPresentableName\". Otherwise returns the\n MIME type value associated with paramName."}, {"method_name": "setHumanPresentableName", "method_sig": "public void setHumanPresentableName (String humanPresentableName)", "description": "Sets the human presentable name for the data format that this\n DataFlavor represents. This name would be localized for different\n countries."}, {"method_name": "equals", "method_sig": "public boolean equals (Object o)", "description": "Indicates whether some other object is \"equal to\" this one.\n \n The equals method implements an equivalence relation\n on non-null object references:\n \nIt is reflexive: for any non-null reference value\n     x, x.equals(x) should return\n     true.\n It is symmetric: for any non-null reference values\n     x and y, x.equals(y)\n     should return true if and only if\n     y.equals(x) returns true.\n It is transitive: for any non-null reference values\n     x, y, and z, if\n     x.equals(y) returns true and\n     y.equals(z) returns true, then\n     x.equals(z) should return true.\n It is consistent: for any non-null reference values\n     x and y, multiple invocations of\n     x.equals(y) consistently return true\n     or consistently return false, provided no\n     information used in equals comparisons on the\n     objects is modified.\n For any non-null reference value x,\n     x.equals(null) should return false.\n \n\n The equals method for class Object implements\n the most discriminating possible equivalence relation on objects;\n that is, for any non-null reference values x and\n y, this method returns true if and only\n if x and y refer to the same object\n (x == y has the value true).\n \n Note that it is generally necessary to override the hashCode\n method whenever this method is overridden, so as to maintain the\n general contract for the hashCode method, which states\n that equal objects must have equal hash codes.\n \n The equals comparison for the DataFlavor class is implemented as\n follows: Two DataFlavors are considered equal if and only if\n their MIME primary type and subtype and representation class are equal.\n Additionally, if the primary type is \"text\", the subtype denotes a text\n flavor which supports the charset parameter, and the representation class\n is not java.io.Reader, java.lang.String,\n java.nio.CharBuffer, or [C, the charset parameter\n must also be equal. If a charset is not explicitly specified for one or\n both DataFlavors, the platform default encoding is assumed. See\n selectBestTextFlavor for a list of text flavors which support the\n charset parameter."}, {"method_name": "equals", "method_sig": "public boolean equals (DataFlavor that)", "description": "This method has the same behavior as equals(Object). The only\n difference being that it takes a DataFlavor instance as a\n parameter."}, {"method_name": "equals", "method_sig": "@Deprecated\npublic boolean equals (String s)", "description": "Compares only the mimeType against the passed in String\n and representationClass is not considered in the comparison. If\n representationClass needs to be compared, then\n equals(new DataFlavor(s)) may be used."}, {"method_name": "hashCode", "method_sig": "public int hashCode()", "description": "Returns hash code for this DataFlavor. For two equal\n DataFlavors, hash codes are equal. For the String that\n matches DataFlavor.equals(String), it is not guaranteed that\n DataFlavor's hash code is equal to the hash code of the\n String."}, {"method_name": "match", "method_sig": "public boolean match (DataFlavor that)", "description": "Identical to equals(DataFlavor)."}, {"method_name": "isMimeTypeEqual", "method_sig": "public boolean isMimeTypeEqual (String mimeType)", "description": "Returns whether the string representation of the MIME type passed in is\n equivalent to the MIME type of this DataFlavor. Parameters are\n not included in the comparison."}, {"method_name": "isMimeTypeEqual", "method_sig": "public final boolean isMimeTypeEqual (DataFlavor dataFlavor)", "description": "Compares the mimeType of two DataFlavor objects. No\n parameters are considered."}, {"method_name": "isMimeTypeSerializedObject", "method_sig": "public boolean isMimeTypeSerializedObject()", "description": "Does the DataFlavor represent a serialized object?"}, {"method_name": "getDefaultRepresentationClass", "method_sig": "public final Class<?> getDefaultRepresentationClass()", "description": "Returns the default representation class."}, {"method_name": "getDefaultRepresentationClassAsString", "method_sig": "public final String getDefaultRepresentationClassAsString()", "description": "Returns the name of the default representation class."}, {"method_name": "isRepresentationClassInputStream", "method_sig": "public boolean isRepresentationClassInputStream()", "description": "Does the DataFlavor represent a java.io.InputStream?"}, {"method_name": "isRepresentationClassReader", "method_sig": "public boolean isRepresentationClassReader()", "description": "Returns whether the representation class for this DataFlavor is\n java.io.Reader or a subclass thereof."}, {"method_name": "isRepresentationClassCharBuffer", "method_sig": "public boolean isRepresentationClassCharBuffer()", "description": "Returns whether the representation class for this DataFlavor is\n java.nio.CharBuffer or a subclass thereof."}, {"method_name": "isRepresentationClassByteBuffer", "method_sig": "public boolean isRepresentationClassByteBuffer()", "description": "Returns whether the representation class for this DataFlavor is\n java.nio.ByteBuffer or a subclass thereof."}, {"method_name": "isRepresentationClassSerializable", "method_sig": "public boolean isRepresentationClassSerializable()", "description": "Returns true if the representation class can be serialized."}, {"method_name": "isRepresentationClassRemote", "method_sig": "public boolean isRepresentationClassRemote()", "description": "Returns true if the representation class is Remote."}, {"method_name": "isFlavorSerializedObjectType", "method_sig": "public boolean isFlavorSerializedObjectType()", "description": "Returns true if the DataFlavor specified represents a\n serialized object."}, {"method_name": "isFlavorRemoteObjectType", "method_sig": "public boolean isFlavorRemoteObjectType()", "description": "Returns true if the DataFlavor specified represents a\n remote object."}, {"method_name": "isFlavorJavaFileListType", "method_sig": "public boolean isFlavorJavaFileListType()", "description": "Returns true if the DataFlavor specified represents a\n list of file objects."}, {"method_name": "isFlavorTextType", "method_sig": "public boolean isFlavorTextType()", "description": "Returns whether this DataFlavor is a valid text flavor for this\n implementation of the Java platform. Only flavors equivalent to\n DataFlavor.stringFlavor and DataFlavors with a primary\n MIME type of \"text\" can be valid text flavors.\n \n If this flavor supports the charset parameter, it must be equivalent to\n DataFlavor.stringFlavor, or its representation must be\n java.io.Reader, java.lang.String,\n java.nio.CharBuffer, [C, java.io.InputStream,\n java.nio.ByteBuffer, or [B. If the representation is\n java.io.InputStream, java.nio.ByteBuffer, or [B,\n then this flavor's charset parameter must be supported by this\n implementation of the Java platform. If a charset is not specified, then\n the platform default charset, which is always supported, is assumed.\n \n If this flavor does not support the charset parameter, its representation\n must be java.io.InputStream, java.nio.ByteBuffer, or\n [B.\n \n See selectBestTextFlavor for a list of text flavors which support\n the charset parameter."}, {"method_name": "writeExternal", "method_sig": "public void writeExternal (ObjectOutput os)\n                   throws IOException", "description": "Serializes this DataFlavor."}, {"method_name": "readExternal", "method_sig": "public void readExternal (ObjectInput is)\n                  throws IOException,\n                         ClassNotFoundException", "description": "Restores this DataFlavor from a Serialized state."}, {"method_name": "clone", "method_sig": "public Object clone()\n             throws CloneNotSupportedException", "description": "Returns a clone of this DataFlavor."}, {"method_name": "normalizeMimeTypeParameter", "method_sig": "@Deprecated\nprotected String normalizeMimeTypeParameter (String parameterName,\n                                            String parameterValue)", "description": "Called on DataFlavor for every MIME Type parameter to allow\n DataFlavor subclasses to handle special parameters like the\n text/plain charset parameters, whose values are case insensitive.\n (MIME type parameter values are supposed to be case sensitive.\n \n This method is called for each parameter name/value pair and should\n return the normalized representation of the parameterValue."}, {"method_name": "normalizeMimeType", "method_sig": "@Deprecated\nprotected String normalizeMimeType (String mimeType)", "description": "Called for each MIME type string to give DataFlavor subtypes the\n opportunity to change how the normalization of MIME types is\n accomplished. One possible use would be to add default parameter/value\n pairs in cases where none are present in the MIME type string passed in."}]}