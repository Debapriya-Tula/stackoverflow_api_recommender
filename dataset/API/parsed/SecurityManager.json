{"name": "Class SecurityManager", "module": "java.base", "package": "java.lang", "text": "The security manager is a class that allows\n applications to implement a security policy. It allows an\n application to determine, before performing a possibly unsafe or\n sensitive operation, what the operation is and whether\n it is being attempted in a security context that allows the\n operation to be performed. The\n application can allow or disallow the operation.\n \n The SecurityManager class contains many methods with\n names that begin with the word check. These methods\n are called by various methods in the Java libraries before those\n methods perform certain potentially sensitive operations. The\n invocation of such a check method typically looks like this:\n \n     SecurityManager security = System.getSecurityManager();\n     if (security != null) {\n         security.checkXXX(argument, \u00a0.\u00a0.\u00a0.\u00a0);\n     }\n \n\n The security manager is thereby given an opportunity to prevent\n completion of the operation by throwing an exception. A security\n manager routine simply returns if the operation is permitted, but\n throws a SecurityException if the operation is not\n permitted.\n \n The current security manager is set by the\n setSecurityManager method in class\n System. The current security manager is obtained\n by the getSecurityManager method.\n \n The special method\n checkPermission(java.security.Permission)\n determines whether an access request indicated by a specified\n permission should be granted or denied. The\n default implementation calls\n\n \n   AccessController.checkPermission(perm);\n \n\n If a requested access is allowed,\n checkPermission returns quietly. If denied, a\n SecurityException is thrown.\n \n The default implementation of each of the other\n check methods in SecurityManager is to\n call the SecurityManager checkPermission method\n to determine if the calling thread has permission to perform the requested\n operation.\n \n Note that the checkPermission method with\n just a single permission argument always performs security checks\n within the context of the currently executing thread.\n Sometimes a security check that should be made within a given context\n will actually need to be done from within a\n different context (for example, from within a worker thread).\n The getSecurityContext method\n and the checkPermission\n method that includes a context argument are provided\n for this situation. The\n getSecurityContext method returns a \"snapshot\"\n of the current calling context. (The default implementation\n returns an AccessControlContext object.) A sample call is\n the following:\n\n \n   Object context = null;\n   SecurityManager sm = System.getSecurityManager();\n   if (sm != null) context = sm.getSecurityContext();\n \n\n The checkPermission method\n that takes a context object in addition to a permission\n makes access decisions based on that context,\n rather than on that of the current execution thread.\n Code within a different context can thus call that method,\n passing the permission and the\n previously-saved context object. A sample call, using the\n SecurityManager sm obtained as in the previous example,\n is the following:\n\n \n   if (sm != null) sm.checkPermission(permission, context);\n \nPermissions fall into these categories: File, Socket, Net,\n Security, Runtime, Property, AWT, Reflect, and Serializable.\n The classes managing these various\n permission categories are java.io.FilePermission,\n java.net.SocketPermission,\n java.net.NetPermission,\n java.security.SecurityPermission,\n java.lang.RuntimePermission,\n java.util.PropertyPermission,\n java.awt.AWTPermission,\n java.lang.reflect.ReflectPermission, and\n java.io.SerializablePermission.\n\n All but the first two (FilePermission and SocketPermission) are\n subclasses of java.security.BasicPermission, which itself\n is an abstract subclass of the\n top-level class for permissions, which is\n java.security.Permission. BasicPermission defines the\n functionality needed for all permissions that contain a name\n that follows the hierarchical property naming convention\n (for example, \"exitVM\", \"setFactory\", \"queuePrintJob\", etc).\n An asterisk\n may appear at the end of the name, following a \".\", or by itself, to\n signify a wildcard match. For example: \"a.*\" or \"*\" is valid,\n \"*a\" or \"a*b\" is not valid.\n\n FilePermission and SocketPermission are subclasses of the\n top-level class for permissions\n (java.security.Permission). Classes like these\n that have a more complicated name syntax than that used by\n BasicPermission subclass directly from Permission rather than from\n BasicPermission. For example,\n for a java.io.FilePermission object, the permission name is\n the path name of a file (or directory).\n\n Some of the permission classes have an \"actions\" list that tells\n the actions that are permitted for the object.  For example,\n for a java.io.FilePermission object, the actions list\n (such as \"read, write\") specifies which actions are granted for the\n specified file (or for files in the specified directory).\n\n Other permission classes are for \"named\" permissions -\n ones that contain a name but no actions list; you either have the\n named permission or you don't.\n\n Note: There is also a java.security.AllPermission\n permission that implies all permissions. It exists to simplify the work\n of system administrators who might need to perform multiple\n tasks that require all (or numerous) permissions.\n \n See Permissions in the Java Development Kit (JDK)\n for permission-related information.\n This document includes a table listing the various SecurityManager\n check methods and the permission(s) the default\n implementation of each such method requires.\n It also contains a table of the methods\n that require permissions, and for each such method tells\n which permission it requires.", "codes": ["public class SecurityManager\nextends Object"], "fields": [], "methods": [{"method_name": "getClassContext", "method_sig": "protected Class<?>[] getClassContext()", "description": "Returns the current execution stack as an array of classes.\n \n The length of the array is the number of methods on the execution\n stack. The element at index 0 is the class of the\n currently executing method, the element at index 1 is\n the class of that method's caller, and so on."}, {"method_name": "getSecurityContext", "method_sig": "public Object getSecurityContext()", "description": "Creates an object that encapsulates the current execution\n environment. The result of this method is used, for example, by the\n three-argument checkConnect method and by the\n two-argument checkRead method.\n These methods are needed because a trusted method may be called\n on to read a file or open a socket on behalf of another method.\n The trusted method needs to determine if the other (possibly\n untrusted) method would be allowed to perform the operation on its\n own.\n  The default implementation of this method is to return\n an AccessControlContext object."}, {"method_name": "checkPermission", "method_sig": "public void checkPermission (Permission perm)", "description": "Throws a SecurityException if the requested\n access, specified by the given permission, is not permitted based\n on the security policy currently in effect.\n \n This method calls AccessController.checkPermission\n with the given permission."}, {"method_name": "checkPermission", "method_sig": "public void checkPermission (Permission perm,\n                            Object context)", "description": "Throws a SecurityException if the\n specified security context is denied access to the resource\n specified by the given permission.\n The context must be a security\n context returned by a previous call to\n getSecurityContext and the access control\n decision is based upon the configured security policy for\n that security context.\n \n If context is an instance of\n AccessControlContext then the\n AccessControlContext.checkPermission method is\n invoked with the specified permission.\n \n If context is not an instance of\n AccessControlContext then a\n SecurityException is thrown."}, {"method_name": "checkCreateClassLoader", "method_sig": "public void checkCreateClassLoader()", "description": "Throws a SecurityException if the\n calling thread is not allowed to create a new class loader.\n \n This method calls checkPermission with the\n RuntimePermission(\"createClassLoader\")\n permission.\n \n If you override this method, then you should make a call to\n super.checkCreateClassLoader\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkAccess", "method_sig": "public void checkAccess (Thread t)", "description": "Throws a SecurityException if the\n calling thread is not allowed to modify the thread argument.\n \n This method is invoked for the current security manager by the\n stop, suspend, resume,\n setPriority, setName, and\n setDaemon methods of class Thread.\n \n If the thread argument is a system thread (belongs to\n the thread group with a null parent) then\n this method calls checkPermission with the\n RuntimePermission(\"modifyThread\") permission.\n If the thread argument is not a system thread,\n this method just returns silently.\n \n Applications that want a stricter policy should override this\n method. If this method is overridden, the method that overrides\n it should additionally check to see if the calling thread has the\n RuntimePermission(\"modifyThread\") permission, and\n if so, return silently. This is to ensure that code granted\n that permission (such as the JDK itself) is allowed to\n manipulate any thread.\n \n If this method is overridden, then\n super.checkAccess should\n be called by the first statement in the overridden method, or the\n equivalent security check should be placed in the overridden method."}, {"method_name": "checkAccess", "method_sig": "public void checkAccess (ThreadGroup g)", "description": "Throws a SecurityException if the\n calling thread is not allowed to modify the thread group argument.\n \n This method is invoked for the current security manager when a\n new child thread or child thread group is created, and by the\n setDaemon, setMaxPriority,\n stop, suspend, resume, and\n destroy methods of class ThreadGroup.\n \n If the thread group argument is the system thread group (\n has a null parent) then\n this method calls checkPermission with the\n RuntimePermission(\"modifyThreadGroup\") permission.\n If the thread group argument is not the system thread group,\n this method just returns silently.\n \n Applications that want a stricter policy should override this\n method. If this method is overridden, the method that overrides\n it should additionally check to see if the calling thread has the\n RuntimePermission(\"modifyThreadGroup\") permission, and\n if so, return silently. This is to ensure that code granted\n that permission (such as the JDK itself) is allowed to\n manipulate any thread.\n \n If this method is overridden, then\n super.checkAccess should\n be called by the first statement in the overridden method, or the\n equivalent security check should be placed in the overridden method."}, {"method_name": "checkExit", "method_sig": "public void checkExit (int status)", "description": "Throws a SecurityException if the\n calling thread is not allowed to cause the Java Virtual Machine to\n halt with the specified status code.\n \n This method is invoked for the current security manager by the\n exit method of class Runtime. A status\n of 0 indicates success; other values indicate various\n errors.\n \n This method calls checkPermission with the\n RuntimePermission(\"exitVM.\"+status) permission.\n \n If you override this method, then you should make a call to\n super.checkExit\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkExec", "method_sig": "public void checkExec (String cmd)", "description": "Throws a SecurityException if the\n calling thread is not allowed to create a subprocess.\n \n This method is invoked for the current security manager by the\n exec methods of class Runtime.\n \n This method calls checkPermission with the\n FilePermission(cmd,\"execute\") permission\n if cmd is an absolute path, otherwise it calls\n checkPermission with\n FilePermission(\"<<ALL FILES>>\",\"execute\").\n \n If you override this method, then you should make a call to\n super.checkExec\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkLink", "method_sig": "public void checkLink (String lib)", "description": "Throws a SecurityException if the\n calling thread is not allowed to dynamic link the library code\n specified by the string argument file. The argument is either a\n simple library name or a complete filename.\n \n This method is invoked for the current security manager by\n methods load and loadLibrary of class\n Runtime.\n \n This method calls checkPermission with the\n RuntimePermission(\"loadLibrary.\"+lib) permission.\n \n If you override this method, then you should make a call to\n super.checkLink\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkRead", "method_sig": "public void checkRead (FileDescriptor fd)", "description": "Throws a SecurityException if the\n calling thread is not allowed to read from the specified file\n descriptor.\n \n This method calls checkPermission with the\n RuntimePermission(\"readFileDescriptor\")\n permission.\n \n If you override this method, then you should make a call to\n super.checkRead\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkRead", "method_sig": "public void checkRead (String file)", "description": "Throws a SecurityException if the\n calling thread is not allowed to read the file specified by the\n string argument.\n \n This method calls checkPermission with the\n FilePermission(file,\"read\") permission.\n \n If you override this method, then you should make a call to\n super.checkRead\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkRead", "method_sig": "public void checkRead (String file,\n                      Object context)", "description": "Throws a SecurityException if the\n specified security context is not allowed to read the file\n specified by the string argument. The context must be a security\n context returned by a previous call to\n getSecurityContext.\n  If context is an instance of\n AccessControlContext then the\n AccessControlContext.checkPermission method will\n be invoked with the FilePermission(file,\"read\") permission.\n  If context is not an instance of\n AccessControlContext then a\n SecurityException is thrown.\n \n If you override this method, then you should make a call to\n super.checkRead\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkWrite", "method_sig": "public void checkWrite (FileDescriptor fd)", "description": "Throws a SecurityException if the\n calling thread is not allowed to write to the specified file\n descriptor.\n \n This method calls checkPermission with the\n RuntimePermission(\"writeFileDescriptor\")\n permission.\n \n If you override this method, then you should make a call to\n super.checkWrite\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkWrite", "method_sig": "public void checkWrite (String file)", "description": "Throws a SecurityException if the\n calling thread is not allowed to write to the file specified by\n the string argument.\n \n This method calls checkPermission with the\n FilePermission(file,\"write\") permission.\n \n If you override this method, then you should make a call to\n super.checkWrite\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkDelete", "method_sig": "public void checkDelete (String file)", "description": "Throws a SecurityException if the\n calling thread is not allowed to delete the specified file.\n \n This method is invoked for the current security manager by the\n delete method of class File.\n \n This method calls checkPermission with the\n FilePermission(file,\"delete\") permission.\n \n If you override this method, then you should make a call to\n super.checkDelete\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkConnect", "method_sig": "public void checkConnect (String host,\n                         int port)", "description": "Throws a SecurityException if the\n calling thread is not allowed to open a socket connection to the\n specified host and port number.\n \n A port number of -1 indicates that the calling\n method is attempting to determine the IP address of the specified\n host name.\n \n This method calls checkPermission with the\n SocketPermission(host+\":\"+port,\"connect\") permission if\n the port is not equal to -1. If the port is equal to -1, then\n it calls checkPermission with the\n SocketPermission(host,\"resolve\") permission.\n \n If you override this method, then you should make a call to\n super.checkConnect\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkConnect", "method_sig": "public void checkConnect (String host,\n                         int port,\n                         Object context)", "description": "Throws a SecurityException if the\n specified security context is not allowed to open a socket\n connection to the specified host and port number.\n \n A port number of -1 indicates that the calling\n method is attempting to determine the IP address of the specified\n host name.\n  If context is not an instance of\n AccessControlContext then a\n SecurityException is thrown.\n \n Otherwise, the port number is checked. If it is not equal\n to -1, the context's checkPermission\n method is called with a\n SocketPermission(host+\":\"+port,\"connect\") permission.\n If the port is equal to -1, then\n the context's checkPermission method\n is called with a\n SocketPermission(host,\"resolve\") permission.\n \n If you override this method, then you should make a call to\n super.checkConnect\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkListen", "method_sig": "public void checkListen (int port)", "description": "Throws a SecurityException if the\n calling thread is not allowed to wait for a connection request on\n the specified local port number.\n \n This method calls checkPermission with the\n SocketPermission(\"localhost:\"+port,\"listen\").\n \n If you override this method, then you should make a call to\n super.checkListen\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkAccept", "method_sig": "public void checkAccept (String host,\n                        int port)", "description": "Throws a SecurityException if the\n calling thread is not permitted to accept a socket connection from\n the specified host and port number.\n \n This method is invoked for the current security manager by the\n accept method of class ServerSocket.\n \n This method calls checkPermission with the\n SocketPermission(host+\":\"+port,\"accept\") permission.\n \n If you override this method, then you should make a call to\n super.checkAccept\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkMulticast", "method_sig": "public void checkMulticast (InetAddress maddr)", "description": "Throws a SecurityException if the\n calling thread is not allowed to use\n (join/leave/send/receive) IP multicast.\n \n This method calls checkPermission with the\n java.net.SocketPermission(maddr.getHostAddress(),\n \"accept,connect\") permission.\n \n If you override this method, then you should make a call to\n super.checkMulticast\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkMulticast", "method_sig": "@Deprecated(since=\"1.4\")\npublic void checkMulticast (InetAddress maddr,\n                           byte ttl)", "description": "Throws a SecurityException if the\n calling thread is not allowed to use\n (join/leave/send/receive) IP multicast.\n \n This method calls checkPermission with the\n java.net.SocketPermission(maddr.getHostAddress(),\n \"accept,connect\") permission.\n \n If you override this method, then you should make a call to\n super.checkMulticast\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkPropertiesAccess", "method_sig": "public void checkPropertiesAccess()", "description": "Throws a SecurityException if the\n calling thread is not allowed to access or modify the system\n properties.\n \n This method is used by the getProperties and\n setProperties methods of class System.\n \n This method calls checkPermission with the\n PropertyPermission(\"*\", \"read,write\") permission.\n \n If you override this method, then you should make a call to\n super.checkPropertiesAccess\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkPropertyAccess", "method_sig": "public void checkPropertyAccess (String key)", "description": "Throws a SecurityException if the\n calling thread is not allowed to access the system property with\n the specified key name.\n \n This method is used by the getProperty method of\n class System.\n \n This method calls checkPermission with the\n PropertyPermission(key, \"read\") permission.\n \n If you override this method, then you should make a call to\n super.checkPropertyAccess\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkPrintJobAccess", "method_sig": "public void checkPrintJobAccess()", "description": "Throws a SecurityException if the\n calling thread is not allowed to initiate a print job request.\n \n This method calls\n checkPermission with the\n RuntimePermission(\"queuePrintJob\") permission.\n \n If you override this method, then you should make a call to\n super.checkPrintJobAccess\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkPackageAccess", "method_sig": "public void checkPackageAccess (String pkg)", "description": "Throws a SecurityException if the calling thread is not allowed\n to access the specified package.\n \n During class loading, this method may be called by the loadClass\n method of class loaders and by the Java Virtual Machine to ensure that\n the caller is allowed to access the package of the class that is\n being loaded.\n \n This method checks if the specified package starts with or equals\n any of the packages in the package.access Security Property.\n An implementation may also check the package against an additional\n list of restricted packages as noted below. If the package is restricted,\n checkPermission(Permission) is called with a\n RuntimePermission(\"accessClassInPackage.\"+pkg) permission.\n \n If this method is overridden, then super.checkPackageAccess\n should be called as the first line in the overridden method."}, {"method_name": "checkPackageDefinition", "method_sig": "public void checkPackageDefinition (String pkg)", "description": "Throws a SecurityException if the calling thread is not\n allowed to define classes in the specified package.\n \n This method is called by the loadClass method of some\n class loaders.\n \n This method checks if the specified package starts with or equals\n any of the packages in the package.definition Security\n Property. An implementation may also check the package against an\n additional list of restricted packages as noted below. If the package\n is restricted, checkPermission(Permission) is called with a\n RuntimePermission(\"defineClassInPackage.\"+pkg) permission.\n \n If this method is overridden, then super.checkPackageDefinition\n should be called as the first line in the overridden method."}, {"method_name": "checkSetFactory", "method_sig": "public void checkSetFactory()", "description": "Throws a SecurityException if the\n calling thread is not allowed to set the socket factory used by\n ServerSocket or Socket, or the stream\n handler factory used by URL.\n \n This method calls checkPermission with the\n RuntimePermission(\"setFactory\") permission.\n \n If you override this method, then you should make a call to\n super.checkSetFactory\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "checkSecurityAccess", "method_sig": "public void checkSecurityAccess (String target)", "description": "Determines whether the permission with the specified permission target\n name should be granted or denied.\n\n  If the requested permission is allowed, this method returns\n quietly. If denied, a SecurityException is raised.\n\n  This method creates a SecurityPermission object for\n the given permission target name and calls checkPermission\n with it.\n\n  See the documentation for\n SecurityPermission for\n a list of possible permission target names.\n\n  If you override this method, then you should make a call to\n super.checkSecurityAccess\n at the point the overridden method would normally throw an\n exception."}, {"method_name": "getThreadGroup", "method_sig": "public ThreadGroup getThreadGroup()", "description": "Returns the thread group into which to instantiate any new\n thread being created at the time this is being called.\n By default, it returns the thread group of the current\n thread. This should be overridden by a specific security\n manager to return the appropriate thread group."}]}