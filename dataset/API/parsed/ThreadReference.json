{"name": "Interface ThreadReference", "module": "jdk.jdi", "package": "com.sun.jdi", "text": "A thread object from the target VM.\n A ThreadReference is an ObjectReference with additional\n access to thread-specific information from the target VM.", "codes": ["public interface ThreadReference\nextends ObjectReference"], "fields": [{"field_name": "THREAD_STATUS_UNKNOWN", "field_sig": "static final\u00a0int THREAD_STATUS_UNKNOWN", "description": "Thread status is unknown"}, {"field_name": "THREAD_STATUS_ZOMBIE", "field_sig": "static final\u00a0int THREAD_STATUS_ZOMBIE", "description": "Thread has completed execution"}, {"field_name": "THREAD_STATUS_RUNNING", "field_sig": "static final\u00a0int THREAD_STATUS_RUNNING", "description": "Thread is runnable"}, {"field_name": "THREAD_STATUS_SLEEPING", "field_sig": "static final\u00a0int THREAD_STATUS_SLEEPING", "description": "Thread is sleeping - Thread.sleep() or JVM_Sleep() was called"}, {"field_name": "THREAD_STATUS_MONITOR", "field_sig": "static final\u00a0int THREAD_STATUS_MONITOR", "description": "Thread is waiting on a java monitor"}, {"field_name": "THREAD_STATUS_WAIT", "field_sig": "static final\u00a0int THREAD_STATUS_WAIT", "description": "Thread is waiting - Object.wait() or JVM_MonitorWait() was called"}, {"field_name": "THREAD_STATUS_NOT_STARTED", "field_sig": "static final\u00a0int THREAD_STATUS_NOT_STARTED", "description": "Thread has not yet been started"}], "methods": [{"method_name": "name", "method_sig": "String name()", "description": "Returns the name of this thread."}, {"method_name": "suspend", "method_sig": "void suspend()", "description": "Suspends this thread. The thread can be resumed through\n resume() or resumed with other threads through\n VirtualMachine.resume().\n \n Unlike Thread.suspend(),\n suspends of both the virtual machine and individual threads are\n counted. Before a thread will run again, it must be resumed\n (through resume() or resume())\n the same number of times it has been suspended.\n \n Suspending single threads with this method has the same dangers\n as Thread.suspend(). If the suspended thread\n holds a monitor needed by another running thread, deadlock is\n possible in the target VM (at least until the suspended thread\n is resumed again).\n \n The suspended thread is guaranteed to remain suspended until\n resumed through one of the JDI resume methods mentioned above;\n the application in the target VM cannot resume the suspended thread\n through Thread.resume()."}, {"method_name": "resume", "method_sig": "void resume()", "description": "Resumes this thread. If this thread was not previously suspended\n through suspend() or through VirtualMachine.suspend(),\n or because of a SUSPEND_ALL or SUSPEND_EVENT_THREAD event, then\n invoking this method has no effect. Otherwise, the count of pending\n suspends on this thread is decremented. If it is decremented to 0,\n the thread will continue to execute.\n Note: the normal way to resume from an event related suspension is\n via EventSet.resume()."}, {"method_name": "suspendCount", "method_sig": "int suspendCount()", "description": "Returns the number of pending suspends for this thread. See\n suspend() for an explanation of counted suspends."}, {"method_name": "stop", "method_sig": "void stop (ObjectReference throwable)\n   throws InvalidTypeException", "description": "Stops this thread with an asynchronous exception.\n A debugger thread in the target VM will stop this thread\n with the given Throwable object."}, {"method_name": "interrupt", "method_sig": "void interrupt()", "description": "Interrupts this thread unless the thread has been suspended by the\n debugger."}, {"method_name": "status", "method_sig": "int status()", "description": "Returns the thread's status. If the thread is not suspended the\n thread's current status is returned. If the thread is suspended, the\n thread's status before the suspension is returned (or\n THREAD_STATUS_UNKNOWN if this information is not available.\n isSuspended() can be used to determine if the thread has been\n suspended."}, {"method_name": "isSuspended", "method_sig": "boolean isSuspended()", "description": "Determines whether the thread has been suspended by the\n the debugger."}, {"method_name": "isAtBreakpoint", "method_sig": "boolean isAtBreakpoint()", "description": "Determines whether the thread is suspended at a breakpoint."}, {"method_name": "threadGroup", "method_sig": "ThreadGroupReference threadGroup()", "description": "Returns this thread's thread group."}, {"method_name": "frameCount", "method_sig": "int frameCount()\n        throws IncompatibleThreadStateException", "description": "Returns the number of stack frames in the thread's current\n call stack.\n The thread must be suspended (normally through an interruption\n to the VM) to get this information, and\n it is only valid until the thread is resumed again."}, {"method_name": "frames", "method_sig": "List<StackFrame> frames()\n                 throws IncompatibleThreadStateException", "description": "Returns a List containing each StackFrame in the\n thread's current call stack.\n The thread must be suspended (normally through an interruption\n to the VM) to get this information, and\n it is only valid until the thread is resumed again."}, {"method_name": "frame", "method_sig": "StackFrame frame (int index)\n          throws IncompatibleThreadStateException", "description": "Returns the StackFrame at the given index in the\n thread's current call stack. Index 0 retrieves the current\n frame; higher indices retrieve caller frames.\n The thread must be suspended (normally through an interruption\n to the VM) to get this information, and\n it is only valid until the thread is resumed again."}, {"method_name": "frames", "method_sig": "List<StackFrame> frames (int start,\n                        int length)\n                 throws IncompatibleThreadStateException", "description": "Returns a List containing a range of StackFrame mirrors\n from the thread's current call stack.\n The thread must be suspended (normally through an interruption\n to the VM) to get this information, and\n it is only valid until the thread is resumed again."}, {"method_name": "ownedMonitors", "method_sig": "List<ObjectReference> ownedMonitors()\n                             throws IncompatibleThreadStateException", "description": "Returns a List containing an ObjectReference for\n each monitor owned by the thread.\n A monitor is owned by a thread if it has been entered\n (via the synchronized statement or entry into a synchronized\n method) and has not been relinquished through Object.wait().\n \n Not all target virtual machines support this operation.\n Use VirtualMachine.canGetOwnedMonitorInfo()\n to determine if the operation is supported."}, {"method_name": "ownedMonitorsAndFrames", "method_sig": "List<MonitorInfo> ownedMonitorsAndFrames()\n                                  throws IncompatibleThreadStateException", "description": "Returns a List containing a MonitorInfo object for\n each monitor owned by the thread.\n A monitor is owned by a thread if it has been entered\n (via the synchronized statement or entry into a synchronized\n method) and has not been relinquished through Object.wait().\n \n Not all target virtual machines support this operation.\n Use VirtualMachine.canGetMonitorFrameInfo()\n to determine if the operation is supported."}, {"method_name": "currentContendedMonitor", "method_sig": "ObjectReference currentContendedMonitor()\n                                 throws IncompatibleThreadStateException", "description": "Returns an ObjectReference for the monitor, if any,\n for which this thread is currently waiting.\n The thread can be waiting for a monitor through entry into a\n synchronized method, the synchronized statement, or\n Object.wait().  The status() method can be used\n to differentiate between the first two cases and the third.\n \n Not all target virtual machines support this operation.\n Use VirtualMachine.canGetCurrentContendedMonitor()\n to determine if the operation is supported."}, {"method_name": "popFrames", "method_sig": "void popFrames (StackFrame frame)\n        throws IncompatibleThreadStateException", "description": "Pop stack frames.\n \n All frames up to and including the frame are\n popped off the stack.\n The frame previous to the parameter frame\n will become the current frame.\n \n After this operation, this thread will be\n suspended at the invoke instruction of the target method\n that created frame.\n The frame's method can be reentered with a step into\n the instruction.\n \n The operand stack is restored, however, any changes\n to the arguments that occurred in the called method, remain.\n For example, if the method foo:\n \n    void foo(int x) {\n        System.out.println(\"Foo: \" + x);\n        x = 4;\n        System.out.println(\"pop here\");\n    }\n \n was called with foo(7) and foo\n is popped at the second println and resumed,\n it will print: Foo: 4.\n \n Locks acquired by a popped frame are released when it\n is popped. This applies to synchronized methods that\n are popped, and to any synchronized blocks within them.\n \n Finally blocks are not executed.\n \n No aspect of state, other than this thread's execution point and\n locks, is affected by this call.  Specifically, the values of\n fields are unchanged, as are external resources such as\n I/O streams.  Additionally, the target program might be\n placed in a state that is impossible with normal program flow;\n for example, order of lock acquisition might be perturbed.\n Thus the target program may\n proceed differently than the user would expect.\n \n The specified thread must be suspended.\n \n All StackFrame objects for this thread are\n invalidated.\n \n No events are generated by this method.\n \n None of the frames through and including the frame for the caller\n of frame may be native.\n \n Not all target virtual machines support this operation.\n Use VirtualMachine.canPopFrames()\n to determine if the operation is supported."}, {"method_name": "forceEarlyReturn", "method_sig": "void forceEarlyReturn (Value value)\n               throws InvalidTypeException,\n                      ClassNotLoadedException,\n                      IncompatibleThreadStateException", "description": "Force a method to return before it reaches a return\n statement.\n \n The method which will return early is referred to as the\n called method. The called method is the current method (as\n defined by the Frames section in the Java Virtual Machine\n Specification) for the specified thread at the time this\n method is called.\n \n The thread must be suspended.\n The return occurs when execution of Java programming\n language code is resumed on this thread. Between the call to\n this method and resumption of thread execution, the\n state of the stack is undefined.\n \n No further instructions are executed in the called\n method. Specifically, finally blocks are not executed. Note:\n this can cause inconsistent states in the application.\n \n A lock acquired by calling the called method (if it is a\n synchronized method) and locks acquired by entering\n synchronized blocks within the called method are\n released. Note: this does not apply to native locks or\n java.util.concurrent.locks locks.\n \n Events, such as MethodExit, are generated as they would be in\n a normal return.\n \n The called method must be a non-native Java programming\n language method. Forcing return on a thread with only one\n frame on the stack causes the thread to exit when resumed.\n \n The value argument is the value that the\n method is to return.\n If the return type of the method is void, then value must\n be a  VoidValue.\n Object values must be assignment compatible with the method return type\n (This implies that the method return type must be loaded through the\n enclosing class's class loader). Primitive values must be\n either assignment compatible with the method return type or must be\n convertible to the variable type without loss of information.\n See JLS section 5.2 for more information on assignment\n compatibility.\n \n Not all target virtual machines support this operation.\n Use VirtualMachine.canForceEarlyReturn()\n to determine if the operation is supported."}]}