{"name": "Class DynamicLinkerFactory", "module": "jdk.dynalink", "package": "jdk.dynalink", "text": "A factory class for creating DynamicLinker objects. Dynamic linkers\n are the central objects in Dynalink; these are composed of several\n GuardingDynamicLinker objects and coordinate linking of call sites\n with them. The usual dynamic linker is a linker\n composed of all GuardingDynamicLinker objects explicitly pre-created\n by the user of the factory and configured with\n setPrioritizedLinkers(List), as well as any\n automatically discovered ones, and\n finally the ones configured with setFallbackLinkers(List); this last\n category usually includes BeansLinker.", "codes": ["public final class DynamicLinkerFactory\nextends Object"], "fields": [], "methods": [{"method_name": "setClassLoader", "method_sig": "public void setClassLoader (ClassLoader classLoader)", "description": "Sets the class loader for automatic discovery of available guarding\n dynamic linkers. GuardingDynamicLinkerExporter implementations\n available through this class loader will be automatically instantiated\n using the ServiceLoader mechanism and the linkers they provide\n will be incorporated into DynamicLinkers that this factory\n creates. This allows for cross-language interoperability where call sites\n belonging to this language runtime can be linked by linkers from these\n automatically discovered runtimes if their native objects are passed to\n this runtime. If class loader is not set explicitly by invoking this\n method, then the thread context class loader of the thread invoking\n createLinker() will be used. If this method is invoked\n explicitly with null then ServiceLoader.loadInstalled(Class) will\n be used to load the linkers."}, {"method_name": "setPrioritizedLinkers", "method_sig": "public void setPrioritizedLinkers (List<? extends GuardingDynamicLinker> prioritizedLinkers)", "description": "Sets the prioritized guarding dynamic linkers. Language runtimes using\n Dynalink will usually have at least one linker for their own language.\n These linkers will be consulted first by the resulting dynamic linker\n when it is linking call sites, before any autodiscovered and fallback\n linkers. If the factory also autodiscovers a linker class matching one\n of the prioritized linkers, the autodiscovered class will be ignored and\n the explicit prioritized instance will be used."}, {"method_name": "setPrioritizedLinkers", "method_sig": "public void setPrioritizedLinkers (GuardingDynamicLinker... prioritizedLinkers)", "description": "Sets the prioritized guarding dynamic linkers. Identical to calling\n setPrioritizedLinkers(List) with\n Arrays.asList(prioritizedLinkers)."}, {"method_name": "setPrioritizedLinker", "method_sig": "public void setPrioritizedLinker (GuardingDynamicLinker prioritizedLinker)", "description": "Sets a single prioritized linker. Identical to calling\n setPrioritizedLinkers(List) with a single-element list."}, {"method_name": "setFallbackLinkers", "method_sig": "public void setFallbackLinkers (List<? extends GuardingDynamicLinker> fallbackLinkers)", "description": "Sets the fallback guarding dynamic linkers. These linkers will be\n consulted last by the resulting dynamic linker when it is linking call\n sites, after any autodiscovered and prioritized linkers. If the factory\n also autodiscovers a linker class matching one of the fallback linkers,\n the autodiscovered class will be ignored and the explicit fallback\n instance will be used."}, {"method_name": "setFallbackLinkers", "method_sig": "public void setFallbackLinkers (GuardingDynamicLinker... fallbackLinkers)", "description": "Sets the fallback guarding dynamic linkers. Identical to calling\n setFallbackLinkers(List) with\n Arrays.asList(fallbackLinkers)."}, {"method_name": "setSyncOnRelink", "method_sig": "public void setSyncOnRelink (boolean syncOnRelink)", "description": "Sets whether the dynamic linker created by this factory will invoke\n MutableCallSite.syncAll(MutableCallSite[]) after a call site is\n relinked. Defaults to false. You probably want to set it to true if your\n runtime supports multithreaded execution of dynamically linked code."}, {"method_name": "setUnstableRelinkThreshold", "method_sig": "public void setUnstableRelinkThreshold (int unstableRelinkThreshold)", "description": "Sets the unstable relink threshold; the number of times a call site is\n relinked after which it will be considered unstable, and subsequent link\n requests for it will indicate this. Defaults to 8 when not set explicitly."}, {"method_name": "setPrelinkTransformer", "method_sig": "public void setPrelinkTransformer (GuardedInvocationTransformer prelinkTransformer)", "description": "Set the pre-link transformer. This is a\n GuardedInvocationTransformer that will get the final chance to\n modify the guarded invocation after it has been created by a component\n linker and before the dynamic linker links it into the call site. It is\n normally used to adapt the return value type of the invocation to the\n type of the call site. When not set explicitly, a default pre-link\n transformer will be used that simply calls\n GuardedInvocation.asType(LinkerServices, MethodType). Customized\n pre-link transformers are rarely needed; they are mostly used as a\n building block for implementing advanced techniques such as code\n deoptimization strategies."}, {"method_name": "setAutoConversionStrategy", "method_sig": "public void setAutoConversionStrategy (MethodTypeConversionStrategy autoConversionStrategy)", "description": "Sets an object representing the conversion strategy for automatic type\n conversions. After\n LinkerServices.asType(MethodHandle, MethodType) has applied all\n custom conversions to a method handle, it still needs to effect\n method\n invocation conversions that can usually be automatically applied as per\n MethodHandle.asType(MethodType). However, sometimes language\n runtimes will want to customize even those conversions for their own call\n sites. A typical example is allowing unboxing of null return values,\n which is by default prohibited by ordinary\n MethodHandles.asType(). In this case, a language runtime can\n install its own custom automatic conversion strategy, that can deal with\n null values. Note that when the strategy's\n MethodTypeConversionStrategy.asType(MethodHandle, MethodType)\n is invoked, the custom language conversions will already have been\n applied to the method handle, so by design the difference between the\n handle's current method type and the desired final type will always only\n be ones that can be subjected to method invocation conversions. The\n strategy also doesn't need to invoke a final\n MethodHandle.asType() as that will be done internally as the\n final step."}, {"method_name": "setInternalObjectsFilter", "method_sig": "public void setInternalObjectsFilter (MethodHandleTransformer internalObjectsFilter)", "description": "Sets a method handle transformer that is supposed to act as the\n implementation of\n LinkerServices.filterInternalObjects(MethodHandle) for linker\n services of dynamic linkers created by this factory. Some language\n runtimes can have internal objects that should not escape their scope.\n They can add a transformer here that will modify the method handle so\n that any parameters that can receive potentially internal language\n runtime objects will have a filter added on them to prevent them from\n escaping, potentially by wrapping them. The transformer can also\n potentially add an unwrapping filter to the return value.\n DefaultInternalObjectFilter is provided as a convenience class\n for easily creating such filtering transformers."}, {"method_name": "createLinker", "method_sig": "public DynamicLinker createLinker()", "description": "Creates a new dynamic linker based on the current configuration. This\n method can be invoked more than once to create multiple dynamic linkers.\n Automatically discovered linkers are newly instantiated on every\n invocation of this method. It is allowed to change the factory's\n configuration between invocations. The method is not thread safe. After\n invocation, callers can invoke getAutoLoadingErrors() to\n retrieve a list of ServiceConfigurationErrors that occurred while\n trying to load automatically discovered linkers. These are never thrown\n from the call to this method as it makes every effort to recover from\n them and ignore the failing linkers."}, {"method_name": "getAutoLoadingErrors", "method_sig": "public List<ServiceConfigurationError> getAutoLoadingErrors()", "description": "Returns a list of ServiceConfigurationErrors that were\n encountered while loading automatically discovered linkers during the\n last invocation of createLinker(). They can be any non-Dynalink\n specific service configuration issues, as well as some Dynalink-specific\n errors when an exporter that the factory tried to automatically load:\n \ndid not have the runtime permission named\n GuardingDynamicLinkerExporter.AUTOLOAD_PERMISSION_NAME in a\n system with a security manager, or\nreturned null from Supplier.get(), or\nthe list returned from Supplier.get()\n had a null element.\n"}]}