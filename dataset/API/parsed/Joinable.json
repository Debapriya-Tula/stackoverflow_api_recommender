{"name": "Interface Joinable", "module": "java.sql.rowset", "package": "javax.sql.rowset", "text": "1.0 Background\n The Joinable interface provides the methods for getting and\n setting a match column, which is the basis for forming the SQL JOIN\n formed by adding RowSet objects to a JoinRowSet\n object.\n \n Any standard RowSet implementation may implement\n the Joinable interface in order to be\n added to a JoinRowSet object. Implementing this interface gives\n a RowSet object the ability to use Joinable methods,\n which set, retrieve, and get information about match columns.  An\n application may add a\n RowSet object that has not implemented the Joinable\n interface to a JoinRowSet object, but to do so it must use one\n of the JoinRowSet.addRowSet methods that takes both a\n RowSet object and a match column or an array of RowSet\n objects and an array of match columns.\n \n To get access to the methods in the Joinable interface, a\n RowSet object implements at least one of the\n five standard RowSet interfaces and also implements the\n Joinable interface.  In addition, most RowSet\n objects extend the BaseRowSet class.  For example:\n \n     class MyRowSetImpl extends BaseRowSet implements CachedRowSet, Joinable {\n         :\n         :\n     }\n \n2.0 Usage Guidelines\n\n The methods in the Joinable interface allow a RowSet object\n to set a match column, retrieve a match column, or unset a match column, which is\n the column upon which an SQL JOIN can be based.\n An instance of a class that implements these methods can be added to a\n JoinRowSet object to allow an SQL JOIN relationship to\n  be established.\n\n \n     CachedRowSet crs = new MyRowSetImpl();\n     crs.populate((ResultSet)rs);\n     (Joinable)crs.setMatchColumnIndex(1);\n\n     JoinRowSet jrs = new JoinRowSetImpl();\n     jrs.addRowSet(crs);\n \n In the previous example, crs is a CachedRowSet object that\n has implemented the Joinable interface.  In the following example,\n crs2 has not, so it must supply the match column as an argument to the\n addRowSet method. This example assumes that column 1 is the match\n column.\n \n     CachedRowSet crs2 = new MyRowSetImpl();\n     crs2.populate((ResultSet)rs);\n\n     JoinRowSet jrs2 = new JoinRowSetImpl();\n     jrs2.addRowSet(crs2, 1);\n \n\n The JoinRowSet interface makes it possible to get data from one or\n more RowSet objects consolidated into one table without having to incur\n the expense of creating a connection to a database. It is therefore ideally suited\n for use by disconnected RowSet objects. Nevertheless, any\n RowSet object may implement this interface\n regardless of whether it is connected or disconnected. Note that a\n JdbcRowSet object, being always connected to its data source, can\n become part of an SQL JOIN directly without having to become part\n of a JoinRowSet object.\n\n 3.0 Managing Multiple Match Columns\n The index array passed into the setMatchColumn methods indicates\n how many match columns are being set (the length of the array) in addition to\n which columns will be used for the match. For example:\n \n     int[] i = {1, 2, 4, 7}; // indicates four match columns, with column\n                             // indexes 1, 2, 4, 7 participating in the JOIN.\n     Joinable.setMatchColumn(i);\n \n Subsequent match columns may be added as follows to a different Joinable\n object (a RowSet object that has implemented the Joinable\n interface).\n \n     int[] w = {3, 2, 5, 3};\n     Joinable2.setMatchColumn(w);\n \n When an application adds two or more RowSet objects to a\n JoinRowSet object, the order of the indexes in the array is\n particularly important. Each index of\n the array maps directly to the corresponding index of the previously added\n RowSet object. If overlap or underlap occurs, the match column\n data is maintained in the event an additional Joinable RowSet is\n added and needs to relate to the match column data. Therefore, applications\n can set multiple match columns in any order, but\n this order has a direct effect on the outcome of the SQL JOIN.\n \n This assertion applies in exactly the same manner when column names are used\n rather than column indexes to indicate match columns.", "codes": ["public interface Joinable"], "fields": [], "methods": [{"method_name": "setMatchColumn", "method_sig": "void setMatchColumn (int columnIdx)\n             throws SQLException", "description": "Sets the designated column as the match column for this RowSet\n object. A JoinRowSet object can now add this RowSet\n object based on the match column.\n \n Sub-interfaces such as the CachedRowSet\u2122\n interface define the method CachedRowSet.setKeyColumns, which allows\n primary key semantics to be enforced on specific columns.\n Implementations of the setMatchColumn(int columnIdx) method\n should ensure that the constraints on the key columns are maintained when\n a CachedRowSet object sets a primary key column as a match column."}, {"method_name": "setMatchColumn", "method_sig": "void setMatchColumn (int[] columnIdxes)\n             throws SQLException", "description": "Sets the designated columns as the match column for this RowSet\n object. A JoinRowSet object can now add this RowSet\n object based on the match column."}, {"method_name": "setMatchColumn", "method_sig": "void setMatchColumn (String columnName)\n             throws SQLException", "description": "Sets the designated column as the match column for this RowSet\n object. A JoinRowSet object can now add this RowSet\n object based on the match column.\n \n Subinterfaces such as the CachedRowSet interface define\n the method CachedRowSet.setKeyColumns, which allows\n primary key semantics to be enforced on specific columns.\n Implementations of the setMatchColumn(String columnIdx) method\n should ensure that the constraints on the key columns are maintained when\n a CachedRowSet object sets a primary key column as a match column."}, {"method_name": "setMatchColumn", "method_sig": "void setMatchColumn (String[] columnNames)\n             throws SQLException", "description": "Sets the designated columns as the match column for this RowSet\n object. A JoinRowSet object can now add this RowSet\n object based on the match column."}, {"method_name": "getMatchColumnIndexes", "method_sig": "int[] getMatchColumnIndexes()\n                     throws SQLException", "description": "Retrieves the indexes of the match columns that were set for this\n RowSet object with the method\n setMatchColumn(int[] columnIdxes)."}, {"method_name": "getMatchColumnNames", "method_sig": "String[] getMatchColumnNames()\n                      throws SQLException", "description": "Retrieves the names of the match columns that were set for this\n RowSet object with the method\n setMatchColumn(String [] columnNames)."}, {"method_name": "unsetMatchColumn", "method_sig": "void unsetMatchColumn (int columnIdx)\n               throws SQLException", "description": "Unsets the designated column as the match column for this RowSet\n object.\n \nRowSet objects that implement the Joinable interface\n must ensure that a key-like constraint continues to be enforced until the\n method CachedRowSet.unsetKeyColumns has been called on the\n designated column."}, {"method_name": "unsetMatchColumn", "method_sig": "void unsetMatchColumn (int[] columnIdxes)\n               throws SQLException", "description": "Unsets the designated columns as the match column for this RowSet\n object."}, {"method_name": "unsetMatchColumn", "method_sig": "void unsetMatchColumn (String columnName)\n               throws SQLException", "description": "Unsets the designated column as the match column for this RowSet\n object.\n \nRowSet objects that implement the Joinable interface\n must ensure that a key-like constraint continues to be enforced until the\n method CachedRowSet.unsetKeyColumns has been called on the\n designated column."}, {"method_name": "unsetMatchColumn", "method_sig": "void unsetMatchColumn (String[] columnName)\n               throws SQLException", "description": "Unsets the designated columns as the match columns for this RowSet\n object."}]}