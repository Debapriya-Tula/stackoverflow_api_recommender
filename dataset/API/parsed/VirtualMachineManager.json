{"name": "Interface VirtualMachineManager", "module": "jdk.jdi", "package": "com.sun.jdi", "text": "A manager of connections to target virtual machines. The\n VirtualMachineManager allows one application to debug\n multiple target VMs. (Note that the converse is not\n supported; a target VM can be debugged by only one\n debugger application.) This interface\n contains methods to manage connections\n to remote target VMs and to obtain the VirtualMachine\n mirror for available target VMs.\n \n Connections can be made using one of several different\n Connector objects. Each connector encapsulates\n a different way of connecting the debugger with a target VM.\n \n The VirtualMachineManager supports many different scenarios for\n connecting a debugger to a virtual machine. Four examples\n are presented in the table below. The\n examples use the command line syntax in Sun's implementation.\n Some Connector implementations may require slightly\n different handling than presented below.\n\n \nFour scenarios for connecting a debugger to a virtual machine\"\n\n\nScenario\nDescription\n\n\n\nDebugger launches target VM (simplest, most-common scenario)\nDebugger calls the LaunchingConnector.launch(java.util.Map)\n method of the default connector, obtained with defaultConnector(). The\n target VM is launched, and a connection between that VM and the\n debugger is established. A VirtualMachine mirror is returned.\n Or, for more control\n \n\n Debugger selects a connector from the list returned by\n launchingConnectors() with desired characteristics\n (for example, transport type, etc.).\n \n Debugger calls the LaunchingConnector.launch(java.util.Map)\n method of the selected connector. The\n target VM is launched, and a connection between that VM and the\n debugger is established. A VirtualMachine mirror is returned.\n \n\n\n\nDebugger attaches to previously-running VM\n\n\n\n Target VM is launched using the options\n -agentlib:jdwp=transport=xxx,server=y\n\n\n Target VM generates and outputs the tranport-specific address at which it will\n listen for a connection.\n\n Debugger is launched. Debugger selects a connector in the list\n returned by attachingConnectors() matching the transport with\n the name \"xxx\".\n \n Debugger presents the default connector parameters (obtained through\n Connector.defaultArguments()) to the end user, allowing the user to\n fill in the transport-specific address generated by the target VM.\n \n Debugger calls the AttachingConnector.attach(java.util.Map) method\n of the selected to attach to the target VM. A VirtualMachine\n mirror is returned.\n \n\n\n\nTarget VM attaches to previously-running debugger\n\n\n\n At startup, debugger selects one or more connectors from\n the list returned by listeningConnectors() for one or more\n transports.\n\n Debugger calls the ListeningConnector.startListening(java.util.Map) method for each selected\n connector. For each call, a transport-specific address string is\n generated and returned. The debugger makes the transport names and\n corresponding address strings available to the end user.\n \n Debugger calls\n ListeningConnector.accept(java.util.Map)\n for each selected connector to wait for\n a target VM to connect.\n\n Later, target VM is launched by end user with the options\n -agentlib:jdwp=transport=xxx,address=yyy\n where \"xxx\" the transport for one of the connectors selected by the\n the debugger and \"yyy\"\n is the address generated by\n ListeningConnector.accept(java.util.Map) for that\n transport.\n\n Debugger's call to ListeningConnector.accept(java.util.Map) returns\n a VirtualMachine mirror.\n\n\n\n\nTarget VM launches debugger (sometimes called \"Just-In-Time\" debugging)\n\n\n\n Target VM is launched with the options\n -agentlib:jdwp=launch=cmdline,onuncaught=y,transport=xxx,server=y\n\n\n Later, an uncaught exception is thrown in the target VM. The target\n VM generates the tranport-specific address at which it will\n listen for a connection.\n Target VM launches the debugger with the following items concatenated\n together (separated by spaces) to form the command line:\n \n The launch= value\n  The transport= value\n  The generated transport-specific address at which VM is listening for\n debugger connection.\n \n\n Upon launch, debugger selects a connector in the list\n returned by attachingConnectors() matching the transport with\n the name \"xxx\".\n \n Debugger changes the default connector parameters (obtained through\n Connector.defaultArguments()) to specify\n the transport specific address at which the VM is listenig. Optionally,\n other connector arguments can be presented to the user.\n \n Debugger calls the\n AttachingConnector.attach(java.util.Map) method\n of the selected to attach to the target VM. A VirtualMachine\n mirror is returned.\n \n\n\n\n Connectors are created at start-up time. That is, they\n are created the first time that Bootstrap.virtualMachineManager() is invoked.\n The list of all Connectors created at start-up time can be\n obtained from the VirtualMachineManager by invoking the\n allConnectors method.\n\n  Connectors are created at start-up time if they are\n installed on the platform. In addition, Connectors are created\n automatically by the VirtualMachineManager to encapsulate any\n TransportService implementations\n that are installed on the platform. These two mechanisms for\n creating Connectors are described here.\n\n  A Connector is installed on the platform if it is installed\n in a jar file that is visible to the defining class loader of\n the Connector type,\n and that jar file contains a provider configuration file named\n Connector in the resource directory\n META-INF/services, and the provider configuration file\n lists the full-qualified class name of the Connector\n implementation. A Connector is a class that implements the\n Connector interface. More\n appropriately the class implements one of the specific Connector\n types, namely AttachingConnector, ListeningConnector, or LaunchingConnector. The format of the provider configuration file\n is one fully-qualified class name per line. Space and tab characters\n surrounding each class, as well as blank lines are ignored. The\n comment character is '#' (0x23), and on each\n line all characters following the first comment character are\n ignored. The file must be encoded in UTF-8.\n\n  At start-up time the VirtualMachineManager attempts to load\n and instantiate (using the no-arg constructor) each class listed\n in the provider configuration file. Exceptions thrown when loading\n or creating the Connector are caught and ignored. In other words,\n the start-up process continues despite of errors.\n\n  In addition to Connectors installed on the platform the\n VirtualMachineManager will also create Connectors to encapsulate\n any TransportService implementations\n that are installed on the platform. A TransportService is\n installed on the platform if it installed in a jar file that is\n visible to the defining class loader for the\n TransportService type, and that jar\n file contains a provider configuration file named\n TransportService in the resource\n directory META-INF/services, and the provider\n configuration file lists the full-qualified class name of the\n TransportService implementation. A TransportService is a concrete\n sub-class of TransportService. The format of the provider configuration file\n is the same as the provider configuration file for Connectors\n except that each class listed must be the fully-qualified class\n name of a class that implements the TransportService interface.\n\n  For each TransportService installed on the platform, the\n VirtualMachineManager creates a corresponding AttachingConnector and\n ListeningConnector. These Connectors are created to encapsulate a\n Transport that in turn encapsulates the TransportService.\n The AttachingConnector will be named based on the name of the\n transport service concatenated with the string Attach.\n For example, if the transport service name() method\n returns telepathic then the AttachingConnector will\n be named telepathicAttach. Similiarly the ListeningConnector\n will be named with the string Listen tagged onto the\n name of the transport service. The description() method\n of both the AttachingConnector, and the ListeningConnector, will\n delegate to the description() method of the underlying transport service. Both\n the AttachingConnector and the ListeningConnector will have two\n Connector Arguments.\n A StringArgument\n named address is the connector argument to specify the\n address to attach too, or to listen on. A\n IntegerArgument\n named timeout is the connector argument to specify the\n timeout when attaching, or accepting. The timeout connector may be\n ignored depending on if the transport service supports an attach\n timeout or accept timeout.\n\n  Initialization of the virtual machine manager will fail, that is\n Bootstrap.virtualMachineManager() will throw an\n error if the virtual machine manager is unable to create any\n connectors.", "codes": ["public interface VirtualMachineManager"], "fields": [], "methods": [{"method_name": "defaultConnector", "method_sig": "LaunchingConnector defaultConnector()", "description": "Identifies the default connector. This connector should\n be used as the launching connector when selection of a\n connector with specific characteristics is unnecessary."}, {"method_name": "launchingConnectors", "method_sig": "List<LaunchingConnector> launchingConnectors()", "description": "Returns the list of known LaunchingConnector objects.\n Any of the returned objects can be used to launch a new target\n VM and immediately create a VirtualMachine mirror for it.\n\n Note that a target VM launched by a launching connector is not guaranteed\n to be stable until after the VMStartEvent has been received."}, {"method_name": "attachingConnectors", "method_sig": "List<AttachingConnector> attachingConnectors()", "description": "Returns the list of known AttachingConnector objects.\n Any of the returned objects can be used to attach to an existing target\n VM and create a VirtualMachine mirror for it."}, {"method_name": "listeningConnectors", "method_sig": "List<ListeningConnector> listeningConnectors()", "description": "Returns the list of known ListeningConnector objects.\n Any of the returned objects can be used to listen for a\n connection initiated by a target VM\n and create a VirtualMachine mirror for it."}, {"method_name": "allConnectors", "method_sig": "List<Connector> allConnectors()", "description": "Returns the list of all known Connector objects."}, {"method_name": "connectedVirtualMachines", "method_sig": "List<VirtualMachine> connectedVirtualMachines()", "description": "Lists all target VMs which are connected to the debugger.\n The list includes VirtualMachine instances for\n any target VMs which initiated a connection\n and any\n target VMs to which this manager has initiated a connection.\n A target VM will remain in this list\n until the VM is disconnected.\n VMDisconnectEvent is placed in the event queue\n after the VM is removed from the list."}, {"method_name": "majorInterfaceVersion", "method_sig": "int majorInterfaceVersion()", "description": "Returns the major version number of the JDI interface.\n See VirtualMachine.version() target VM version and\n information and\n VirtualMachine.description() more version information."}, {"method_name": "minorInterfaceVersion", "method_sig": "int minorInterfaceVersion()", "description": "Returns the minor version number of the JDI interface.\n See VirtualMachine.version() target VM version and\n information and\n VirtualMachine.description() more version information."}, {"method_name": "createVirtualMachine", "method_sig": "VirtualMachine createVirtualMachine (Connection connection,\n                                    Process process)\n                             throws IOException", "description": "Create a virtual machine mirror for a target VM.\n\n  Creates a virtual machine mirror for a target VM\n for which a Connection\n already exists. A Connection is created when a Connector establishes\n a connection and successfully handshakes with a target VM.\n A Connector can then use this method to create a virtual machine\n mirror to represent the composite state of the target VM.\n\n  The process argument specifies the\n Process object for the taget VM. It may be\n specified as null. If the target VM is launched\n by a LaunchingConnector the process argument should be\n specified, otherwise calling VirtualMachine.process()\n on the created virtual machine will return null.\n\n  This method exists so that Connectors may create\n a virtual machine mirror when a connection is established\n to a target VM. Only developers creating new Connector\n implementations should need to make direct use of this\n method."}, {"method_name": "createVirtualMachine", "method_sig": "VirtualMachine createVirtualMachine (Connection connection)\n                             throws IOException", "description": "Creates a new virtual machine.\n\n  This convenience method works as if by invoking createVirtualMachine(Connection, Process) method and\n specifying null as the process argument.\n\n  This method exists so that Connectors may create\n a virtual machine mirror when a connection is established\n to a target VM. Only developers creating new Connector\n implementations should need to make direct use of this\n method."}]}