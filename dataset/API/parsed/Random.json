{"name": "Class Random", "module": "java.base", "package": "java.util", "text": "An instance of this class is used to generate a stream of\n pseudorandom numbers. The class uses a 48-bit seed, which is\n modified using a linear congruential formula. (See Donald Knuth,\n The Art of Computer Programming, Volume 2, Section 3.2.1.)\n \n If two instances of Random are created with the same\n seed, and the same sequence of method calls is made for each, they\n will generate and return identical sequences of numbers. In order to\n guarantee this property, particular algorithms are specified for the\n class Random. Java implementations must use all the algorithms\n shown here for the class Random, for the sake of absolute\n portability of Java code. However, subclasses of class Random\n are permitted to use other algorithms, so long as they adhere to the\n general contracts for all the methods.\n \n The algorithms implemented by class Random use a\n protected utility method that on each invocation can supply\n up to 32 pseudorandomly generated bits.\n \n Many applications will find the method Math.random() simpler to use.\n\n Instances of java.util.Random are threadsafe.\n However, the concurrent use of the same java.util.Random\n instance across threads may encounter contention and consequent\n poor performance. Consider instead using\n ThreadLocalRandom in multithreaded\n designs.\n\n Instances of java.util.Random are not cryptographically\n secure.  Consider instead using SecureRandom to\n get a cryptographically secure pseudo-random number generator for use\n by security-sensitive applications.", "codes": ["public class Random\nextends Object\nimplements Serializable"], "fields": [], "methods": [{"method_name": "setSeed", "method_sig": "public void setSeed (long seed)", "description": "Sets the seed of this random number generator using a single\n long seed. The general contract of setSeed is\n that it alters the state of this random number generator object\n so as to be in exactly the same state as if it had just been\n created with the argument seed as a seed. The method\n setSeed is implemented by class Random by\n atomically updating the seed to\n  (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1)\n and clearing the haveNextNextGaussian flag used by nextGaussian().\n\n The implementation of setSeed by class Random\n happens to use only 48 bits of the given seed. In general, however,\n an overriding method may use all 64 bits of the long\n argument as a seed value."}, {"method_name": "next", "method_sig": "protected int next (int bits)", "description": "Generates the next pseudorandom number. Subclasses should\n override this, as this is used by all other methods.\n\n The general contract of next is that it returns an\n int value and if the argument bits is between\n 1 and 32 (inclusive), then that many low-order\n bits of the returned value will be (approximately) independently\n chosen bit values, each of which is (approximately) equally\n likely to be 0 or 1. The method next is\n implemented by class Random by atomically updating the seed to\n  (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1)\n and returning\n  (int)(seed >>> (48 - bits)).\n\n This is a linear congruential pseudorandom number generator, as\n defined by D. H. Lehmer and described by Donald E. Knuth in\n The Art of Computer Programming, Volume 2:\n Seminumerical Algorithms, section 3.2.1."}, {"method_name": "nextBytes", "method_sig": "public void nextBytes (byte[] bytes)", "description": "Generates random bytes and places them into a user-supplied\n byte array.  The number of random bytes produced is equal to\n the length of the byte array.\n\n The method nextBytes is implemented by class Random\n as if by:\n   \n public void nextBytes(byte[] bytes) {\n   for (int i = 0; i < bytes.length; )\n     for (int rnd = nextInt(), n = Math.min(bytes.length - i, 4);\n          n-- > 0; rnd >>= 8)\n       bytes[i++] = (byte)rnd;\n }"}, {"method_name": "nextInt", "method_sig": "public int nextInt()", "description": "Returns the next pseudorandom, uniformly distributed int\n value from this random number generator's sequence. The general\n contract of nextInt is that one int value is\n pseudorandomly generated and returned. All 232 possible\n int values are produced with (approximately) equal probability.\n\n The method nextInt is implemented by class Random\n as if by:\n   \n public int nextInt() {\n   return next(32);\n }"}, {"method_name": "nextInt", "method_sig": "public int nextInt (int bound)", "description": "Returns a pseudorandom, uniformly distributed int value\n between 0 (inclusive) and the specified value (exclusive), drawn from\n this random number generator's sequence.  The general contract of\n nextInt is that one int value in the specified range\n is pseudorandomly generated and returned.  All bound possible\n int values are produced with (approximately) equal\n probability.  The method nextInt(int bound) is implemented by\n class Random as if by:\n   \n public int nextInt(int bound) {\n   if (bound <= 0)\n     throw new IllegalArgumentException(\"bound must be positive\");\n\n   if ((bound & -bound) == bound)  // i.e., bound is a power of 2\n     return (int)((bound * (long)next(31)) >> 31);\n\n   int bits, val;\n   do {\n       bits = next(31);\n       val = bits % bound;\n   } while (bits - val + (bound-1) < 0);\n   return val;\n }\nThe hedge \"approximately\" is used in the foregoing description only\n because the next method is only approximately an unbiased source of\n independently chosen bits.  If it were a perfect source of randomly\n chosen bits, then the algorithm shown would choose int\n values from the stated range with perfect uniformity.\n \n The algorithm is slightly tricky.  It rejects values that would result\n in an uneven distribution (due to the fact that 2^31 is not divisible\n by n). The probability of a value being rejected depends on n.  The\n worst case is n=2^30+1, for which the probability of a reject is 1/2,\n and the expected number of iterations before the loop terminates is 2.\n \n The algorithm treats the case where n is a power of two specially: it\n returns the correct number of high-order bits from the underlying\n pseudo-random number generator.  In the absence of special treatment,\n the correct number of low-order bits would be returned.  Linear\n congruential pseudo-random number generators such as the one\n implemented by this class are known to have short periods in the\n sequence of values of their low-order bits.  Thus, this special case\n greatly increases the length of the sequence of values returned by\n successive calls to this method if n is a small power of two."}, {"method_name": "nextLong", "method_sig": "public long nextLong()", "description": "Returns the next pseudorandom, uniformly distributed long\n value from this random number generator's sequence. The general\n contract of nextLong is that one long value is\n pseudorandomly generated and returned.\n\n The method nextLong is implemented by class Random\n as if by:\n   \n public long nextLong() {\n   return ((long)next(32) << 32) + next(32);\n }\n\n Because class Random uses a seed with only 48 bits,\n this algorithm will not return all possible long values."}, {"method_name": "nextBoolean", "method_sig": "public boolean nextBoolean()", "description": "Returns the next pseudorandom, uniformly distributed\n boolean value from this random number generator's\n sequence. The general contract of nextBoolean is that one\n boolean value is pseudorandomly generated and returned.  The\n values true and false are produced with\n (approximately) equal probability.\n\n The method nextBoolean is implemented by class Random\n as if by:\n   \n public boolean nextBoolean() {\n   return next(1) != 0;\n }"}, {"method_name": "nextFloat", "method_sig": "public float nextFloat()", "description": "Returns the next pseudorandom, uniformly distributed float\n value between 0.0 and 1.0 from this random\n number generator's sequence.\n\n The general contract of nextFloat is that one\n float value, chosen (approximately) uniformly from the\n range 0.0f (inclusive) to 1.0f (exclusive), is\n pseudorandomly generated and returned. All 224 possible\n float values of the form m\u00a0x\u00a02-24,\n where m is a positive integer less than 224, are\n produced with (approximately) equal probability.\n\n The method nextFloat is implemented by class Random\n as if by:\n   \n public float nextFloat() {\n   return next(24) / ((float)(1 << 24));\n }\nThe hedge \"approximately\" is used in the foregoing description only\n because the next method is only approximately an unbiased source of\n independently chosen bits. If it were a perfect source of randomly\n chosen bits, then the algorithm shown would choose float\n values from the stated range with perfect uniformity.\n [In early versions of Java, the result was incorrectly calculated as:\n   \n   return next(30) / ((float)(1 << 30));\n This might seem to be equivalent, if not better, but in fact it\n introduced a slight nonuniformity because of the bias in the rounding\n of floating-point numbers: it was slightly more likely that the\n low-order bit of the significand would be 0 than that it would be 1.]"}, {"method_name": "nextDouble", "method_sig": "public double nextDouble()", "description": "Returns the next pseudorandom, uniformly distributed\n double value between 0.0 and\n 1.0 from this random number generator's sequence.\n\n The general contract of nextDouble is that one\n double value, chosen (approximately) uniformly from the\n range 0.0d (inclusive) to 1.0d (exclusive), is\n pseudorandomly generated and returned.\n\n The method nextDouble is implemented by class Random\n as if by:\n   \n public double nextDouble() {\n   return (((long)next(26) << 27) + next(27))\n     / (double)(1L << 53);\n }\nThe hedge \"approximately\" is used in the foregoing description only\n because the next method is only approximately an unbiased\n source of independently chosen bits. If it were a perfect source of\n randomly chosen bits, then the algorithm shown would choose\n double values from the stated range with perfect uniformity.\n [In early versions of Java, the result was incorrectly calculated as:\n   \n   return (((long)next(27) << 27) + next(27))\n     / (double)(1L << 54);\n This might seem to be equivalent, if not better, but in fact it\n introduced a large nonuniformity because of the bias in the rounding\n of floating-point numbers: it was three times as likely that the\n low-order bit of the significand would be 0 than that it would be 1!\n This nonuniformity probably doesn't matter much in practice, but we\n strive for perfection.]"}, {"method_name": "nextGaussian", "method_sig": "public double nextGaussian()", "description": "Returns the next pseudorandom, Gaussian (\"normally\") distributed\n double value with mean 0.0 and standard\n deviation 1.0 from this random number generator's sequence.\n \n The general contract of nextGaussian is that one\n double value, chosen from (approximately) the usual\n normal distribution with mean 0.0 and standard deviation\n 1.0, is pseudorandomly generated and returned.\n\n The method nextGaussian is implemented by class\n Random as if by a threadsafe version of the following:\n   \n private double nextNextGaussian;\n private boolean haveNextNextGaussian = false;\n\n public double nextGaussian() {\n   if (haveNextNextGaussian) {\n     haveNextNextGaussian = false;\n     return nextNextGaussian;\n   } else {\n     double v1, v2, s;\n     do {\n       v1 = 2 * nextDouble() - 1;   // between -1.0 and 1.0\n       v2 = 2 * nextDouble() - 1;   // between -1.0 and 1.0\n       s = v1 * v1 + v2 * v2;\n     } while (s >= 1 || s == 0);\n     double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s);\n     nextNextGaussian = v2 * multiplier;\n     haveNextNextGaussian = true;\n     return v1 * multiplier;\n   }\n }\n This uses the polar method of G. E. P. Box, M. E. Muller, and\n G. Marsaglia, as described by Donald E. Knuth in The Art of\n Computer Programming, Volume 2: Seminumerical Algorithms,\n section 3.4.1, subsection C, algorithm P. Note that it generates two\n independent values at the cost of only one call to StrictMath.log\n and one call to StrictMath.sqrt."}, {"method_name": "ints", "method_sig": "public IntStream ints (long streamSize)", "description": "Returns a stream producing the given streamSize number of\n pseudorandom int values.\n\n A pseudorandom int value is generated as if it's the result of\n calling the method nextInt()."}, {"method_name": "ints", "method_sig": "public IntStream ints()", "description": "Returns an effectively unlimited stream of pseudorandom int\n values.\n\n A pseudorandom int value is generated as if it's the result of\n calling the method nextInt()."}, {"method_name": "ints", "method_sig": "public IntStream ints (long streamSize,\n                      int randomNumberOrigin,\n                      int randomNumberBound)", "description": "Returns a stream producing the given streamSize number\n of pseudorandom int values, each conforming to the given\n origin (inclusive) and bound (exclusive).\n\n A pseudorandom int value is generated as if it's the result of\n calling the following method with the origin and bound:\n  \n int nextInt(int origin, int bound) {\n   int n = bound - origin;\n   if (n > 0) {\n     return nextInt(n) + origin;\n   }\n   else {  // range not representable as int\n     int r;\n     do {\n       r = nextInt();\n     } while (r < origin || r >= bound);\n     return r;\n   }\n }"}, {"method_name": "ints", "method_sig": "public IntStream ints (int randomNumberOrigin,\n                      int randomNumberBound)", "description": "Returns an effectively unlimited stream of pseudorandom \n int values, each conforming to the given origin (inclusive) and bound\n (exclusive).\n\n A pseudorandom int value is generated as if it's the result of\n calling the following method with the origin and bound:\n  \n int nextInt(int origin, int bound) {\n   int n = bound - origin;\n   if (n > 0) {\n     return nextInt(n) + origin;\n   }\n   else {  // range not representable as int\n     int r;\n     do {\n       r = nextInt();\n     } while (r < origin || r >= bound);\n     return r;\n   }\n }"}, {"method_name": "longs", "method_sig": "public LongStream longs (long streamSize)", "description": "Returns a stream producing the given streamSize number of\n pseudorandom long values.\n\n A pseudorandom long value is generated as if it's the result\n of calling the method nextLong()."}, {"method_name": "longs", "method_sig": "public LongStream longs()", "description": "Returns an effectively unlimited stream of pseudorandom long\n values.\n\n A pseudorandom long value is generated as if it's the result\n of calling the method nextLong()."}, {"method_name": "longs", "method_sig": "public LongStream longs (long streamSize,\n                        long randomNumberOrigin,\n                        long randomNumberBound)", "description": "Returns a stream producing the given streamSize number of\n pseudorandom long, each conforming to the given origin\n (inclusive) and bound (exclusive).\n\n A pseudorandom long value is generated as if it's the result\n of calling the following method with the origin and bound:\n  \n long nextLong(long origin, long bound) {\n   long r = nextLong();\n   long n = bound - origin, m = n - 1;\n   if ((n & m) == 0L)  // power of two\n     r = (r & m) + origin;\n   else if (n > 0L) {  // reject over-represented candidates\n     for (long u = r >>> 1;            // ensure nonnegative\n          u + m - (r = u % n) < 0L;    // rejection check\n          u = nextLong() >>> 1) // retry\n         ;\n     r += origin;\n   }\n   else {              // range not representable as long\n     while (r < origin || r >= bound)\n       r = nextLong();\n   }\n   return r;\n }"}, {"method_name": "longs", "method_sig": "public LongStream longs (long randomNumberOrigin,\n                        long randomNumberBound)", "description": "Returns an effectively unlimited stream of pseudorandom \n long values, each conforming to the given origin (inclusive) and bound\n (exclusive).\n\n A pseudorandom long value is generated as if it's the result\n of calling the following method with the origin and bound:\n  \n long nextLong(long origin, long bound) {\n   long r = nextLong();\n   long n = bound - origin, m = n - 1;\n   if ((n & m) == 0L)  // power of two\n     r = (r & m) + origin;\n   else if (n > 0L) {  // reject over-represented candidates\n     for (long u = r >>> 1;            // ensure nonnegative\n          u + m - (r = u % n) < 0L;    // rejection check\n          u = nextLong() >>> 1) // retry\n         ;\n     r += origin;\n   }\n   else {              // range not representable as long\n     while (r < origin || r >= bound)\n       r = nextLong();\n   }\n   return r;\n }"}, {"method_name": "doubles", "method_sig": "public DoubleStream doubles (long streamSize)", "description": "Returns a stream producing the given streamSize number of\n pseudorandom double values, each between zero\n (inclusive) and one (exclusive).\n\n A pseudorandom double value is generated as if it's the result\n of calling the method nextDouble()."}, {"method_name": "doubles", "method_sig": "public DoubleStream doubles()", "description": "Returns an effectively unlimited stream of pseudorandom \n double values, each between zero (inclusive) and one\n (exclusive).\n\n A pseudorandom double value is generated as if it's the result\n of calling the method nextDouble()."}, {"method_name": "doubles", "method_sig": "public DoubleStream doubles (long streamSize,\n                            double randomNumberOrigin,\n                            double randomNumberBound)", "description": "Returns a stream producing the given streamSize number of\n pseudorandom double values, each conforming to the given origin\n (inclusive) and bound (exclusive).\n\n A pseudorandom double value is generated as if it's the result\n of calling the following method with the origin and bound:\n  \n double nextDouble(double origin, double bound) {\n   double r = nextDouble();\n   r = r * (bound - origin) + origin;\n   if (r >= bound) // correct for rounding\n     r = Math.nextDown(bound);\n   return r;\n }"}, {"method_name": "doubles", "method_sig": "public DoubleStream doubles (double randomNumberOrigin,\n                            double randomNumberBound)", "description": "Returns an effectively unlimited stream of pseudorandom \n double values, each conforming to the given origin (inclusive) and bound\n (exclusive).\n\n A pseudorandom double value is generated as if it's the result\n of calling the following method with the origin and bound:\n  \n double nextDouble(double origin, double bound) {\n   double r = nextDouble();\n   r = r * (bound - origin) + origin;\n   if (r >= bound) // correct for rounding\n     r = Math.nextDown(bound);\n   return r;\n }"}]}