{"name": "Interface ModuleFinder", "module": "java.base", "package": "java.lang.module", "text": "A finder of modules. A ModuleFinder is used to find modules during\n resolution or\n service binding.\n\n  A ModuleFinder can only find one module with a given name. A\n ModuleFinder that finds modules in a sequence of directories, for\n example, will locate the first occurrence of a module of a given name and\n will ignore other modules of that name that appear in directories later in\n the sequence. \n Example usage: \n\n     Path dir1, dir2, dir3;\n\n     ModuleFinder finder = ModuleFinder.of(dir1, dir2, dir3);\n\n     Optional<ModuleReference> omref = finder.find(\"jdk.foo\");\n     omref.ifPresent(mref -> ... );\n\n \n The find and findAll methods\n defined here can fail for several reasons. These include I/O errors, errors\n detected parsing a module descriptor (module-info.class), or in the\n case of ModuleFinder returned by ModuleFinder.of, that\n two or more modules with the same name are found in a directory.\n When an error is detected then these methods throw FindException with an appropriate cause.\n The behavior of a ModuleFinder after a FindException is\n thrown is undefined. For example, invoking find after an exception\n is thrown may or may not scan the same modules that lead to the exception.\n It is recommended that a module finder be discarded after an exception is\n thrown. \n A ModuleFinder is not required to be thread safe. ", "codes": ["public interface ModuleFinder"], "fields": [], "methods": [{"method_name": "find", "method_sig": "Optional<ModuleReference> find (String name)", "description": "Finds a reference to a module of a given name.\n\n  A ModuleFinder provides a consistent view of the\n modules that it locates. If find is invoked several times to\n locate the same module (by name) then it will return the same result\n each time. If a module is located then it is guaranteed to be a member\n of the set of modules returned by the findAll\n method. "}, {"method_name": "findAll", "method_sig": "Set<ModuleReference> findAll()", "description": "Returns the set of all module references that this finder can locate.\n\n  A ModuleFinder provides a consistent view of the modules\n that it locates. If findAll is invoked several times\n then it will return the same (equals) result each time. For each \n ModuleReference element in the returned set then it is guaranteed that\n find will locate the ModuleReference if invoked\n to find that module. "}, {"method_name": "ofSystem", "method_sig": "static ModuleFinder ofSystem()", "description": "Returns a module finder that locates the system modules. The\n system modules are the modules in the Java run-time image.\n The module finder will always find java.base.\n\n  If there is a security manager set then its checkPermission method is\n invoked to check that the caller has been granted\n RuntimePermission(\"accessSystemModules\")\n to access the system modules. "}, {"method_name": "of", "method_sig": "static ModuleFinder of (Path... entries)", "description": "Returns a module finder that locates modules on the file system by\n searching a sequence of directories and/or packaged modules.\n\n Each element in the given array is one of:\n \n A path to a directory of modules.\n A path to the top-level directory of an\n         exploded module. \n A path to a packaged module. \n\n\n The module finder locates modules by searching each directory, exploded\n module, or packaged module in array index order. It finds the first\n occurrence of a module with a given name and ignores other modules of\n that name that appear later in the sequence.\n\n  If an element is a path to a directory of modules then each entry in\n the directory is a packaged module or the top-level directory of an\n exploded module. It is an error if a directory contains more than one\n module with the same name. If an element is a path to a directory, and\n that directory contains a file named module-info.class, then the\n directory is treated as an exploded module rather than a directory of\n modules. \n The module finder returned by this method\n supports modules packaged as JAR files. A JAR file with a \n module-info.class in its top-level directory, or in a versioned entry\n in a multi-release\n JAR file, is a modular JAR file and thus defines an explicit\n module. A JAR file that does not have a module-info.class in its\n top-level directory defines an automatic module, as follows:\n \n\n If the JAR file has the attribute \"Automatic-Module-Name\"\n     in its main manifest then its value is the module name. The module name is otherwise\n     derived from the name of the JAR file. \n The version, and the\n     module name when the attribute \"Automatic-Module-Name\" is not\n     present, are derived from the file name of the JAR file as follows: \n\n The \".jar\" suffix is removed. \n If the name matches the regular expression \n         \"-(\\\\d+(\\\\.|$))\" then the module name will be derived from the\n         subsequence preceding the hyphen of the first occurrence. The\n         subsequence after the hyphen is parsed as a Version and ignored if it cannot be\n         parsed as a Version. \n All non-alphanumeric characters ([^A-Za-z0-9])\n         in the module name are replaced with a dot (\".\"), all\n         repeating dots are replaced with one dot, and all leading and\n         trailing dots are removed. \n As an example, a JAR file named \"foo-bar.jar\" will\n         derive a module name \"foo.bar\" and no version. A JAR file\n         named \"foo-bar-1.2.3-SNAPSHOT.jar\" will derive a module\n         name \"foo.bar\" and \"1.2.3-SNAPSHOT\" as the version.\n         \n\n The set of packages in the module is derived from the\n     non-directory entries in the JAR file that have names ending in\n     \".class\". A candidate package name is derived from the name\n     using the characters up to, but not including, the last forward slash.\n     All remaining forward slashes are replaced with dot (\".\"). If\n     the resulting string is a legal package name then it is assumed to be\n     a package name. For example, if the JAR file contains the entry\n     \"p/q/Foo.class\" then the package name derived is\n     \"p.q\".\n The contents of entries starting with \n     META-INF/services/ are assumed to be service configuration files\n     (see ServiceLoader). If the name of a file\n     (that follows META-INF/services/) is a legal class name\n     then it is assumed to be the fully-qualified class name of a service\n     type. The entries in the file are assumed to be the fully-qualified\n     class names of provider classes. \n If the JAR file has a Main-Class attribute in its\n     main manifest, its value is a legal class name, and its package is\n     in the set of packages derived for the module, then the value is the\n     module main class. \n\n If a ModuleDescriptor cannot be created (by means of the\n ModuleDescriptor.Builder API) for an\n automatic module then FindException is thrown. This can arise\n when the value of the \"Automatic-Module-Name\" attribute is not a\n legal module name, a legal module name cannot be derived from the file\n name of the JAR file, where the JAR file contains a .class in\n the top-level directory of the JAR file, where an entry in a service\n configuration file is not a legal class name or its package name is not\n in the set of packages derived for the module. \n In addition to JAR files, an implementation may also support modules\n that are packaged in other implementation specific module formats. If\n an element in the array specified to this method is a path to a directory\n of modules then entries in the directory that not recognized as modules\n are ignored. If an element in the array is a path to a packaged module\n that is not recognized then a FindException is thrown when the\n file is encountered. Paths to files that do not exist are always ignored.\n \n As with automatic modules, the contents of a packaged or exploded\n module may need to be scanned in order to determine the packages\n in the module. Whether hidden files are ignored or not is implementation specific and therefore\n not specified. If a .class file (other than \n module-info.class) is found in the top-level directory then it is\n assumed to be a class in the unnamed package and so FindException\n is thrown. \n Finders created by this method are lazy and do not eagerly check\n that the given file paths are directories or packaged modules.\n Consequently, the find or findAll methods will only\n fail if invoking these methods results in searching a directory or\n packaged module and an error is encountered. "}, {"method_name": "compose", "method_sig": "static ModuleFinder compose (ModuleFinder... finders)", "description": "Returns a module finder that is composed from a sequence of zero or more\n module finders. The find method of the resulting\n module finder will locate a module by invoking the find method\n of each module finder, in array index order, until either the module is\n found or all module finders have been searched. The findAll method of the resulting module finder will return a set of\n modules that includes all modules located by the first module finder.\n The set of modules will include all modules located by the second or\n subsequent module finder that are not located by previous module finders\n in the sequence.\n\n  When locating modules then any exceptions or errors thrown by the\n find or findAll methods of the underlying module finders\n will be propagated to the caller of the resulting module finder's\n find or findAll methods. "}]}