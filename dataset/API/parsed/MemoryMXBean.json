{"name": "Interface MemoryMXBean", "module": "java.management", "package": "java.lang.management", "text": "The management interface for the memory system of\n the Java virtual machine.\n\n  A Java virtual machine has a single instance of the implementation\n class of this interface.  This instance implementing this interface is\n an MXBean\n that can be obtained by calling\n the ManagementFactory.getMemoryMXBean() method or\n from the platform MBeanServer method.\n\n The ObjectName for uniquely identifying the MXBean for\n the memory system within an MBeanServer is:\n \njava.lang:type=Memory\n\n\n It can be obtained by calling the\n PlatformManagedObject.getObjectName() method.\n\n  Memory \n The memory system of the Java virtual machine manages\n the following kinds of memory:\n\n  1. Heap \n The Java virtual machine has a heap that is the runtime\n data area from which memory for all class instances and arrays\n are allocated.  It is created at the Java virtual machine start-up.\n Heap memory for objects is reclaimed by an automatic memory management\n system which is known as a garbage collector.\n\n The heap may be of a fixed size or may be expanded and shrunk.\n The memory for the heap does not need to be contiguous.\n\n  2. Non-Heap Memory\n The Java virtual machine manages memory other than the heap\n (referred as non-heap memory).\n\n  The Java virtual machine has a method area that is shared\n among all threads.\n The method area belongs to non-heap memory.  It stores per-class structures\n such as a runtime constant pool, field and method data, and the code for\n methods and constructors.  It is created at the Java virtual machine\n start-up.\n\n  The method area is logically part of the heap but a Java virtual\n machine implementation may choose not to either garbage collect\n or compact it.  Similar to the heap, the method area may be of a\n fixed size or may be expanded and shrunk.  The memory for the\n method area does not need to be contiguous.\n\n In addition to the method area, a Java virtual machine\n implementation may require memory for internal processing or\n optimization which also belongs to non-heap memory.\n For example, the JIT compiler requires memory for storing the native\n machine code translated from the Java virtual machine code for\n high performance.\n\n Memory Pools and Memory Managers\nMemory pools and\n memory managers are the abstract entities\n that monitor and manage the memory system\n of the Java virtual machine.\n\n A memory pool represents a memory area that the Java virtual machine\n manages.  The Java virtual machine has at least one memory pool\n and it may create or remove memory pools during execution.\n A memory pool can belong to either the heap or the non-heap memory.\n\n A memory manager is responsible for managing one or more memory pools.\n The garbage collector is one type of memory manager responsible\n for reclaiming memory occupied by unreachable objects.  A Java virtual\n machine may have one or more memory managers.   It may\n add or remove memory managers during execution.\n A memory pool can be managed by more than one memory manager.\n\n Memory Usage Monitoring\n\n Memory usage is a very important monitoring attribute for the memory system.\n The memory usage, for example, could indicate:\n \nthe memory usage of an application,\nthe workload being imposed on the automatic memory management system,\npotential memory leakage.\n\n\n The memory usage can be monitored in three ways:\n \nPolling\nUsage Threshold Notification\nCollection Usage Threshold Notification\n\n\n Details are specified in the MemoryPoolMXBean interface.\n\n The memory usage monitoring mechanism is intended for load-balancing\n or workload distribution use.  For example, an application would stop\n receiving any new workload when its memory usage exceeds a\n certain threshold. It is not intended for an application to detect\n and recover from a low memory condition.\n\n Notifications\nThis MemoryMXBean is a\n NotificationEmitter\n that emits two types of memory notifications if any one of the memory pools\n supports a usage threshold\n or a collection usage\n threshold which can be determined by calling the\n MemoryPoolMXBean.isUsageThresholdSupported() and\n MemoryPoolMXBean.isCollectionUsageThresholdSupported() methods.\n \nusage threshold exceeded notification - for notifying that\n       the memory usage of a memory pool is increased and has reached\n       or exceeded its\n        usage threshold value.\n       \ncollection usage threshold exceeded notification - for notifying that\n       the memory usage of a memory pool is greater than or equal to its\n       \n       collection usage threshold after the Java virtual machine\n       has expended effort in recycling unused objects in that\n       memory pool.\n\n\n The notification emitted is a Notification\n instance whose user data is set to a CompositeData\n that represents a MemoryNotificationInfo object\n containing information about the memory pool when the notification\n was constructed. The CompositeData contains the attributes\n as described in MemoryNotificationInfo.\n\n \nNotificationEmitter\n The MemoryMXBean object returned by\n ManagementFactory.getMemoryMXBean() implements\n the NotificationEmitter\n interface that allows a listener to be registered within the\n MemoryMXBean as a notification listener.\n\n Below is an example code that registers a MyListener to handle\n notification emitted by the MemoryMXBean.\n\n \n class MyListener implements javax.management.NotificationListener {\n     public void handleNotification(Notification notif, Object handback) {\n         // handle notification\n         ....\n     }\n }\n\n MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();\n NotificationEmitter emitter = (NotificationEmitter) mbean;\n MyListener listener = new MyListener();\n emitter.addNotificationListener(listener, null, null);\n ", "codes": ["public interface MemoryMXBean\nextends PlatformManagedObject"], "fields": [], "methods": [{"method_name": "getObjectPendingFinalizationCount", "method_sig": "int getObjectPendingFinalizationCount()", "description": "Returns the approximate number of objects for which\n finalization is pending."}, {"method_name": "getHeapMemoryUsage", "method_sig": "MemoryUsage getHeapMemoryUsage()", "description": "Returns the current memory usage of the heap that\n is used for object allocation.  The heap consists\n of one or more memory pools.  The used\n and committed size of the returned memory\n usage is the sum of those values of all heap memory pools\n whereas the init and max size of the\n returned memory usage represents the setting of the heap\n memory which may not be the sum of those of all heap\n memory pools.\n \n The amount of used memory in the returned memory usage\n is the amount of memory occupied by both live objects\n and garbage objects that have not been collected, if any.\n\n \nMBeanServer access:\n The mapped type of MemoryUsage is\n CompositeData with attributes as specified in\n MemoryUsage."}, {"method_name": "getNonHeapMemoryUsage", "method_sig": "MemoryUsage getNonHeapMemoryUsage()", "description": "Returns the current memory usage of non-heap memory that\n is used by the Java virtual machine.\n The non-heap memory consists of one or more memory pools.\n The used and committed size of the\n returned memory usage is the sum of those values of\n all non-heap memory pools whereas the init\n and max size of the returned memory usage\n represents the setting of the non-heap\n memory which may not be the sum of those of all non-heap\n memory pools.\n\n \nMBeanServer access:\n The mapped type of MemoryUsage is\n CompositeData with attributes as specified in\n MemoryUsage."}, {"method_name": "isVerbose", "method_sig": "boolean isVerbose()", "description": "Tests if verbose output for the memory system is enabled."}, {"method_name": "setVerbose", "method_sig": "void setVerbose (boolean value)", "description": "Enables or disables verbose output for the memory\n system.  The verbose output information and the output stream\n to which the verbose information is emitted are implementation\n dependent.  Typically, a Java virtual machine implementation\n prints a message whenever it frees memory at garbage collection.\n\n \n Each invocation of this method enables or disables verbose\n output globally."}, {"method_name": "gc", "method_sig": "void gc()", "description": "Runs the garbage collector.\n The call gc() is effectively equivalent to the\n call:\n \n System.gc()\n "}]}