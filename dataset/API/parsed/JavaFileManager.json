{"name": "Interface JavaFileManager", "module": "java.compiler", "package": "javax.tools", "text": "File manager for tools operating on Java\u2122 programming language\n source and class files.  In this context, file means an\n abstraction of regular files and other sources of data.\n\n When constructing new JavaFileObjects, the file manager must\n determine where to create them.  For example, if a file manager\n manages regular files on a file system, it would most likely have a\n current/working directory to use as default location when creating\n or finding files.  A number of hints can be provided to a file\n manager as to where to create files.  Any file manager might choose\n to ignore these hints.\n\n Some methods in this interface use class names.  Such class\n names must be given in the Java Virtual Machine internal form of\n fully qualified class and interface names.  For convenience '.'\n and '/' are interchangeable.  The internal form is defined in\n chapter four of\n The Java\u2122 Virtual Machine Specification.\n\n \nDiscussion: this means that the names\n   \"java/lang.package-info\", \"java/lang/package-info\",\n   \"java.lang.package-info\", are valid and equivalent.  Compare to\n   binary name as defined in\n   The Java\u2122 Language Specification,\n   section 13.1 \"The Form of a Binary\".\n \nThe case of names is significant.  All names should be treated\n as case-sensitive.  For example, some file systems have\n case-insensitive, case-aware file names.  File objects representing\n such files should take care to preserve case by using File.getCanonicalFile() or similar means.  If the system is\n not case-aware, file objects must use other means to preserve case.\n\n Relative names: some\n methods in this interface use relative names.  A relative name is a\n non-null, non-empty sequence of path segments separated by '/'.\n '.' or '..'  are invalid path segments.  A valid relative name must\n match the \"path-rootless\" rule of RFC\u00a03986,\n section\u00a03.3.  Informally, this should be true:\n\n \n  URI.create(relativeName).normalize().getPath().equals(relativeName)\nAll methods in this interface might throw a SecurityException.\n\n An object of this interface is not required to support\n multi-threaded access, that is, be synchronized.  However, it must\n support concurrent access to different file objects created by this\n object.\n\n Implementation note: a consequence of this requirement\n is that a trivial implementation of output to a JarOutputStream is not a sufficient implementation.\n That is, rather than creating a JavaFileObject that returns the\n JarOutputStream directly, the contents must be cached until closed\n and then written to the JarOutputStream.\n\n Unless explicitly allowed, all methods in this interface might\n throw a NullPointerException if given a null argument.", "codes": ["public interface JavaFileManager\nextends Closeable, Flushable, OptionChecker"], "fields": [], "methods": [{"method_name": "getClassLoader", "method_sig": "ClassLoader getClassLoader (JavaFileManager.Location location)", "description": "Returns a class loader for loading plug-ins from the given\n package-oriented location.\n For example, to load annotation processors,\n a compiler will request a class loader for the ANNOTATION_PROCESSOR_PATH location."}, {"method_name": "list", "method_sig": "Iterable<JavaFileObject> list (JavaFileManager.Location location,\n                              String packageName,\n                              Set<JavaFileObject.Kind> kinds,\n                              boolean recurse)\n                       throws IOException", "description": "Lists all file objects matching the given criteria in the given\n package-oriented location.\n List file objects in \"subpackages\" if recurse is true.\n\n Note: even if the given location is unknown to this file\n manager, it may not return null.  Also, an unknown\n location may not cause an exception."}, {"method_name": "inferBinaryName", "method_sig": "String inferBinaryName (JavaFileManager.Location location,\n                       JavaFileObject file)", "description": "Infers a binary name of a file object based on a package-oriented location.\n The binary name returned might not be a valid binary name according to\n The Java\u2122 Language Specification."}, {"method_name": "isSameFile", "method_sig": "boolean isSameFile (FileObject a,\n                   FileObject b)", "description": "Compares two file objects and return true if they represent the\n same underlying object."}, {"method_name": "handleOption", "method_sig": "boolean handleOption (String current,\n                     Iterator<String> remaining)", "description": "Handles one option.  If current is an option to this\n file manager it will consume any arguments to that option from\n remaining and return true, otherwise return false."}, {"method_name": "hasLocation", "method_sig": "boolean hasLocation (JavaFileManager.Location location)", "description": "Determines if a location is known to this file manager."}, {"method_name": "getJavaFileForInput", "method_sig": "JavaFileObject getJavaFileForInput (JavaFileManager.Location location,\n                                   String className,\n                                   JavaFileObject.Kind kind)\n                            throws IOException", "description": "Returns a file object for input\n representing the specified class of the specified kind in the\n given package-oriented location."}, {"method_name": "getJavaFileForOutput", "method_sig": "JavaFileObject getJavaFileForOutput (JavaFileManager.Location location,\n                                    String className,\n                                    JavaFileObject.Kind kind,\n                                    FileObject sibling)\n                             throws IOException", "description": "Returns a file object for output\n representing the specified class of the specified kind in the\n given package-oriented location.\n\n Optionally, this file manager might consider the sibling as\n a hint for where to place the output.  The exact semantics of\n this hint is unspecified.  The JDK compiler, javac, for\n example, will place class files in the same directories as\n originating source files unless a class file output directory\n is provided.  To facilitate this behavior, javac might provide\n the originating source file as sibling when calling this\n method."}, {"method_name": "getFileForInput", "method_sig": "FileObject getFileForInput (JavaFileManager.Location location,\n                           String packageName,\n                           String relativeName)\n                    throws IOException", "description": "Returns a file object for input\n representing the specified relative\n name in the specified package in the given package-oriented location.\n\n If the returned object represents a source or class file, it must be an instance\n of JavaFileObject.\n\n Informally, the file object returned by this method is\n located in the concatenation of the location, package name, and\n relative name.  For example, to locate the properties file\n \"resources/compiler.properties\" in the package\n \"com.sun.tools.javac\" in the SOURCE_PATH location, this method\n might be called like so:\n\n getFileForInput(SOURCE_PATH, \"com.sun.tools.javac\", \"resources/compiler.properties\");\nIf the call was executed on Windows, with SOURCE_PATH set to\n \"C:\\Documents\u00a0and\u00a0Settings\\UncleBob\\src\\share\\classes\",\n a valid result would be a file object representing the file\n \"C:\\Documents\u00a0and\u00a0Settings\\UncleBob\\src\\share\\classes\\com\\sun\\tools\\javac\\resources\\compiler.properties\"."}, {"method_name": "getFileForOutput", "method_sig": "FileObject getFileForOutput (JavaFileManager.Location location,\n                            String packageName,\n                            String relativeName,\n                            FileObject sibling)\n                     throws IOException", "description": "Returns a file object for output\n representing the specified relative\n name in the specified package in the given location.\n\n Optionally, this file manager might consider the sibling as\n a hint for where to place the output.  The exact semantics of\n this hint is unspecified.  The JDK compiler, javac, for\n example, will place class files in the same directories as\n originating source files unless a class file output directory\n is provided.  To facilitate this behavior, javac might provide\n the originating source file as sibling when calling this\n method.\n\n If the returned object represents a source or class file, it must be an instance\n of JavaFileObject.\n\n Informally, the file object returned by this method is\n located in the concatenation of the location, package name, and\n relative name or next to the sibling argument.  See getFileForInput for an example."}, {"method_name": "flush", "method_sig": "void flush()\n    throws IOException", "description": "Flushes any resources opened for output by this file manager\n directly or indirectly.  Flushing a closed file manager has no\n effect."}, {"method_name": "close", "method_sig": "void close()\n    throws IOException", "description": "Releases any resources opened by this file manager directly or\n indirectly.  This might render this file manager useless and\n the effect of subsequent calls to methods on this object or any\n objects obtained through this object is undefined unless\n explicitly allowed.  However, closing a file manager which has\n already been closed has no effect."}, {"method_name": "getLocationForModule", "method_sig": "default JavaFileManager.Location getLocationForModule (JavaFileManager.Location location,\n                                                      String moduleName)\n                                               throws IOException", "description": "Gets a location for a named module within a location, which may be either\n a module-oriented location or an output location.\n The result will be an output location if the given location is\n an output location, or it will be a package-oriented location."}, {"method_name": "getLocationForModule", "method_sig": "default JavaFileManager.Location getLocationForModule (JavaFileManager.Location location,\n                                                      JavaFileObject fo)\n                                               throws IOException", "description": "Gets a location for the module containing a specific file\n to be found within a location, which may be either\n a module-oriented location or an output location.\n The result will be an output location if the given location is\n an output location, or it will be a package-oriented location."}, {"method_name": "getServiceLoader", "method_sig": "default <S> ServiceLoader<S> getServiceLoader (JavaFileManager.Location location,\n                                              Class<S> service)\n                                       throws IOException", "description": "Get a service loader for a specific service class from a given location.\n\n If the location is a module-oriented location, the service loader will use the\n service declarations in the modules found in that location. Otherwise, a service loader\n is created using the package-oriented location, in which case, the services are\n determined using the provider-configuration files in META-INF/services."}, {"method_name": "inferModuleName", "method_sig": "default String inferModuleName (JavaFileManager.Location location)\n                        throws IOException", "description": "Infer the name of the module from its location, as returned by\n getLocationForModule or listModuleLocations."}, {"method_name": "listLocationsForModules", "method_sig": "default Iterable<Set<JavaFileManager.Location>> listLocationsForModules (JavaFileManager.Location location)\n                                                                 throws IOException", "description": "Lists the locations for all the modules in a module-oriented location or an output location.\n The locations that are returned will be output locations if the given location is an output,\n or it will be a package-oriented locations."}, {"method_name": "contains", "method_sig": "default boolean contains (JavaFileManager.Location location,\n                         FileObject fo)\n                  throws IOException", "description": "Determines whether or not a given file object is \"contained in\" a specified location.\n\n For a package-oriented location, a file object is contained in the location if there exist\n values for packageName and relativeName such that either of the following\n calls would return the same file object:\n \n     getFileForInput(location, packageName, relativeName)\n     getFileForOutput(location, packageName, relativeName, null)\n \nFor a module-oriented location, a file object is contained in the location if there exists\n a module that may be obtained by the call:\n \n     getLocationForModule(location, moduleName)\n \n such that the file object is contained in the (package-oriented) location for that module."}]}