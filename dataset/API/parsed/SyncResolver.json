{"name": "Interface SyncResolver", "module": "java.sql.rowset", "package": "javax.sql.rowset.spi", "text": "Defines a framework that allows applications to use a manual decision tree\n to decide what should be done when a synchronization conflict occurs.\n Although it is not mandatory for\n applications to resolve synchronization conflicts manually, this\n framework provides the means to delegate to the application when conflicts\n arise.\n \n Note that a conflict is a situation where the RowSet object's original\n values for a row do not match the values in the data source, which indicates that\n the data source row has been modified since the last synchronization. Note also that\n a RowSet object's original values are the values it had just prior to the\n the last synchronization, which are not necessarily its initial values.\n\n\n Description of a SyncResolver Object\n\n A SyncResolver object is a specialized RowSet object\n that implements the SyncResolver interface.\n It may operate as either a connected RowSet object (an\n implementation of the JdbcRowSet interface) or a connected\n RowSet object (an implementation of the\n CachedRowSet interface or one of its subinterfaces). For information\n on the subinterfaces, see the\n javax.sql.rowset package\n description. The reference implementation for SyncResolver implements\n the CachedRowSet interface, but other implementations\n may choose to implement the JdbcRowSet interface to satisfy\n particular needs.\n \n After an application has attempted to synchronize a RowSet object with\n the data source (by calling the CachedRowSet\n method acceptChanges), and one or more conflicts have been found,\n a rowset's SyncProvider object creates an instance of\n SyncResolver. This new SyncResolver object has\n the same number of rows and columns as the\n RowSet object that was attempting the synchronization. The\n SyncResolver object contains the values from the data source that caused\n the conflict(s) and null for all other values.\n In addition, it contains information about each conflict.\n\n\n Getting and Using a SyncResolver Object\n\n When the method acceptChanges encounters conflicts, the\n SyncProvider object creates a SyncProviderException\n object and sets it with the new SyncResolver object. The method\n acceptChanges will throw this exception, which\n the application can then catch and use to retrieve the\n SyncResolver object it contains. The following code snippet uses the\n SyncProviderException method getSyncResolver to get\n the SyncResolver object resolver.\n \n \n      catch (SyncProviderException spe) {\n         SyncResolver resolver = spe.getSyncResolver();\n     ...\n     }\n\n }\n \n\n With resolver in hand, an application can use it to get the information\n it contains about the conflict or conflicts.  A SyncResolver object\n such as resolver keeps\n track of the conflicts for each row in which there is a conflict.  It also places a\n lock on the table or tables affected by the rowset's command so that no more\n conflicts can occur while the current conflicts are being resolved.\n \n The following kinds of information can be obtained from a SyncResolver\n object:\n\n    What operation was being attempted when a conflict occurred\n The SyncProvider interface defines four constants\n describing states that may occur. Three\n constants describe the type of operation (update, delete, or insert) that a\n RowSet object was attempting to perform when a conflict was discovered,\n and the fourth indicates that there is no conflict.\n These constants are the possible return values when a SyncResolver object\n calls the method getStatus.\n \n     int operation = resolver.getStatus(); \n \nThe value in the data source that caused a conflict\n A conflict exists when a value that a RowSet object has changed\n and is attempting to write to the data source\n has also been changed in the data source since the last synchronization.  An\n application can call the SyncResolver method\n getConflictValue to retrieve the\n value in the data source that is the cause of the conflict because the values in a\n SyncResolver object are the conflict values from the data source.\n \n     java.lang.Object conflictValue = resolver.getConflictValue(2);\n \n Note that the column in resolver can be designated by the column number,\n as is done in the preceding line of code, or by the column name.\n \n With the information retrieved from the methods getStatus and\n getConflictValue, the application may make a determination as to\n which value should be persisted in the data source. The application then calls the\n SyncResolver method setResolvedValue, which sets the value\n to be persisted in the RowSet object and also in the data source.\n \n     resolver.setResolvedValue(\"DEPT\", 8390426);\n \n In the preceding line of code,\n the column name designates the column in the RowSet object\n that is to be set with the given value. The column number can also be used to\n designate the column.\n \n An application calls the method setResolvedValue after it has\n resolved all of the conflicts in the current conflict row and repeats this process\n for each conflict row in the SyncResolver object.\n\n\n Navigating a SyncResolver Object\n\n Because a SyncResolver object is a RowSet object, an\n application can use all of the RowSet methods for moving the cursor\n to navigate a SyncResolver object. For example, an application can\n use the RowSet method next to get to each row and then\n call the SyncResolver method getStatus to see if the row\n contains a conflict.  In a row with one or more conflicts, the application can\n iterate through the columns to find any non-null values, which will be the values\n from the data source that are in conflict.\n \n To make it easier to navigate a SyncResolver object, especially when\n there are large numbers of rows with no conflicts, the SyncResolver\n interface defines the methods nextConflict and\n previousConflict, which move only to rows\n that contain at least one conflict value. Then an application can call the\n SyncResolver method getConflictValue, supplying it\n with the column number, to get the conflict value itself. The code fragment in the\n next section gives an example.\n\n Code Example\n\n The following code fragment demonstrates how a disconnected RowSet\n object crs might attempt to synchronize itself with the\n underlying data source and then resolve the conflicts. In the try\n block, crs calls the method acceptChanges, passing it the\n Connection object con.  If there are no conflicts, the\n changes in crs are simply written to the data source.  However, if there\n is a conflict, the method acceptChanges throws a\n SyncProviderException object, and the\n catch block takes effect.  In this example, which\n illustrates one of the many ways a SyncResolver object can be used,\n the SyncResolver method nextConflict is used in a\n while loop. The loop will end when nextConflict returns\n false, which will occur when there are no more conflict rows in the\n SyncResolver object resolver. In This particular code fragment,\n resolver looks for rows that have update conflicts (rows with the status\n SyncResolver.UPDATE_ROW_CONFLICT), and the rest of this code fragment\n executes only for rows where conflicts occurred because crs was attempting an\n update.\n \n After the cursor for resolver has moved to the next conflict row that\n has an update conflict, the method getRow indicates the number of the\n current row, and\n the cursor for the CachedRowSet object crs is moved to\n the comparable row in crs. By iterating\n through the columns of that row in both resolver and crs, the conflicting\n values can be retrieved and compared to decide which one should be persisted. In this\n code fragment, the value in crs is the one set as the resolved value, which means\n that it will be used to overwrite the conflict value in the data source.\n\n \n \n     try {\n\n         crs.acceptChanges(con);\n\n     } catch (SyncProviderException spe) {\n\n         SyncResolver resolver = spe.getSyncResolver();\n\n         Object crsValue;  // value in the RowSet object\n         Object resolverValue:  // value in the SyncResolver object\n         Object resolvedValue:  // value to be persisted\n\n         while(resolver.nextConflict())  {\n             if(resolver.getStatus() == SyncResolver.UPDATE_ROW_CONFLICT)  {\n                 int row = resolver.getRow();\n                 crs.absolute(row);\n\n                 int colCount = crs.getMetaData().getColumnCount();\n                 for(int j = 1; j <= colCount; j++) {\n                     if (resolver.getConflictValue(j) != null)  {\n                         crsValue = crs.getObject(j);\n                         resolverValue = resolver.getConflictValue(j);\n                         . . .\n                         // compare crsValue and resolverValue to determine\n                         // which should be the resolved value (the value to persist)\n                         resolvedValue = crsValue;\n\n                         resolver.setResolvedValue(j, resolvedValue);\n                      }\n                  }\n              }\n          }\n      }\n ", "codes": ["public interface SyncResolver\nextends RowSet"], "fields": [{"field_name": "UPDATE_ROW_CONFLICT", "field_sig": "static final\u00a0int UPDATE_ROW_CONFLICT", "description": "Indicates that a conflict occurred while the RowSet object was\n attempting to update a row in the data source.\n The values in the data source row to be updated differ from the\n RowSet object's original values for that row, which means that\n the row in the data source has been updated or deleted since the last\n synchronization."}, {"field_name": "DELETE_ROW_CONFLICT", "field_sig": "static final\u00a0int DELETE_ROW_CONFLICT", "description": "Indicates that a conflict occurred while the RowSet object was\n attempting to delete a row in the data source.\n The values in the data source row to be updated differ from the\n RowSet object's original values for that row, which means that\n the row in the data source has been updated or deleted since the last\n synchronization."}, {"field_name": "INSERT_ROW_CONFLICT", "field_sig": "static final\u00a0int INSERT_ROW_CONFLICT", "description": "Indicates that a conflict occurred while the RowSet object was\n attempting to insert a row into the data source.  This means that a\n row with the same primary key as the row to be inserted has been inserted\n into the data source since the last synchronization."}, {"field_name": "NO_ROW_CONFLICT", "field_sig": "static final\u00a0int NO_ROW_CONFLICT", "description": "Indicates that no conflict occurred while the RowSet object\n was attempting to update, delete or insert a row in the data source. The values in\n the SyncResolver will contain null values only as an indication\n that no information in pertinent to the conflict resolution in this row."}], "methods": [{"method_name": "getStatus", "method_sig": "int getStatus()", "description": "Retrieves the conflict status of the current row of this SyncResolver,\n which indicates the operation\n the RowSet object was attempting when the conflict occurred."}, {"method_name": "getConflictValue", "method_sig": "Object getConflictValue (int index)\n                 throws SQLException", "description": "Retrieves the value in the designated column in the current row of this\n SyncResolver object, which is the value in the data source\n that caused a conflict."}, {"method_name": "getConflictValue", "method_sig": "Object getConflictValue (String columnName)\n                 throws SQLException", "description": "Retrieves the value in the designated column in the current row of this\n SyncResolver object, which is the value in the data source\n that caused a conflict."}, {"method_name": "setResolvedValue", "method_sig": "void setResolvedValue (int index,\n                      Object obj)\n               throws SQLException", "description": "Sets obj as the value in column index in the current row of the\n RowSet object that is being synchronized. obj\n is set as the value in the data source internally."}, {"method_name": "setResolvedValue", "method_sig": "void setResolvedValue (String columnName,\n                      Object obj)\n               throws SQLException", "description": "Sets obj as the value in column columnName in the current row of the\n RowSet object that is being synchronized. obj\n is set as the value in the data source internally."}, {"method_name": "nextConflict", "method_sig": "boolean nextConflict()\n              throws SQLException", "description": "Moves the cursor down from its current position to the next row that contains\n a conflict value. A SyncResolver object's\n cursor is initially positioned before the first conflict row; the first call to the\n method nextConflict makes the first conflict row the current row;\n the second call makes the second conflict row the current row, and so on.\n \n A call to the method nextConflict will implicitly close\n an input stream if one is open and will clear the SyncResolver\n object's warning chain."}, {"method_name": "previousConflict", "method_sig": "boolean previousConflict()\n                  throws SQLException", "description": "Moves the cursor up from its current position to the previous conflict\n row in this SyncResolver object.\n \n A call to the method previousConflict will implicitly close\n an input stream if one is open and will clear the SyncResolver\n object's warning chain."}]}