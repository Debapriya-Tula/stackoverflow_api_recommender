{"name": "Class BufferedImage", "module": "java.desktop", "package": "java.awt.image", "text": "The BufferedImage subclass describes an Image with an accessible buffer of image data.\n A BufferedImage is comprised of a ColorModel and a\n Raster of image data.\n The number and types of bands in the SampleModel of the\n Raster must match the number and types required by the\n ColorModel to represent its color and alpha components.\n All BufferedImage objects have an upper left corner\n coordinate of (0,\u00a00).  Any Raster used to construct a\n BufferedImage must therefore have minX=0 and minY=0.\n\n \n This class relies on the data fetching and setting methods\n of Raster,\n and on the color characterization methods of ColorModel.", "codes": ["public class BufferedImage\nextends Image\nimplements WritableRenderedImage, Transparency"], "fields": [{"field_name": "TYPE_CUSTOM", "field_sig": "public static final\u00a0int TYPE_CUSTOM", "description": "Image type is not recognized so it must be a customized\n image.  This type is only used as a return value for the getType()\n method."}, {"field_name": "TYPE_INT_RGB", "field_sig": "public static final\u00a0int TYPE_INT_RGB", "description": "Represents an image with 8-bit RGB color components packed into\n integer pixels.  The image has a DirectColorModel without\n alpha.\n When data with non-opaque alpha is stored\n in an image of this type,\n the color data must be adjusted to a non-premultiplied form\n and the alpha discarded,\n as described in the\n AlphaComposite documentation."}, {"field_name": "TYPE_INT_ARGB", "field_sig": "public static final\u00a0int TYPE_INT_ARGB", "description": "Represents an image with 8-bit RGBA color components packed into\n integer pixels.  The image has a DirectColorModel\n with alpha. The color data in this image is considered not to be\n premultiplied with alpha.  When this type is used as the\n imageType argument to a BufferedImage\n constructor, the created image is consistent with images\n created in the JDK1.1 and earlier releases."}, {"field_name": "TYPE_INT_ARGB_PRE", "field_sig": "public static final\u00a0int TYPE_INT_ARGB_PRE", "description": "Represents an image with 8-bit RGBA color components packed into\n integer pixels.  The image has a DirectColorModel\n with alpha.  The color data in this image is considered to be\n premultiplied with alpha."}, {"field_name": "TYPE_INT_BGR", "field_sig": "public static final\u00a0int TYPE_INT_BGR", "description": "Represents an image with 8-bit RGB color components, corresponding\n to a Windows- or Solaris- style BGR color model, with the colors\n Blue, Green, and Red packed into integer pixels.  There is no alpha.\n The image has a DirectColorModel.\n When data with non-opaque alpha is stored\n in an image of this type,\n the color data must be adjusted to a non-premultiplied form\n and the alpha discarded,\n as described in the\n AlphaComposite documentation."}, {"field_name": "TYPE_3BYTE_BGR", "field_sig": "public static final\u00a0int TYPE_3BYTE_BGR", "description": "Represents an image with 8-bit RGB color components, corresponding\n to a Windows-style BGR color model) with the colors Blue, Green,\n and Red stored in 3 bytes.  There is no alpha.  The image has a\n ComponentColorModel.\n When data with non-opaque alpha is stored\n in an image of this type,\n the color data must be adjusted to a non-premultiplied form\n and the alpha discarded,\n as described in the\n AlphaComposite documentation."}, {"field_name": "TYPE_4BYTE_ABGR", "field_sig": "public static final\u00a0int TYPE_4BYTE_ABGR", "description": "Represents an image with 8-bit RGBA color components with the colors\n Blue, Green, and Red stored in 3 bytes and 1 byte of alpha.  The\n image has a ComponentColorModel with alpha.  The\n color data in this image is considered not to be premultiplied with\n alpha.  The byte data is interleaved in a single\n byte array in the order A, B, G, R\n from lower to higher byte addresses within each pixel."}, {"field_name": "TYPE_4BYTE_ABGR_PRE", "field_sig": "public static final\u00a0int TYPE_4BYTE_ABGR_PRE", "description": "Represents an image with 8-bit RGBA color components with the colors\n Blue, Green, and Red stored in 3 bytes and 1 byte of alpha.  The\n image has a ComponentColorModel with alpha. The color\n data in this image is considered to be premultiplied with alpha.\n The byte data is interleaved in a single byte array in the order\n A, B, G, R from lower to higher byte addresses within each pixel."}, {"field_name": "TYPE_USHORT_565_RGB", "field_sig": "public static final\u00a0int TYPE_USHORT_565_RGB", "description": "Represents an image with 5-6-5 RGB color components (5-bits red,\n 6-bits green, 5-bits blue) with no alpha.  This image has\n a DirectColorModel.\n When data with non-opaque alpha is stored\n in an image of this type,\n the color data must be adjusted to a non-premultiplied form\n and the alpha discarded,\n as described in the\n AlphaComposite documentation."}, {"field_name": "TYPE_USHORT_555_RGB", "field_sig": "public static final\u00a0int TYPE_USHORT_555_RGB", "description": "Represents an image with 5-5-5 RGB color components (5-bits red,\n 5-bits green, 5-bits blue) with no alpha.  This image has\n a DirectColorModel.\n When data with non-opaque alpha is stored\n in an image of this type,\n the color data must be adjusted to a non-premultiplied form\n and the alpha discarded,\n as described in the\n AlphaComposite documentation."}, {"field_name": "TYPE_BYTE_GRAY", "field_sig": "public static final\u00a0int TYPE_BYTE_GRAY", "description": "Represents a unsigned byte grayscale image, non-indexed.  This\n image has a ComponentColorModel with a CS_GRAY\n ColorSpace.\n When data with non-opaque alpha is stored\n in an image of this type,\n the color data must be adjusted to a non-premultiplied form\n and the alpha discarded,\n as described in the\n AlphaComposite documentation."}, {"field_name": "TYPE_USHORT_GRAY", "field_sig": "public static final\u00a0int TYPE_USHORT_GRAY", "description": "Represents an unsigned short grayscale image, non-indexed).  This\n image has a ComponentColorModel with a CS_GRAY\n ColorSpace.\n When data with non-opaque alpha is stored\n in an image of this type,\n the color data must be adjusted to a non-premultiplied form\n and the alpha discarded,\n as described in the\n AlphaComposite documentation."}, {"field_name": "TYPE_BYTE_BINARY", "field_sig": "public static final\u00a0int TYPE_BYTE_BINARY", "description": "Represents an opaque byte-packed 1, 2, or 4 bit image.  The\n image has an IndexColorModel without alpha.  When this\n type is used as the imageType argument to the\n BufferedImage constructor that takes an\n imageType argument but no ColorModel\n argument, a 1-bit image is created with an\n IndexColorModel with two colors in the default\n sRGB ColorSpace: {0,\u00a00,\u00a00} and\n {255,\u00a0255,\u00a0255}.\n\n  Images with 2 or 4 bits per pixel may be constructed via\n the BufferedImage constructor that takes a\n ColorModel argument by supplying a\n ColorModel with an appropriate map size.\n\n  Images with 8 bits per pixel should use the image types\n TYPE_BYTE_INDEXED or TYPE_BYTE_GRAY\n depending on their ColorModel.\n\n  When color data is stored in an image of this type,\n the closest color in the colormap is determined\n by the IndexColorModel and the resulting index is stored.\n Approximation and loss of alpha or color components\n can result, depending on the colors in the\n IndexColorModel colormap."}, {"field_name": "TYPE_BYTE_INDEXED", "field_sig": "public static final\u00a0int TYPE_BYTE_INDEXED", "description": "Represents an indexed byte image.  When this type is used as the\n imageType argument to the BufferedImage\n constructor that takes an imageType argument\n but no ColorModel argument, an\n IndexColorModel is created with\n a 256-color 6/6/6 color cube palette with the rest of the colors\n from 216-255 populated by grayscale values in the\n default sRGB ColorSpace.\n\n  When color data is stored in an image of this type,\n the closest color in the colormap is determined\n by the IndexColorModel and the resulting index is stored.\n Approximation and loss of alpha or color components\n can result, depending on the colors in the\n IndexColorModel colormap."}], "methods": [{"method_name": "getType", "method_sig": "public int getType()", "description": "Returns the image type.  If it is not one of the known types,\n TYPE_CUSTOM is returned."}, {"method_name": "getColorModel", "method_sig": "public ColorModel getColorModel()", "description": "Returns the ColorModel."}, {"method_name": "getRaster", "method_sig": "public WritableRaster getRaster()", "description": "Returns the WritableRaster."}, {"method_name": "getAlphaRaster", "method_sig": "public WritableRaster getAlphaRaster()", "description": "Returns a WritableRaster representing the alpha\n channel for BufferedImage objects\n with ColorModel objects that support a separate\n spatial alpha channel, such as ComponentColorModel and\n DirectColorModel.  Returns null if there\n is no alpha channel associated with the ColorModel in\n this image.  This method assumes that for all\n ColorModel objects other than\n IndexColorModel, if the ColorModel\n supports alpha, there is a separate alpha channel\n which is stored as the last band of image data.\n If the image uses an IndexColorModel that\n has alpha in the lookup table, this method returns\n null since there is no spatially discrete alpha\n channel.  This method creates a new\n WritableRaster, but shares the data array."}, {"method_name": "getRGB", "method_sig": "public int getRGB (int x,\n                  int y)", "description": "Returns an integer pixel in the default RGB color model\n (TYPE_INT_ARGB) and default sRGB colorspace.  Color\n conversion takes place if this default model does not match\n the image ColorModel.  There are only 8-bits of\n precision for each color component in the returned data when using\n this method.\n\n \n\n An ArrayOutOfBoundsException may be thrown\n if the coordinates are not in bounds.\n However, explicit bounds checking is not guaranteed."}, {"method_name": "getRGB", "method_sig": "public int[] getRGB (int startX,\n                    int startY,\n                    int w,\n                    int h,\n                    int[] rgbArray,\n                    int offset,\n                    int scansize)", "description": "Returns an array of integer pixels in the default RGB color model\n (TYPE_INT_ARGB) and default sRGB color space,\n from a portion of the image data.  Color conversion takes\n place if the default model does not match the image\n ColorModel.  There are only 8-bits of precision for\n each color component in the returned data when\n using this method.  With a specified coordinate (x,\u00a0y) in the\n image, the ARGB pixel can be accessed in this way:\n\n \n    pixel   = rgbArray[offset + (y-startY)*scansize + (x-startX)]; \n\n\n An ArrayOutOfBoundsException may be thrown\n if the region is not in bounds.\n However, explicit bounds checking is not guaranteed."}, {"method_name": "setRGB", "method_sig": "public void setRGB (int x,\n                   int y,\n                   int rgb)", "description": "Sets a pixel in this BufferedImage to the specified\n RGB value. The pixel is assumed to be in the default RGB color\n model, TYPE_INT_ARGB, and default sRGB color space.  For images\n with an IndexColorModel, the index with the nearest\n color is chosen.\n\n \n\n An ArrayOutOfBoundsException may be thrown\n if the coordinates are not in bounds.\n However, explicit bounds checking is not guaranteed."}, {"method_name": "setRGB", "method_sig": "public void setRGB (int startX,\n                   int startY,\n                   int w,\n                   int h,\n                   int[] rgbArray,\n                   int offset,\n                   int scansize)", "description": "Sets an array of integer pixels in the default RGB color model\n (TYPE_INT_ARGB) and default sRGB color space,\n into a portion of the image data.  Color conversion takes place\n if the default model does not match the image\n ColorModel.  There are only 8-bits of precision for\n each color component in the returned data when\n using this method.  With a specified coordinate (x,\u00a0y) in the\n this image, the ARGB pixel can be accessed in this way:\n \n    pixel   = rgbArray[offset + (y-startY)*scansize + (x-startX)];\n \n WARNING: No dithering takes place.\n\n \n\n An ArrayOutOfBoundsException may be thrown\n if the region is not in bounds.\n However, explicit bounds checking is not guaranteed."}, {"method_name": "getWidth", "method_sig": "public int getWidth()", "description": "Returns the width of the BufferedImage."}, {"method_name": "getHeight", "method_sig": "public int getHeight()", "description": "Returns the height of the BufferedImage."}, {"method_name": "getWidth", "method_sig": "public int getWidth (ImageObserver observer)", "description": "Returns the width of the BufferedImage."}, {"method_name": "getHeight", "method_sig": "public int getHeight (ImageObserver observer)", "description": "Returns the height of the BufferedImage."}, {"method_name": "getSource", "method_sig": "public ImageProducer getSource()", "description": "Returns the object that produces the pixels for the image."}, {"method_name": "getProperty", "method_sig": "public Object getProperty (String name,\n                          ImageObserver observer)", "description": "Returns a property of the image by name.  Individual property names\n are defined by the various image formats.  If a property is not\n defined for a particular image, this method returns the\n UndefinedProperty field.  If the properties\n for this image are not yet known, then this method returns\n null and the ImageObserver object is\n notified later.  The property name \"comment\" should be used to\n store an optional comment that can be presented to the user as a\n description of the image, its source, or its author."}, {"method_name": "getProperty", "method_sig": "public Object getProperty (String name)", "description": "Returns a property of the image by name."}, {"method_name": "getGraphics", "method_sig": "public Graphics getGraphics()", "description": "This method returns a Graphics2D, but is here\n for backwards compatibility.  createGraphics is more\n convenient, since it is declared to return a\n Graphics2D."}, {"method_name": "createGraphics", "method_sig": "public Graphics2D createGraphics()", "description": "Creates a Graphics2D, which can be used to draw into\n this BufferedImage."}, {"method_name": "getSubimage", "method_sig": "public BufferedImage getSubimage (int x,\n                                 int y,\n                                 int w,\n                                 int h)", "description": "Returns a subimage defined by a specified rectangular region.\n The returned BufferedImage shares the same\n data array as the original image."}, {"method_name": "isAlphaPremultiplied", "method_sig": "public boolean isAlphaPremultiplied()", "description": "Returns whether or not the alpha has been premultiplied.  It\n returns false if there is no alpha."}, {"method_name": "coerceData", "method_sig": "public void coerceData (boolean isAlphaPremultiplied)", "description": "Forces the data to match the state specified in the\n isAlphaPremultiplied variable.  It may multiply or\n divide the color raster data by alpha, or do nothing if the data is\n in the correct state."}, {"method_name": "toString", "method_sig": "public String toString()", "description": "Returns a String representation of this\n BufferedImage object and its values."}, {"method_name": "getSources", "method_sig": "public Vector<RenderedImage> getSources()", "description": "Returns a Vector of RenderedImage objects that are\n the immediate sources, not the sources of these immediate sources,\n of image data for this BufferedImage.  This\n method returns null if the BufferedImage\n has no information about its immediate sources.  It returns an\n empty Vector if the BufferedImage has no\n immediate sources."}, {"method_name": "getPropertyNames", "method_sig": "public String[] getPropertyNames()", "description": "Returns an array of names recognized by\n getProperty(String)\n or null, if no property names are recognized."}, {"method_name": "getMinX", "method_sig": "public int getMinX()", "description": "Returns the minimum x coordinate of this\n BufferedImage.  This is always zero."}, {"method_name": "getMinY", "method_sig": "public int getMinY()", "description": "Returns the minimum y coordinate of this\n BufferedImage.  This is always zero."}, {"method_name": "getSampleModel", "method_sig": "public SampleModel getSampleModel()", "description": "Returns the SampleModel associated with this\n BufferedImage."}, {"method_name": "getNumXTiles", "method_sig": "public int getNumXTiles()", "description": "Returns the number of tiles in the x direction.\n This is always one."}, {"method_name": "getNumYTiles", "method_sig": "public int getNumYTiles()", "description": "Returns the number of tiles in the y direction.\n This is always one."}, {"method_name": "getMinTileX", "method_sig": "public int getMinTileX()", "description": "Returns the minimum tile index in the x direction.\n This is always zero."}, {"method_name": "getMinTileY", "method_sig": "public int getMinTileY()", "description": "Returns the minimum tile index in the y direction.\n This is always zero."}, {"method_name": "getTileWidth", "method_sig": "public int getTileWidth()", "description": "Returns the tile width in pixels."}, {"method_name": "getTileHeight", "method_sig": "public int getTileHeight()", "description": "Returns the tile height in pixels."}, {"method_name": "getTileGridXOffset", "method_sig": "public int getTileGridXOffset()", "description": "Returns the x offset of the tile grid relative to the origin,\n For example, the x coordinate of the location of tile\n (0,\u00a00).  This is always zero."}, {"method_name": "getTileGridYOffset", "method_sig": "public int getTileGridYOffset()", "description": "Returns the y offset of the tile grid relative to the origin,\n For example, the y coordinate of the location of tile\n (0,\u00a00).  This is always zero."}, {"method_name": "getTile", "method_sig": "public Raster getTile (int tileX,\n                      int tileY)", "description": "Returns tile (tileX,\u00a0tileY).  Note\n that tileX and tileY are indices\n into the tile array, not pixel locations.  The Raster\n that is returned is live, which means that it is updated if the\n image is changed."}, {"method_name": "getData", "method_sig": "public Raster getData()", "description": "Returns the image as one large tile.  The Raster\n returned is a copy of the image data is not updated if the\n image is changed."}, {"method_name": "getData", "method_sig": "public Raster getData (Rectangle rect)", "description": "Computes and returns an arbitrary region of the\n BufferedImage.  The Raster returned is a\n copy of the image data and is not updated if the image is\n changed."}, {"method_name": "copyData", "method_sig": "public WritableRaster copyData (WritableRaster outRaster)", "description": "Computes an arbitrary rectangular region of the\n BufferedImage and copies it into a specified\n WritableRaster.  The region to be computed is\n determined from the bounds of the specified\n WritableRaster.  The specified\n WritableRaster must have a\n SampleModel that is compatible with this image.  If\n outRaster is null,\n an appropriate WritableRaster is created."}, {"method_name": "setData", "method_sig": "public void setData (Raster r)", "description": "Sets a rectangular region of the image to the contents of the\n specified Raster r, which is\n assumed to be in the same coordinate space as the\n BufferedImage. The operation is clipped to the bounds\n of the BufferedImage."}, {"method_name": "addTileObserver", "method_sig": "public void addTileObserver (TileObserver to)", "description": "Adds a tile observer.  If the observer is already present,\n it receives multiple notifications."}, {"method_name": "removeTileObserver", "method_sig": "public void removeTileObserver (TileObserver to)", "description": "Removes a tile observer.  If the observer was not registered,\n nothing happens.  If the observer was registered for multiple\n notifications, it is now registered for one fewer notification."}, {"method_name": "isTileWritable", "method_sig": "public boolean isTileWritable (int tileX,\n                              int tileY)", "description": "Returns whether or not a tile is currently checked out for writing."}, {"method_name": "getWritableTileIndices", "method_sig": "public Point[] getWritableTileIndices()", "description": "Returns an array of Point objects indicating which tiles\n are checked out for writing.  Returns null if none are\n checked out."}, {"method_name": "hasTileWriters", "method_sig": "public boolean hasTileWriters()", "description": "Returns whether or not any tile is checked out for writing.\n Semantically equivalent to\n \n (getWritableTileIndices() != null).\n "}, {"method_name": "getWritableTile", "method_sig": "public WritableRaster getWritableTile (int tileX,\n                                      int tileY)", "description": "Checks out a tile for writing.  All registered\n TileObservers are notified when a tile goes from having\n no writers to having one writer."}, {"method_name": "releaseWritableTile", "method_sig": "public void releaseWritableTile (int tileX,\n                                int tileY)", "description": "Relinquishes permission to write to a tile.  If the caller\n continues to write to the tile, the results are undefined.\n Calls to this method should only appear in matching pairs\n with calls to getWritableTile(int, int).  Any other leads\n to undefined results.  All registered TileObservers\n are notified when a tile goes from having one writer to having no\n writers."}, {"method_name": "getTransparency", "method_sig": "public int getTransparency()", "description": "Returns the transparency.  Returns either OPAQUE, BITMASK,\n or TRANSLUCENT."}]}