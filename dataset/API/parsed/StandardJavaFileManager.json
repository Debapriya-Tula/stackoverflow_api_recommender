{"name": "Interface StandardJavaFileManager", "module": "java.compiler", "package": "javax.tools", "text": "File manager based on java.io.File and java.nio.file.Path.\n\n A common way to obtain an instance of this class is using\n getStandardFileManager, for example:\n\n \n   JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n   DiagnosticCollector<JavaFileObject> diagnostics =\n       new DiagnosticCollector<JavaFileObject>();\n   StandardJavaFileManager fm = compiler.getStandardFileManager(diagnostics, null, null);\n \n\n This file manager creates file objects representing regular\n files,\n zip file entries, or entries in\n similar file system based containers.  Any file object returned\n from a file manager implementing this interface must observe the\n following behavior:\n\n \n\n     File names need not be canonical.\n   \n\n     For file objects representing regular files\n     \n\n         the method FileObject.delete()\n         is equivalent to File.delete(),\n       \n\n         the method FileObject.getLastModified()\n         is equivalent to File.lastModified(),\n       \n\n         the methods FileObject.getCharContent(boolean),\n         FileObject.openInputStream(), and\n         FileObject.openReader(boolean)\n         must succeed if the following would succeed (ignoring\n         encoding issues):\n         \nnew FileInputStream(new File(fileObject.toUri()))\n\n\n\n         and the methods\n         FileObject.openOutputStream(), and\n         FileObject.openWriter() must\n         succeed if the following would succeed (ignoring encoding\n         issues):\n         \nnew FileOutputStream(new File(fileObject.toUri()))\n\n\n\n\n\n     The URI returned from\n     FileObject.toUri()\n\n\n         must be absolute (have a schema), and\n       \n\n         must have a normalized\npath component which\n         can be resolved without any process-specific context such\n         as the current directory (file names must be absolute).\n       \n\n\n\n\n According to these rules, the following URIs, for example, are\n allowed:\n \n\nfile:///C:/Documents%20and%20Settings/UncleBob/BobsApp/Test.java\n\n\njar:///C:/Documents%20and%20Settings/UncleBob/lib/vendorA.jar!/com/vendora/LibraryClass.class\n\n\n Whereas these are not (reason in parentheses):\n \n\nfile:BobsApp/Test.java (the file name is relative\n     and depend on the current directory)\n   \n\njar:lib/vendorA.jar!/com/vendora/LibraryClass.class\n     (the first half of the path depends on the current directory,\n     whereas the component after ! is legal)\n   \n\nTest.java (this URI depends on the current\n     directory and does not have a schema)\n   \n\njar:///C:/Documents%20and%20Settings/UncleBob/BobsApp/../lib/vendorA.jar!com/vendora/LibraryClass.class\n     (the path is not normalized)\n   \n\nAll implementations of this interface must support Path objects representing\n files in the default file system.\n It is recommended that implementations should support Path objects from any filesystem.", "codes": ["public interface StandardJavaFileManager\nextends JavaFileManager"], "fields": [], "methods": [{"method_name": "isSameFile", "method_sig": "boolean isSameFile (FileObject a,\n                   FileObject b)", "description": "Compares two file objects and return true if they represent the\n same canonical file, zip file entry, or entry in any file\n system based container."}, {"method_name": "getJavaFileObjectsFromFiles", "method_sig": "Iterable<? extends JavaFileObject> getJavaFileObjectsFromFiles (Iterable<? extends File> files)", "description": "Returns file objects representing the given files."}, {"method_name": "getJavaFileObjectsFromPaths", "method_sig": "default Iterable<? extends JavaFileObject> getJavaFileObjectsFromPaths (Iterable<? extends Path> paths)", "description": "Returns file objects representing the given paths."}, {"method_name": "getJavaFileObjects", "method_sig": "Iterable<? extends JavaFileObject> getJavaFileObjects (File... files)", "description": "Returns file objects representing the given files.\n Convenience method equivalent to:\n\n \n     getJavaFileObjectsFromFiles(Arrays.asList(files))\n "}, {"method_name": "getJavaFileObjects", "method_sig": "default Iterable<? extends JavaFileObject> getJavaFileObjects (Path... paths)", "description": "Returns file objects representing the given paths.\n Convenience method equivalent to:\n\n \n     getJavaFileObjectsFromPaths(Arrays.asList(paths))\n "}, {"method_name": "getJavaFileObjectsFromStrings", "method_sig": "Iterable<? extends JavaFileObject> getJavaFileObjectsFromStrings (Iterable<String> names)", "description": "Returns file objects representing the given file names."}, {"method_name": "getJavaFileObjects", "method_sig": "Iterable<? extends JavaFileObject> getJavaFileObjects (String... names)", "description": "Returns file objects representing the given file names.\n Convenience method equivalent to:\n\n \n     getJavaFileObjectsFromStrings(Arrays.asList(names))\n "}, {"method_name": "setLocation", "method_sig": "void setLocation (JavaFileManager.Location location,\n                 Iterable<? extends File> files)\n          throws IOException", "description": "Associates the given search path with the given location.  Any\n previous value will be discarded.\n\n If the location is a module-oriented or output location, any module-specific\n associations set up by setLocationForModule\n will be cancelled."}, {"method_name": "setLocationFromPaths", "method_sig": "default void setLocationFromPaths (JavaFileManager.Location location,\n                                  Collection<? extends Path> paths)\n                           throws IOException", "description": "Associates the given search path with the given location.\n Any previous value will be discarded.\n\n If the location is a module-oriented or output location, any module-specific\n associations set up by setLocationForModule\n will be cancelled."}, {"method_name": "setLocationForModule", "method_sig": "default void setLocationForModule (JavaFileManager.Location location,\n                                  String moduleName,\n                                  Collection<? extends Path> paths)\n                           throws IOException", "description": "Associates the given search path with the given module and location,\n which must be a module-oriented or output location.\n Any previous value will be discarded.\n This overrides any default association derived from the search path\n associated with the location itself.\n\n All such module-specific associations will be cancelled if a\n new search path is associated with the location by calling\n setLocation  or\n setLocationFromPaths."}, {"method_name": "getLocation", "method_sig": "Iterable<? extends File> getLocation (JavaFileManager.Location location)", "description": "Returns the search path associated with the given location."}, {"method_name": "getLocationAsPaths", "method_sig": "default Iterable<? extends Path> getLocationAsPaths (JavaFileManager.Location location)", "description": "Returns the search path associated with the given location."}, {"method_name": "asPath", "method_sig": "default Path asPath (FileObject file)", "description": "Returns the path, if any, underlying this file object (optional operation).\n File objects derived from a FileSystem,\n including the default file system, typically have a corresponding underlying\n Path object. In such cases, this method may be\n used to access that object."}, {"method_name": "setPathFactory", "method_sig": "default void setPathFactory (StandardJavaFileManager.PathFactory f)", "description": "Specify a factory that can be used to generate a path from a string, or series of strings.\n\n If this method is not called, a factory whose getPath method is\n equivalent to calling\n java.nio.file.Paths.get(first, more)\n will be used."}]}