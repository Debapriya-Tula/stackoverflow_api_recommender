{"name": "Class ClassLoader", "module": "java.base", "package": "java.lang", "text": "A class loader is an object that is responsible for loading classes. The\n class ClassLoader is an abstract class.  Given the binary name of a class, a class loader should attempt to\n locate or generate data that constitutes a definition for the class.  A\n typical strategy is to transform the name into a file name and then read a\n \"class file\" of that name from a file system.\n\n  Every Class object contains a reference to the ClassLoader that defined\n it.\n\n  Class objects for array classes are not created by class\n loaders, but are created automatically as required by the Java runtime.\n The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element\n type; if the element type is a primitive type, then the array class has no\n class loader.\n\n  Applications implement subclasses of ClassLoader in order to\n extend the manner in which the Java virtual machine dynamically loads\n classes.\n\n  Class loaders may typically be used by security managers to indicate\n security domains.\n\n  In addition to loading classes, a class loader is also responsible for\n locating resources. A resource is some data (a \".class\" file,\n configuration data, or an image for example) that is identified with an\n abstract '/'-separated path name. Resources are typically packaged with an\n application or library so that they can be located by code in the\n application or library. In some cases, the resources are included so that\n they can be located by other libraries.\n\n  The ClassLoader class uses a delegation model to search for\n classes and resources.  Each instance of ClassLoader has an\n associated parent class loader. When requested to find a class or\n resource, a ClassLoader instance will usually delegate the search\n for the class or resource to its parent class loader before attempting to\n find the class or resource itself.\n\n  Class loaders that support concurrent loading of classes are known as\n parallel capable class\n loaders and are required to register themselves at their class initialization\n time by invoking the ClassLoader.registerAsParallelCapable\n method. Note that the ClassLoader class is registered as parallel\n capable by default. However, its subclasses still need to register themselves\n if they are parallel capable.\n In environments in which the delegation model is not strictly\n hierarchical, class loaders need to be parallel capable, otherwise class\n loading can lead to deadlocks because the loader lock is held for the\n duration of the class loading process (see loadClass methods).\n\n  Run-time Built-in Class Loaders\n\n The Java run-time has the following built-in class loaders:\n\n \nBootstrap class loader.\n     It is the virtual machine's built-in class loader, typically represented\n     as null, and does not have a parent.\nPlatform class loader.\n     All platform classes are visible to the platform class loader\n     that can be used as the parent of a ClassLoader instance.\n     Platform classes include Java SE platform APIs, their implementation\n     classes and JDK-specific run-time classes that are defined by the\n     platform class loader or its ancestors.\n      To allow for upgrading/overriding of modules defined to the platform\n     class loader, and where upgraded modules read modules defined to class\n     loaders other than the platform class loader and its ancestors, then\n     the platform class loader may have to delegate to other class loaders,\n     the application class loader for example.\n     In other words, classes in named modules defined to class loaders\n     other than the platform class loader and its ancestors may be visible\n     to the platform class loader. \nSystem class loader.\n     It is also known as application class loader and is distinct\n     from the platform class loader.\n     The system class loader is typically used to define classes on the\n     application class path, module path, and JDK-specific tools.\n     The platform class loader is a parent or an ancestor of the system class\n     loader that all platform classes are visible to it.\n\n Normally, the Java virtual machine loads classes from the local file\n system in a platform-dependent manner.\n However, some classes may not originate from a file; they may originate\n from other sources, such as the network, or they could be constructed by an\n application.  The method defineClass converts an array of bytes into an instance of class\n Class. Instances of this newly defined class can be created using\n Class.newInstance.\n\n  The methods and constructors of objects created by a class loader may\n reference other classes.  To determine the class(es) referred to, the Java\n virtual machine invokes the loadClass method of\n the class loader that originally created the class.\n\n  For example, an application could create a network class loader to\n download class files from a server.  Sample code might look like:\n\n \n   ClassLoader loader\u00a0= new NetworkClassLoader(host,\u00a0port);\n   Object main\u00a0= loader.loadClass(\"Main\", true).newInstance();\n       \u00a0.\u00a0.\u00a0.\n \n The network class loader subclass must define the methods findClass and loadClassData to load a class\n from the network.  Once it has downloaded the bytes that make up the class,\n it should use the method defineClass to\n create a class instance.  A sample implementation is:\n\n \n     class NetworkClassLoader extends ClassLoader {\n         String host;\n         int port;\n\n         public Class findClass(String name) {\n             byte[] b = loadClassData(name);\n             return defineClass(name, b, 0, b.length);\n         }\n\n         private byte[] loadClassData(String name) {\n             // load the class data from the connection\n             \u00a0.\u00a0.\u00a0.\n         }\n     }\n \n Binary names \n Any class name provided as a String parameter to methods in\n ClassLoader must be a binary name as defined by\n The Java\u2122 Language Specification.\n\n  Examples of valid class names include:\n \n   \"java.lang.String\"\n   \"javax.swing.JSpinner$DefaultEditor\"\n   \"java.security.KeyStore$Builder$FileBuilder$1\"\n   \"java.net.URLClassLoader$3$1\"\n \n Any package name provided as a String parameter to methods in\n ClassLoader must be either the empty string (denoting an unnamed package)\n or a fully qualified name as defined by\n The Java\u2122 Language Specification.", "codes": ["public abstract class ClassLoader\nextends Object"], "fields": [], "methods": [{"method_name": "getName", "method_sig": "public String getName()", "description": "Returns the name of this class loader or null if\n this class loader is not named."}, {"method_name": "loadClass", "method_sig": "public Class<?> loadClass (String name)\n                   throws ClassNotFoundException", "description": "Loads the class with the specified binary name.\n This method searches for classes in the same manner as the loadClass(String, boolean) method.  It is invoked by the Java virtual\n machine to resolve class references.  Invoking this method is equivalent\n to invoking loadClass(name,\n false)."}, {"method_name": "loadClass", "method_sig": "protected Class<?> loadClass (String name,\n                             boolean resolve)\n                      throws ClassNotFoundException", "description": "Loads the class with the specified binary name.  The\n default implementation of this method searches for classes in the\n following order:\n\n \n Invoke findLoadedClass(String) to check if the class\n   has already been loaded.  \n Invoke the loadClass method\n   on the parent class loader.  If the parent is null the class\n   loader built into the virtual machine is used, instead.  \n Invoke the findClass(String) method to find the\n   class.  \n\n If the class was found using the above steps, and the\n resolve flag is true, this method will then invoke the resolveClass(Class) method on the resulting Class object.\n\n  Subclasses of ClassLoader are encouraged to override findClass(String), rather than this method.  \n Unless overridden, this method synchronizes on the result of\n getClassLoadingLock method\n during the entire class loading process."}, {"method_name": "getClassLoadingLock", "method_sig": "protected Object getClassLoadingLock (String className)", "description": "Returns the lock object for class loading operations.\n For backward compatibility, the default implementation of this method\n behaves as follows. If this ClassLoader object is registered as\n parallel capable, the method returns a dedicated object associated\n with the specified class name. Otherwise, the method returns this\n ClassLoader object."}, {"method_name": "findClass", "method_sig": "protected Class<?> findClass (String name)\n                      throws ClassNotFoundException", "description": "Finds the class with the specified binary name.\n This method should be overridden by class loader implementations that\n follow the delegation model for loading classes, and will be invoked by\n the loadClass method after checking the\n parent class loader for the requested class."}, {"method_name": "findClass", "method_sig": "protected Class<?> findClass (String moduleName,\n                             String name)", "description": "Finds the class with the given binary name\n in a module defined to this class loader.\n Class loader implementations that support loading from modules\n should override this method."}, {"method_name": "defineClass", "method_sig": "@Deprecated(since=\"1.1\")\nprotected final Class<?> defineClass (byte[] b,\n                                     int off,\n                                     int len)\n                              throws ClassFormatError", "description": "Converts an array of bytes into an instance of class Class.\n Before the Class can be used it must be resolved.  This method\n is deprecated in favor of the version that takes a binary name as its first argument, and is more secure."}, {"method_name": "defineClass", "method_sig": "protected final Class<?> defineClass (String name,\n                                     byte[] b,\n                                     int off,\n                                     int len)\n                              throws ClassFormatError", "description": "Converts an array of bytes into an instance of class Class.\n Before the Class can be used it must be resolved.\n\n  This method assigns a default ProtectionDomain to the newly defined class.  The\n ProtectionDomain is effectively granted the same set of\n permissions returned when Policy.getPolicy().getPermissions(new CodeSource(null, null))\n is invoked.  The default protection domain is created on the first invocation\n of defineClass,\n and re-used on subsequent invocations.\n\n  To assign a specific ProtectionDomain to the class, use\n the defineClass method that takes a\n ProtectionDomain as one of its arguments.  \n\n This method defines a package in this class loader corresponding to the\n package of the Class (if such a package has not already been defined\n in this class loader). The name of the defined package is derived from\n the binary name of the class specified by\n the byte array b.\n Other properties of the defined package are as specified by Package."}, {"method_name": "defineClass", "method_sig": "protected final Class<?> defineClass (String name,\n                                     byte[] b,\n                                     int off,\n                                     int len,\n                                     ProtectionDomain protectionDomain)\n                              throws ClassFormatError", "description": "Converts an array of bytes into an instance of class Class,\n with a given ProtectionDomain.\n\n  If the given ProtectionDomain is null,\n then a default protection domain will be assigned to the class as specified\n in the documentation for defineClass(String, byte[], int, int).\n Before the class can be used it must be resolved.\n\n  The first class defined in a package determines the exact set of\n certificates that all subsequent classes defined in that package must\n contain.  The set of certificates for a class is obtained from the\n CodeSource within the\n ProtectionDomain of the class.  Any classes added to that\n package must contain the same set of certificates or a\n SecurityException will be thrown.  Note that if\n name is null, this check is not performed.\n You should always pass in the binary name of the\n class you are defining as well as the bytes.  This ensures that the\n class you are defining is indeed the class you think it is.\n\n  If the specified name begins with \"java.\", it can\n only be defined by the platform class loader or its ancestors; otherwise SecurityException\n will be thrown.  If name is not null, it must be equal to\n the binary name of the class\n specified by the byte array b, otherwise a NoClassDefFoundError will be thrown.\n\n  This method defines a package in this class loader corresponding to the\n package of the Class (if such a package has not already been defined\n in this class loader). The name of the defined package is derived from\n the binary name of the class specified by\n the byte array b.\n Other properties of the defined package are as specified by Package."}, {"method_name": "defineClass", "method_sig": "protected final Class<?> defineClass (String name,\n                                     ByteBuffer b,\n                                     ProtectionDomain protectionDomain)\n                              throws ClassFormatError", "description": "Converts a ByteBuffer into an instance\n of class Class, with the given ProtectionDomain.\n If the given ProtectionDomain is null, then a default\n protection domain will be assigned to the class as\n specified in the documentation for defineClass(String, byte[],\n int, int).  Before the class can be used it must be resolved.\n\n The rules about the first class defined in a package determining the\n set of certificates for the package, the restrictions on class names,\n and the defined package of the class\n are identical to those specified in the documentation for defineClass(String, byte[], int, int, ProtectionDomain).\n\n  An invocation of this method of the form\n cl.defineClass(name,\nbBuffer, pd) yields exactly the same\n result as the statements\n\n \n ...\n byte[] temp = new byte[bBuffer.remaining()];\n     bBuffer.get(temp);\n     return cl.defineClass(name, temp, 0,\n temp.length, pd);\n"}, {"method_name": "resolveClass", "method_sig": "protected final void resolveClass (Class<?> c)", "description": "Links the specified class.  This (misleadingly named) method may be\n used by a class loader to link a class.  If the class c has\n already been linked, then this method simply returns. Otherwise, the\n class is linked as described in the \"Execution\" chapter of\n The Java\u2122 Language Specification."}, {"method_name": "findSystemClass", "method_sig": "protected final Class<?> findSystemClass (String name)\n                                  throws ClassNotFoundException", "description": "Finds a class with the specified binary name,\n loading it if necessary.\n\n  This method loads the class through the system class loader (see\n getSystemClassLoader()).  The Class object returned\n might have more than one ClassLoader associated with it.\n Subclasses of ClassLoader need not usually invoke this method,\n because most class loaders need to override just findClass(String).  "}, {"method_name": "findLoadedClass", "method_sig": "protected final Class<?> findLoadedClass (String name)", "description": "Returns the class with the given binary name if this\n loader has been recorded by the Java virtual machine as an initiating\n loader of a class with that binary name.  Otherwise\n null is returned."}, {"method_name": "setSigners", "method_sig": "protected final void setSigners (Class<?> c,\n                                Object[] signers)", "description": "Sets the signers of a class.  This should be invoked after defining a\n class."}, {"method_name": "findResource", "method_sig": "protected URL findResource (String moduleName,\n                           String name)\n                    throws IOException", "description": "Returns a URL to a resource in a module defined to this class loader.\n Class loader implementations that support loading from modules\n should override this method."}, {"method_name": "getResource", "method_sig": "public URL getResource (String name)", "description": "Finds the resource with the given name.  A resource is some data\n (images, audio, text, etc) that can be accessed by class code in a way\n that is independent of the location of the code.\n\n  The name of a resource is a '/'-separated path name that\n identifies the resource. \n Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally (even if the caller of this method is in the\n same module as the resource). "}, {"method_name": "getResources", "method_sig": "public Enumeration<URL> getResources (String name)\n                              throws IOException", "description": "Finds all the resources with the given name. A resource is some data\n (images, audio, text, etc) that can be accessed by class code in a way\n that is independent of the location of the code.\n\n  The name of a resource is a /-separated path name that\n identifies the resource. \n Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally (even if the caller of this method is in the\n same module as the resource). "}, {"method_name": "resources", "method_sig": "public Stream<URL> resources (String name)", "description": "Returns a stream whose elements are the URLs of all the resources with\n the given name. A resource is some data (images, audio, text, etc) that\n can be accessed by class code in a way that is independent of the\n location of the code.\n\n  The name of a resource is a /-separated path name that\n identifies the resource.\n\n  The resources will be located when the returned stream is evaluated.\n If the evaluation results in an IOException then the I/O\n exception is wrapped in an UncheckedIOException that is then\n thrown.\n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally (even if the caller of this method is in the\n same module as the resource). "}, {"method_name": "findResource", "method_sig": "protected URL findResource (String name)", "description": "Finds the resource with the given name. Class loader implementations\n should override this method.\n\n  For resources in named modules then the method must implement the\n rules for encapsulation specified in the Module getResourceAsStream method. Additionally,\n it must not find non-\".class\" resources in packages of named\n modules unless the package is opened\n unconditionally. "}, {"method_name": "findResources", "method_sig": "protected Enumeration<URL> findResources (String name)\n                                  throws IOException", "description": "Returns an enumeration of URL objects\n representing all the resources with the given name. Class loader\n implementations should override this method.\n\n  For resources in named modules then the method must implement the\n rules for encapsulation specified in the Module getResourceAsStream method. Additionally,\n it must not find non-\".class\" resources in packages of named\n modules unless the package is opened\n unconditionally. "}, {"method_name": "registerAsParallelCapable", "method_sig": "protected static boolean registerAsParallelCapable()", "description": "Registers the caller as\n parallel capable.\n The registration succeeds if and only if all of the following\n conditions are met:\n \n no instance of the caller has been created\n all of the super classes (except class Object) of the caller are\n registered as parallel capable\n\nNote that once a class loader is registered as parallel capable, there\n is no way to change it back."}, {"method_name": "isRegisteredAsParallelCapable", "method_sig": "public final boolean isRegisteredAsParallelCapable()", "description": "Returns true if this class loader is registered as\n parallel capable, otherwise\n false."}, {"method_name": "getSystemResource", "method_sig": "public static URL getSystemResource (String name)", "description": "Find a resource of the specified name from the search path used to load\n classes.  This method locates the resource through the system class\n loader (see getSystemClassLoader()).\n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally. "}, {"method_name": "getSystemResources", "method_sig": "public static Enumeration<URL> getSystemResources (String name)\n                                           throws IOException", "description": "Finds all resources of the specified name from the search path used to\n load classes.  The resources thus found are returned as an\n Enumeration of URL objects.\n\n  The search order is described in the documentation for getSystemResource(String).  \n Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally. "}, {"method_name": "getResourceAsStream", "method_sig": "public InputStream getResourceAsStream (String name)", "description": "Returns an input stream for reading the specified resource.\n\n  The search order is described in the documentation for getResource(String).  \n Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally. "}, {"method_name": "getSystemResourceAsStream", "method_sig": "public static InputStream getSystemResourceAsStream (String name)", "description": "Open for reading, a resource of the specified name from the search path\n used to load classes.  This method locates the resource through the\n system class loader (see getSystemClassLoader()).\n\n  Resources in named modules are subject to the encapsulation rules\n specified by Module.getResourceAsStream.\n Additionally, and except for the special case where the resource has a\n name ending with \".class\", this method will only find resources in\n packages of named modules when the package is opened unconditionally. "}, {"method_name": "getParent", "method_sig": "public final ClassLoader getParent()", "description": "Returns the parent class loader for delegation. Some implementations may\n use null to represent the bootstrap class loader. This method\n will return null in such implementations if this class loader's\n parent is the bootstrap class loader."}, {"method_name": "getUnnamedModule", "method_sig": "public final Module getUnnamedModule()", "description": "Returns the unnamed Module for this class loader."}, {"method_name": "getPlatformClassLoader", "method_sig": "public static ClassLoader getPlatformClassLoader()", "description": "Returns the platform class loader.  All\n platform classes are visible to\n the platform class loader."}, {"method_name": "getSystemClassLoader", "method_sig": "public static ClassLoader getSystemClassLoader()", "description": "Returns the system class loader.  This is the default\n delegation parent for new ClassLoader instances, and is\n typically the class loader used to start the application.\n\n  This method is first invoked early in the runtime's startup\n sequence, at which point it creates the system class loader. This\n class loader will be the context class loader for the main application\n thread (for example, the thread that invokes the main method of\n the main class).\n\n  The default system class loader is an implementation-dependent\n instance of this class.\n\n  If the system property \"java.system.class.loader\" is defined\n when this method is first invoked then the value of that property is\n taken to be the name of a class that will be returned as the system\n class loader.  The class is loaded using the default system class loader\n and must define a public constructor that takes a single parameter of\n type ClassLoader which is used as the delegation parent.  An\n instance is then created using this constructor with the default system\n class loader as the parameter.  The resulting class loader is defined\n to be the system class loader. During construction, the class loader\n should take great care to avoid calling getSystemClassLoader().\n If circular initialization of the system class loader is detected then\n an IllegalStateException is thrown."}, {"method_name": "definePackage", "method_sig": "protected Package definePackage (String name,\n                                String specTitle,\n                                String specVersion,\n                                String specVendor,\n                                String implTitle,\n                                String implVersion,\n                                String implVendor,\n                                URL sealBase)", "description": "Defines a package by name in this ClassLoader.\n \nPackage names must be unique within a class loader and\n cannot be redefined or changed once created.\n \n If a class loader wishes to define a package with specific properties,\n such as version information, then the class loader should call this\n definePackage method before calling defineClass.\n Otherwise, the\n defineClass\n method will define a package in this class loader corresponding to the package\n of the newly defined class; the properties of this defined package are\n specified by Package."}, {"method_name": "getDefinedPackage", "method_sig": "public final Package getDefinedPackage (String name)", "description": "Returns a Package of the given name that\n has been defined by this class loader."}, {"method_name": "getDefinedPackages", "method_sig": "public final Package[] getDefinedPackages()", "description": "Returns all of the Packages that have been defined by\n this class loader.  The returned array has no duplicated Packages\n of the same name."}, {"method_name": "getPackage", "method_sig": "@Deprecated(since=\"9\")\nprotected Package getPackage (String name)", "description": "Finds a package by name in this class loader and its ancestors.\n \n If this class loader defines a Package of the given name,\n the Package is returned. Otherwise, the ancestors of\n this class loader are searched recursively (parent by parent)\n for a Package of the given name."}, {"method_name": "getPackages", "method_sig": "protected Package[] getPackages()", "description": "Returns all of the Packages that have been defined by\n this class loader and its ancestors.  The returned array may contain\n more than one Package object of the same package name, each\n defined by a different class loader in the class loader hierarchy."}, {"method_name": "findLibrary", "method_sig": "protected String findLibrary (String libname)", "description": "Returns the absolute path name of a native library.  The VM invokes this\n method to locate the native libraries that belong to classes loaded with\n this class loader. If this method returns null, the VM\n searches the library along the path specified as the\n \"java.library.path\" property."}, {"method_name": "setDefaultAssertionStatus", "method_sig": "public void setDefaultAssertionStatus (boolean enabled)", "description": "Sets the default assertion status for this class loader.  This setting\n determines whether classes loaded by this class loader and initialized\n in the future will have assertions enabled or disabled by default.\n This setting may be overridden on a per-package or per-class basis by\n invoking setPackageAssertionStatus(String, boolean) or setClassAssertionStatus(String, boolean)."}, {"method_name": "setPackageAssertionStatus", "method_sig": "public void setPackageAssertionStatus (String packageName,\n                                      boolean enabled)", "description": "Sets the package default assertion status for the named package.  The\n package default assertion status determines the assertion status for\n classes initialized in the future that belong to the named package or\n any of its \"subpackages\".\n\n  A subpackage of a package named p is any package whose name begins\n with \"p.\".  For example, javax.swing.text is a\n subpackage of javax.swing, and both java.util and\n java.lang.reflect are subpackages of java.\n\n  In the event that multiple package defaults apply to a given class,\n the package default pertaining to the most specific package takes\n precedence over the others.  For example, if javax.lang and\n javax.lang.reflect both have package defaults associated with\n them, the latter package default applies to classes in\n javax.lang.reflect.\n\n  Package defaults take precedence over the class loader's default\n assertion status, and may be overridden on a per-class basis by invoking\n setClassAssertionStatus(String, boolean).  "}, {"method_name": "setClassAssertionStatus", "method_sig": "public void setClassAssertionStatus (String className,\n                                    boolean enabled)", "description": "Sets the desired assertion status for the named top-level class in this\n class loader and any nested classes contained therein.  This setting\n takes precedence over the class loader's default assertion status, and\n over any applicable per-package default.  This method has no effect if\n the named class has already been initialized.  (Once a class is\n initialized, its assertion status cannot change.)\n\n  If the named class is not a top-level class, this invocation will\n have no effect on the actual assertion status of any class. "}, {"method_name": "clearAssertionStatus", "method_sig": "public void clearAssertionStatus()", "description": "Sets the default assertion status for this class loader to\n false and discards any package defaults or class assertion\n status settings associated with the class loader.  This method is\n provided so that class loaders can be made to ignore any command line or\n persistent assertion status settings and \"start with a clean slate.\""}]}