{"name": "Class EventHandler", "module": "java.desktop", "package": "java.beans", "text": "The EventHandler class provides\n support for dynamically generating event listeners whose methods\n execute a simple statement involving an incoming event object\n and a target object.\n \n The EventHandler class is intended to be used by interactive tools, such as\n application builders, that allow developers to make connections between\n beans. Typically connections are made from a user interface bean\n (the event source)\n to an application logic bean (the target). The most effective\n connections of this kind isolate the application logic from the user\n interface.  For example, the EventHandler for a\n connection from a JCheckBox to a method\n that accepts a boolean value can deal with extracting the state\n of the check box and passing it directly to the method so that\n the method is isolated from the user interface layer.\n \n Inner classes are another, more general way to handle events from\n user interfaces.  The EventHandler class\n handles only a subset of what is possible using inner\n classes. However, EventHandler works better\n with the long-term persistence scheme than inner classes.\n Also, using EventHandler in large applications in\n which the same interface is implemented many times can\n reduce the disk and memory footprint of the application.\n \n The reason that listeners created with EventHandler\n have such a small\n footprint is that the Proxy class, on which\n the EventHandler relies, shares implementations\n of identical\n interfaces. For example, if you use\n the EventHandler create methods to make\n all the ActionListeners in an application,\n all the action listeners will be instances of a single class\n (one created by the Proxy class).\n In general, listeners based on\n the Proxy class require one listener class\n to be created per listener type (interface),\n whereas the inner class\n approach requires one class to be created per listener\n (object that implements the interface).\n\n \n You don't generally deal directly with EventHandler\n instances.\n Instead, you use one of the EventHandler\ncreate methods to create\n an object that implements a given listener interface.\n This listener object uses an EventHandler object\n behind the scenes to encapsulate information about the\n event, the object to be sent a message when the event occurs,\n the message (method) to be sent, and any argument\n to the method.\n The following section gives examples of how to create listener\n objects using the create methods.\n\n Examples of Using EventHandler\n\n The simplest use of EventHandler is to install\n a listener that calls a method on the target object with no arguments.\n In the following example we create an ActionListener\n that invokes the toFront method on an instance\n of javax.swing.JFrame.\n\n \n\nmyButton.addActionListener(\n    (ActionListener)EventHandler.create(ActionListener.class, frame, \"toFront\"));\n\n\n\n When myButton is pressed, the statement\n frame.toFront() will be executed.  One could get\n the same effect, with some additional compile-time type safety,\n by defining a new implementation of the ActionListener\n interface and adding an instance of it to the button:\n\n \n\n//Equivalent code using an inner class instead of EventHandler.\nmyButton.addActionListener(new ActionListener() {\n    public void actionPerformed(ActionEvent e) {\n        frame.toFront();\n    }\n});\n\n\n\n The next simplest use of EventHandler is\n to extract a property value from the first argument\n of the method in the listener interface (typically an event object)\n and use it to set the value of a property in the target object.\n In the following example we create an ActionListener that\n sets the nextFocusableComponent property of the target\n (myButton) object to the value of the \"source\" property of the event.\n\n \n\nEventHandler.create(ActionListener.class, myButton, \"nextFocusableComponent\", \"source\")\n\n\n\n This would correspond to the following inner class implementation:\n\n \n\n//Equivalent code using an inner class instead of EventHandler.\nnew ActionListener() {\n    public void actionPerformed(ActionEvent e) {\n        myButton.setNextFocusableComponent((Component)e.getSource());\n    }\n}\n\n\n\n It's also possible to create an EventHandler that\n just passes the incoming event object to the target's action.\n If the fourth EventHandler.create argument is\n an empty string, then the event is just passed along:\n\n \n\nEventHandler.create(ActionListener.class, target, \"doActionEvent\", \"\")\n\n\n\n This would correspond to the following inner class implementation:\n\n \n\n//Equivalent code using an inner class instead of EventHandler.\nnew ActionListener() {\n    public void actionPerformed(ActionEvent e) {\n        target.doActionEvent(e);\n    }\n}\n\n\n\n Probably the most common use of EventHandler\n is to extract a property value from the\n source of the event object and set this value as\n the value of a property of the target object.\n In the following example we create an ActionListener that\n sets the \"label\" property of the target\n object to the value of the \"text\" property of the\n source (the value of the \"source\" property) of the event.\n\n \n\nEventHandler.create(ActionListener.class, myButton, \"label\", \"source.text\")\n\n\n\n This would correspond to the following inner class implementation:\n\n \n\n//Equivalent code using an inner class instead of EventHandler.\nnew ActionListener {\n    public void actionPerformed(ActionEvent e) {\n        myButton.setLabel(((JTextField)e.getSource()).getText());\n    }\n}\n\n\n\n The event property may be \"qualified\" with an arbitrary number\n of property prefixes delimited with the \".\" character. The \"qualifying\"\n names that appear before the \".\" characters are taken as the names of\n properties that should be applied, left-most first, to\n the event object.\n \n For example, the following action listener\n\n \n\nEventHandler.create(ActionListener.class, target, \"a\", \"b.c.d\")\n\n\n\n might be written as the following inner class\n (assuming all the properties had canonical getter methods and\n returned the appropriate types):\n\n \n\n//Equivalent code using an inner class instead of EventHandler.\nnew ActionListener {\n    public void actionPerformed(ActionEvent e) {\n        target.setA(e.getB().getC().isD());\n    }\n}\n\n\n The target property may also be \"qualified\" with an arbitrary number\n of property prefixs delimited with the \".\" character.  For example, the\n following action listener:\n \n   EventHandler.create(ActionListener.class, target, \"a.b\", \"c.d\")\n \n might be written as the following inner class\n (assuming all the properties had canonical getter methods and\n returned the appropriate types):\n \n   //Equivalent code using an inner class instead of EventHandler.\n   new ActionListener {\n     public void actionPerformed(ActionEvent e) {\n         target.getA().setB(e.getC().isD());\n    }\n}\n\n\n As EventHandler ultimately relies on reflection to invoke\n a method we recommend against targeting an overloaded method.  For example,\n if the target is an instance of the class MyTarget which is\n defined as:\n \n   public class MyTarget {\n     public void doIt(String);\n     public void doIt(Object);\n   }\n \n Then the method doIt is overloaded.  EventHandler will invoke\n the method that is appropriate based on the source.  If the source is\n null, then either method is appropriate and the one that is invoked is\n undefined.  For that reason we recommend against targeting overloaded\n methods.", "codes": ["public class EventHandler\nextends Object\nimplements InvocationHandler"], "fields": [], "methods": [{"method_name": "getTarget", "method_sig": "public Object getTarget()", "description": "Returns the object to which this event handler will send a message."}, {"method_name": "getAction", "method_sig": "public String getAction()", "description": "Returns the name of the target's writable property\n that this event handler will set,\n or the name of the method that this event handler\n will invoke on the target."}, {"method_name": "getEventPropertyName", "method_sig": "public String getEventPropertyName()", "description": "Returns the property of the event that should be\n used in the action applied to the target."}, {"method_name": "getListenerMethodName", "method_sig": "public String getListenerMethodName()", "description": "Returns the name of the method that will trigger the action.\n A return value of null signifies that all methods in the\n listener interface trigger the action."}, {"method_name": "invoke", "method_sig": "public Object invoke (Object proxy,\n                     Method method,\n                     Object[] arguments)", "description": "Extract the appropriate property value from the event and\n pass it to the action associated with\n this EventHandler."}, {"method_name": "create", "method_sig": "public static <T> T create (Class<T> listenerInterface,\n                           Object target,\n                           String action)", "description": "Creates an implementation of listenerInterface in which\n all of the methods in the listener interface apply\n the handler's action to the target. This\n method is implemented by calling the other, more general,\n implementation of the create method with both\n the eventPropertyName and the listenerMethodName\n taking the value null. Refer to\n the general version of create for a complete description of\n the action parameter.\n \n To create an ActionListener that shows a\n JDialog with dialog.show(),\n one can write:\n\n\n\nEventHandler.create(ActionListener.class, dialog, \"show\")\n\n"}, {"method_name": "create", "method_sig": "public static <T> T create (Class<T> listenerInterface,\n                           Object target,\n                           String action,\n                           String eventPropertyName)", "description": "/**\n Creates an implementation of listenerInterface in which\n all of the methods pass the value of the event\n expression, eventPropertyName, to the final method in the\n statement, action, which is applied to the target.\n This method is implemented by calling the\n more general, implementation of the create method with\n the listenerMethodName taking the value null.\n Refer to\n the general version of create for a complete description of\n the action and eventPropertyName parameters.\n \n To create an ActionListener that sets the\n the text of a JLabel to the text value of\n the JTextField source of the incoming event,\n you can use the following code:\n\n\n\nEventHandler.create(ActionListener.class, label, \"text\", \"source.text\");\n\n\n\n This is equivalent to the following code:\n\n\n//Equivalent code using an inner class instead of EventHandler.\nnew ActionListener() {\n    public void actionPerformed(ActionEvent event) {\n        label.setText(((JTextField)(event.getSource())).getText());\n     }\n};\n\n"}, {"method_name": "create", "method_sig": "public static <T> T create (Class<T> listenerInterface,\n                           Object target,\n                           String action,\n                           String eventPropertyName,\n                           String listenerMethodName)", "description": "Creates an implementation of listenerInterface in which\n the method named listenerMethodName\n passes the value of the event expression, eventPropertyName,\n to the final method in the statement, action, which\n is applied to the target. All of the other listener\n methods do nothing.\n \n The eventPropertyName string is used to extract a value\n from the incoming event object that is passed to the target\n method.  The common case is the target method takes no arguments, in\n which case a value of null should be used for the\n eventPropertyName.  Alternatively if you want\n the incoming event object passed directly to the target method use\n the empty string.\n The format of the eventPropertyName string is a sequence of\n methods or properties where each method or\n property is applied to the value returned by the preceding method\n starting from the incoming event object.\n The syntax is: propertyName{.propertyName}*\n where propertyName matches a method or\n property.  For example, to extract the point\n property from a MouseEvent, you could use either\n \"point\" or \"getPoint\" as the\n eventPropertyName.  To extract the \"text\" property from\n a MouseEvent with a JLabel source use any\n of the following as eventPropertyName:\n \"source.text\",\n \"getSource.text\" \"getSource.getText\" or\n \"source.getText\".  If a method can not be found, or an\n exception is generated as part of invoking a method a\n RuntimeException will be thrown at dispatch time.  For\n example, if the incoming event object is null, and\n eventPropertyName is non-null and not empty, a\n RuntimeException will be thrown.\n \n The action argument is of the same format as the\n eventPropertyName argument where the last property name\n identifies either a method name or writable property.\n \n If the listenerMethodName is null\nall methods in the interface trigger the action to be\n executed on the target.\n \n For example, to create a MouseListener that sets the target\n object's origin property to the incoming MouseEvent's\n location (that's the value of mouseEvent.getPoint()) each\n time a mouse button is pressed, one would write:\n\n\nEventHandler.create(MouseListener.class, target, \"origin\", \"point\", \"mousePressed\");\n\n\n\n This is comparable to writing a MouseListener in which all\n of the methods except mousePressed are no-ops:\n\n\n\n//Equivalent code using an inner class instead of EventHandler.\nnew MouseAdapter() {\n    public void mousePressed(MouseEvent e) {\n        target.setOrigin(e.getPoint());\n    }\n};\n \n"}]}