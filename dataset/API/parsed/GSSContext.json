{"name": "Interface GSSContext", "module": "java.security.jgss", "package": "org.ietf.jgss", "text": "This interface encapsulates the GSS-API security context and provides\n the security services that are available over the context.  Security\n contexts are established between peers using locally acquired\n credentials.  Multiple contexts may exist simultaneously between a pair\n of peers, using the same or different set of credentials.  GSS-API\n functions in a manner independent of the underlying transport protocol\n and depends on its calling application to transport the tokens that are\n generated by the security context between the peers.\n\n If the caller instantiates the context using the default\n GSSManager instance, then the Kerberos v5 GSS-API mechanism\n is guaranteed to be available for context establishment. This mechanism\n is identified by the Oid \"1.2.840.113554.1.2.2\" and is defined in RFC\n 1964.\n\n Before the context establishment phase is initiated, the context\n initiator may request specific characteristics desired of the\n established context. Not all underlying mechanisms support all\n characteristics that a caller might desire. After the context is\n established, the caller can check the actual characteristics and services\n offered by that context by means of various query methods. When using\n the Kerberos v5 GSS-API mechanism offered by the default\n GSSManager instance, all optional services will be\n available locally. They are mutual authentication, credential\n delegation, confidentiality and integrity protection, and per-message\n replay detection and sequencing. Note that in the GSS-API, message integrity\n is a prerequisite for message confidentiality.\n\n The context establishment occurs in a loop where the\n initiator calls initSecContext\n and the acceptor calls acceptSecContext until the context is established. While in this loop\n the initSecContext and acceptSecContext\n methods produce tokens that the application sends over to the peer. The\n peer passes any such token as input to its acceptSecContext\n or initSecContext as the case may be.\n\n During the context establishment phase, the isProtReady method may be called to determine if the\n context can be used for the per-message operations of wrap and getMIC.  This allows applications to use\n per-message operations on contexts which aren't yet fully\n established.\n\n After the context has been established or the isProtReady\n method returns true, the query routines can be invoked to\n determine the actual characteristics and services of the established\n context.  The application can also start using the per-message methods\n of wrap and\n getMIC to obtain\n cryptographic operations on application supplied data.\n\n When the context is no longer needed, the application should call\n dispose to release any system resources the context\n may be using.\n\n A security context typically maintains sequencing and replay detection\n information about the tokens it processes. Therefore, the sequence in\n which any tokens are presented to this context for processing can be\n important. Also note that none of the methods in this interface are\n synchronized. Therefore, it is not advisable to share a\n GSSContext among several threads unless some application\n level synchronization is in place.\n\n Finally, different mechanism providers might place different security\n restrictions on using GSS-API contexts. These will be documented by the\n mechanism provider. The application will need to ensure that it has the\n appropriate permissions if such checks are made in the mechanism layer.\n\n The stream-based methods of GSSContext have been deprecated in\n Java SE 11. These methods have also been removed from\n \n RFC 8353: Generic Security Service API Version 2: Java Bindings Update\n for the following reasons (see section 11): \"The overloaded methods of\n GSSContext that use input and output streams as the means to convey\n authentication and per-message GSS-API tokens as described in Section 5.15\n of RFC 5653 are removed in this update as the wire protocol\n should be defined by an application and not a library. It's also impossible\n to implement these methods correctly when the token has no self-framing\n (where the end cannot be determined), or the library has no knowledge of\n the token format (for example, as a bridge talking to another GSS library)\".\n These methods include initSecContext(InputStream, OutputStream),\n acceptSecContext(InputStream, OutputStream),\n wrap(InputStream, OutputStream, MessageProp),\n unwrap(InputStream, OutputStream, MessageProp),\n getMIC(InputStream, OutputStream, MessageProp),\n and verifyMIC(InputStream, InputStream, MessageProp).\n\n The example code presented below demonstrates the usage of the\n GSSContext interface for the initiating peer.  Different\n operations on the GSSContext object are presented,\n including: object instantiation, setting of desired flags, context\n establishment, query of actual context flags, per-message operations on\n application data, and finally context deletion.\n\n \n    // Create a context using default credentials\n    // and the implementation specific default mechanism\n    GSSManager manager ...\n    GSSName targetName ...\n    GSSContext context = manager.createContext(targetName, null, null,\n                                           GSSContext.INDEFINITE_LIFETIME);\n\n    // set desired context options prior to context establishment\n    context.requestConf(true);\n    context.requestMutualAuth(true);\n    context.requestReplayDet(true);\n    context.requestSequenceDet(true);\n\n    // establish a context between peers\n\n    byte []inToken = new byte[0];\n\n    // Loop while there still is a token to be processed\n\n    while (!context.isEstablished()) {\n\n        byte[] outToken\n            = context.initSecContext(inToken, 0, inToken.length);\n\n        // send the output token if generated\n        if (outToken != null)\n            sendToken(outToken);\n\n        if (!context.isEstablished()) {\n            inToken = readToken();\n    }\n\n     // display context information\n     System.out.println(\"Remaining lifetime in seconds = \"\n                                          + context.getLifetime());\n     System.out.println(\"Context mechanism = \" + context.getMech());\n     System.out.println(\"Initiator = \" + context.getSrcName());\n     System.out.println(\"Acceptor = \" + context.getTargName());\n\n     if (context.getConfState())\n             System.out.println(\"Confidentiality (i.e., privacy) is available\");\n\n     if (context.getIntegState())\n             System.out.println(\"Integrity is available\");\n\n     // perform wrap on an application supplied message, appMsg,\n     // using QOP = 0, and requesting privacy service\n     byte [] appMsg ...\n\n     MessageProp mProp = new MessageProp(0, true);\n\n     byte []tok = context.wrap(appMsg, 0, appMsg.length, mProp);\n\n     sendToken(tok);\n\n     // release the local-end of the context\n     context.dispose();\n\n ", "codes": ["public interface GSSContext"], "fields": [{"field_name": "DEFAULT_LIFETIME", "field_sig": "static final\u00a0int DEFAULT_LIFETIME", "description": "A lifetime constant representing the default context lifetime.  This\n value is set to 0."}, {"field_name": "INDEFINITE_LIFETIME", "field_sig": "static final\u00a0int INDEFINITE_LIFETIME", "description": "A lifetime constant representing indefinite context lifetime.\n This value must is set to the maximum integer value in Java -\n Integer.MAX_VALUE."}], "methods": [{"method_name": "initSecContext", "method_sig": "byte[] initSecContext (byte[] inputBuf,\n                      int offset,\n                      int len)\n               throws GSSException", "description": "Called by the context initiator to start the context creation\n phase and process any tokens generated\n by the peer's acceptSecContext method.\n This method may return an output token which the application will need\n to send to the peer for processing by its acceptSecContext\n method. The application can call isEstablished to determine if the context establishment phase is\n complete on this side of the context.  A return value of\n false from isEstablished indicates that\n more tokens are expected to be supplied to\n initSecContext.  Upon completion of the context\n establishment, the available context options may be queried through\n the get methods.\n\n Note that it is possible that the initSecContext method\n return a token for the peer, and isEstablished return\n true also. This indicates that the token needs to be sent\n to the peer, but the local end of the context is now fully\n established.\n\n Some mechanism providers might require that the caller be granted\n permission to initiate a security context. A failed permission check\n might cause a SecurityException\n to be thrown from this method."}, {"method_name": "initSecContext", "method_sig": "@Deprecated(since=\"11\")\nint initSecContext (InputStream inStream,\n                   OutputStream outStream)\n            throws GSSException", "description": "Called by the context initiator to start the context creation\n phase and process any tokens generated\n by the peer's acceptSecContext method using\n streams. This method may write an output token to the\n OutpuStream, which the application will\n need to send to the peer for processing by its\n acceptSecContext call. Typically, the application would\n ensure this by calling the  flush\n method on an OutputStream that encapsulates the\n connection between the two peers. The application can\n determine if a token is written to the OutputStream from the return\n value of this method. A return value of 0 indicates that\n no token was written. The application can call\n isEstablished to determine if the context\n establishment phase is complete on this side of the context. A\n return  value of false from isEstablished\n indicates that more tokens are expected to be supplied to\n initSecContext.\n Upon completion of the context establishment, the available context\n options may be queried through the get methods.\n\n Note that it is possible that the initSecContext method\n return a token for the peer, and isEstablished return\n true also. This indicates that the token needs to be sent\n to the peer, but the local end of the context is now fully\n established.\n\n The GSS-API authentication tokens contain a definitive start and\n end. This method will attempt to read one of these tokens per\n invocation, and may block on the stream if only part of the token is\n available.  In all other respects this method is equivalent to the\n byte array based initSecContext.\n\n Some mechanism providers might require that the caller be granted\n permission to initiate a security context. A failed permission check\n might cause a SecurityException\n to be thrown from this method.\n\n The following example code demonstrates how this method might be\n used:\n \n     InputStream is ...\n     OutputStream os ...\n     GSSContext context ...\n\n     // Loop while there is still a token to be processed\n\n     while (!context.isEstablished()) {\n\n         context.initSecContext(is, os);\n\n         // send output token if generated\n         os.flush();\n     }\n "}, {"method_name": "acceptSecContext", "method_sig": "byte[] acceptSecContext (byte[] inToken,\n                        int offset,\n                        int len)\n                 throws GSSException", "description": "Called by the context acceptor upon receiving a token from the\n peer. This method may return an output token which the application\n will need to send to the peer for further processing by its\n initSecContext call.\n\n The application can call isEstablished to\n determine if the context establishment phase is complete for this\n peer.  A return value of false from\n isEstablished indicates that more tokens are expected to\n be supplied to this method.    Upon completion of the context\n establishment, the available context options may be queried through\n the get methods.\n\n Note that it is possible that acceptSecContext return a\n token for the peer, and isEstablished return\n true also.  This indicates that the token needs to be\n sent to the peer, but the local end of the context is now fully\n established.\n\n Some mechanism providers might require that the caller be granted\n permission to accept a security context. A failed permission check\n might cause a SecurityException\n to be thrown from this method.\n\n The following example code demonstrates how this method might be\n used:\n \n     byte[] inToken;\n     byte[] outToken;\n     GSSContext context ...\n\n     // Loop while there is still a token to be processed\n\n     while (!context.isEstablished()) {\n         inToken = readToken();\n         outToken = context.acceptSecContext(inToken, 0,\n                                             inToken.length);\n         // send output token if generated\n         if (outToken != null)\n             sendToken(outToken);\n     }\n "}, {"method_name": "acceptSecContext", "method_sig": "@Deprecated(since=\"11\")\nvoid acceptSecContext (InputStream inStream,\n                      OutputStream outStream)\n               throws GSSException", "description": "Called by the context acceptor to process a token from the peer using\n streams.   It may write an output token to the\n OutputStream, which the application\n will need to send to the peer for processing by its\n initSecContext method.  Typically, the application would\n ensure this by calling the  flush\n method on an OutputStream that encapsulates the\n connection between the two peers. The application can call\n isEstablished to determine if the context\n establishment phase is complete on this side of the context. A\n return  value of false from isEstablished\n indicates that more tokens are expected to be supplied to\n acceptSecContext.\n Upon completion of the context establishment, the available context\n options may be queried through the get methods.\n\n Note that it is possible that acceptSecContext return a\n token for the peer, and isEstablished return\n true also.  This indicates that the token needs to be\n sent to the peer, but the local end of the context is now fully\n established.\n\n The GSS-API authentication tokens contain a definitive start and\n end. This method will attempt to read one of these tokens per\n invocation, and may block on the stream if only part of the token is\n available. In all other respects this method is equivalent to the byte\n array based acceptSecContext.\n\n Some mechanism providers might require that the caller be granted\n permission to accept a security context. A failed permission check\n might cause a SecurityException\n to be thrown from this method.\n\n The following example code demonstrates how this method might be\n used:\n \n     InputStream is ...\n     OutputStream os ...\n     GSSContext context ...\n\n     // Loop while there is still a token to be processed\n\n     while (!context.isEstablished()) {\n\n         context.acceptSecContext(is, os);\n\n         // send output token if generated\n         os.flush();\n     }\n "}, {"method_name": "isEstablished", "method_sig": "boolean isEstablished()", "description": "Used during context establishment to determine the state of the\n context."}, {"method_name": "dispose", "method_sig": "void dispose()\n      throws GSSException", "description": "Releases any system resources and cryptographic information stored in\n the context object and invalidates the context."}, {"method_name": "getWrapSizeLimit", "method_sig": "int getWrapSizeLimit (int qop,\n                     boolean confReq,\n                     int maxTokenSize)\n              throws GSSException", "description": "Used to determine limits on the size of the message\n that can be passed to wrap. Returns the maximum\n message size that, if presented to the wrap method with\n the same confReq and qop parameters, will\n result in an output token containing no more\n than maxTokenSize bytes.\n\n This call is intended for use by applications that communicate over\n protocols that impose a maximum message size.  It enables the\n application to fragment messages prior to applying protection.\n\n GSS-API implementations are recommended but not required to detect\n invalid QOP values when getWrapSizeLimit is called.\n This routine guarantees only a maximum message size, not the\n availability of specific QOP values for message protection."}, {"method_name": "wrap", "method_sig": "byte[] wrap (byte[] inBuf,\n            int offset,\n            int len,\n            MessageProp msgProp)\n     throws GSSException", "description": "Applies per-message security services over the established security\n context. The method will return a token with the\n application supplied data and a cryptographic MIC over it.\n The data may be encrypted if confidentiality (privacy) was\n requested.\n\n The MessageProp object is instantiated by the application and used\n to specify a QOP value which selects cryptographic algorithms, and a\n privacy service to optionally encrypt the message.  The underlying\n mechanism that is used in the call may not be able to provide the\n privacy service.  It sets the actual privacy service that it does\n provide in this MessageProp object which the caller should then\n query upon return.  If the mechanism is not able to provide the\n requested QOP, it throws a GSSException with the BAD_QOP code.\n\n Since some application-level protocols may wish to use tokens\n emitted by wrap to provide \"secure framing\", implementations should\n support the wrapping of zero-length messages.\n\n The application will be responsible for sending the token to the\n peer."}, {"method_name": "wrap", "method_sig": "@Deprecated(since=\"11\")\nvoid wrap (InputStream inStream,\n          OutputStream outStream,\n          MessageProp msgProp)\n   throws GSSException", "description": "Applies per-message security services over the established security\n context using streams. The method will return a\n token with the application supplied data and a cryptographic MIC over it.\n The data may be encrypted if confidentiality\n (privacy) was requested. This method is equivalent to the byte array\n based wrap method.\n\n The application will be responsible for sending the token to the\n peer.  Typically, the application would\n ensure this by calling the  flush\n method on an OutputStream that encapsulates the\n connection between the two peers.\n\n The MessageProp object is instantiated by the application and used\n to specify a QOP value which selects cryptographic algorithms, and a\n privacy service to optionally encrypt the message.  The underlying\n mechanism that is used in the call may not be able to provide the\n privacy service.  It sets the actual privacy service that it does\n provide in this MessageProp object which the caller should then\n query upon return.  If the mechanism is not able to provide the\n requested QOP, it throws a GSSException with the BAD_QOP code.\n\n Since some application-level protocols may wish to use tokens\n emitted by wrap to provide \"secure framing\", implementations should\n support the wrapping of zero-length messages."}, {"method_name": "unwrap", "method_sig": "byte[] unwrap (byte[] inBuf,\n              int offset,\n              int len,\n              MessageProp msgProp)\n       throws GSSException", "description": "Used to process tokens generated by the wrap method on\n the other side of the context. The method will return the message\n supplied by the peer application to its wrap call, while at the same\n time verifying the embedded MIC for that message.\n\n The MessageProp object is instantiated by the application and is\n used by the underlying mechanism to return information to the caller\n such as the QOP, whether confidentiality was applied to the message,\n and other supplementary message state information.\n\n Since some application-level protocols may wish to use tokens\n emitted by wrap to provide \"secure framing\", implementations should\n support the wrapping and unwrapping of zero-length messages."}, {"method_name": "unwrap", "method_sig": "@Deprecated(since=\"11\")\nvoid unwrap (InputStream inStream,\n            OutputStream outStream,\n            MessageProp msgProp)\n     throws GSSException", "description": "Uses streams to process tokens generated by the wrap\n method on the other side of the context. The method will return the\n message supplied by the peer application to its wrap call, while at\n the same time verifying the embedded MIC for that message.\n\n The MessageProp object is instantiated by the application and is\n used by the underlying mechanism to return information to the caller\n such as the QOP, whether confidentiality was applied to the message,\n and other supplementary message state information.\n\n Since some application-level protocols may wish to use tokens\n emitted by wrap to provide \"secure framing\", implementations should\n support the wrapping and unwrapping of zero-length messages.\n\n The format of the input token that this method\n reads is defined in the specification for the underlying mechanism that\n will be used. This method will attempt to read one of these tokens per\n invocation. If the mechanism token contains a definitive start and\n end this method may block on the InputStream if only\n part of the token is available. If the start and end of the token\n are not definitive then the method will attempt to treat all\n available bytes as part of the token.\n\n Other than the possible blocking behavior described above, this\n method is equivalent to the byte array based unwrap method."}, {"method_name": "getMIC", "method_sig": "byte[] getMIC (byte[] inMsg,\n              int offset,\n              int len,\n              MessageProp msgProp)\n       throws GSSException", "description": "Returns a token containing a cryptographic Message Integrity Code\n (MIC) for the supplied message,  for transfer to the peer\n application.  Unlike wrap, which encapsulates the user message in the\n returned token, only the message MIC is returned in the output\n token.\n\n Note that privacy can only be applied through the wrap call.\n\n Since some application-level protocols may wish to use tokens emitted\n by getMIC to provide \"secure framing\", implementations should support\n derivation of MICs from zero-length messages."}, {"method_name": "getMIC", "method_sig": "@Deprecated(since=\"11\")\nvoid getMIC (InputStream inStream,\n            OutputStream outStream,\n            MessageProp msgProp)\n     throws GSSException", "description": "Uses streams to produce a token containing a cryptographic MIC for\n the supplied message, for transfer to the peer application.\n Unlike wrap, which encapsulates the user message in the returned\n token, only the message MIC is produced in the output token. This\n method is equivalent to the byte array based getMIC method.\n\n Note that privacy can only be applied through the wrap call.\n\n Since some application-level protocols may wish to use tokens emitted\n by getMIC to provide \"secure framing\", implementations should support\n derivation of MICs from zero-length messages."}, {"method_name": "verifyMIC", "method_sig": "void verifyMIC (byte[] inToken,\n               int tokOffset,\n               int tokLen,\n               byte[] inMsg,\n               int msgOffset,\n               int msgLen,\n               MessageProp msgProp)\n        throws GSSException", "description": "Verifies the cryptographic MIC, contained in the token parameter,\n over the supplied message.\n\n The MessageProp object is instantiated by the application and is used\n by the underlying mechanism to return information to the caller such\n as the QOP indicating the strength of protection that was applied to\n the message and other supplementary message state information.\n\n Since some application-level protocols may wish to use tokens emitted\n by getMIC to provide \"secure framing\", implementations should support\n the calculation and verification of MICs over zero-length messages."}, {"method_name": "verifyMIC", "method_sig": "@Deprecated(since=\"11\")\nvoid verifyMIC (InputStream tokStream,\n               InputStream msgStream,\n               MessageProp msgProp)\n        throws GSSException", "description": "Uses streams to verify the cryptographic MIC, contained in the token\n parameter, over the supplied message.  This method is equivalent to\n the byte array based verifyMIC method.\n\n The MessageProp object is instantiated by the application and is used\n by the underlying mechanism to return information to the caller such\n as the QOP indicating the strength of protection that was applied to\n the message and other supplementary message state information.\n\n Since some application-level protocols may wish to use tokens emitted\n by getMIC to provide \"secure framing\", implementations should support\n the calculation and verification of MICs over zero-length messages.\n\n The format of the input token that this method\n reads is defined in the specification for the underlying mechanism that\n will be used. This method will attempt to read one of these tokens per\n invocation. If the mechanism token contains a definitive start and\n end this method may block on the InputStream if only\n part of the token is available. If the start and end of the token\n are not definitive then the method will attempt to treat all\n available bytes as part of the token.\n\n Other than the possible blocking behavior described above, this\n method is equivalent to the byte array based verifyMIC method."}, {"method_name": "export", "method_sig": "byte[] export()\n       throws GSSException", "description": "Exports this context so that another process may\n import it.. Provided to support the sharing of work between\n multiple processes. This routine will typically be used by the\n context-acceptor, in an application where a single process receives\n incoming connection requests and accepts security contexts over\n them, then passes the established context to one or more other\n processes for message exchange.\n\n This method deactivates the security context and creates an\n interprocess token which, when passed to GSSManager.createContext in\n another process, will re-activate the context in the second process.\n Only a single instantiation of a given context may be active at any\n one time; a subsequent attempt by a context exporter to access the\n exported security context will fail.\n\n The implementation may constrain the set of processes by which the\n interprocess token may be imported, either as a function of local\n security policy, or as a result of implementation decisions.  For\n example, some implementations may constrain contexts to be passed\n only between processes that run under the same account, or which are\n part of the same process group.\n\n The interprocess token may contain security-sensitive information\n (for example cryptographic keys).  While mechanisms are encouraged\n to either avoid placing such sensitive information within\n interprocess tokens, or to encrypt the token before returning it to\n the application, in a typical GSS-API implementation this may not be\n possible.  Thus the application must take care to protect the\n interprocess token, and ensure that any process to which the token\n is transferred is trustworthy. \n\n Implementations are not required to support the inter-process\n transfer of security contexts.  Calling the isTransferable method will indicate if the context object is\n transferable.\n\n Calling this method on a context that\n is not exportable will result in this exception being thrown with\n the error code GSSException.UNAVAILABLE."}, {"method_name": "requestMutualAuth", "method_sig": "void requestMutualAuth (boolean state)\n                throws GSSException", "description": "Requests that mutual authentication be done during\n context establishment. This request can only be made on the context\n initiator's side and it has to be done prior to the first call to\n initSecContext.\n\n Not all mechanisms support mutual authentication and some mechanisms\n might require mutual authentication even if the application\n doesn't. Therefore, the application should check to see if the\n request was honored with the getMutualAuthState method."}, {"method_name": "requestReplayDet", "method_sig": "void requestReplayDet (boolean state)\n               throws GSSException", "description": "Requests that replay detection be enabled for the\n per-message security services after context establishment. This\n request can only be made on the context initiator's side and it has\n to be done prior to the first call to\n initSecContext. During context establishment replay\n detection is not an option and is a function of the underlying\n mechanism's capabilities.\n\n Not all mechanisms support replay detection and some mechanisms\n might require replay detection even if the application\n doesn't. Therefore, the application should check to see if the\n request was honored with the getReplayDetState method. If replay detection is enabled then the\n MessageProp.isDuplicateToken and MessageProp.isOldToken methods will return\n valid results for the MessageProp object that is passed\n in to the unwrap method or the verifyMIC\n method."}, {"method_name": "requestSequenceDet", "method_sig": "void requestSequenceDet (boolean state)\n                 throws GSSException", "description": "Requests that sequence checking be enabled for the\n per-message security services after context establishment. This\n request can only be made on the context initiator's side and it has\n to be done prior to the first call to\n initSecContext. During context establishment sequence\n checking is not an option and is a function of the underlying\n mechanism's capabilities.\n\n Not all mechanisms support sequence checking and some mechanisms\n might require sequence checking even if the application\n doesn't. Therefore, the application should check to see if the\n request was honored with the getSequenceDetState method. If sequence checking is enabled then the\n MessageProp.isDuplicateToken,\n MessageProp.isOldToken,\n MessageProp.isUnseqToken, and\n MessageProp.isGapToken methods will return\n valid results for the MessageProp object that is passed\n in to the unwrap method or the verifyMIC\n method."}, {"method_name": "requestCredDeleg", "method_sig": "void requestCredDeleg (boolean state)\n               throws GSSException", "description": "Requests that the initiator's credentials be\n delegated to the acceptor during context establishment. This\n request can only be made on the context initiator's side and it has\n to be done prior to the first call to\n initSecContext.\n\n Not all mechanisms support credential delegation. Therefore, an\n application that desires delegation should check to see if the\n request was honored with the getCredDelegState method. If the application indicates that\n delegation must not be used, then the mechanism will honor the\n request and delegation will not occur. This is an exception\n to the general rule that a mechanism may enable a service even if it\n is not requested."}, {"method_name": "requestAnonymity", "method_sig": "void requestAnonymity (boolean state)\n               throws GSSException", "description": "Requests that the initiator's identity not be\n disclosed to the acceptor. This request can only be made on the\n context initiator's side and it has to be done prior to the first\n call to initSecContext.\n\n Not all mechanisms support anonymity for the initiator. Therefore, the\n application should check to see if the request was honored with the\n getAnonymityState method."}, {"method_name": "requestConf", "method_sig": "void requestConf (boolean state)\n          throws GSSException", "description": "Requests that data confidentiality be enabled\n for the wrap method. This request can only be made on\n the context initiator's side and it has to be done prior to the\n first call to initSecContext.\n\n Not all mechanisms support confidentiality and other mechanisms\n might enable it even if the application doesn't request\n it. The application may check to see if the request was honored with\n the getConfState method. If confidentiality\n is enabled, only then will the mechanism honor a request for privacy\n in the MessageProp\n object that is passed in to the wrap method.\n\n Enabling confidentiality will also automatically enable\n integrity."}, {"method_name": "requestInteg", "method_sig": "void requestInteg (boolean state)\n           throws GSSException", "description": "Requests that data integrity be enabled\n for the wrap and getMICmethods. This\n request can only be made on the context initiator's side and it has\n to be done prior to the first call to initSecContext.\n\n Not all mechanisms support integrity and other mechanisms\n might enable it even if the application doesn't request\n it. The application may check to see if the request was honored with\n the getIntegState method.\n\n Disabling integrity will also automatically disable\n confidentiality."}, {"method_name": "requestLifetime", "method_sig": "void requestLifetime (int lifetime)\n              throws GSSException", "description": "Requests a lifetime in seconds for the\n context. This method can only be called on the context initiator's\n side  and it has to be done prior to the first call to\n initSecContext.\n\n The actual lifetime of the context will depend on the capabilities of\n the underlying mechanism and the application should call the getLifetime method to determine this."}, {"method_name": "setChannelBinding", "method_sig": "void setChannelBinding (ChannelBinding cb)\n                throws GSSException", "description": "Sets the channel bindings to be used during context\n establishment. This method can be called on both\n the context initiator's and the context acceptor's side, but it must\n be called before context establishment begins. This means that an\n initiator must call it before the first call to\n initSecContext and the acceptor must call it before the\n first call to acceptSecContext."}, {"method_name": "getCredDelegState", "method_sig": "boolean getCredDelegState()", "description": "Determines if credential delegation is enabled on\n this context. It can be called by both the context initiator and the\n context acceptor. For a definitive answer this method must be\n called only after context establishment is complete. Note that if an\n initiator requests that delegation not be allowed the requestCredDeleg method will honor that\n request and this method will return false on the\n initiator's side from that point onwards."}, {"method_name": "getMutualAuthState", "method_sig": "boolean getMutualAuthState()", "description": "Determines if mutual authentication is enabled on\n this context. It can be called by both the context initiator and the\n context acceptor. For a definitive answer this method must be\n called only after context establishment is complete. An initiator\n that requests mutual authentication can call this method after\n context completion and dispose the context if its request was not\n honored."}, {"method_name": "getReplayDetState", "method_sig": "boolean getReplayDetState()", "description": "Determines if replay detection is enabled for the\n per-message security services from this context. It can be called by\n both the context initiator and the context acceptor. For a\n definitive answer this method must be called only after context\n establishment is complete. An initiator that requests replay\n detection can call this method after context completion and\n dispose the context if its request was not honored."}, {"method_name": "getSequenceDetState", "method_sig": "boolean getSequenceDetState()", "description": "Determines if sequence checking is enabled for the\n per-message security services from this context. It can be called by\n both the context initiator and the context acceptor. For a\n definitive answer this method must be called only after context\n establishment is complete. An initiator that requests sequence\n checking can call this method after context completion and\n dispose the context if its request was not honored."}, {"method_name": "getAnonymityState", "method_sig": "boolean getAnonymityState()", "description": "Determines if the context initiator is\n anonymously authenticated to the context acceptor. It can be called by\n both the context initiator and the context acceptor, and at any\n time. On the initiator side, a call to this method determines\n if the identity of the initiator has been disclosed in any of the\n context establishment tokens that might have been generated thus far\n by initSecContext. An initiator that absolutely must be\n authenticated anonymously should call this method after each call to\n initSecContext to determine if the generated token\n should be sent to the peer or the context aborted. On the\n acceptor side, a call to this method determines if any of the tokens\n processed by acceptSecContext thus far have divulged\n the identity of the initiator."}, {"method_name": "isTransferable", "method_sig": "boolean isTransferable()\n                throws GSSException", "description": "Determines if the context is transferable to other processes\n through the use of the export method.  This call\n is only valid on fully established contexts."}, {"method_name": "isProtReady", "method_sig": "boolean isProtReady()", "description": "Determines if the context is ready for per message operations to be\n used over it.  Some mechanisms may allow the usage of the\n per-message operations before the context is fully established."}, {"method_name": "getConfState", "method_sig": "boolean getConfState()", "description": "Determines if data confidentiality is available\n over the context. This method can be called by both the context\n initiator and the context acceptor, but only after one of isProtReady or isEstablished return true. If this method returns\n true, so will getIntegState"}, {"method_name": "getIntegState", "method_sig": "boolean getIntegState()", "description": "Determines if data integrity is available\n over the context. This method can be called by both the context\n initiator and the context acceptor, but only after one of isProtReady or isEstablished return true. This method will always\n return true if getConfState\n returns true."}, {"method_name": "getLifetime", "method_sig": "int getLifetime()", "description": "Determines what the remaining lifetime for this\n context is. It can be called by both the context initiator and the\n context acceptor, but for a definitive answer it should be called\n only after isEstablished returns\n true."}, {"method_name": "getSrcName", "method_sig": "GSSName getSrcName()\n            throws GSSException", "description": "Returns the name of the context initiator. This call is valid only\n after one of isProtReady or isEstablished return true."}, {"method_name": "getTargName", "method_sig": "GSSName getTargName()\n             throws GSSException", "description": "Returns the name of the context acceptor. This call is valid only\n after one of isProtReady or isEstablished return true."}, {"method_name": "getMech", "method_sig": "Oid getMech()\n     throws GSSException", "description": "Determines what mechanism is being used for this\n context. This method may be called before the context is fully\n established, but the mechanism returned may change on successive\n calls in the negotiated mechanism case."}, {"method_name": "getDelegCred", "method_sig": "GSSCredential getDelegCred()\n                    throws GSSException", "description": "Obtains the credentials delegated by the context\n initiator to the context acceptor. It should be called only on the\n context acceptor's side, and once the context is fully\n established. The caller can use the method getCredDelegState to determine if there are\n any delegated credentials."}, {"method_name": "isInitiator", "method_sig": "boolean isInitiator()\n             throws GSSException", "description": "Determines if this is the context initiator. This\n can be called on both the context initiator's and context acceptor's\n side."}]}