{"name": "Class MidiMessage", "module": "java.desktop", "package": "javax.sound.midi", "text": "MidiMessage is the base class for MIDI messages. They include not\n only the standard MIDI messages that a synthesizer can respond to, but also\n \"meta-events\" that can be used by sequencer programs. There are meta-events\n for such information as lyrics, copyrights, tempo indications, time and key\n signatures, markers, etc. For more information, see the Standard MIDI Files\n 1.0 specification, which is part of the Complete MIDI 1.0 Detailed\n Specification published by the MIDI Manufacturer's Association\n (http://www.midi.org).\n \n The base MidiMessage class provides access to three types of\n information about a MIDI message:\n \nThe messages's status byte\n   The total length of the message in bytes (the status byte plus any data\n   bytes)\n   A byte array containing the complete message\n \nMidiMessage includes methods to get, but not set, these values.\n Setting them is a subclass responsibility.\n \nThe MIDI standard expresses MIDI data in bytes.\n However, because Java\u2122 uses signed bytes, the Java Sound API uses\n integers instead of bytes when expressing MIDI data. For example, the\n getStatus() method of MidiMessage returns MIDI status bytes\n as integers. If you are processing MIDI data that originated outside Java\n Sound and now is encoded as signed bytes, the bytes can be converted to\n integers using this conversion:\n \nint i = (int)(byte & 0xFF)\n\n If you simply need to pass a known MIDI byte value as a method parameter, it\n can be expressed directly as an integer, using (for example) decimal or\n hexadecimal notation. For instance, to pass the \"active sensing\" status byte\n as the first argument to ShortMessage's\n setMessage(int) method, you can express\n it as 254 or 0xFE.", "codes": ["public abstract class MidiMessage\nextends Object\nimplements Cloneable"], "fields": [{"field_name": "data", "field_sig": "protected\u00a0byte[] data", "description": "The MIDI message data. The first byte is the status byte for the message;\n subsequent bytes up to the length of the message are data bytes for this\n message."}, {"field_name": "length", "field_sig": "protected\u00a0int length", "description": "The number of bytes in the MIDI message, including the status byte and\n any data bytes."}], "methods": [{"method_name": "setMessage", "method_sig": "protected void setMessage (byte[] data,\n                          int length)\n                   throws InvalidMidiDataException", "description": "Sets the data for the MIDI message. This protected method is called by\n concrete subclasses, which should ensure that the data array specifies a\n complete, valid MIDI message."}, {"method_name": "getMessage", "method_sig": "public byte[] getMessage()", "description": "Obtains the MIDI message data. The first byte of the returned byte array\n is the status byte of the message. Any subsequent bytes up to the length\n of the message are data bytes. The byte array may have a length which is\n greater than that of the actual message; the total length of the message\n in bytes is reported by the getLength() method."}, {"method_name": "getStatus", "method_sig": "public int getStatus()", "description": "Obtains the status byte for the MIDI message. The status \"byte\" is\n represented as an integer; see the\n discussion in the MidiMessage\n class description."}, {"method_name": "getLength", "method_sig": "public int getLength()", "description": "Obtains the total length of the MIDI message in bytes. A MIDI message\n consists of one status byte and zero or more data bytes. The return value\n ranges from 1 for system real-time messages, to 2 or 3 for channel\n messages, to any value for meta and system exclusive messages."}, {"method_name": "clone", "method_sig": "public abstract Object clone()", "description": "Creates a new object of the same class and with the same contents as this\n object."}]}