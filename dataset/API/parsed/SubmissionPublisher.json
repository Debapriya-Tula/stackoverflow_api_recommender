{"name": "Class SubmissionPublisher<T>", "module": "java.base", "package": "java.util.concurrent", "text": "A Flow.Publisher that asynchronously issues submitted\n (non-null) items to current subscribers until it is closed.  Each\n current subscriber receives newly submitted items in the same order\n unless drops or exceptions are encountered.  Using a\n SubmissionPublisher allows item generators to act as compliant  reactive-streams\n Publishers relying on drop handling and/or blocking for flow\n control.\n\n A SubmissionPublisher uses the Executor supplied in its\n constructor for delivery to subscribers. The best choice of\n Executor depends on expected usage. If the generator(s) of\n submitted items run in separate threads, and the number of\n subscribers can be estimated, consider using a Executors.newFixedThreadPool(int). Otherwise consider using the\n default, normally the ForkJoinPool.commonPool().\n\n Buffering allows producers and consumers to transiently operate\n at different rates.  Each subscriber uses an independent buffer.\n Buffers are created upon first use and expanded as needed up to the\n given maximum. (The enforced capacity may be rounded up to the\n nearest power of two and/or bounded by the largest value supported\n by this implementation.)  Invocations of request do not directly result in\n buffer expansion, but risk saturation if unfilled requests exceed\n the maximum capacity.  The default value of Flow.defaultBufferSize() may provide a useful starting point for\n choosing a capacity based on expected rates, resources, and usages.\n\n A single SubmissionPublisher may be shared among multiple\n sources. Actions in a source thread prior to publishing an item or\n issuing a signal \nhappen-before actions subsequent to the corresponding\n access by each subscriber. But reported estimates of lag and demand\n are designed for use in monitoring, not for synchronization\n control, and may reflect stale or inaccurate views of progress.\n\n Publication methods support different policies about what to do\n when buffers are saturated. Method submit\n blocks until resources are available. This is simplest, but least\n responsive.  The offer methods may drop items (either\n immediately or with bounded timeout), but provide an opportunity to\n interpose a handler and then retry.\n\n If any Subscriber method throws an exception, its subscription\n is cancelled.  If a handler is supplied as a constructor argument,\n it is invoked before cancellation upon an exception in method\n onNext, but exceptions in methods\n onSubscribe,\n onError and\n onComplete are not recorded or\n handled before cancellation.  If the supplied Executor throws\n RejectedExecutionException (or any other RuntimeException\n or Error) when attempting to execute a task, or a drop handler\n throws an exception when processing a dropped item, then the\n exception is rethrown. In these cases, not all subscribers will\n have been issued the published item. It is usually good practice to\n closeExceptionally in these cases.\n\n Method consume(Consumer) simplifies support for a\n common case in which the only action of a subscriber is to request\n and process all items using a supplied function.\n\n This class may also serve as a convenient base for subclasses\n that generate items, and use the methods in this class to publish\n them.  For example here is a class that periodically publishes the\n items generated from a supplier. (In practice you might add methods\n to independently start and stop generation, to share Executors\n among publishers, and so on, or use a SubmissionPublisher as a\n component rather than a superclass.)\n\n  \n class PeriodicPublisher<T> extends SubmissionPublisher<T> {\n   final ScheduledFuture<?> periodicTask;\n   final ScheduledExecutorService scheduler;\n   PeriodicPublisher(Executor executor, int maxBufferCapacity,\n                     Supplier<? extends T> supplier,\n                     long period, TimeUnit unit) {\n     super(executor, maxBufferCapacity);\n     scheduler = new ScheduledThreadPoolExecutor(1);\n     periodicTask = scheduler.scheduleAtFixedRate(\n       () -> submit(supplier.get()), 0, period, unit);\n   }\n   public void close() {\n     periodicTask.cancel(false);\n     scheduler.shutdown();\n     super.close();\n   }\n }\nHere is an example of a Flow.Processor implementation.\n It uses single-step requests to its publisher for simplicity of\n illustration. A more adaptive version could monitor flow using the\n lag estimate returned from submit, along with other utility\n methods.\n\n  \n class TransformProcessor<S,T> extends SubmissionPublisher<T>\n   implements Flow.Processor<S,T> {\n   final Function<? super S, ? extends T> function;\n   Flow.Subscription subscription;\n   TransformProcessor(Executor executor, int maxBufferCapacity,\n                      Function<? super S, ? extends T> function) {\n     super(executor, maxBufferCapacity);\n     this.function = function;\n   }\n   public void onSubscribe(Flow.Subscription subscription) {\n     (this.subscription = subscription).request(1);\n   }\n   public void onNext(S item) {\n     subscription.request(1);\n     submit(function.apply(item));\n   }\n   public void onError(Throwable ex) { closeExceptionally(ex); }\n   public void onComplete() { close(); }\n }", "codes": ["public class SubmissionPublisher<T>\nextends Object\nimplements Flow.Publisher<T>, AutoCloseable"], "fields": [], "methods": [{"method_name": "subscribe", "method_sig": "public void subscribe (Flow.Subscriber<? super T> subscriber)", "description": "Adds the given Subscriber unless already subscribed.  If already\n subscribed, the Subscriber's onError method is invoked on\n the existing subscription with an IllegalStateException.\n Otherwise, upon success, the Subscriber's onSubscribe method is invoked\n asynchronously with a new Flow.Subscription.  If onSubscribe throws an exception, the\n subscription is cancelled. Otherwise, if this SubmissionPublisher\n was closed exceptionally, then the subscriber's onError method is invoked with the\n corresponding exception, or if closed without exception, the\n subscriber's onComplete\n method is invoked.  Subscribers may enable receiving items by\n invoking the request\n method of the new Subscription, and may unsubscribe by invoking\n its cancel method."}, {"method_name": "submit", "method_sig": "public int submit (T item)", "description": "Publishes the given item to each current subscriber by\n asynchronously invoking its onNext method, blocking uninterruptibly while resources for any\n subscriber are unavailable. This method returns an estimate of\n the maximum lag (number of items submitted but not yet consumed)\n among all current subscribers. This value is at least one\n (accounting for this submitted item) if there are any\n subscribers, else zero.\n\n If the Executor for this publisher throws a\n RejectedExecutionException (or any other RuntimeException or\n Error) when attempting to asynchronously notify subscribers,\n then this exception is rethrown, in which case not all\n subscribers will have been issued this item."}, {"method_name": "offer", "method_sig": "public int offer (T item,\n                 BiPredicate<Flow.Subscriber<? super T>, ? super T> onDrop)", "description": "Publishes the given item, if possible, to each current subscriber\n by asynchronously invoking its onNext method. The item may be\n dropped by one or more subscribers if resource limits are\n exceeded, in which case the given handler (if non-null) is\n invoked, and if it returns true, retried once.  Other calls to\n methods in this class by other threads are blocked while the\n handler is invoked.  Unless recovery is assured, options are\n usually limited to logging the error and/or issuing an onError signal to the\n subscriber.\n\n This method returns a status indicator: If negative, it\n represents the (negative) number of drops (failed attempts to\n issue the item to a subscriber). Otherwise it is an estimate of\n the maximum lag (number of items submitted but not yet\n consumed) among all current subscribers. This value is at least\n one (accounting for this submitted item) if there are any\n subscribers, else zero.\n\n If the Executor for this publisher throws a\n RejectedExecutionException (or any other RuntimeException or\n Error) when attempting to asynchronously notify subscribers, or\n the drop handler throws an exception when processing a dropped\n item, then this exception is rethrown."}, {"method_name": "offer", "method_sig": "public int offer (T item,\n                 long timeout,\n                 TimeUnit unit,\n                 BiPredicate<Flow.Subscriber<? super T>, ? super T> onDrop)", "description": "Publishes the given item, if possible, to each current subscriber\n by asynchronously invoking its onNext method, blocking while\n resources for any subscription are unavailable, up to the\n specified timeout or until the caller thread is interrupted, at\n which point the given handler (if non-null) is invoked, and if it\n returns true, retried once. (The drop handler may distinguish\n timeouts from interrupts by checking whether the current thread\n is interrupted.)  Other calls to methods in this class by other\n threads are blocked while the handler is invoked.  Unless\n recovery is assured, options are usually limited to logging the\n error and/or issuing an onError signal to the subscriber.\n\n This method returns a status indicator: If negative, it\n represents the (negative) number of drops (failed attempts to\n issue the item to a subscriber). Otherwise it is an estimate of\n the maximum lag (number of items submitted but not yet\n consumed) among all current subscribers. This value is at least\n one (accounting for this submitted item) if there are any\n subscribers, else zero.\n\n If the Executor for this publisher throws a\n RejectedExecutionException (or any other RuntimeException or\n Error) when attempting to asynchronously notify subscribers, or\n the drop handler throws an exception when processing a dropped\n item, then this exception is rethrown."}, {"method_name": "close", "method_sig": "public void close()", "description": "Unless already closed, issues onComplete signals to current\n subscribers, and disallows subsequent attempts to publish.\n Upon return, this method does NOT guarantee that all\n subscribers have yet completed."}, {"method_name": "closeExceptionally", "method_sig": "public void closeExceptionally (Throwable error)", "description": "Unless already closed, issues onError signals to current\n subscribers with the given error, and disallows subsequent\n attempts to publish.  Future subscribers also receive the given\n error. Upon return, this method does NOT guarantee\n that all subscribers have yet completed."}, {"method_name": "isClosed", "method_sig": "public boolean isClosed()", "description": "Returns true if this publisher is not accepting submissions."}, {"method_name": "getClosedException", "method_sig": "public Throwable getClosedException()", "description": "Returns the exception associated with closeExceptionally, or null if\n not closed or if closed normally."}, {"method_name": "hasSubscribers", "method_sig": "public boolean hasSubscribers()", "description": "Returns true if this publisher has any subscribers."}, {"method_name": "getNumberOfSubscribers", "method_sig": "public int getNumberOfSubscribers()", "description": "Returns the number of current subscribers."}, {"method_name": "getExecutor", "method_sig": "public Executor getExecutor()", "description": "Returns the Executor used for asynchronous delivery."}, {"method_name": "getMaxBufferCapacity", "method_sig": "public int getMaxBufferCapacity()", "description": "Returns the maximum per-subscriber buffer capacity."}, {"method_name": "getSubscribers", "method_sig": "public List<Flow.Subscriber<? super T>> getSubscribers()", "description": "Returns a list of current subscribers for monitoring and\n tracking purposes, not for invoking Flow.Subscriber\n methods on the subscribers."}, {"method_name": "isSubscribed", "method_sig": "public boolean isSubscribed (Flow.Subscriber<? super T> subscriber)", "description": "Returns true if the given Subscriber is currently subscribed."}, {"method_name": "estimateMinimumDemand", "method_sig": "public long estimateMinimumDemand()", "description": "Returns an estimate of the minimum number of items requested\n (via request) but not\n yet produced, among all current subscribers."}, {"method_name": "estimateMaximumLag", "method_sig": "public int estimateMaximumLag()", "description": "Returns an estimate of the maximum number of items produced but\n not yet consumed among all current subscribers."}, {"method_name": "consume", "method_sig": "public CompletableFuture<Void> consume (Consumer<? super T> consumer)", "description": "Processes all published items using the given Consumer function.\n Returns a CompletableFuture that is completed normally when this\n publisher signals onComplete, or completed exceptionally upon any error, or an\n exception is thrown by the Consumer, or the returned\n CompletableFuture is cancelled, in which case no further items\n are processed."}]}